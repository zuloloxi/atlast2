; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\A15\facultate\forth\atlast-2.0\atlast.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_09GAMPJJGL@TEMPSTRN?5?$AA@		; `string'
PUBLIC	??_C@_09GDELENAF@TEMPSTRL?5?$AA@		; `string'
PUBLIC	??_C@_05OHLFDECO@HEAP?5?$AA@			; `string'
PUBLIC	??_C@_07NIFKNEP@RSTACK?5?$AA@			; `string'
PUBLIC	??_C@_06OCMIFJOD@STACK?5?$AA@			; `string'
PUBLIC	??_C@_06BLNAKME@STDERR?$AA@			; `string'
PUBLIC	??_C@_06DNBFFLKD@STDOUT?$AA@			; `string'
PUBLIC	??_C@_05MHDFGKA@STDIN?$AA@			; `string'
PUBLIC	??_C@_09NMMMFPKN@0EVALUATE?$AA@			; `string'
PUBLIC	??_C@_06KIMIPMHH@0FLOAD?$AA@			; `string'
PUBLIC	??_C@_06KFFEKIFD@0FSEEK?$AA@			; `string'
PUBLIC	??_C@_06FHOENJAL@0FTELL?$AA@			; `string'
PUBLIC	??_C@_06GHNAMGFD@0FPUTC?$AA@			; `string'
PUBLIC	??_C@_06OFAJNKFO@0FGETC?$AA@			; `string'
PUBLIC	??_C@_07GLDELNNH@0FWRITE?$AA@			; `string'
PUBLIC	??_C@_06BIKFDFPA@0FREAD?$AA@			; `string'
PUBLIC	??_C@_06CNBCNEAC@0FPUTS?$AA@			; `string'
PUBLIC	??_C@_06KPMLMIAP@0FGETS?$AA@			; `string'
PUBLIC	??_C@_08OAJGAKDH@0FDELETE?$AA@			; `string'
PUBLIC	??_C@_07MIHJNOA@0FCLOSE?$AA@			; `string'
PUBLIC	??_C@_06BKPEIBDI@0FOPEN?$AA@			; `string'
PUBLIC	??_C@_05IPGGCMEL@0FILE?$AA@			; `string'
PUBLIC	??_C@_06IGNJJOKG@0WORDS?$AA@			; `string'
PUBLIC	??_C@_05NAGDOFCC@0TYPE?$AA@			; `string'
PUBLIC	??_C@_03PJKCHKGH@1?4?$CI?$AA@			; `string'
PUBLIC	??_C@_03DENJCON@1?4?$CC?$AA@			; `string'
PUBLIC	??_C@_03INNFLNDP@0?4S?$AA@			; `string'
PUBLIC	??_C@_03NEMBNEAN@0CR?$AA@			; `string'
PUBLIC	??_C@_02HMALOJEB@0?$DP?$AA@			; `string'
PUBLIC	??_C@_02CPNCMKFB@0?4?$AA@			; `string'
PUBLIC	??_C@_09PHABBLJC@0?$DORESOLVE?$AA@		; `string'
PUBLIC	??_C@_06LPOCMLO@0?$DOMARK?$AA@			; `string'
PUBLIC	??_C@_09NJPHDDBE@0?$DMRESOLVE?$AA@		; `string'
PUBLIC	??_C@_06EGDGINLF@0?$DMMARK?$AA@			; `string'
PUBLIC	??_C@_08LLNBOFDH@0COMPILE?$AA@			; `string'
PUBLIC	??_C@_08MEIBGFMH@1LITERAL?$AA@			; `string'
PUBLIC	??_C@_0L@PPPNOFDC@1?$FLCOMPILE?$FN?$AA@		; `string'
PUBLIC	??_C@_08NHEDMBGE@0S?$DONAME?$CB?$AA@		; `string'
PUBLIC	??_C@_08DIOIEBIC@0NAME?$DOS?$CB?$AA@		; `string'
PUBLIC	??_C@_07JDOMHGJI@0L?$DONAME?$AA@		; `string'
PUBLIC	??_C@_07CHMCIPOJ@0N?$DOLINK?$AA@		; `string'
PUBLIC	??_C@_06KBEICDKO@0LINK?$DO?$AA@			; `string'
PUBLIC	??_C@_06MENLELIA@0NAME?$DO?$AA@			; `string'
PUBLIC	??_C@_06GEBNCAAE@0BODY?$DO?$AA@			; `string'
PUBLIC	??_C@_06OGBGHHPF@0?$DOLINK?$AA@			; `string'
PUBLIC	??_C@_06MFKHJPKN@0?$DONAME?$AA@			; `string'
PUBLIC	??_C@_05JFPJMJGE@0FIND?$AA@			; `string'
PUBLIC	??_C@_06EIGKJEPF@0STATE?$AA@			; `string'
PUBLIC	??_C@_06JCOGDEN@0?$DOBODY?$AA@			; `string'
PUBLIC	??_C@_08BMCODLCA@0EXECUTE?$AA@			; `string'
PUBLIC	??_C@_04ILIHGCAL@1?$FL?8?$FN?$AA@		; `string'
PUBLIC	??_C@_02POBAHBBI@0?8?$AA@			; `string'
PUBLIC	??_C@_06HGPCBKK@0DOES?$DO?$AA@			; `string'
PUBLIC	??_C@_07CKFDKAEF@0FORGET?$AA@			; `string'
PUBLIC	??_C@_07HOLFGALO@0CREATE?$AA@			; `string'
PUBLIC	??_C@_02CLMAOAGE@0?$FN?$AA@			; `string'
PUBLIC	??_C@_02HMFICNNF@1?$FL?$AA@			; `string'
PUBLIC	??_C@_0L@FBPCDAOB@0IMMEDIATE?$AA@		; `string'
PUBLIC	??_C@_02BJKFEGHC@1?$DL?$AA@			; `string'
PUBLIC	??_C@_02BHMBNAE@0?3?$AA@			; `string'
PUBLIC	??_C@_0N@JACHHCHC@0WORDSUNUSED?$AA@		; `string'
PUBLIC	??_C@_0L@KDKOLN@0WORDSUSED?$AA@			; `string'
PUBLIC	??_C@_09BHMIPPJ@0WALKBACK?$AA@			; `string'
PUBLIC	??_C@_06MDEGOEBI@0TRACE?$AA@			; `string'
PUBLIC	??_C@_07COPGIKHD@0SYSTEM?$AA@			; `string'
PUBLIC	??_C@_07EPGGOCC@1ABORT?$CC?$AA@			; `string'
PUBLIC	??_C@_06FOFPHNNG@0ABORT?$AA@			; `string'
PUBLIC	??_C@_05BCHLGOAF@0QUIT?$AA@			; `string'
PUBLIC	??_C@_02COEDGEPC@0J?$AA@			; `string'
PUBLIC	??_C@_02FGODHDB@0I?$AA@				; `string'
PUBLIC	??_C@_06OEOOEOOH@0LEAVE?$AA@			; `string'
PUBLIC	??_C@_09LADNBAGF@0?$CI?$CLXLOOP?$CJ?$AA@	; `string'
PUBLIC	??_C@_08EENKAJAP@0?$CIXLOOP?$CJ?$AA@		; `string'
PUBLIC	??_C@_07LBIDLKB@0?$CIX?$DPDO?$CJ?$AA@		; `string'
PUBLIC	??_C@_06CJKBMPO@0?$CIXDO?$CJ?$AA@		; `string'
PUBLIC	??_C@_06JOOFBBBI@1?$CLLOOP?$AA@			; `string'
PUBLIC	??_C@_05BOBCOANO@1LOOP?$AA@			; `string'
PUBLIC	??_C@_04NKGAHPF@1?$DPDO?$AA@			; `string'
PUBLIC	??_C@_03JGFOMJPB@1DO?$AA@			; `string'
PUBLIC	??_C@_07DDDAIFH@1REPEAT?$AA@			; `string'
PUBLIC	??_C@_06HBNHNPD@1WHILE?$AA@			; `string'
PUBLIC	??_C@_06HAEJDIGL@1AGAIN?$AA@			; `string'
PUBLIC	??_C@_06LAOPNPLI@1UNTIL?$AA@			; `string'
PUBLIC	??_C@_06KJHGEGHJ@1BEGIN?$AA@			; `string'
PUBLIC	??_C@_05KNIMAIMD@0?$DPDUP?$AA@			; `string'
PUBLIC	??_C@_05KIDLOCN@1THEN?$AA@			; `string'
PUBLIC	??_C@_05CDDOJBEB@1ELSE?$AA@			; `string'
PUBLIC	??_C@_03EPEEOBOL@1IF?$AA@			; `string'
PUBLIC	??_C@_08KNNMAPJN@0?$DPBRANCH?$AA@		; `string'
PUBLIC	??_C@_07NJOGBGCE@0BRANCH?$AA@			; `string'
PUBLIC	??_C@_06HFODLJPA@0?$CILIT?$CJ?$AA@		; `string'
PUBLIC	??_C@_05HFHBIHJK@0EXIT?$AA@			; `string'
PUBLIC	??_C@_07LAEIABPO@0?$CINEST?$CJ?$AA@		; `string'
PUBLIC	??_C@_04MDDBKNON@0TAN?$AA@			; `string'
PUBLIC	??_C@_05PHKKOGKD@0SQRT?$AA@			; `string'
PUBLIC	??_C@_04FAPFMEOM@0SIN?$AA@			; `string'
PUBLIC	??_C@_04NNMNLOKI@0POW?$AA@			; `string'
PUBLIC	??_C@_04INMAEENO@0LOG?$AA@			; `string'
PUBLIC	??_C@_04OMCCDKDH@0EXP?$AA@			; `string'
PUBLIC	??_C@_04PLANIDNN@0COS?$AA@			; `string'
PUBLIC	??_C@_06HHLLPOPC@0ATAN2?$AA@			; `string'
PUBLIC	??_C@_05HEBJDFIB@0ATAN?$AA@			; `string'
PUBLIC	??_C@_05OHNNFMIA@0ASIN?$AA@			; `string'
PUBLIC	??_C@_05EMCFBLLB@0ACOS?$AA@			; `string'
PUBLIC	??_C@_04CLKKNGJG@0FIX?$AA@			; `string'
PUBLIC	??_C@_06OCAKOOCG@0FLOAT?$AA@			; `string'
PUBLIC	??_C@_03FBIACABM@0F?4?$AA@			; `string'
PUBLIC	??_C@_04GBBKODMP@0F?$DM?$DN?$AA@		; `string'
PUBLIC	??_C@_04GCJODHKB@0F?$DO?$DN?$AA@		; `string'
PUBLIC	??_C@_03CJHEFAMP@0F?$DM?$AA@			; `string'
PUBLIC	??_C@_03BLECDCEN@0F?$DO?$AA@			; `string'
PUBLIC	??_C@_04EKDHLAAM@0F?$DM?$DO?$AA@		; `string'
PUBLIC	??_C@_03DAGPGBIO@0F?$DN?$AA@			; `string'
PUBLIC	??_C@_05FMNEJMHJ@0FABS?$AA@			; `string'
PUBLIC	??_C@_08LMFEPDDP@0FNEGATE?$AA@			; `string'
PUBLIC	??_C@_05PHLAEEFD@0FMAX?$AA@			; `string'
PUBLIC	??_C@_05OFDLKADM@0FMIN?$AA@			; `string'
PUBLIC	??_C@_03EIJLBBFN@0F?1?$AA@			; `string'
PUBLIC	??_C@_03DFOMOFBI@0F?$CK?$AA@			; `string'
PUBLIC	??_C@_03HKKNHDNP@0F?9?$AA@			; `string'
PUBLIC	??_C@_03CMPHNEFJ@0F?$CL?$AA@			; `string'
PUBLIC	??_C@_07GOKPFGBJ@0?$CIFLIT?$CJ?$AA@		; `string'
PUBLIC	??_C@_08LJDPGIKE@0STRREAL?$AA@			; `string'
PUBLIC	??_C@_07JKCOHJKG@0STRINT?$AA@			; `string'
PUBLIC	??_C@_09KKFANBFF@0FSTRFORM?$AA@			; `string'
PUBLIC	??_C@_08EEJJJFOK@0STRFORM?$AA@			; `string'
PUBLIC	??_C@_08GINNEDKC@0COMPARE?$AA@			; `string'
PUBLIC	??_C@_07EJNNALFK@0SUBSTR?$AA@			; `string'
PUBLIC	??_C@_08MCJEDBJE@0STRCHAR?$AA@			; `string'
PUBLIC	??_C@_07JDLJOCJP@0STRCMP?$AA@			; `string'
PUBLIC	??_C@_07BBIIJMKO@0STRLEN?$AA@			; `string'
PUBLIC	??_C@_03DGBKLFMC@0S?$CL?$AA@			; `string'
PUBLIC	??_C@_07POMPNOPP@0STRCAT?$AA@			; `string'
PUBLIC	??_C@_03MMPFFNEI@0S?$CB?$AA@			; `string'
PUBLIC	??_C@_07FGIFGJPF@0STRCPY?$AA@			; `string'
PUBLIC	??_C@_07PLMBDIDE@0STRING?$AA@			; `string'
PUBLIC	??_C@_09FEDGBOAP@0?$CISTRLIT?$CJ?$AA@		; `string'
PUBLIC	??_C@_06DHACAGHC@0ARRAY?$AA@			; `string'
PUBLIC	??_C@_05GMDIKDOI@0HERE?$AA@			; `string'
PUBLIC	??_C@_03DGKEKDGF@0C?$DN?$AA@			; `string'
PUBLIC	??_C@_03GFHNIAHF@0C?0?$AA@			; `string'
PUBLIC	??_C@_03KMDFKENO@0C?$EA?$AA@			; `string'
PUBLIC	??_C@_03NANDPODI@0C?$CB?$AA@			; `string'
PUBLIC	??_C@_02BNOEKIND@0?0?$AA@			; `string'
PUBLIC	??_C@_06OHCEFMHK@0ALLOT?$AA@			; `string'
PUBLIC	??_C@_03JGBHGEKA@0?$CL?$CB?$AA@			; `string'
PUBLIC	??_C@_02NEKMIMHI@0?$EA?$AA@			; `string'
PUBLIC	??_C@_02KIEKNGJO@0?$CB?$AA@			; `string'
PUBLIC	??_C@_09LHOCOAIG@0CONSTANT?$AA@			; `string'
PUBLIC	??_C@_09KMOEGCKP@0VARIABLE?$AA@			; `string'
PUBLIC	??_C@_03PJAGKGLJ@02?$EA?$AA@			; `string'
PUBLIC	??_C@_03IFOAPMFP@02?$CB?$AA@			; `string'
PUBLIC	??_C@_0L@BDHAKCDN@02CONSTANT?$AA@		; `string'
PUBLIC	??_C@_0L@IHGCABE@02VARIABLE?$AA@		; `string'
PUBLIC	??_C@_05FFLDCHJD@02ROT?$AA@			; `string'
PUBLIC	??_C@_06EJFLMMGO@02OVER?$AA@			; `string'
PUBLIC	??_C@_06GBMIBLNG@02SWAP?$AA@			; `string'
PUBLIC	??_C@_06IOEIINHM@02DROP?$AA@			; `string'
PUBLIC	??_C@_05FFBMMMHC@02DUP?$AA@			; `string'
PUBLIC	??_C@_03HJAIEECN@00?$DM?$AA@			; `string'
PUBLIC	??_C@_03ELDOCGKP@00?$DO?$AA@			; `string'
PUBLIC	??_C@_04EGDEPEM@00?$DM?$DO?$AA@			; `string'
PUBLIC	??_C@_03GABDHFGM@00?$DN?$AA@			; `string'
PUBLIC	??_C@_03BLGDNBNB@02?1?$AA@			; `string'
PUBLIC	??_C@_03GGBECFJE@02?$CK?$AA@			; `string'
PUBLIC	??_C@_03CJFFLDFD@02?9?$AA@			; `string'
PUBLIC	??_C@_03CLBDANAK@01?9?$AA@			; `string'
PUBLIC	??_C@_03HPAPBENF@02?$CL?$AA@			; `string'
PUBLIC	??_C@_03HNEJKKIM@01?$CL?$AA@			; `string'
PUBLIC	??_C@_03LBNBGNJJ@0R?$EA?$AA@			; `string'
PUBLIC	??_C@_03GNDJOB@0R?$DO?$AA@			; `string'
PUBLIC	??_C@_03IIOICPAO@0?$DOR?$AA@			; `string'
PUBLIC	??_C@_05OOKPPJJM@0ROLL?$AA@			; `string'
PUBLIC	??_C@_05LHADCHMA@0?9ROT?$AA@			; `string'
PUBLIC	??_C@_04FMOJCFOA@0ROT?$AA@			; `string'
PUBLIC	??_C@_05PFBJCENK@0PICK?$AA@			; `string'
PUBLIC	??_C@_05IAFOLGOK@0OVER?$AA@			; `string'
PUBLIC	??_C@_05KIMNGBFC@0SWAP?$AA@			; `string'
PUBLIC	??_C@_05EHENPHPI@0DROP?$AA@			; `string'
PUBLIC	??_C@_04FMEGMOAB@0DUP?$AA@			; `string'
PUBLIC	??_C@_06ILCADIHH@0CLEAR?$AA@			; `string'
PUBLIC	??_C@_06FGDCFGFD@0DEPTH?$AA@			; `string'
PUBLIC	??_C@_06GELFJCJH@0SHIFT?$AA@			; `string'
PUBLIC	??_C@_04EGCGMNMH@0NOT?$AA@			; `string'
PUBLIC	??_C@_04GFAOGCAC@0XOR?$AA@			; `string'
PUBLIC	??_C@_03NNNLCNGJ@0OR?$AA@			; `string'
PUBLIC	??_C@_04FFEFKFPH@0AND?$AA@			; `string'
PUBLIC	??_C@_03GJAJIMAI@0?$DM?$DN?$AA@			; `string'
PUBLIC	??_C@_03GKINFIGG@0?$DO?$DN?$AA@			; `string'
PUBLIC	??_C@_02FHCGLKIC@0?$DM?$AA@			; `string'
PUBLIC	??_C@_02GFBANIAA@0?$DO?$AA@			; `string'
PUBLIC	??_C@_03ECCENPML@0?$DM?$DO?$AA@			; `string'
PUBLIC	??_C@_02EODNILMD@0?$DN?$AA@			; `string'
PUBLIC	??_C@_04FJNMNIAF@0ABS?$AA@			; `string'
PUBLIC	??_C@_07HLHBGADN@0NEGATE?$AA@			; `string'
PUBLIC	??_C@_04PCLIAACP@0MAX?$AA@			; `string'
PUBLIC	??_C@_04OADDOEEA@0MIN?$AA@			; `string'
PUBLIC	??_C@_05IPHLCBDI@0?1MOD?$AA@			; `string'
PUBLIC	??_C@_04BOFBHAHI@0MOD?$AA@			; `string'
PUBLIC	??_C@_02DGMJPLBA@0?1?$AA@			; `string'
PUBLIC	??_C@_02ELLOAPFF@0?$CK?$AA@			; `string'
PUBLIC	??_C@_02EPPJJJC@0?9?$AA@			; `string'
PUBLIC	??_C@_02FCKFDOBE@0?$CL?$AA@			; `string'
PUBLIC	??_C@_02CHHAKFFB@w?$CL?$AA@			; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_02CBLLGHLK@r?$CL?$AA@			; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	_opterr
PUBLIC	_optind
PUBLIC	_optopt
PUBLIC	_atl_stklen
PUBLIC	_atl_rstklen
PUBLIC	_atl_heaplen
PUBLIC	_atl_ltempstr
PUBLIC	_atl_ntempstr
PUBLIC	_atl_trace
PUBLIC	_atl_walkback
PUBLIC	_atl_comment
PUBLIC	_atl_redef
PUBLIC	_atl_errline
_DATA	SEGMENT
COMM	___mingw_optreset:DWORD
COMM	_optarg:DWORD
_DATA	ENDS
_BSS	SEGMENT
_atl_trace DQ	01H DUP (?)
_atl_comment DQ	01H DUP (?)
_atl_errline DQ	01H DUP (?)
_stack	DD	01H DUP (?)
_rstack	DD	01H DUP (?)
_heap	DD	01H DUP (?)
_dict	DD	01H DUP (?)
_dictprot DD	01H DUP (?)
_strbuf	DD	01H DUP (?)
_cstrbuf DD	01H DUP (?)
_wback	DD	01H DUP (?)
_instream DD	01H DUP (?)
_ip	DD	01H DUP (?)
_curword DD	01H DUP (?)
_evalstat DD	01H DUP (?)
_defpend DD	01H DUP (?)
_forgetpend DD	01H DUP (?)
_tickpend DD	01H DUP (?)
_ctickpend DD	01H DUP (?)
_cbrackpend DD	01H DUP (?)
_createword DD	01H DUP (?)
_stringlit DD	01H DUP (?)
_broken	DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_09GAMPJJGL@TEMPSTRN?5?$AA@
CONST	SEGMENT
??_C@_09GAMPJJGL@TEMPSTRN?5?$AA@ DB 'TEMPSTRN ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GDELENAF@TEMPSTRL?5?$AA@
CONST	SEGMENT
??_C@_09GDELENAF@TEMPSTRL?5?$AA@ DB 'TEMPSTRL ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05OHLFDECO@HEAP?5?$AA@
CONST	SEGMENT
??_C@_05OHLFDECO@HEAP?5?$AA@ DB 'HEAP ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NIFKNEP@RSTACK?5?$AA@
CONST	SEGMENT
??_C@_07NIFKNEP@RSTACK?5?$AA@ DB 'RSTACK ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OCMIFJOD@STACK?5?$AA@
CONST	SEGMENT
??_C@_06OCMIFJOD@STACK?5?$AA@ DB 'STACK ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BLNAKME@STDERR?$AA@
CONST	SEGMENT
??_C@_06BLNAKME@STDERR?$AA@ DB 'STDERR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DNBFFLKD@STDOUT?$AA@
CONST	SEGMENT
??_C@_06DNBFFLKD@STDOUT?$AA@ DB 'STDOUT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MHDFGKA@STDIN?$AA@
CONST	SEGMENT
??_C@_05MHDFGKA@STDIN?$AA@ DB 'STDIN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NMMMFPKN@0EVALUATE?$AA@
CONST	SEGMENT
??_C@_09NMMMFPKN@0EVALUATE?$AA@ DB '0EVALUATE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06KIMIPMHH@0FLOAD?$AA@
CONST	SEGMENT
??_C@_06KIMIPMHH@0FLOAD?$AA@ DB '0FLOAD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KFFEKIFD@0FSEEK?$AA@
CONST	SEGMENT
??_C@_06KFFEKIFD@0FSEEK?$AA@ DB '0FSEEK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHOENJAL@0FTELL?$AA@
CONST	SEGMENT
??_C@_06FHOENJAL@0FTELL?$AA@ DB '0FTELL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GHNAMGFD@0FPUTC?$AA@
CONST	SEGMENT
??_C@_06GHNAMGFD@0FPUTC?$AA@ DB '0FPUTC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OFAJNKFO@0FGETC?$AA@
CONST	SEGMENT
??_C@_06OFAJNKFO@0FGETC?$AA@ DB '0FGETC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GLDELNNH@0FWRITE?$AA@
CONST	SEGMENT
??_C@_07GLDELNNH@0FWRITE?$AA@ DB '0FWRITE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BIKFDFPA@0FREAD?$AA@
CONST	SEGMENT
??_C@_06BIKFDFPA@0FREAD?$AA@ DB '0FREAD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CNBCNEAC@0FPUTS?$AA@
CONST	SEGMENT
??_C@_06CNBCNEAC@0FPUTS?$AA@ DB '0FPUTS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KPMLMIAP@0FGETS?$AA@
CONST	SEGMENT
??_C@_06KPMLMIAP@0FGETS?$AA@ DB '0FGETS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OAJGAKDH@0FDELETE?$AA@
CONST	SEGMENT
??_C@_08OAJGAKDH@0FDELETE?$AA@ DB '0FDELETE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MIHJNOA@0FCLOSE?$AA@
CONST	SEGMENT
??_C@_07MIHJNOA@0FCLOSE?$AA@ DB '0FCLOSE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BKPEIBDI@0FOPEN?$AA@
CONST	SEGMENT
??_C@_06BKPEIBDI@0FOPEN?$AA@ DB '0FOPEN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IPGGCMEL@0FILE?$AA@
CONST	SEGMENT
??_C@_05IPGGCMEL@0FILE?$AA@ DB '0FILE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IGNJJOKG@0WORDS?$AA@
CONST	SEGMENT
??_C@_06IGNJJOKG@0WORDS?$AA@ DB '0WORDS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NAGDOFCC@0TYPE?$AA@
CONST	SEGMENT
??_C@_05NAGDOFCC@0TYPE?$AA@ DB '0TYPE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PJKCHKGH@1?4?$CI?$AA@
CONST	SEGMENT
??_C@_03PJKCHKGH@1?4?$CI?$AA@ DB '1.(', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DENJCON@1?4?$CC?$AA@
CONST	SEGMENT
??_C@_03DENJCON@1?4?$CC?$AA@ DB '1."', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03INNFLNDP@0?4S?$AA@
CONST	SEGMENT
??_C@_03INNFLNDP@0?4S?$AA@ DB '0.S', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NEMBNEAN@0CR?$AA@
CONST	SEGMENT
??_C@_03NEMBNEAN@0CR?$AA@ DB '0CR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HMALOJEB@0?$DP?$AA@
CONST	SEGMENT
??_C@_02HMALOJEB@0?$DP?$AA@ DB '0?', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02CPNCMKFB@0?4?$AA@
CONST	SEGMENT
??_C@_02CPNCMKFB@0?4?$AA@ DB '0.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09PHABBLJC@0?$DORESOLVE?$AA@
CONST	SEGMENT
??_C@_09PHABBLJC@0?$DORESOLVE?$AA@ DB '0>RESOLVE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LPOCMLO@0?$DOMARK?$AA@
CONST	SEGMENT
??_C@_06LPOCMLO@0?$DOMARK?$AA@ DB '0>MARK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NJPHDDBE@0?$DMRESOLVE?$AA@
CONST	SEGMENT
??_C@_09NJPHDDBE@0?$DMRESOLVE?$AA@ DB '0<RESOLVE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06EGDGINLF@0?$DMMARK?$AA@
CONST	SEGMENT
??_C@_06EGDGINLF@0?$DMMARK?$AA@ DB '0<MARK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLNBOFDH@0COMPILE?$AA@
CONST	SEGMENT
??_C@_08LLNBOFDH@0COMPILE?$AA@ DB '0COMPILE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MEIBGFMH@1LITERAL?$AA@
CONST	SEGMENT
??_C@_08MEIBGFMH@1LITERAL?$AA@ DB '1LITERAL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PPPNOFDC@1?$FLCOMPILE?$FN?$AA@
CONST	SEGMENT
??_C@_0L@PPPNOFDC@1?$FLCOMPILE?$FN?$AA@ DB '1[COMPILE]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NHEDMBGE@0S?$DONAME?$CB?$AA@
CONST	SEGMENT
??_C@_08NHEDMBGE@0S?$DONAME?$CB?$AA@ DB '0S>NAME!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DIOIEBIC@0NAME?$DOS?$CB?$AA@
CONST	SEGMENT
??_C@_08DIOIEBIC@0NAME?$DOS?$CB?$AA@ DB '0NAME>S!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JDOMHGJI@0L?$DONAME?$AA@
CONST	SEGMENT
??_C@_07JDOMHGJI@0L?$DONAME?$AA@ DB '0L>NAME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CHMCIPOJ@0N?$DOLINK?$AA@
CONST	SEGMENT
??_C@_07CHMCIPOJ@0N?$DOLINK?$AA@ DB '0N>LINK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06KBEICDKO@0LINK?$DO?$AA@
CONST	SEGMENT
??_C@_06KBEICDKO@0LINK?$DO?$AA@ DB '0LINK>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MENLELIA@0NAME?$DO?$AA@
CONST	SEGMENT
??_C@_06MENLELIA@0NAME?$DO?$AA@ DB '0NAME>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06GEBNCAAE@0BODY?$DO?$AA@
CONST	SEGMENT
??_C@_06GEBNCAAE@0BODY?$DO?$AA@ DB '0BODY>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OGBGHHPF@0?$DOLINK?$AA@
CONST	SEGMENT
??_C@_06OGBGHHPF@0?$DOLINK?$AA@ DB '0>LINK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MFKHJPKN@0?$DONAME?$AA@
CONST	SEGMENT
??_C@_06MFKHJPKN@0?$DONAME?$AA@ DB '0>NAME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05JFPJMJGE@0FIND?$AA@
CONST	SEGMENT
??_C@_05JFPJMJGE@0FIND?$AA@ DB '0FIND', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EIGKJEPF@0STATE?$AA@
CONST	SEGMENT
??_C@_06EIGKJEPF@0STATE?$AA@ DB '0STATE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JCOGDEN@0?$DOBODY?$AA@
CONST	SEGMENT
??_C@_06JCOGDEN@0?$DOBODY?$AA@ DB '0>BODY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BMCODLCA@0EXECUTE?$AA@
CONST	SEGMENT
??_C@_08BMCODLCA@0EXECUTE?$AA@ DB '0EXECUTE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04ILIHGCAL@1?$FL?8?$FN?$AA@
CONST	SEGMENT
??_C@_04ILIHGCAL@1?$FL?8?$FN?$AA@ DB '1['']', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02POBAHBBI@0?8?$AA@
CONST	SEGMENT
??_C@_02POBAHBBI@0?8?$AA@ DB '0''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06HGPCBKK@0DOES?$DO?$AA@
CONST	SEGMENT
??_C@_06HGPCBKK@0DOES?$DO?$AA@ DB '0DOES>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CKFDKAEF@0FORGET?$AA@
CONST	SEGMENT
??_C@_07CKFDKAEF@0FORGET?$AA@ DB '0FORGET', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HOLFGALO@0CREATE?$AA@
CONST	SEGMENT
??_C@_07HOLFGALO@0CREATE?$AA@ DB '0CREATE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02CLMAOAGE@0?$FN?$AA@
CONST	SEGMENT
??_C@_02CLMAOAGE@0?$FN?$AA@ DB '0]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02HMFICNNF@1?$FL?$AA@
CONST	SEGMENT
??_C@_02HMFICNNF@1?$FL?$AA@ DB '1[', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FBPCDAOB@0IMMEDIATE?$AA@
CONST	SEGMENT
??_C@_0L@FBPCDAOB@0IMMEDIATE?$AA@ DB '0IMMEDIATE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02BJKFEGHC@1?$DL?$AA@
CONST	SEGMENT
??_C@_02BJKFEGHC@1?$DL?$AA@ DB '1;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02BHMBNAE@0?3?$AA@
CONST	SEGMENT
??_C@_02BHMBNAE@0?3?$AA@ DB '0:', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JACHHCHC@0WORDSUNUSED?$AA@
CONST	SEGMENT
??_C@_0N@JACHHCHC@0WORDSUNUSED?$AA@ DB '0WORDSUNUSED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KDKOLN@0WORDSUSED?$AA@
CONST	SEGMENT
??_C@_0L@KDKOLN@0WORDSUSED?$AA@ DB '0WORDSUSED', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BHMIPPJ@0WALKBACK?$AA@
CONST	SEGMENT
??_C@_09BHMIPPJ@0WALKBACK?$AA@ DB '0WALKBACK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MDEGOEBI@0TRACE?$AA@
CONST	SEGMENT
??_C@_06MDEGOEBI@0TRACE?$AA@ DB '0TRACE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07COPGIKHD@0SYSTEM?$AA@
CONST	SEGMENT
??_C@_07COPGIKHD@0SYSTEM?$AA@ DB '0SYSTEM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EPGGOCC@1ABORT?$CC?$AA@
CONST	SEGMENT
??_C@_07EPGGOCC@1ABORT?$CC?$AA@ DB '1ABORT"', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FOFPHNNG@0ABORT?$AA@
CONST	SEGMENT
??_C@_06FOFPHNNG@0ABORT?$AA@ DB '0ABORT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BCHLGOAF@0QUIT?$AA@
CONST	SEGMENT
??_C@_05BCHLGOAF@0QUIT?$AA@ DB '0QUIT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02COEDGEPC@0J?$AA@
CONST	SEGMENT
??_C@_02COEDGEPC@0J?$AA@ DB '0J', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FGODHDB@0I?$AA@
CONST	SEGMENT
??_C@_02FGODHDB@0I?$AA@ DB '0I', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06OEOOEOOH@0LEAVE?$AA@
CONST	SEGMENT
??_C@_06OEOOEOOH@0LEAVE?$AA@ DB '0LEAVE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09LADNBAGF@0?$CI?$CLXLOOP?$CJ?$AA@
CONST	SEGMENT
??_C@_09LADNBAGF@0?$CI?$CLXLOOP?$CJ?$AA@ DB '0(+XLOOP)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EENKAJAP@0?$CIXLOOP?$CJ?$AA@
CONST	SEGMENT
??_C@_08EENKAJAP@0?$CIXLOOP?$CJ?$AA@ DB '0(XLOOP)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LBIDLKB@0?$CIX?$DPDO?$CJ?$AA@
CONST	SEGMENT
??_C@_07LBIDLKB@0?$CIX?$DPDO?$CJ?$AA@ DB '0(X?DO)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06CJKBMPO@0?$CIXDO?$CJ?$AA@
CONST	SEGMENT
??_C@_06CJKBMPO@0?$CIXDO?$CJ?$AA@ DB '0(XDO)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06JOOFBBBI@1?$CLLOOP?$AA@
CONST	SEGMENT
??_C@_06JOOFBBBI@1?$CLLOOP?$AA@ DB '1+LOOP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05BOBCOANO@1LOOP?$AA@
CONST	SEGMENT
??_C@_05BOBCOANO@1LOOP?$AA@ DB '1LOOP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NKGAHPF@1?$DPDO?$AA@
CONST	SEGMENT
??_C@_04NKGAHPF@1?$DPDO?$AA@ DB '1?DO', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JGFOMJPB@1DO?$AA@
CONST	SEGMENT
??_C@_03JGFOMJPB@1DO?$AA@ DB '1DO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DDDAIFH@1REPEAT?$AA@
CONST	SEGMENT
??_C@_07DDDAIFH@1REPEAT?$AA@ DB '1REPEAT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HBNHNPD@1WHILE?$AA@
CONST	SEGMENT
??_C@_06HBNHNPD@1WHILE?$AA@ DB '1WHILE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HAEJDIGL@1AGAIN?$AA@
CONST	SEGMENT
??_C@_06HAEJDIGL@1AGAIN?$AA@ DB '1AGAIN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LAOPNPLI@1UNTIL?$AA@
CONST	SEGMENT
??_C@_06LAOPNPLI@1UNTIL?$AA@ DB '1UNTIL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KJHGEGHJ@1BEGIN?$AA@
CONST	SEGMENT
??_C@_06KJHGEGHJ@1BEGIN?$AA@ DB '1BEGIN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KNIMAIMD@0?$DPDUP?$AA@
CONST	SEGMENT
??_C@_05KNIMAIMD@0?$DPDUP?$AA@ DB '0?DUP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KIDLOCN@1THEN?$AA@
CONST	SEGMENT
??_C@_05KIDLOCN@1THEN?$AA@ DB '1THEN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CDDOJBEB@1ELSE?$AA@
CONST	SEGMENT
??_C@_05CDDOJBEB@1ELSE?$AA@ DB '1ELSE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EPEEOBOL@1IF?$AA@
CONST	SEGMENT
??_C@_03EPEEOBOL@1IF?$AA@ DB '1IF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08KNNMAPJN@0?$DPBRANCH?$AA@
CONST	SEGMENT
??_C@_08KNNMAPJN@0?$DPBRANCH?$AA@ DB '0?BRANCH', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NJOGBGCE@0BRANCH?$AA@
CONST	SEGMENT
??_C@_07NJOGBGCE@0BRANCH?$AA@ DB '0BRANCH', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HFODLJPA@0?$CILIT?$CJ?$AA@
CONST	SEGMENT
??_C@_06HFODLJPA@0?$CILIT?$CJ?$AA@ DB '0(LIT)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05HFHBIHJK@0EXIT?$AA@
CONST	SEGMENT
??_C@_05HFHBIHJK@0EXIT?$AA@ DB '0EXIT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LAEIABPO@0?$CINEST?$CJ?$AA@
CONST	SEGMENT
??_C@_07LAEIABPO@0?$CINEST?$CJ?$AA@ DB '0(NEST)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04MDDBKNON@0TAN?$AA@
CONST	SEGMENT
??_C@_04MDDBKNON@0TAN?$AA@ DB '0TAN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PHKKOGKD@0SQRT?$AA@
CONST	SEGMENT
??_C@_05PHKKOGKD@0SQRT?$AA@ DB '0SQRT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FAPFMEOM@0SIN?$AA@
CONST	SEGMENT
??_C@_04FAPFMEOM@0SIN?$AA@ DB '0SIN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NNMNLOKI@0POW?$AA@
CONST	SEGMENT
??_C@_04NNMNLOKI@0POW?$AA@ DB '0POW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04INMAEENO@0LOG?$AA@
CONST	SEGMENT
??_C@_04INMAEENO@0LOG?$AA@ DB '0LOG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OMCCDKDH@0EXP?$AA@
CONST	SEGMENT
??_C@_04OMCCDKDH@0EXP?$AA@ DB '0EXP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PLANIDNN@0COS?$AA@
CONST	SEGMENT
??_C@_04PLANIDNN@0COS?$AA@ DB '0COS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HHLLPOPC@0ATAN2?$AA@
CONST	SEGMENT
??_C@_06HHLLPOPC@0ATAN2?$AA@ DB '0ATAN2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HEBJDFIB@0ATAN?$AA@
CONST	SEGMENT
??_C@_05HEBJDFIB@0ATAN?$AA@ DB '0ATAN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OHNNFMIA@0ASIN?$AA@
CONST	SEGMENT
??_C@_05OHNNFMIA@0ASIN?$AA@ DB '0ASIN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EMCFBLLB@0ACOS?$AA@
CONST	SEGMENT
??_C@_05EMCFBLLB@0ACOS?$AA@ DB '0ACOS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CLKKNGJG@0FIX?$AA@
CONST	SEGMENT
??_C@_04CLKKNGJG@0FIX?$AA@ DB '0FIX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OCAKOOCG@0FLOAT?$AA@
CONST	SEGMENT
??_C@_06OCAKOOCG@0FLOAT?$AA@ DB '0FLOAT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FBIACABM@0F?4?$AA@
CONST	SEGMENT
??_C@_03FBIACABM@0F?4?$AA@ DB '0F.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GBBKODMP@0F?$DM?$DN?$AA@
CONST	SEGMENT
??_C@_04GBBKODMP@0F?$DM?$DN?$AA@ DB '0F<=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GCJODHKB@0F?$DO?$DN?$AA@
CONST	SEGMENT
??_C@_04GCJODHKB@0F?$DO?$DN?$AA@ DB '0F>=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CJHEFAMP@0F?$DM?$AA@
CONST	SEGMENT
??_C@_03CJHEFAMP@0F?$DM?$AA@ DB '0F<', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BLECDCEN@0F?$DO?$AA@
CONST	SEGMENT
??_C@_03BLECDCEN@0F?$DO?$AA@ DB '0F>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EKDHLAAM@0F?$DM?$DO?$AA@
CONST	SEGMENT
??_C@_04EKDHLAAM@0F?$DM?$DO?$AA@ DB '0F<>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DAGPGBIO@0F?$DN?$AA@
CONST	SEGMENT
??_C@_03DAGPGBIO@0F?$DN?$AA@ DB '0F=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FMNEJMHJ@0FABS?$AA@
CONST	SEGMENT
??_C@_05FMNEJMHJ@0FABS?$AA@ DB '0FABS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LMFEPDDP@0FNEGATE?$AA@
CONST	SEGMENT
??_C@_08LMFEPDDP@0FNEGATE?$AA@ DB '0FNEGATE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05PHLAEEFD@0FMAX?$AA@
CONST	SEGMENT
??_C@_05PHLAEEFD@0FMAX?$AA@ DB '0FMAX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OFDLKADM@0FMIN?$AA@
CONST	SEGMENT
??_C@_05OFDLKADM@0FMIN?$AA@ DB '0FMIN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EIJLBBFN@0F?1?$AA@
CONST	SEGMENT
??_C@_03EIJLBBFN@0F?1?$AA@ DB '0F/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DFOMOFBI@0F?$CK?$AA@
CONST	SEGMENT
??_C@_03DFOMOFBI@0F?$CK?$AA@ DB '0F*', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HKKNHDNP@0F?9?$AA@
CONST	SEGMENT
??_C@_03HKKNHDNP@0F?9?$AA@ DB '0F-', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CMPHNEFJ@0F?$CL?$AA@
CONST	SEGMENT
??_C@_03CMPHNEFJ@0F?$CL?$AA@ DB '0F+', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GOKPFGBJ@0?$CIFLIT?$CJ?$AA@
CONST	SEGMENT
??_C@_07GOKPFGBJ@0?$CIFLIT?$CJ?$AA@ DB '0(FLIT)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LJDPGIKE@0STRREAL?$AA@
CONST	SEGMENT
??_C@_08LJDPGIKE@0STRREAL?$AA@ DB '0STRREAL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JKCOHJKG@0STRINT?$AA@
CONST	SEGMENT
??_C@_07JKCOHJKG@0STRINT?$AA@ DB '0STRINT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KKFANBFF@0FSTRFORM?$AA@
CONST	SEGMENT
??_C@_09KKFANBFF@0FSTRFORM?$AA@ DB '0FSTRFORM', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EEJJJFOK@0STRFORM?$AA@
CONST	SEGMENT
??_C@_08EEJJJFOK@0STRFORM?$AA@ DB '0STRFORM', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GINNEDKC@0COMPARE?$AA@
CONST	SEGMENT
??_C@_08GINNEDKC@0COMPARE?$AA@ DB '0COMPARE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07EJNNALFK@0SUBSTR?$AA@
CONST	SEGMENT
??_C@_07EJNNALFK@0SUBSTR?$AA@ DB '0SUBSTR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MCJEDBJE@0STRCHAR?$AA@
CONST	SEGMENT
??_C@_08MCJEDBJE@0STRCHAR?$AA@ DB '0STRCHAR', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JDLJOCJP@0STRCMP?$AA@
CONST	SEGMENT
??_C@_07JDLJOCJP@0STRCMP?$AA@ DB '0STRCMP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BBIIJMKO@0STRLEN?$AA@
CONST	SEGMENT
??_C@_07BBIIJMKO@0STRLEN?$AA@ DB '0STRLEN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DGBKLFMC@0S?$CL?$AA@
CONST	SEGMENT
??_C@_03DGBKLFMC@0S?$CL?$AA@ DB '0S+', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07POMPNOPP@0STRCAT?$AA@
CONST	SEGMENT
??_C@_07POMPNOPP@0STRCAT?$AA@ DB '0STRCAT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MMPFFNEI@0S?$CB?$AA@
CONST	SEGMENT
??_C@_03MMPFFNEI@0S?$CB?$AA@ DB '0S!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FGIFGJPF@0STRCPY?$AA@
CONST	SEGMENT
??_C@_07FGIFGJPF@0STRCPY?$AA@ DB '0STRCPY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PLMBDIDE@0STRING?$AA@
CONST	SEGMENT
??_C@_07PLMBDIDE@0STRING?$AA@ DB '0STRING', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09FEDGBOAP@0?$CISTRLIT?$CJ?$AA@
CONST	SEGMENT
??_C@_09FEDGBOAP@0?$CISTRLIT?$CJ?$AA@ DB '0(STRLIT)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DHACAGHC@0ARRAY?$AA@
CONST	SEGMENT
??_C@_06DHACAGHC@0ARRAY?$AA@ DB '0ARRAY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GMDIKDOI@0HERE?$AA@
CONST	SEGMENT
??_C@_05GMDIKDOI@0HERE?$AA@ DB '0HERE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DGKEKDGF@0C?$DN?$AA@
CONST	SEGMENT
??_C@_03DGKEKDGF@0C?$DN?$AA@ DB '0C=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GFHNIAHF@0C?0?$AA@
CONST	SEGMENT
??_C@_03GFHNIAHF@0C?0?$AA@ DB '0C,', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KMDFKENO@0C?$EA?$AA@
CONST	SEGMENT
??_C@_03KMDFKENO@0C?$EA?$AA@ DB '0C@', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NANDPODI@0C?$CB?$AA@
CONST	SEGMENT
??_C@_03NANDPODI@0C?$CB?$AA@ DB '0C!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02BNOEKIND@0?0?$AA@
CONST	SEGMENT
??_C@_02BNOEKIND@0?0?$AA@ DB '0,', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06OHCEFMHK@0ALLOT?$AA@
CONST	SEGMENT
??_C@_06OHCEFMHK@0ALLOT?$AA@ DB '0ALLOT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JGBHGEKA@0?$CL?$CB?$AA@
CONST	SEGMENT
??_C@_03JGBHGEKA@0?$CL?$CB?$AA@ DB '0+!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02NEKMIMHI@0?$EA?$AA@
CONST	SEGMENT
??_C@_02NEKMIMHI@0?$EA?$AA@ DB '0@', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KIEKNGJO@0?$CB?$AA@
CONST	SEGMENT
??_C@_02KIEKNGJO@0?$CB?$AA@ DB '0!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09LHOCOAIG@0CONSTANT?$AA@
CONST	SEGMENT
??_C@_09LHOCOAIG@0CONSTANT?$AA@ DB '0CONSTANT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09KMOEGCKP@0VARIABLE?$AA@
CONST	SEGMENT
??_C@_09KMOEGCKP@0VARIABLE?$AA@ DB '0VARIABLE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03PJAGKGLJ@02?$EA?$AA@
CONST	SEGMENT
??_C@_03PJAGKGLJ@02?$EA?$AA@ DB '02@', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IFOAPMFP@02?$CB?$AA@
CONST	SEGMENT
??_C@_03IFOAPMFP@02?$CB?$AA@ DB '02!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BDHAKCDN@02CONSTANT?$AA@
CONST	SEGMENT
??_C@_0L@BDHAKCDN@02CONSTANT?$AA@ DB '02CONSTANT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IHGCABE@02VARIABLE?$AA@
CONST	SEGMENT
??_C@_0L@IHGCABE@02VARIABLE?$AA@ DB '02VARIABLE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05FFLDCHJD@02ROT?$AA@
CONST	SEGMENT
??_C@_05FFLDCHJD@02ROT?$AA@ DB '02ROT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EJFLMMGO@02OVER?$AA@
CONST	SEGMENT
??_C@_06EJFLMMGO@02OVER?$AA@ DB '02OVER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GBMIBLNG@02SWAP?$AA@
CONST	SEGMENT
??_C@_06GBMIBLNG@02SWAP?$AA@ DB '02SWAP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IOEIINHM@02DROP?$AA@
CONST	SEGMENT
??_C@_06IOEIINHM@02DROP?$AA@ DB '02DROP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FFBMMMHC@02DUP?$AA@
CONST	SEGMENT
??_C@_05FFBMMMHC@02DUP?$AA@ DB '02DUP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HJAIEECN@00?$DM?$AA@
CONST	SEGMENT
??_C@_03HJAIEECN@00?$DM?$AA@ DB '00<', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03ELDOCGKP@00?$DO?$AA@
CONST	SEGMENT
??_C@_03ELDOCGKP@00?$DO?$AA@ DB '00>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EGDEPEM@00?$DM?$DO?$AA@
CONST	SEGMENT
??_C@_04EGDEPEM@00?$DM?$DO?$AA@ DB '00<>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GABDHFGM@00?$DN?$AA@
CONST	SEGMENT
??_C@_03GABDHFGM@00?$DN?$AA@ DB '00=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BLGDNBNB@02?1?$AA@
CONST	SEGMENT
??_C@_03BLGDNBNB@02?1?$AA@ DB '02/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GGBECFJE@02?$CK?$AA@
CONST	SEGMENT
??_C@_03GGBECFJE@02?$CK?$AA@ DB '02*', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CJFFLDFD@02?9?$AA@
CONST	SEGMENT
??_C@_03CJFFLDFD@02?9?$AA@ DB '02-', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CLBDANAK@01?9?$AA@
CONST	SEGMENT
??_C@_03CLBDANAK@01?9?$AA@ DB '01-', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HPAPBENF@02?$CL?$AA@
CONST	SEGMENT
??_C@_03HPAPBENF@02?$CL?$AA@ DB '02+', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HNEJKKIM@01?$CL?$AA@
CONST	SEGMENT
??_C@_03HNEJKKIM@01?$CL?$AA@ DB '01+', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LBNBGNJJ@0R?$EA?$AA@
CONST	SEGMENT
??_C@_03LBNBGNJJ@0R?$EA?$AA@ DB '0R@', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GNDJOB@0R?$DO?$AA@
CONST	SEGMENT
??_C@_03GNDJOB@0R?$DO?$AA@ DB '0R>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IIOICPAO@0?$DOR?$AA@
CONST	SEGMENT
??_C@_03IIOICPAO@0?$DOR?$AA@ DB '0>R', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OOKPPJJM@0ROLL?$AA@
CONST	SEGMENT
??_C@_05OOKPPJJM@0ROLL?$AA@ DB '0ROLL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LHADCHMA@0?9ROT?$AA@
CONST	SEGMENT
??_C@_05LHADCHMA@0?9ROT?$AA@ DB '0-ROT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FMOJCFOA@0ROT?$AA@
CONST	SEGMENT
??_C@_04FMOJCFOA@0ROT?$AA@ DB '0ROT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PFBJCENK@0PICK?$AA@
CONST	SEGMENT
??_C@_05PFBJCENK@0PICK?$AA@ DB '0PICK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IAFOLGOK@0OVER?$AA@
CONST	SEGMENT
??_C@_05IAFOLGOK@0OVER?$AA@ DB '0OVER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KIMNGBFC@0SWAP?$AA@
CONST	SEGMENT
??_C@_05KIMNGBFC@0SWAP?$AA@ DB '0SWAP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EHENPHPI@0DROP?$AA@
CONST	SEGMENT
??_C@_05EHENPHPI@0DROP?$AA@ DB '0DROP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FMEGMOAB@0DUP?$AA@
CONST	SEGMENT
??_C@_04FMEGMOAB@0DUP?$AA@ DB '0DUP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ILCADIHH@0CLEAR?$AA@
CONST	SEGMENT
??_C@_06ILCADIHH@0CLEAR?$AA@ DB '0CLEAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FGDCFGFD@0DEPTH?$AA@
CONST	SEGMENT
??_C@_06FGDCFGFD@0DEPTH?$AA@ DB '0DEPTH', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GELFJCJH@0SHIFT?$AA@
CONST	SEGMENT
??_C@_06GELFJCJH@0SHIFT?$AA@ DB '0SHIFT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EGCGMNMH@0NOT?$AA@
CONST	SEGMENT
??_C@_04EGCGMNMH@0NOT?$AA@ DB '0NOT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GFAOGCAC@0XOR?$AA@
CONST	SEGMENT
??_C@_04GFAOGCAC@0XOR?$AA@ DB '0XOR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NNNLCNGJ@0OR?$AA@
CONST	SEGMENT
??_C@_03NNNLCNGJ@0OR?$AA@ DB '0OR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FFEFKFPH@0AND?$AA@
CONST	SEGMENT
??_C@_04FFEFKFPH@0AND?$AA@ DB '0AND', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GJAJIMAI@0?$DM?$DN?$AA@
CONST	SEGMENT
??_C@_03GJAJIMAI@0?$DM?$DN?$AA@ DB '0<=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GKINFIGG@0?$DO?$DN?$AA@
CONST	SEGMENT
??_C@_03GKINFIGG@0?$DO?$DN?$AA@ DB '0>=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02FHCGLKIC@0?$DM?$AA@
CONST	SEGMENT
??_C@_02FHCGLKIC@0?$DM?$AA@ DB '0<', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GFBANIAA@0?$DO?$AA@
CONST	SEGMENT
??_C@_02GFBANIAA@0?$DO?$AA@ DB '0>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03ECCENPML@0?$DM?$DO?$AA@
CONST	SEGMENT
??_C@_03ECCENPML@0?$DM?$DO?$AA@ DB '0<>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02EODNILMD@0?$DN?$AA@
CONST	SEGMENT
??_C@_02EODNILMD@0?$DN?$AA@ DB '0=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FJNMNIAF@0ABS?$AA@
CONST	SEGMENT
??_C@_04FJNMNIAF@0ABS?$AA@ DB '0ABS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HLHBGADN@0NEGATE?$AA@
CONST	SEGMENT
??_C@_07HLHBGADN@0NEGATE?$AA@ DB '0NEGATE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCLIAACP@0MAX?$AA@
CONST	SEGMENT
??_C@_04PCLIAACP@0MAX?$AA@ DB '0MAX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OADDOEEA@0MIN?$AA@
CONST	SEGMENT
??_C@_04OADDOEEA@0MIN?$AA@ DB '0MIN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IPHLCBDI@0?1MOD?$AA@
CONST	SEGMENT
??_C@_05IPHLCBDI@0?1MOD?$AA@ DB '0/MOD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BOFBHAHI@0MOD?$AA@
CONST	SEGMENT
??_C@_04BOFBHAHI@0MOD?$AA@ DB '0MOD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DGMJPLBA@0?1?$AA@
CONST	SEGMENT
??_C@_02DGMJPLBA@0?1?$AA@ DB '0/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02ELLOAPFF@0?$CK?$AA@
CONST	SEGMENT
??_C@_02ELLOAPFF@0?$CK?$AA@ DB '0*', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02EPPJJJC@0?9?$AA@
CONST	SEGMENT
??_C@_02EPPJJJC@0?9?$AA@ DB '0-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FCKFDOBE@0?$CL?$AA@
CONST	SEGMENT
??_C@_02FCKFDOBE@0?$CL?$AA@ DB '0+', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02CHHAKFFB@w?$CL?$AA@
CONST	SEGMENT
??_C@_02CHHAKFFB@w?$CL?$AA@ DB 'w+', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CBLLGHLK@r?$CL?$AA@
CONST	SEGMENT
??_C@_02CBLLGHLK@r?$CL?$AA@ DB 'r+', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
CONST	SEGMENT
_recargchar DB	'option requires an argument -- %c', 00H
	ORG $+2
_recargstring DB 'option requires an argument -- %s', 00H
	ORG $+2
_ambig	DB	'ambiguous option -- %.*s', 00H
	ORG $+3
_noarg	DB	'option doesn''t take an argument -- %.*s', 00H
_illoptchar DB	'unknown option -- %c', 00H
	ORG $+3
_illoptstring DB 'unknown option -- %s', 00H
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
_opterr	DD	01H
_optind	DD	01H
_optopt	DD	03fH
_place	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
_nonopt_start DD 0ffffffffH
_nonopt_end DD	0ffffffffH
?posixly_correct@?1??getopt_internal@@9@9 DD 0ffffffffH	; `getopt_internal'::`2'::posixly_correct
_base	DD	0aH
_atl_stklen DQ	0000000000000064H
_atl_rstklen DQ	0000000000000064H
_atl_heaplen DQ	00000000000007d0H
_atl_ltempstr DQ 0000000000000100H
_atl_ntempstr DQ 0000000000000004H
_atl_walkback DQ ffffffffffffffffH
_atl_redef DQ	ffffffffffffffffH
_fopenmodes DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:??_C@_01KDCPPGHE@r?$AA@
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:??_C@_02CBLLGHLK@r?$CL?$AA@
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:??_C@_01KDCPPGHE@r?$AA@
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:??_C@_02CBLLGHLK@r?$CL?$AA@
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:??_C@_01NOFIACDB@w?$AA@
	DD	FLAT:??_C@_02CHHAKFFB@w?$CL?$AA@
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:??_C@_01NOFIACDB@w?$AA@
	DD	FLAT:??_C@_02CHHAKFFB@w?$CL?$AA@
_primt	DD	FLAT:??_C@_02FCKFDOBE@0?$CL?$AA@
	DD	FLAT:_P_plus
	DD	FLAT:??_C@_02EPPJJJC@0?9?$AA@
	DD	FLAT:_P_minus
	DD	FLAT:??_C@_02ELLOAPFF@0?$CK?$AA@
	DD	FLAT:_P_times
	DD	FLAT:??_C@_02DGMJPLBA@0?1?$AA@
	DD	FLAT:_P_div
	DD	FLAT:??_C@_04BOFBHAHI@0MOD?$AA@
	DD	FLAT:_P_mod
	DD	FLAT:??_C@_05IPHLCBDI@0?1MOD?$AA@
	DD	FLAT:_P_divmod
	DD	FLAT:??_C@_04OADDOEEA@0MIN?$AA@
	DD	FLAT:_P_min
	DD	FLAT:??_C@_04PCLIAACP@0MAX?$AA@
	DD	FLAT:_P_max
	DD	FLAT:??_C@_07HLHBGADN@0NEGATE?$AA@
	DD	FLAT:_P_neg
	DD	FLAT:??_C@_04FJNMNIAF@0ABS?$AA@
	DD	FLAT:_P_abs
	DD	FLAT:??_C@_02EODNILMD@0?$DN?$AA@
	DD	FLAT:_P_equal
	DD	FLAT:??_C@_03ECCENPML@0?$DM?$DO?$AA@
	DD	FLAT:_P_unequal
	DD	FLAT:??_C@_02GFBANIAA@0?$DO?$AA@
	DD	FLAT:_P_gtr
	DD	FLAT:??_C@_02FHCGLKIC@0?$DM?$AA@
	DD	FLAT:_P_lss
	DD	FLAT:??_C@_03GKINFIGG@0?$DO?$DN?$AA@
	DD	FLAT:_P_geq
	DD	FLAT:??_C@_03GJAJIMAI@0?$DM?$DN?$AA@
	DD	FLAT:_P_leq
	DD	FLAT:??_C@_04FFEFKFPH@0AND?$AA@
	DD	FLAT:_P_and
	DD	FLAT:??_C@_03NNNLCNGJ@0OR?$AA@
	DD	FLAT:_P_or
	DD	FLAT:??_C@_04GFAOGCAC@0XOR?$AA@
	DD	FLAT:_P_xor
	DD	FLAT:??_C@_04EGCGMNMH@0NOT?$AA@
	DD	FLAT:_P_not
	DD	FLAT:??_C@_06GELFJCJH@0SHIFT?$AA@
	DD	FLAT:_P_shift
	DD	FLAT:??_C@_06FGDCFGFD@0DEPTH?$AA@
	DD	FLAT:_P_depth
	DD	FLAT:??_C@_06ILCADIHH@0CLEAR?$AA@
	DD	FLAT:_P_clear
	DD	FLAT:??_C@_04FMEGMOAB@0DUP?$AA@
	DD	FLAT:_P_dup
	DD	FLAT:??_C@_05EHENPHPI@0DROP?$AA@
	DD	FLAT:_P_drop
	DD	FLAT:??_C@_05KIMNGBFC@0SWAP?$AA@
	DD	FLAT:_P_swap
	DD	FLAT:??_C@_05IAFOLGOK@0OVER?$AA@
	DD	FLAT:_P_over
	DD	FLAT:??_C@_05PFBJCENK@0PICK?$AA@
	DD	FLAT:_P_pick
	DD	FLAT:??_C@_04FMOJCFOA@0ROT?$AA@
	DD	FLAT:_P_rot
	DD	FLAT:??_C@_05LHADCHMA@0?9ROT?$AA@
	DD	FLAT:_P_minusrot
	DD	FLAT:??_C@_05OOKPPJJM@0ROLL?$AA@
	DD	FLAT:_P_roll
	DD	FLAT:??_C@_03IIOICPAO@0?$DOR?$AA@
	DD	FLAT:_P_tor
	DD	FLAT:??_C@_03GNDJOB@0R?$DO?$AA@
	DD	FLAT:_P_rfrom
	DD	FLAT:??_C@_03LBNBGNJJ@0R?$EA?$AA@
	DD	FLAT:_P_rfetch
	DD	FLAT:??_C@_03HNEJKKIM@01?$CL?$AA@
	DD	FLAT:_P_1plus
	DD	FLAT:??_C@_03HPAPBENF@02?$CL?$AA@
	DD	FLAT:_P_2plus
	DD	FLAT:??_C@_03CLBDANAK@01?9?$AA@
	DD	FLAT:_P_1minus
	DD	FLAT:??_C@_03CJFFLDFD@02?9?$AA@
	DD	FLAT:_P_2minus
	DD	FLAT:??_C@_03GGBECFJE@02?$CK?$AA@
	DD	FLAT:_P_2times
	DD	FLAT:??_C@_03BLGDNBNB@02?1?$AA@
	DD	FLAT:_P_2div
	DD	FLAT:??_C@_03GABDHFGM@00?$DN?$AA@
	DD	FLAT:_P_0equal
	DD	FLAT:??_C@_04EGDEPEM@00?$DM?$DO?$AA@
	DD	FLAT:_P_0notequal
	DD	FLAT:??_C@_03ELDOCGKP@00?$DO?$AA@
	DD	FLAT:_P_0gtr
	DD	FLAT:??_C@_03HJAIEECN@00?$DM?$AA@
	DD	FLAT:_P_0lss
	DD	FLAT:??_C@_05FFBMMMHC@02DUP?$AA@
	DD	FLAT:_P_2dup
	DD	FLAT:??_C@_06IOEIINHM@02DROP?$AA@
	DD	FLAT:_P_2drop
	DD	FLAT:??_C@_06GBMIBLNG@02SWAP?$AA@
	DD	FLAT:_P_2swap
	DD	FLAT:??_C@_06EJFLMMGO@02OVER?$AA@
	DD	FLAT:_P_2over
	DD	FLAT:??_C@_05FFLDCHJD@02ROT?$AA@
	DD	FLAT:_P_2rot
	DD	FLAT:??_C@_0L@IHGCABE@02VARIABLE?$AA@
	DD	FLAT:_P_2variable
	DD	FLAT:??_C@_0L@BDHAKCDN@02CONSTANT?$AA@
	DD	FLAT:_P_2constant
	DD	FLAT:??_C@_03IFOAPMFP@02?$CB?$AA@
	DD	FLAT:_P_2bang
	DD	FLAT:??_C@_03PJAGKGLJ@02?$EA?$AA@
	DD	FLAT:_P_2at
	DD	FLAT:??_C@_09KMOEGCKP@0VARIABLE?$AA@
	DD	FLAT:_P_variable
	DD	FLAT:??_C@_09LHOCOAIG@0CONSTANT?$AA@
	DD	FLAT:_P_constant
	DD	FLAT:??_C@_02KIEKNGJO@0?$CB?$AA@
	DD	FLAT:_P_bang
	DD	FLAT:??_C@_02NEKMIMHI@0?$EA?$AA@
	DD	FLAT:_P_at
	DD	FLAT:??_C@_03JGBHGEKA@0?$CL?$CB?$AA@
	DD	FLAT:_P_plusbang
	DD	FLAT:??_C@_06OHCEFMHK@0ALLOT?$AA@
	DD	FLAT:_P_allot
	DD	FLAT:??_C@_02BNOEKIND@0?0?$AA@
	DD	FLAT:_P_comma
	DD	FLAT:??_C@_03NANDPODI@0C?$CB?$AA@
	DD	FLAT:_P_cbang
	DD	FLAT:??_C@_03KMDFKENO@0C?$EA?$AA@
	DD	FLAT:_P_cat
	DD	FLAT:??_C@_03GFHNIAHF@0C?0?$AA@
	DD	FLAT:_P_ccomma
	DD	FLAT:??_C@_03DGKEKDGF@0C?$DN?$AA@
	DD	FLAT:_P_cequal
	DD	FLAT:??_C@_05GMDIKDOI@0HERE?$AA@
	DD	FLAT:_P_here
	DD	FLAT:??_C@_06DHACAGHC@0ARRAY?$AA@
	DD	FLAT:_P_array
	DD	FLAT:??_C@_09FEDGBOAP@0?$CISTRLIT?$CJ?$AA@
	DD	FLAT:_P_strlit
	DD	FLAT:??_C@_07PLMBDIDE@0STRING?$AA@
	DD	FLAT:_P_string
	DD	FLAT:??_C@_07FGIFGJPF@0STRCPY?$AA@
	DD	FLAT:_P_strcpy
	DD	FLAT:??_C@_03MMPFFNEI@0S?$CB?$AA@
	DD	FLAT:_P_strcpy
	DD	FLAT:??_C@_07POMPNOPP@0STRCAT?$AA@
	DD	FLAT:_P_strcat
	DD	FLAT:??_C@_03DGBKLFMC@0S?$CL?$AA@
	DD	FLAT:_P_strcat
	DD	FLAT:??_C@_07BBIIJMKO@0STRLEN?$AA@
	DD	FLAT:_P_strlen
	DD	FLAT:??_C@_07JDLJOCJP@0STRCMP?$AA@
	DD	FLAT:_P_strcmp
	DD	FLAT:??_C@_08MCJEDBJE@0STRCHAR?$AA@
	DD	FLAT:_P_strchar
	DD	FLAT:??_C@_07EJNNALFK@0SUBSTR?$AA@
	DD	FLAT:_P_substr
	DD	FLAT:??_C@_08GINNEDKC@0COMPARE?$AA@
	DD	FLAT:_P_strcmp
	DD	FLAT:??_C@_08EEJJJFOK@0STRFORM?$AA@
	DD	FLAT:_P_strform
	DD	FLAT:??_C@_09KKFANBFF@0FSTRFORM?$AA@
	DD	FLAT:_P_fstrform
	DD	FLAT:??_C@_07JKCOHJKG@0STRINT?$AA@
	DD	FLAT:_P_strint
	DD	FLAT:??_C@_08LJDPGIKE@0STRREAL?$AA@
	DD	FLAT:_P_strreal
	DD	FLAT:??_C@_07GOKPFGBJ@0?$CIFLIT?$CJ?$AA@
	DD	FLAT:_P_flit
	DD	FLAT:??_C@_03CMPHNEFJ@0F?$CL?$AA@
	DD	FLAT:_P_fplus
	DD	FLAT:??_C@_03HKKNHDNP@0F?9?$AA@
	DD	FLAT:_P_fminus
	DD	FLAT:??_C@_03DFOMOFBI@0F?$CK?$AA@
	DD	FLAT:_P_ftimes
	DD	FLAT:??_C@_03EIJLBBFN@0F?1?$AA@
	DD	FLAT:_P_fdiv
	DD	FLAT:??_C@_05OFDLKADM@0FMIN?$AA@
	DD	FLAT:_P_fmin
	DD	FLAT:??_C@_05PHLAEEFD@0FMAX?$AA@
	DD	FLAT:_P_fmax
	DD	FLAT:??_C@_08LMFEPDDP@0FNEGATE?$AA@
	DD	FLAT:_P_fneg
	DD	FLAT:??_C@_05FMNEJMHJ@0FABS?$AA@
	DD	FLAT:_P_fabs
	DD	FLAT:??_C@_03DAGPGBIO@0F?$DN?$AA@
	DD	FLAT:_P_fequal
	DD	FLAT:??_C@_04EKDHLAAM@0F?$DM?$DO?$AA@
	DD	FLAT:_P_funequal
	DD	FLAT:??_C@_03BLECDCEN@0F?$DO?$AA@
	DD	FLAT:_P_fgtr
	DD	FLAT:??_C@_03CJHEFAMP@0F?$DM?$AA@
	DD	FLAT:_P_flss
	DD	FLAT:??_C@_04GCJODHKB@0F?$DO?$DN?$AA@
	DD	FLAT:_P_fgeq
	DD	FLAT:??_C@_04GBBKODMP@0F?$DM?$DN?$AA@
	DD	FLAT:_P_fleq
	DD	FLAT:??_C@_03FBIACABM@0F?4?$AA@
	DD	FLAT:_P_fdot
	DD	FLAT:??_C@_06OCAKOOCG@0FLOAT?$AA@
	DD	FLAT:_P_float
	DD	FLAT:??_C@_04CLKKNGJG@0FIX?$AA@
	DD	FLAT:_P_fix
	DD	FLAT:??_C@_05EMCFBLLB@0ACOS?$AA@
	DD	FLAT:_P_acos
	DD	FLAT:??_C@_05OHNNFMIA@0ASIN?$AA@
	DD	FLAT:_P_asin
	DD	FLAT:??_C@_05HEBJDFIB@0ATAN?$AA@
	DD	FLAT:_P_atan
	DD	FLAT:??_C@_06HHLLPOPC@0ATAN2?$AA@
	DD	FLAT:_P_atan2
	DD	FLAT:??_C@_04PLANIDNN@0COS?$AA@
	DD	FLAT:_P_cos
	DD	FLAT:??_C@_04OMCCDKDH@0EXP?$AA@
	DD	FLAT:_P_exp
	DD	FLAT:??_C@_04INMAEENO@0LOG?$AA@
	DD	FLAT:_P_log
	DD	FLAT:??_C@_04NNMNLOKI@0POW?$AA@
	DD	FLAT:_P_pow
	DD	FLAT:??_C@_04FAPFMEOM@0SIN?$AA@
	DD	FLAT:_P_sin
	DD	FLAT:??_C@_05PHKKOGKD@0SQRT?$AA@
	DD	FLAT:_P_sqrt
	DD	FLAT:??_C@_04MDDBKNON@0TAN?$AA@
	DD	FLAT:_P_tan
	DD	FLAT:??_C@_07LAEIABPO@0?$CINEST?$CJ?$AA@
	DD	FLAT:_P_nest
	DD	FLAT:??_C@_05HFHBIHJK@0EXIT?$AA@
	DD	FLAT:_P_exit
	DD	FLAT:??_C@_06HFODLJPA@0?$CILIT?$CJ?$AA@
	DD	FLAT:_P_dolit
	DD	FLAT:??_C@_07NJOGBGCE@0BRANCH?$AA@
	DD	FLAT:_P_branch
	DD	FLAT:??_C@_08KNNMAPJN@0?$DPBRANCH?$AA@
	DD	FLAT:_P_qbranch
	DD	FLAT:??_C@_03EPEEOBOL@1IF?$AA@
	DD	FLAT:_P_if
	DD	FLAT:??_C@_05CDDOJBEB@1ELSE?$AA@
	DD	FLAT:_P_else
	DD	FLAT:??_C@_05KIDLOCN@1THEN?$AA@
	DD	FLAT:_P_then
	DD	FLAT:??_C@_05KNIMAIMD@0?$DPDUP?$AA@
	DD	FLAT:_P_qdup
	DD	FLAT:??_C@_06KJHGEGHJ@1BEGIN?$AA@
	DD	FLAT:_P_begin
	DD	FLAT:??_C@_06LAOPNPLI@1UNTIL?$AA@
	DD	FLAT:_P_until
	DD	FLAT:??_C@_06HAEJDIGL@1AGAIN?$AA@
	DD	FLAT:_P_again
	DD	FLAT:??_C@_06HBNHNPD@1WHILE?$AA@
	DD	FLAT:_P_while
	DD	FLAT:??_C@_07DDDAIFH@1REPEAT?$AA@
	DD	FLAT:_P_repeat
	DD	FLAT:??_C@_03JGFOMJPB@1DO?$AA@
	DD	FLAT:_P_do
	DD	FLAT:??_C@_04NKGAHPF@1?$DPDO?$AA@
	DD	FLAT:_P_qdo
	DD	FLAT:??_C@_05BOBCOANO@1LOOP?$AA@
	DD	FLAT:_P_loop
	DD	FLAT:??_C@_06JOOFBBBI@1?$CLLOOP?$AA@
	DD	FLAT:_P_ploop
	DD	FLAT:??_C@_06CJKBMPO@0?$CIXDO?$CJ?$AA@
	DD	FLAT:_P_xdo
	DD	FLAT:??_C@_07LBIDLKB@0?$CIX?$DPDO?$CJ?$AA@
	DD	FLAT:_P_xqdo
	DD	FLAT:??_C@_08EENKAJAP@0?$CIXLOOP?$CJ?$AA@
	DD	FLAT:_P_xloop
	DD	FLAT:??_C@_09LADNBAGF@0?$CI?$CLXLOOP?$CJ?$AA@
	DD	FLAT:_P_xploop
	DD	FLAT:??_C@_06OEOOEOOH@0LEAVE?$AA@
	DD	FLAT:_P_leave
	DD	FLAT:??_C@_02FGODHDB@0I?$AA@
	DD	FLAT:_P_i
	DD	FLAT:??_C@_02COEDGEPC@0J?$AA@
	DD	FLAT:_P_j
	DD	FLAT:??_C@_05BCHLGOAF@0QUIT?$AA@
	DD	FLAT:_P_quit
	DD	FLAT:??_C@_06FOFPHNNG@0ABORT?$AA@
	DD	FLAT:_P_abort
	DD	FLAT:??_C@_07EPGGOCC@1ABORT?$CC?$AA@
	DD	FLAT:_P_abortq
	DD	FLAT:??_C@_07COPGIKHD@0SYSTEM?$AA@
	DD	FLAT:_P_system
	DD	FLAT:??_C@_06MDEGOEBI@0TRACE?$AA@
	DD	FLAT:_P_trace
	DD	FLAT:??_C@_09BHMIPPJ@0WALKBACK?$AA@
	DD	FLAT:_P_walkback
	DD	FLAT:??_C@_0L@KDKOLN@0WORDSUSED?$AA@
	DD	FLAT:_P_wordsused
	DD	FLAT:??_C@_0N@JACHHCHC@0WORDSUNUSED?$AA@
	DD	FLAT:_P_wordsunused
	DD	FLAT:??_C@_02BHMBNAE@0?3?$AA@
	DD	FLAT:_P_colon
	DD	FLAT:??_C@_02BJKFEGHC@1?$DL?$AA@
	DD	FLAT:_P_semicolon
	DD	FLAT:??_C@_0L@FBPCDAOB@0IMMEDIATE?$AA@
	DD	FLAT:_P_immediate
	DD	FLAT:??_C@_02HMFICNNF@1?$FL?$AA@
	DD	FLAT:_P_lbrack
	DD	FLAT:??_C@_02CLMAOAGE@0?$FN?$AA@
	DD	FLAT:_P_rbrack
	DD	FLAT:??_C@_07HOLFGALO@0CREATE?$AA@
	DD	FLAT:_P_create
	DD	FLAT:??_C@_07CKFDKAEF@0FORGET?$AA@
	DD	FLAT:_P_forget
	DD	FLAT:??_C@_06HGPCBKK@0DOES?$DO?$AA@
	DD	FLAT:_P_does
	DD	FLAT:??_C@_02POBAHBBI@0?8?$AA@
	DD	FLAT:_P_tick
	DD	FLAT:??_C@_04ILIHGCAL@1?$FL?8?$FN?$AA@
	DD	FLAT:_P_bracktick
	DD	FLAT:??_C@_08BMCODLCA@0EXECUTE?$AA@
	DD	FLAT:_P_execute
	DD	FLAT:??_C@_06JCOGDEN@0?$DOBODY?$AA@
	DD	FLAT:_P_body
	DD	FLAT:??_C@_06EIGKJEPF@0STATE?$AA@
	DD	FLAT:_P_state
	DD	FLAT:??_C@_05JFPJMJGE@0FIND?$AA@
	DD	FLAT:_P_find
	DD	FLAT:??_C@_06MFKHJPKN@0?$DONAME?$AA@
	DD	FLAT:_P_toname
	DD	FLAT:??_C@_06OGBGHHPF@0?$DOLINK?$AA@
	DD	FLAT:_P_tolink
	DD	FLAT:??_C@_06GEBNCAAE@0BODY?$DO?$AA@
	DD	FLAT:_P_frombody
	DD	FLAT:??_C@_06MENLELIA@0NAME?$DO?$AA@
	DD	FLAT:_P_fromname
	DD	FLAT:??_C@_06KBEICDKO@0LINK?$DO?$AA@
	DD	FLAT:_P_fromlink
	DD	FLAT:??_C@_07CHMCIPOJ@0N?$DOLINK?$AA@
	DD	FLAT:_P_nametolink
	DD	FLAT:??_C@_07JDOMHGJI@0L?$DONAME?$AA@
	DD	FLAT:_P_linktoname
	DD	FLAT:??_C@_08DIOIEBIC@0NAME?$DOS?$CB?$AA@
	DD	FLAT:_P_fetchname
	DD	FLAT:??_C@_08NHEDMBGE@0S?$DONAME?$CB?$AA@
	DD	FLAT:_P_storename
	DD	FLAT:??_C@_0L@PPPNOFDC@1?$FLCOMPILE?$FN?$AA@
	DD	FLAT:_P_brackcompile
	DD	FLAT:??_C@_08MEIBGFMH@1LITERAL?$AA@
	DD	FLAT:_P_literal
	DD	FLAT:??_C@_08LLNBOFDH@0COMPILE?$AA@
	DD	FLAT:_P_compile
	DD	FLAT:??_C@_06EGDGINLF@0?$DMMARK?$AA@
	DD	FLAT:_P_backmark
	DD	FLAT:??_C@_09NJPHDDBE@0?$DMRESOLVE?$AA@
	DD	FLAT:_P_backresolve
	DD	FLAT:??_C@_06LPOCMLO@0?$DOMARK?$AA@
	DD	FLAT:_P_fwdmark
	DD	FLAT:??_C@_09PHABBLJC@0?$DORESOLVE?$AA@
	DD	FLAT:_P_fwdresolve
	DD	FLAT:??_C@_02CPNCMKFB@0?4?$AA@
	DD	FLAT:_P_dot
	DD	FLAT:??_C@_02HMALOJEB@0?$DP?$AA@
	DD	FLAT:_P_question
	DD	FLAT:??_C@_03NEMBNEAN@0CR?$AA@
	DD	FLAT:_P_cr
	DD	FLAT:??_C@_03INNFLNDP@0?4S?$AA@
	DD	FLAT:_P_dots
	DD	FLAT:??_C@_03DENJCON@1?4?$CC?$AA@
	DD	FLAT:_P_dotquote
	DD	FLAT:??_C@_03PJKCHKGH@1?4?$CI?$AA@
	DD	FLAT:_P_dotparen
	DD	FLAT:??_C@_05NAGDOFCC@0TYPE?$AA@
	DD	FLAT:_P_type
	DD	FLAT:??_C@_06IGNJJOKG@0WORDS?$AA@
	DD	FLAT:_P_words
	DD	FLAT:??_C@_05IPGGCMEL@0FILE?$AA@
	DD	FLAT:_P_file
	DD	FLAT:??_C@_06BKPEIBDI@0FOPEN?$AA@
	DD	FLAT:_P_fopen
	DD	FLAT:??_C@_07MIHJNOA@0FCLOSE?$AA@
	DD	FLAT:_P_fclose
	DD	FLAT:??_C@_08OAJGAKDH@0FDELETE?$AA@
	DD	FLAT:_P_fdelete
	DD	FLAT:??_C@_06KPMLMIAP@0FGETS?$AA@
	DD	FLAT:_P_fgetline
	DD	FLAT:??_C@_06CNBCNEAC@0FPUTS?$AA@
	DD	FLAT:_P_fputline
	DD	FLAT:??_C@_06BIKFDFPA@0FREAD?$AA@
	DD	FLAT:_P_fread
	DD	FLAT:??_C@_07GLDELNNH@0FWRITE?$AA@
	DD	FLAT:_P_fwrite
	DD	FLAT:??_C@_06OFAJNKFO@0FGETC?$AA@
	DD	FLAT:_P_fgetc
	DD	FLAT:??_C@_06GHNAMGFD@0FPUTC?$AA@
	DD	FLAT:_P_fputc
	DD	FLAT:??_C@_06FHOENJAL@0FTELL?$AA@
	DD	FLAT:_P_ftell
	DD	FLAT:??_C@_06KFFEKIFD@0FSEEK?$AA@
	DD	FLAT:_P_fseek
	DD	FLAT:??_C@_06KIMIPMHH@0FLOAD?$AA@
	DD	FLAT:_P_fload
	DD	FLAT:??_C@_09NMMMFPKN@0EVALUATE?$AA@
	DD	FLAT:_P_evaluate
	DD	00H
	DD	00H
?stdfiles@?8??atl_init@@9@9 DD FLAT:??_C@_05MHDFGKA@STDIN?$AA@ ; `atl_init'::`9'::stdfiles
	DD	00H
	DD	FLAT:??_C@_06DNBFFLKD@STDOUT?$AA@
	DD	00H
	DD	FLAT:??_C@_06BLNAKME@STDERR?$AA@
	DD	00H
?proname@?1??atl_prologue@@9@9 DD FLAT:??_C@_06OCMIFJOD@STACK?5?$AA@ ; `atl_prologue'::`2'::proname
	DD	FLAT:_atl_stklen
	DD	FLAT:??_C@_07NIFKNEP@RSTACK?5?$AA@
	DD	FLAT:_atl_rstklen
	DD	FLAT:??_C@_05OHLFDECO@HEAP?5?$AA@
	DD	FLAT:_atl_heaplen
	DD	FLAT:??_C@_09GDELENAF@TEMPSTRL?5?$AA@
	DD	FLAT:_atl_ltempstr
	DD	FLAT:??_C@_09GAMPJJGL@TEMPSTRN?5?$AA@
	DD	FLAT:_atl_ntempstr
_DATA	ENDS
PUBLIC	_getopt
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\a15\facultate\forth\atlast-2.0\getopt.h
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT _getopt
_TEXT	SEGMENT
_nargc$ = 8						; size = 4
_nargv$ = 12						; size = 4
_options$ = 16						; size = 4
_getopt	PROC						; COMDAT

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 223  : 
; 224  : 	/*
; 225  : 	 * We don't pass FLAG_PERMUTE to getopt_internal() since
; 226  : 	 * the BSD getopt(3) (unlike GNU) has never done this.
; 227  : 	 *
; 228  : 	 * Furthermore, since many privileged programs call getopt()
; 229  : 	 * before dropping privileges it makes sense to keep things
; 230  : 	 * as simple (and bug-free) as possible.
; 231  : 	 */
; 232  : 	return (getopt_internal(nargc, nargv, options, NULL, NULL, 0));

  0001e	6a 00		 push	 0
  00020	6a 00		 push	 0
  00022	6a 00		 push	 0
  00024	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  00027	50		 push	 eax
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR _nargv$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 08	 mov	 edx, DWORD PTR _nargc$[ebp]
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 _getopt_internal
  00035	83 c4 18	 add	 esp, 24			; 00000018H

; 233  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_getopt	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@DMNGMDNL@POSIXLY_CORRECT?$AA@		; `string'
EXTRN	__imp__strchr:PROC
EXTRN	__imp__getenv:PROC
;	COMDAT ??_C@_0BA@DMNGMDNL@POSIXLY_CORRECT?$AA@
CONST	SEGMENT
??_C@_0BA@DMNGMDNL@POSIXLY_CORRECT?$AA@ DB 'POSIXLY_CORRECT', 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _getopt_internal
_TEXT	SEGMENT
tv203 = -232						; size = 4
_short_too$ = -32					; size = 4
_optchar$ = -20						; size = 4
_oli$ = -8						; size = 4
_nargc$ = 8						; size = 4
_nargv$ = 12						; size = 4
_options$ = 16						; size = 4
_long_options$ = 20					; size = 4
_idx$ = 24						; size = 4
_flags$ = 28						; size = 4
_getopt_internal PROC					; COMDAT

; 420  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00012	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 421  : 	char *oli;				/* option letter list index */
; 422  : 	int optchar, short_too;
; 423  : 	static int posixly_correct = -1;
; 424  : 
; 425  : 	if (options == NULL)

  0001e	83 7d 10 00	 cmp	 DWORD PTR _options$[ebp], 0
  00022	75 08		 jne	 SHORT $LN54@getopt_int

; 426  : 		return (-1);

  00024	83 c8 ff	 or	 eax, -1
  00027	e9 c6 06 00 00	 jmp	 $LN55@getopt_int
$LN54@getopt_int:

; 427  : 
; 428  : 	/*
; 429  : 	 * XXX Some GNU programs (like cvs) set optind to 0 instead of
; 430  : 	 * XXX using optreset.  Work around this braindamage.
; 431  : 	 */
; 432  : 	if (optind == 0)

  0002c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _optind, 0
  00033	75 14		 jne	 SHORT $LN53@getopt_int

; 433  : 		optind = optreset = 1;

  00035	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ___mingw_optreset, 1
  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___mingw_optreset
  00044	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax
$LN53@getopt_int:

; 434  : 
; 435  : 	/*
; 436  : 	 * Disable GNU extensions if POSIXLY_CORRECT is set or options
; 437  : 	 * string begins with a '+'.
; 438  : 	 *
; 439  : 	 * CV, 2009-12-14: Check POSIXLY_CORRECT anew if optind == 0 or
; 440  : 	 *                 optreset != 0 for GNU compatibility.
; 441  : 	 */
; 442  : 	if (posixly_correct == -1 || optreset != 0)

  00049	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?posixly_correct@?1??getopt_internal@@9@9, -1
  00050	74 09		 je	 SHORT $LN51@getopt_int
  00052	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ___mingw_optreset, 0
  00059	74 22		 je	 SHORT $LN52@getopt_int
$LN51@getopt_int:

; 443  : 		posixly_correct = (getenv("POSIXLY_CORRECT") != NULL);

  0005b	8b f4		 mov	 esi, esp
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@DMNGMDNL@POSIXLY_CORRECT?$AA@
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__getenv
  00068	83 c4 04	 add	 esp, 4
  0006b	3b f4		 cmp	 esi, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	f7 d8		 neg	 eax
  00074	1b c0		 sbb	 eax, eax
  00076	f7 d8		 neg	 eax
  00078	a3 00 00 00 00	 mov	 DWORD PTR ?posixly_correct@?1??getopt_internal@@9@9, eax
$LN52@getopt_int:

; 444  : 	if (*options == '-')

  0007d	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  00080	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00083	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  00086	75 0b		 jne	 SHORT $LN50@getopt_int

; 445  : 		flags |= FLAG_ALLARGS;

  00088	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  0008b	83 c8 02	 or	 eax, 2
  0008e	89 45 1c	 mov	 DWORD PTR _flags$[ebp], eax
  00091	eb 1d		 jmp	 SHORT $LN49@getopt_int
$LN50@getopt_int:

; 446  : 	else if (posixly_correct || *options == '+')

  00093	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?posixly_correct@?1??getopt_internal@@9@9, 0
  0009a	75 0b		 jne	 SHORT $LN47@getopt_int
  0009c	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  0009f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000a2	83 f9 2b	 cmp	 ecx, 43			; 0000002bH
  000a5	75 09		 jne	 SHORT $LN49@getopt_int
$LN47@getopt_int:

; 447  : 		flags &= ~FLAG_PERMUTE;

  000a7	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  000aa	83 e0 fe	 and	 eax, -2			; fffffffeH
  000ad	89 45 1c	 mov	 DWORD PTR _flags$[ebp], eax
$LN49@getopt_int:

; 448  : 	if (*options == '+' || *options == '-')

  000b0	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  000b3	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000b6	83 f9 2b	 cmp	 ecx, 43			; 0000002bH
  000b9	74 0b		 je	 SHORT $LN45@getopt_int
  000bb	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  000be	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000c1	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  000c4	75 09		 jne	 SHORT $LN46@getopt_int
$LN45@getopt_int:

; 449  : 		options++;

  000c6	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  000c9	83 c0 01	 add	 eax, 1
  000cc	89 45 10	 mov	 DWORD PTR _options$[ebp], eax
$LN46@getopt_int:

; 450  : 
; 451  : 	optarg = NULL;

  000cf	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _optarg, 0

; 452  : 	if (optreset)

  000d9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ___mingw_optreset, 0
  000e0	74 14		 je	 SHORT $start$82039

; 453  : 		nonopt_start = nonopt_end = -1;

  000e2	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _nonopt_end, -1
  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _nonopt_end
  000f1	a3 00 00 00 00	 mov	 DWORD PTR _nonopt_start, eax
$start$82039:

; 454  : start:
; 455  : 	if (optreset || !*place) {		/* update scanning pointer */

  000f6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ___mingw_optreset, 0
  000fd	75 10		 jne	 SHORT $LN42@getopt_int
  000ff	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  00104	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00107	85 c9		 test	 ecx, ecx
  00109	0f 85 6b 02 00
	00		 jne	 $LN43@getopt_int
$LN42@getopt_int:

; 456  : 		optreset = 0;

  0010f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ___mingw_optreset, 0

; 457  : 		if (optind >= nargc) {          /* end of argument vector */

  00119	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  0011e	3b 45 08	 cmp	 eax, DWORD PTR _nargc$[ebp]
  00121	7c 7d		 jl	 SHORT $LN41@getopt_int

; 458  : 			place = EMSG;

  00123	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET ??_C@_00CNPNBAHC@?$AA@

; 459  : 			if (nonopt_end != -1) {

  0012d	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _nonopt_end, -1
  00134	74 3b		 je	 SHORT $LN40@getopt_int

; 460  : 				/* do permutation, if we have to */
; 461  : 				permute_args(nonopt_start, nonopt_end,
; 462  : 				    optind, nargv);

  00136	8b 45 0c	 mov	 eax, DWORD PTR _nargv$[ebp]
  00139	50		 push	 eax
  0013a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  00140	51		 push	 ecx
  00141	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _nonopt_end
  00147	52		 push	 edx
  00148	a1 00 00 00 00	 mov	 eax, DWORD PTR _nonopt_start
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 _permute_args
  00153	83 c4 10	 add	 esp, 16			; 00000010H

; 463  : 				optind -= nonopt_end - nonopt_start;

  00156	a1 00 00 00 00	 mov	 eax, DWORD PTR _nonopt_end
  0015b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _nonopt_start
  00161	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  00167	2b c8		 sub	 ecx, eax
  00169	89 0d 00 00 00
	00		 mov	 DWORD PTR _optind, ecx
  0016f	eb 13		 jmp	 SHORT $LN39@getopt_int
$LN40@getopt_int:

; 464  : 			}
; 465  : 			else if (nonopt_start != -1) {

  00171	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _nonopt_start, -1
  00178	74 0a		 je	 SHORT $LN39@getopt_int

; 466  : 				/*
; 467  : 				 * If we skipped non-options, set optind
; 468  : 				 * to the first of them.
; 469  : 				 */
; 470  : 				optind = nonopt_start;

  0017a	a1 00 00 00 00	 mov	 eax, DWORD PTR _nonopt_start
  0017f	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax
$LN39@getopt_int:

; 471  : 			}
; 472  : 			nonopt_start = nonopt_end = -1;

  00184	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _nonopt_end, -1
  0018e	a1 00 00 00 00	 mov	 eax, DWORD PTR _nonopt_end
  00193	a3 00 00 00 00	 mov	 DWORD PTR _nonopt_start, eax

; 473  : 			return (-1);

  00198	83 c8 ff	 or	 eax, -1
  0019b	e9 52 05 00 00	 jmp	 $LN55@getopt_int
$LN41@getopt_int:

; 474  : 		}
; 475  : 		if (*(place = nargv[optind]) != '-' ||
; 476  : 		    (place[1] == '\0' && strchr(options, '-') == NULL)) {

  001a0	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  001a5	8b 4d 0c	 mov	 ecx, DWORD PTR _nargv$[ebp]
  001a8	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  001ab	89 15 00 00 00
	00		 mov	 DWORD PTR _place, edx
  001b1	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  001b6	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001b9	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  001bc	75 31		 jne	 SHORT $LN36@getopt_int
  001be	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  001c3	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  001c7	85 c9		 test	 ecx, ecx
  001c9	0f 85 dd 00 00
	00		 jne	 $LN37@getopt_int
  001cf	8b f4		 mov	 esi, esp
  001d1	6a 2d		 push	 45			; 0000002dH
  001d3	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  001d6	50		 push	 eax
  001d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strchr
  001dd	83 c4 08	 add	 esp, 8
  001e0	3b f4		 cmp	 esi, esp
  001e2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001e7	85 c0		 test	 eax, eax
  001e9	0f 85 bd 00 00
	00		 jne	 $LN37@getopt_int
$LN36@getopt_int:

; 477  : 			place = EMSG;		/* found non-option */

  001ef	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET ??_C@_00CNPNBAHC@?$AA@

; 478  : 			if (flags & FLAG_ALLARGS) {

  001f9	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  001fc	83 e0 02	 and	 eax, 2
  001ff	74 28		 je	 SHORT $LN35@getopt_int

; 479  : 				/*
; 480  : 				 * GNU extension:
; 481  : 				 * return non-option as argument to option 1
; 482  : 				 */
; 483  : 				optarg = nargv[optind++];

  00201	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  00206	8b 4d 0c	 mov	 ecx, DWORD PTR _nargv$[ebp]
  00209	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0020c	89 15 00 00 00
	00		 mov	 DWORD PTR _optarg, edx
  00212	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  00217	83 c0 01	 add	 eax, 1
  0021a	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax

; 484  : 				return (INORDER);

  0021f	b8 01 00 00 00	 mov	 eax, 1
  00224	e9 c9 04 00 00	 jmp	 $LN55@getopt_int
$LN35@getopt_int:

; 485  : 			}
; 486  : 			if (!(flags & FLAG_PERMUTE)) {

  00229	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  0022c	83 e0 01	 and	 eax, 1
  0022f	75 08		 jne	 SHORT $LN34@getopt_int

; 487  : 				/*
; 488  : 				 * If no permutation wanted, stop parsing
; 489  : 				 * at first non-option.
; 490  : 				 */
; 491  : 				return (-1);

  00231	83 c8 ff	 or	 eax, -1
  00234	e9 b9 04 00 00	 jmp	 $LN55@getopt_int
$LN34@getopt_int:

; 492  : 			}
; 493  : 			/* do permutation */
; 494  : 			if (nonopt_start == -1)

  00239	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _nonopt_start, -1
  00240	75 0c		 jne	 SHORT $LN33@getopt_int

; 495  : 				nonopt_start = optind;

  00242	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  00247	a3 00 00 00 00	 mov	 DWORD PTR _nonopt_start, eax
  0024c	eb 4c		 jmp	 SHORT $LN32@getopt_int
$LN33@getopt_int:

; 496  : 			else if (nonopt_end != -1) {

  0024e	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _nonopt_end, -1
  00255	74 43		 je	 SHORT $LN32@getopt_int

; 497  : 				permute_args(nonopt_start, nonopt_end,
; 498  : 				    optind, nargv);

  00257	8b 45 0c	 mov	 eax, DWORD PTR _nargv$[ebp]
  0025a	50		 push	 eax
  0025b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  00261	51		 push	 ecx
  00262	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _nonopt_end
  00268	52		 push	 edx
  00269	a1 00 00 00 00	 mov	 eax, DWORD PTR _nonopt_start
  0026e	50		 push	 eax
  0026f	e8 00 00 00 00	 call	 _permute_args
  00274	83 c4 10	 add	 esp, 16			; 00000010H

; 499  : 				nonopt_start = optind -
; 500  : 				    (nonopt_end - nonopt_start);

  00277	a1 00 00 00 00	 mov	 eax, DWORD PTR _nonopt_end
  0027c	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _nonopt_start
  00282	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  00288	2b c8		 sub	 ecx, eax
  0028a	89 0d 00 00 00
	00		 mov	 DWORD PTR _nonopt_start, ecx

; 501  : 				nonopt_end = -1;

  00290	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _nonopt_end, -1
$LN32@getopt_int:

; 502  : 			}
; 503  : 			optind++;

  0029a	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  0029f	83 c0 01	 add	 eax, 1
  002a2	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax

; 504  : 			/* process next argument */
; 505  : 			goto start;

  002a7	e9 4a fe ff ff	 jmp	 $start$82039
$LN37@getopt_int:

; 506  : 		}
; 507  : 		if (nonopt_start != -1 && nonopt_end == -1)

  002ac	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _nonopt_start, -1
  002b3	74 13		 je	 SHORT $LN30@getopt_int
  002b5	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _nonopt_end, -1
  002bc	75 0a		 jne	 SHORT $LN30@getopt_int

; 508  : 			nonopt_end = optind;

  002be	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  002c3	a3 00 00 00 00	 mov	 DWORD PTR _nonopt_end, eax
$LN30@getopt_int:

; 509  : 
; 510  : 		/*
; 511  : 		 * If we have "-" do nothing, if "--" we are done.
; 512  : 		 */
; 513  : 		if (place[1] != '\0' && *++place == '-' && place[1] == '\0') {

  002c8	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  002cd	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  002d1	85 c9		 test	 ecx, ecx
  002d3	0f 84 a1 00 00
	00		 je	 $LN43@getopt_int
  002d9	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  002de	83 c0 01	 add	 eax, 1
  002e1	a3 00 00 00 00	 mov	 DWORD PTR _place, eax
  002e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _place
  002ec	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  002ef	83 fa 2d	 cmp	 edx, 45			; 0000002dH
  002f2	0f 85 82 00 00
	00		 jne	 $LN43@getopt_int
  002f8	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  002fd	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  00301	85 c9		 test	 ecx, ecx
  00303	75 75		 jne	 SHORT $LN43@getopt_int

; 514  : 			optind++;

  00305	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  0030a	83 c0 01	 add	 eax, 1
  0030d	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax

; 515  : 			place = EMSG;

  00312	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET ??_C@_00CNPNBAHC@?$AA@

; 516  : 			/*
; 517  : 			 * We found an option (--), so if we skipped
; 518  : 			 * non-options, we have to permute.
; 519  : 			 */
; 520  : 			if (nonopt_end != -1) {

  0031c	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _nonopt_end, -1
  00323	74 39		 je	 SHORT $LN28@getopt_int

; 521  : 				permute_args(nonopt_start, nonopt_end,
; 522  : 				    optind, nargv);

  00325	8b 45 0c	 mov	 eax, DWORD PTR _nargv$[ebp]
  00328	50		 push	 eax
  00329	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  0032f	51		 push	 ecx
  00330	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _nonopt_end
  00336	52		 push	 edx
  00337	a1 00 00 00 00	 mov	 eax, DWORD PTR _nonopt_start
  0033c	50		 push	 eax
  0033d	e8 00 00 00 00	 call	 _permute_args
  00342	83 c4 10	 add	 esp, 16			; 00000010H

; 523  : 				optind -= nonopt_end - nonopt_start;

  00345	a1 00 00 00 00	 mov	 eax, DWORD PTR _nonopt_end
  0034a	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _nonopt_start
  00350	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  00356	2b c8		 sub	 ecx, eax
  00358	89 0d 00 00 00
	00		 mov	 DWORD PTR _optind, ecx
$LN28@getopt_int:

; 524  : 			}
; 525  : 			nonopt_start = nonopt_end = -1;

  0035e	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _nonopt_end, -1
  00368	a1 00 00 00 00	 mov	 eax, DWORD PTR _nonopt_end
  0036d	a3 00 00 00 00	 mov	 DWORD PTR _nonopt_start, eax

; 526  : 			return (-1);

  00372	83 c8 ff	 or	 eax, -1
  00375	e9 78 03 00 00	 jmp	 $LN55@getopt_int
$LN43@getopt_int:

; 527  : 		}
; 528  : 	}
; 529  : 
; 530  : 	/*
; 531  : 	 * Check long options if:
; 532  : 	 *  1) we were passed some
; 533  : 	 *  2) the arg is not just "-"
; 534  : 	 *  3) either the arg starts with -- we are getopt_long_only()
; 535  : 	 */
; 536  : 	if (long_options != NULL && place != nargv[optind] &&
; 537  : 	    (*place == '-' || (flags & FLAG_LONGONLY))) {

  0037a	83 7d 14 00	 cmp	 DWORD PTR _long_options$[ebp], 0
  0037e	0f 84 c1 00 00
	00		 je	 $LN27@getopt_int
  00384	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  00389	8b 4d 0c	 mov	 ecx, DWORD PTR _nargv$[ebp]
  0038c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _place
  00392	3b 14 81	 cmp	 edx, DWORD PTR [ecx+eax*4]
  00395	0f 84 aa 00 00
	00		 je	 $LN27@getopt_int
  0039b	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  003a0	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  003a3	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  003a6	74 0c		 je	 SHORT $LN26@getopt_int
  003a8	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  003ab	83 e0 04	 and	 eax, 4
  003ae	0f 84 91 00 00
	00		 je	 $LN27@getopt_int
$LN26@getopt_int:

; 538  : 		short_too = 0;

  003b4	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _short_too$[ebp], 0

; 539  : 		if (*place == '-')

  003bb	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  003c0	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  003c3	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  003c6	75 0f		 jne	 SHORT $LN25@getopt_int

; 540  : 			place++;		/* --foo long option */

  003c8	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  003cd	83 c0 01	 add	 eax, 1
  003d0	a3 00 00 00 00	 mov	 DWORD PTR _place, eax
  003d5	eb 37		 jmp	 SHORT $LN24@getopt_int
$LN25@getopt_int:

; 541  : 		else if (*place != ':' && strchr(options, *place) != NULL)

  003d7	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  003dc	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  003df	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  003e2	74 2a		 je	 SHORT $LN24@getopt_int
  003e4	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  003e9	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  003ec	8b f4		 mov	 esi, esp
  003ee	51		 push	 ecx
  003ef	8b 55 10	 mov	 edx, DWORD PTR _options$[ebp]
  003f2	52		 push	 edx
  003f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strchr
  003f9	83 c4 08	 add	 esp, 8
  003fc	3b f4		 cmp	 esi, esp
  003fe	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00403	85 c0		 test	 eax, eax
  00405	74 07		 je	 SHORT $LN24@getopt_int

; 542  : 			short_too = 1;		/* could be short option too */

  00407	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _short_too$[ebp], 1
$LN24@getopt_int:

; 543  : 
; 544  : 		optchar = parse_long_options(nargv, options, long_options,
; 545  : 		    idx, short_too);

  0040e	8b 45 e0	 mov	 eax, DWORD PTR _short_too$[ebp]
  00411	50		 push	 eax
  00412	8b 4d 18	 mov	 ecx, DWORD PTR _idx$[ebp]
  00415	51		 push	 ecx
  00416	8b 55 14	 mov	 edx, DWORD PTR _long_options$[ebp]
  00419	52		 push	 edx
  0041a	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  0041d	50		 push	 eax
  0041e	8b 4d 0c	 mov	 ecx, DWORD PTR _nargv$[ebp]
  00421	51		 push	 ecx
  00422	e8 00 00 00 00	 call	 _parse_long_options
  00427	83 c4 14	 add	 esp, 20			; 00000014H
  0042a	89 45 ec	 mov	 DWORD PTR _optchar$[ebp], eax

; 546  : 		if (optchar != -1) {

  0042d	83 7d ec ff	 cmp	 DWORD PTR _optchar$[ebp], -1
  00431	74 12		 je	 SHORT $LN27@getopt_int

; 547  : 			place = EMSG;

  00433	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET ??_C@_00CNPNBAHC@?$AA@

; 548  : 			return (optchar);

  0043d	8b 45 ec	 mov	 eax, DWORD PTR _optchar$[ebp]
  00440	e9 ad 02 00 00	 jmp	 $LN55@getopt_int
$LN27@getopt_int:

; 549  : 		}
; 550  : 	}
; 551  : 
; 552  : 	if ((optchar = (int)*place++) == (int)':' ||
; 553  : 	    (optchar == (int)'-' && *place != '\0') ||
; 554  : 	    (oli = (char*)strchr(options, optchar)) == NULL) {

  00445	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  0044a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0044d	89 4d ec	 mov	 DWORD PTR _optchar$[ebp], ecx
  00450	8b 55 ec	 mov	 edx, DWORD PTR _optchar$[ebp]
  00453	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  00458	83 c0 01	 add	 eax, 1
  0045b	a3 00 00 00 00	 mov	 DWORD PTR _place, eax
  00460	83 fa 3a	 cmp	 edx, 58			; 0000003aH
  00463	75 0c		 jne	 SHORT $LN57@getopt_int
  00465	c7 85 18 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv203[ebp], 1
  0046f	eb 0a		 jmp	 SHORT $LN58@getopt_int
$LN57@getopt_int:
  00471	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv203[ebp], 0
$LN58@getopt_int:
  0047b	83 bd 18 ff ff
	ff 00		 cmp	 DWORD PTR tv203[ebp], 0
  00482	75 35		 jne	 SHORT $LN20@getopt_int
  00484	83 7d ec 2d	 cmp	 DWORD PTR _optchar$[ebp], 45 ; 0000002dH
  00488	75 0c		 jne	 SHORT $LN19@getopt_int
  0048a	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  0048f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00492	85 c9		 test	 ecx, ecx
  00494	75 23		 jne	 SHORT $LN20@getopt_int
$LN19@getopt_int:
  00496	8b f4		 mov	 esi, esp
  00498	8b 45 ec	 mov	 eax, DWORD PTR _optchar$[ebp]
  0049b	50		 push	 eax
  0049c	8b 4d 10	 mov	 ecx, DWORD PTR _options$[ebp]
  0049f	51		 push	 ecx
  004a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strchr
  004a6	83 c4 08	 add	 esp, 8
  004a9	3b f4		 cmp	 esi, esp
  004ab	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004b0	89 45 f8	 mov	 DWORD PTR _oli$[ebp], eax
  004b3	83 7d f8 00	 cmp	 DWORD PTR _oli$[ebp], 0
  004b7	75 6a		 jne	 SHORT $LN21@getopt_int
$LN20@getopt_int:

; 555  : 		/*
; 556  : 		 * If the user specified "-" and  '-' isn't listed in
; 557  : 		 * options, return -1 (non-option) as per POSIX.
; 558  : 		 * Otherwise, it is an unknown option character (or ':').
; 559  : 		 */
; 560  : 		if (optchar == (int)'-' && *place == '\0')

  004b9	83 7d ec 2d	 cmp	 DWORD PTR _optchar$[ebp], 45 ; 0000002dH
  004bd	75 14		 jne	 SHORT $LN18@getopt_int
  004bf	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  004c4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  004c7	85 c9		 test	 ecx, ecx
  004c9	75 08		 jne	 SHORT $LN18@getopt_int

; 561  : 			return (-1);

  004cb	83 c8 ff	 or	 eax, -1
  004ce	e9 1f 02 00 00	 jmp	 $LN55@getopt_int
$LN18@getopt_int:

; 562  : 		if (!*place)

  004d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  004d8	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  004db	85 c9		 test	 ecx, ecx
  004dd	75 0d		 jne	 SHORT $LN17@getopt_int

; 563  : 			++optind;

  004df	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  004e4	83 c0 01	 add	 eax, 1
  004e7	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax
$LN17@getopt_int:

; 564  : 		if (PRINT_ERROR)

  004ec	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _opterr, 0
  004f3	74 1c		 je	 SHORT $LN16@getopt_int
  004f5	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  004f8	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  004fb	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  004fe	74 11		 je	 SHORT $LN16@getopt_int

; 565  : 			warnx(illoptchar, optchar);

  00500	8b 45 ec	 mov	 eax, DWORD PTR _optchar$[ebp]
  00503	50		 push	 eax
  00504	68 00 00 00 00	 push	 OFFSET _illoptchar
  00509	e8 00 00 00 00	 call	 _warnx
  0050e	83 c4 08	 add	 esp, 8
$LN16@getopt_int:

; 566  : 		optopt = optchar;

  00511	8b 45 ec	 mov	 eax, DWORD PTR _optchar$[ebp]
  00514	a3 00 00 00 00	 mov	 DWORD PTR _optopt, eax

; 567  : 		return (BADCH);

  00519	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  0051e	e9 cf 01 00 00	 jmp	 $LN55@getopt_int
$LN21@getopt_int:

; 568  : 	}
; 569  : 	if (long_options != NULL && optchar == 'W' && oli[1] == ';') {

  00523	83 7d 14 00	 cmp	 DWORD PTR _long_options$[ebp], 0
  00527	0f 84 d1 00 00
	00		 je	 $LN15@getopt_int
  0052d	83 7d ec 57	 cmp	 DWORD PTR _optchar$[ebp], 87 ; 00000057H
  00531	0f 85 c7 00 00
	00		 jne	 $LN15@getopt_int
  00537	8b 45 f8	 mov	 eax, DWORD PTR _oli$[ebp]
  0053a	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  0053e	83 f9 3b	 cmp	 ecx, 59			; 0000003bH
  00541	0f 85 b7 00 00
	00		 jne	 $LN15@getopt_int

; 570  : 		/* -W long-option */
; 571  : 		if (*place)			/* no space */

  00547	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  0054c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0054f	85 c9		 test	 ecx, ecx
  00551	74 02		 je	 SHORT $LN14@getopt_int
  00553	eb 7a		 jmp	 SHORT $LN13@getopt_int
$LN14@getopt_int:

; 572  : 			/* NOTHING */;
; 573  : 		else if (++optind >= nargc) {	/* no arg */

  00555	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  0055a	83 c0 01	 add	 eax, 1
  0055d	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax
  00562	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  00568	3b 4d 08	 cmp	 ecx, DWORD PTR _nargc$[ebp]
  0056b	7c 51		 jl	 SHORT $LN12@getopt_int

; 574  : 			place = EMSG;

  0056d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET ??_C@_00CNPNBAHC@?$AA@

; 575  : 			if (PRINT_ERROR)

  00577	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _opterr, 0
  0057e	74 1c		 je	 SHORT $LN11@getopt_int
  00580	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  00583	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00586	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  00589	74 11		 je	 SHORT $LN11@getopt_int

; 576  : 				warnx(recargchar, optchar);

  0058b	8b 45 ec	 mov	 eax, DWORD PTR _optchar$[ebp]
  0058e	50		 push	 eax
  0058f	68 00 00 00 00	 push	 OFFSET _recargchar
  00594	e8 00 00 00 00	 call	 _warnx
  00599	83 c4 08	 add	 esp, 8
$LN11@getopt_int:

; 577  : 			optopt = optchar;

  0059c	8b 45 ec	 mov	 eax, DWORD PTR _optchar$[ebp]
  0059f	a3 00 00 00 00	 mov	 DWORD PTR _optopt, eax

; 578  : 			return (BADARG);

  005a4	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  005a7	0f be 00	 movsx	 eax, BYTE PTR [eax]
  005aa	83 e8 3a	 sub	 eax, 58			; 0000003aH
  005ad	f7 d8		 neg	 eax
  005af	1b c0		 sbb	 eax, eax
  005b1	83 e0 05	 and	 eax, 5
  005b4	83 c0 3a	 add	 eax, 58			; 0000003aH
  005b7	e9 36 01 00 00	 jmp	 $LN55@getopt_int

; 579  : 		} else				/* white space */

  005bc	eb 11		 jmp	 SHORT $LN13@getopt_int
$LN12@getopt_int:

; 580  : 			place = nargv[optind];

  005be	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  005c3	8b 4d 0c	 mov	 ecx, DWORD PTR _nargv$[ebp]
  005c6	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  005c9	89 15 00 00 00
	00		 mov	 DWORD PTR _place, edx
$LN13@getopt_int:

; 581  : 		optchar = parse_long_options(nargv, options, long_options,
; 582  : 		    idx, 0);

  005cf	6a 00		 push	 0
  005d1	8b 45 18	 mov	 eax, DWORD PTR _idx$[ebp]
  005d4	50		 push	 eax
  005d5	8b 4d 14	 mov	 ecx, DWORD PTR _long_options$[ebp]
  005d8	51		 push	 ecx
  005d9	8b 55 10	 mov	 edx, DWORD PTR _options$[ebp]
  005dc	52		 push	 edx
  005dd	8b 45 0c	 mov	 eax, DWORD PTR _nargv$[ebp]
  005e0	50		 push	 eax
  005e1	e8 00 00 00 00	 call	 _parse_long_options
  005e6	83 c4 14	 add	 esp, 20			; 00000014H
  005e9	89 45 ec	 mov	 DWORD PTR _optchar$[ebp], eax

; 583  : 		place = EMSG;

  005ec	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET ??_C@_00CNPNBAHC@?$AA@

; 584  : 		return (optchar);

  005f6	8b 45 ec	 mov	 eax, DWORD PTR _optchar$[ebp]
  005f9	e9 f4 00 00 00	 jmp	 $LN55@getopt_int
$LN15@getopt_int:

; 585  : 	}
; 586  : 	if (*++oli != ':') {			/* doesn't take argument */

  005fe	8b 45 f8	 mov	 eax, DWORD PTR _oli$[ebp]
  00601	83 c0 01	 add	 eax, 1
  00604	89 45 f8	 mov	 DWORD PTR _oli$[ebp], eax
  00607	8b 4d f8	 mov	 ecx, DWORD PTR _oli$[ebp]
  0060a	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0060d	83 fa 3a	 cmp	 edx, 58			; 0000003aH
  00610	74 1e		 je	 SHORT $LN9@getopt_int

; 587  : 		if (!*place)

  00612	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  00617	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0061a	85 c9		 test	 ecx, ecx
  0061c	75 0d		 jne	 SHORT $LN8@getopt_int

; 588  : 			++optind;

  0061e	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  00623	83 c0 01	 add	 eax, 1
  00626	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax
$LN8@getopt_int:

; 589  : 	} else {				/* takes (optional) argument */

  0062b	e9 bf 00 00 00	 jmp	 $LN7@getopt_int
$LN9@getopt_int:

; 590  : 		optarg = NULL;

  00630	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _optarg, 0

; 591  : 		if (*place)			/* no white space */

  0063a	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  0063f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00642	85 c9		 test	 ecx, ecx
  00644	74 0f		 je	 SHORT $LN6@getopt_int

; 592  : 			optarg = place;

  00646	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  0064b	a3 00 00 00 00	 mov	 DWORD PTR _optarg, eax
  00650	e9 83 00 00 00	 jmp	 $LN5@getopt_int
$LN6@getopt_int:

; 593  : 		else if (oli[1] != ':') {	/* arg not optional */

  00655	8b 45 f8	 mov	 eax, DWORD PTR _oli$[ebp]
  00658	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  0065c	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  0065f	74 77		 je	 SHORT $LN5@getopt_int

; 594  : 			if (++optind >= nargc) {	/* no arg */

  00661	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  00666	83 c0 01	 add	 eax, 1
  00669	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax
  0066e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  00674	3b 4d 08	 cmp	 ecx, DWORD PTR _nargc$[ebp]
  00677	7c 4e		 jl	 SHORT $LN3@getopt_int

; 595  : 				place = EMSG;

  00679	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET ??_C@_00CNPNBAHC@?$AA@

; 596  : 				if (PRINT_ERROR)

  00683	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _opterr, 0
  0068a	74 1c		 je	 SHORT $LN2@getopt_int
  0068c	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  0068f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00692	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  00695	74 11		 je	 SHORT $LN2@getopt_int

; 597  : 					warnx(recargchar, optchar);

  00697	8b 45 ec	 mov	 eax, DWORD PTR _optchar$[ebp]
  0069a	50		 push	 eax
  0069b	68 00 00 00 00	 push	 OFFSET _recargchar
  006a0	e8 00 00 00 00	 call	 _warnx
  006a5	83 c4 08	 add	 esp, 8
$LN2@getopt_int:

; 598  : 				optopt = optchar;

  006a8	8b 45 ec	 mov	 eax, DWORD PTR _optchar$[ebp]
  006ab	a3 00 00 00 00	 mov	 DWORD PTR _optopt, eax

; 599  : 				return (BADARG);

  006b0	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  006b3	0f be 00	 movsx	 eax, BYTE PTR [eax]
  006b6	83 e8 3a	 sub	 eax, 58			; 0000003aH
  006b9	f7 d8		 neg	 eax
  006bb	1b c0		 sbb	 eax, eax
  006bd	83 e0 05	 and	 eax, 5
  006c0	83 c0 3a	 add	 eax, 58			; 0000003aH
  006c3	eb 2d		 jmp	 SHORT $LN55@getopt_int

; 600  : 			} else

  006c5	eb 11		 jmp	 SHORT $LN5@getopt_int
$LN3@getopt_int:

; 601  : 				optarg = nargv[optind];

  006c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  006cc	8b 4d 0c	 mov	 ecx, DWORD PTR _nargv$[ebp]
  006cf	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  006d2	89 15 00 00 00
	00		 mov	 DWORD PTR _optarg, edx
$LN5@getopt_int:

; 602  : 		}
; 603  : 		place = EMSG;

  006d8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET ??_C@_00CNPNBAHC@?$AA@

; 604  : 		++optind;

  006e2	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  006e7	83 c0 01	 add	 eax, 1
  006ea	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax
$LN7@getopt_int:

; 605  : 	}
; 606  : 	/* dump back option letter */
; 607  : 	return (optchar);

  006ef	8b 45 ec	 mov	 eax, DWORD PTR _optchar$[ebp]
$LN55@getopt_int:

; 608  : }

  006f2	5f		 pop	 edi
  006f3	5e		 pop	 esi
  006f4	5b		 pop	 ebx
  006f5	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  006fb	3b ec		 cmp	 ebp, esp
  006fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00702	8b e5		 mov	 esp, ebp
  00704	5d		 pop	 ebp
  00705	c3		 ret	 0
_getopt_internal ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _warnx
_TEXT	SEGMENT
_ap$ = -8						; size = 4
_fmt$ = 8						; size = 4
_warnx	PROC						; COMDAT

; 151  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 152  :   va_list ap;
; 153  :   va_start(ap,fmt);

  0001e	8d 45 0c	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  00021	89 45 f8	 mov	 DWORD PTR _ap$[ebp], eax

; 154  :   _vwarnx(fmt,ap);

  00024	8b 45 f8	 mov	 eax, DWORD PTR _ap$[ebp]
  00027	50		 push	 eax
  00028	8b 4d 08	 mov	 ecx, DWORD PTR _fmt$[ebp]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 __vwarnx
  00031	83 c4 08	 add	 esp, 8

; 155  :   va_end(ap);

  00034	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ap$[ebp], 0

; 156  : }

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
_warnx	ENDP
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_04PFAOODAA@?$CFs?3?5?$AA@			; `string'
EXTRN	__imp__vfprintf:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp____argv:DWORD
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PFAOODAA@?$CFs?3?5?$AA@
CONST	SEGMENT
??_C@_04PFAOODAA@?$CFs?3?5?$AA@ DB '%s: ', 00H		; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT __vwarnx
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
_ap$ = 12						; size = 4
__vwarnx PROC						; COMDAT

; 142  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 143  :   (void)fprintf(stderr,"%s: ",__progname);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp____argv
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	8b f4		 mov	 esi, esp
  00027	8b 11		 mov	 edx, DWORD PTR [ecx]
  00029	52		 push	 edx
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_04PFAOODAA@?$CFs?3?5?$AA@
  0002f	8b fc		 mov	 edi, esp
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00037	3b fc		 cmp	 edi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	83 c0 40	 add	 eax, 64			; 00000040H
  00041	50		 push	 eax
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004b	3b f4		 cmp	 esi, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 144  :   if (fmt != NULL)

  00052	83 7d 08 00	 cmp	 DWORD PTR _fmt$[ebp], 0
  00056	74 2d		 je	 SHORT $LN1@vwarnx

; 145  :     (void)vfprintf(stderr,fmt,ap);

  00058	8b f4		 mov	 esi, esp
  0005a	8b 45 0c	 mov	 eax, DWORD PTR _ap$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _fmt$[ebp]
  00061	51		 push	 ecx
  00062	8b fc		 mov	 edi, esp
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0006a	3b fc		 cmp	 edi, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	83 c0 40	 add	 eax, 64			; 00000040H
  00074	50		 push	 eax
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__vfprintf
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007e	3b f4		 cmp	 esi, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@vwarnx:

; 146  :   (void)fprintf(stderr,"\n");

  00085	8b f4		 mov	 esi, esp
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  0008c	8b fc		 mov	 edi, esp
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00094	3b fc		 cmp	 edi, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	83 c0 40	 add	 eax, 64			; 00000040H
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000a5	83 c4 08	 add	 esp, 8
  000a8	3b f4		 cmp	 esi, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 147  : }

  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx
  000b2	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000b8	3b ec		 cmp	 ebp, esp
  000ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
__vwarnx ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _permute_args
_TEXT	SEGMENT
_swap$ = -104						; size = 4
_pos$ = -92						; size = 4
_nopts$ = -80						; size = 4
_nnonopts$ = -68					; size = 4
_ncycle$ = -56						; size = 4
_j$ = -44						; size = 4
_i$ = -32						; size = 4
_cyclelen$ = -20					; size = 4
_cstart$ = -8						; size = 4
_panonopt_start$ = 8					; size = 4
_panonopt_end$ = 12					; size = 4
_opt_end$ = 16						; size = 4
_nargv$ = 20						; size = 4
_permute_args PROC					; COMDAT

; 184  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd d4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-300]
  00012	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 185  : 	int cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
; 186  : 	char *swap;
; 187  : 
; 188  : 	/*
; 189  : 	 * compute lengths of blocks and number and size of cycles
; 190  : 	 */
; 191  : 	nnonopts = panonopt_end - panonopt_start;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _panonopt_end$[ebp]
  00021	2b 45 08	 sub	 eax, DWORD PTR _panonopt_start$[ebp]
  00024	89 45 bc	 mov	 DWORD PTR _nnonopts$[ebp], eax

; 192  : 	nopts = opt_end - panonopt_end;

  00027	8b 45 10	 mov	 eax, DWORD PTR _opt_end$[ebp]
  0002a	2b 45 0c	 sub	 eax, DWORD PTR _panonopt_end$[ebp]
  0002d	89 45 b0	 mov	 DWORD PTR _nopts$[ebp], eax

; 193  : 	ncycle = gcd(nnonopts, nopts);

  00030	8b 45 b0	 mov	 eax, DWORD PTR _nopts$[ebp]
  00033	50		 push	 eax
  00034	8b 4d bc	 mov	 ecx, DWORD PTR _nnonopts$[ebp]
  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 _gcd
  0003d	83 c4 08	 add	 esp, 8
  00040	89 45 c8	 mov	 DWORD PTR _ncycle$[ebp], eax

; 194  : 	cyclelen = (opt_end - panonopt_start) / ncycle;

  00043	8b 45 10	 mov	 eax, DWORD PTR _opt_end$[ebp]
  00046	2b 45 08	 sub	 eax, DWORD PTR _panonopt_start$[ebp]
  00049	99		 cdq
  0004a	f7 7d c8	 idiv	 DWORD PTR _ncycle$[ebp]
  0004d	89 45 ec	 mov	 DWORD PTR _cyclelen$[ebp], eax

; 195  : 
; 196  : 	for (i = 0; i < ncycle; i++) {

  00050	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00057	eb 09		 jmp	 SHORT $LN8@permute_ar
$LN7@permute_ar:
  00059	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  0005c	83 c0 01	 add	 eax, 1
  0005f	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax
$LN8@permute_ar:
  00062	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  00065	3b 45 c8	 cmp	 eax, DWORD PTR _ncycle$[ebp]
  00068	7d 76		 jge	 SHORT $LN9@permute_ar

; 197  : 		cstart = panonopt_end+i;

  0006a	8b 45 0c	 mov	 eax, DWORD PTR _panonopt_end$[ebp]
  0006d	03 45 e0	 add	 eax, DWORD PTR _i$[ebp]
  00070	89 45 f8	 mov	 DWORD PTR _cstart$[ebp], eax

; 198  : 		pos = cstart;

  00073	8b 45 f8	 mov	 eax, DWORD PTR _cstart$[ebp]
  00076	89 45 a4	 mov	 DWORD PTR _pos$[ebp], eax

; 199  : 		for (j = 0; j < cyclelen; j++) {

  00079	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00080	eb 09		 jmp	 SHORT $LN5@permute_ar
$LN4@permute_ar:
  00082	8b 45 d4	 mov	 eax, DWORD PTR _j$[ebp]
  00085	83 c0 01	 add	 eax, 1
  00088	89 45 d4	 mov	 DWORD PTR _j$[ebp], eax
$LN5@permute_ar:
  0008b	8b 45 d4	 mov	 eax, DWORD PTR _j$[ebp]
  0008e	3b 45 ec	 cmp	 eax, DWORD PTR _cyclelen$[ebp]
  00091	7d 48		 jge	 SHORT $LN3@permute_ar

; 200  : 			if (pos >= panonopt_end)

  00093	8b 45 a4	 mov	 eax, DWORD PTR _pos$[ebp]
  00096	3b 45 0c	 cmp	 eax, DWORD PTR _panonopt_end$[ebp]
  00099	7c 0b		 jl	 SHORT $LN2@permute_ar

; 201  : 				pos -= nnonopts;

  0009b	8b 45 a4	 mov	 eax, DWORD PTR _pos$[ebp]
  0009e	2b 45 bc	 sub	 eax, DWORD PTR _nnonopts$[ebp]
  000a1	89 45 a4	 mov	 DWORD PTR _pos$[ebp], eax

; 202  : 			else

  000a4	eb 09		 jmp	 SHORT $LN1@permute_ar
$LN2@permute_ar:

; 203  : 				pos += nopts;

  000a6	8b 45 a4	 mov	 eax, DWORD PTR _pos$[ebp]
  000a9	03 45 b0	 add	 eax, DWORD PTR _nopts$[ebp]
  000ac	89 45 a4	 mov	 DWORD PTR _pos$[ebp], eax
$LN1@permute_ar:

; 204  : 			swap = nargv[pos];

  000af	8b 45 a4	 mov	 eax, DWORD PTR _pos$[ebp]
  000b2	8b 4d 14	 mov	 ecx, DWORD PTR _nargv$[ebp]
  000b5	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000b8	89 55 98	 mov	 DWORD PTR _swap$[ebp], edx

; 205  : 			/* LINTED const cast */
; 206  : 			((char **) nargv)[pos] = nargv[cstart];

  000bb	8b 45 a4	 mov	 eax, DWORD PTR _pos$[ebp]
  000be	8b 4d 14	 mov	 ecx, DWORD PTR _nargv$[ebp]
  000c1	8b 55 f8	 mov	 edx, DWORD PTR _cstart$[ebp]
  000c4	8b 75 14	 mov	 esi, DWORD PTR _nargv$[ebp]
  000c7	8b 14 96	 mov	 edx, DWORD PTR [esi+edx*4]
  000ca	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 207  : 			/* LINTED const cast */
; 208  : 			((char **)nargv)[cstart] = swap;

  000cd	8b 45 f8	 mov	 eax, DWORD PTR _cstart$[ebp]
  000d0	8b 4d 14	 mov	 ecx, DWORD PTR _nargv$[ebp]
  000d3	8b 55 98	 mov	 edx, DWORD PTR _swap$[ebp]
  000d6	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 209  : 		}

  000d9	eb a7		 jmp	 SHORT $LN4@permute_ar
$LN3@permute_ar:

; 210  : 	}

  000db	e9 79 ff ff ff	 jmp	 $LN7@permute_ar
$LN9@permute_ar:

; 211  : }

  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi
  000e2	5b		 pop	 ebx
  000e3	81 c4 2c 01 00
	00		 add	 esp, 300		; 0000012cH
  000e9	3b ec		 cmp	 ebp, esp
  000eb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c3		 ret	 0
_permute_args ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _gcd
_TEXT	SEGMENT
_c$ = -8						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_gcd	PROC						; COMDAT

; 163  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 164  : 	int c;
; 165  : 
; 166  : 	c = a % b;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00021	99		 cdq
  00022	f7 7d 0c	 idiv	 DWORD PTR _b$[ebp]
  00025	89 55 f8	 mov	 DWORD PTR _c$[ebp], edx
$LN2@gcd:

; 167  : 	while (c != 0) {

  00028	83 7d f8 00	 cmp	 DWORD PTR _c$[ebp], 0
  0002c	74 18		 je	 SHORT $LN1@gcd

; 168  : 		a = b;

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  00031	89 45 08	 mov	 DWORD PTR _a$[ebp], eax

; 169  : 		b = c;

  00034	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00037	89 45 0c	 mov	 DWORD PTR _b$[ebp], eax

; 170  : 		c = a % b;

  0003a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0003d	99		 cdq
  0003e	f7 7d 0c	 idiv	 DWORD PTR _b$[ebp]
  00041	89 55 f8	 mov	 DWORD PTR _c$[ebp], edx

; 171  : 	}

  00044	eb e2		 jmp	 SHORT $LN2@gcd
$LN1@gcd:

; 172  : 
; 173  : 	return (b);

  00046	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]

; 174  : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_gcd	ENDP
_TEXT	ENDS
EXTRN	__imp__strncmp:PROC
EXTRN	_strlen:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _parse_long_options
_TEXT	SEGMENT
_match$ = -68						; size = 4
_ambiguous$ = -56					; size = 4
_i$ = -44						; size = 4
_current_argv_len$ = -32				; size = 4
_has_equal$ = -20					; size = 4
_current_argv$ = -8					; size = 4
_nargv$ = 8						; size = 4
_options$ = 12						; size = 4
_long_options$ = 16					; size = 4
_idx$ = 20						; size = 4
_short_too$ = 24					; size = 4
_parse_long_options PROC				; COMDAT

; 292  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 293  : 	char *current_argv, *has_equal;
; 294  : 	size_t current_argv_len;
; 295  : 	int i, ambiguous, match;
; 296  : 
; 297  : #define IDENTICAL_INTERPRETATION(_x, _y)                                \
; 298  : 	(long_options[(_x)].has_arg == long_options[(_y)].has_arg &&    \
; 299  : 	 long_options[(_x)].flag == long_options[(_y)].flag &&          \
; 300  : 	 long_options[(_x)].val == long_options[(_y)].val)
; 301  : 
; 302  : 	current_argv = place;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  00023	89 45 f8	 mov	 DWORD PTR _current_argv$[ebp], eax

; 303  : 	match = -1;

  00026	c7 45 bc ff ff
	ff ff		 mov	 DWORD PTR _match$[ebp], -1

; 304  : 	ambiguous = 0;

  0002d	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _ambiguous$[ebp], 0

; 305  : 
; 306  : 	optind++;

  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  00039	83 c0 01	 add	 eax, 1
  0003c	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax

; 307  : 
; 308  : 	if ((has_equal = strchr(current_argv, '=')) != NULL) {

  00041	8b f4		 mov	 esi, esp
  00043	6a 3d		 push	 61			; 0000003dH
  00045	8b 45 f8	 mov	 eax, DWORD PTR _current_argv$[ebp]
  00048	50		 push	 eax
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strchr
  0004f	83 c4 08	 add	 esp, 8
  00052	3b f4		 cmp	 esi, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	89 45 ec	 mov	 DWORD PTR _has_equal$[ebp], eax
  0005c	83 7d ec 00	 cmp	 DWORD PTR _has_equal$[ebp], 0
  00060	74 14		 je	 SHORT $LN34@parse_long

; 309  : 		/* argument found (--option=arg) */
; 310  : 		current_argv_len = has_equal - current_argv;

  00062	8b 45 ec	 mov	 eax, DWORD PTR _has_equal$[ebp]
  00065	2b 45 f8	 sub	 eax, DWORD PTR _current_argv$[ebp]
  00068	89 45 e0	 mov	 DWORD PTR _current_argv_len$[ebp], eax

; 311  : 		has_equal++;

  0006b	8b 45 ec	 mov	 eax, DWORD PTR _has_equal$[ebp]
  0006e	83 c0 01	 add	 eax, 1
  00071	89 45 ec	 mov	 DWORD PTR _has_equal$[ebp], eax

; 312  : 	} else

  00074	eb 0f		 jmp	 SHORT $LN33@parse_long
$LN34@parse_long:

; 313  : 		current_argv_len = strlen(current_argv);

  00076	8b 45 f8	 mov	 eax, DWORD PTR _current_argv$[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 _strlen
  0007f	83 c4 04	 add	 esp, 4
  00082	89 45 e0	 mov	 DWORD PTR _current_argv_len$[ebp], eax
$LN33@parse_long:

; 314  : 
; 315  : 	for (i = 0; long_options[i].name; i++) {

  00085	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0008c	eb 09		 jmp	 SHORT $LN32@parse_long
$LN31@parse_long:
  0008e	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00091	83 c0 01	 add	 eax, 1
  00094	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN32@parse_long:
  00097	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  0009a	c1 e0 04	 shl	 eax, 4
  0009d	8b 4d 10	 mov	 ecx, DWORD PTR _long_options$[ebp]
  000a0	83 3c 01 00	 cmp	 DWORD PTR [ecx+eax], 0
  000a4	0f 84 d2 00 00
	00		 je	 $LN30@parse_long

; 316  : 		/* find matching long option */
; 317  : 		if (strncmp(current_argv, long_options[i].name,
; 318  : 		    current_argv_len))

  000aa	8b f4		 mov	 esi, esp
  000ac	8b 45 e0	 mov	 eax, DWORD PTR _current_argv_len$[ebp]
  000af	50		 push	 eax
  000b0	8b 4d d4	 mov	 ecx, DWORD PTR _i$[ebp]
  000b3	c1 e1 04	 shl	 ecx, 4
  000b6	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  000b9	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  000bc	50		 push	 eax
  000bd	8b 4d f8	 mov	 ecx, DWORD PTR _current_argv$[ebp]
  000c0	51		 push	 ecx
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncmp
  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ca	3b f4		 cmp	 esi, esp
  000cc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d1	85 c0		 test	 eax, eax
  000d3	74 02		 je	 SHORT $LN29@parse_long

; 319  : 			continue;

  000d5	eb b7		 jmp	 SHORT $LN31@parse_long
$LN29@parse_long:

; 320  : 
; 321  : 		if (strlen(long_options[i].name) == current_argv_len) {

  000d7	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  000da	c1 e0 04	 shl	 eax, 4
  000dd	8b 4d 10	 mov	 ecx, DWORD PTR _long_options$[ebp]
  000e0	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  000e3	52		 push	 edx
  000e4	e8 00 00 00 00	 call	 _strlen
  000e9	83 c4 04	 add	 esp, 4
  000ec	3b 45 e0	 cmp	 eax, DWORD PTR _current_argv_len$[ebp]
  000ef	75 0f		 jne	 SHORT $LN28@parse_long

; 322  : 			/* exact match */
; 323  : 			match = i;

  000f1	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  000f4	89 45 bc	 mov	 DWORD PTR _match$[ebp], eax

; 324  : 			ambiguous = 0;

  000f7	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _ambiguous$[ebp], 0

; 325  : 			break;

  000fe	eb 7c		 jmp	 SHORT $LN30@parse_long
$LN28@parse_long:

; 326  : 		}
; 327  : 		/*
; 328  : 		 * If this is a known short option, don't allow
; 329  : 		 * a partial match of a single character.
; 330  : 		 */
; 331  : 		if (short_too && current_argv_len == 1)

  00100	83 7d 18 00	 cmp	 DWORD PTR _short_too$[ebp], 0
  00104	74 08		 je	 SHORT $LN27@parse_long
  00106	83 7d e0 01	 cmp	 DWORD PTR _current_argv_len$[ebp], 1
  0010a	75 02		 jne	 SHORT $LN27@parse_long

; 332  : 			continue;

  0010c	eb 80		 jmp	 SHORT $LN31@parse_long
$LN27@parse_long:

; 333  : 
; 334  : 		if (match == -1)	/* partial match */

  0010e	83 7d bc ff	 cmp	 DWORD PTR _match$[ebp], -1
  00112	75 08		 jne	 SHORT $LN26@parse_long

; 335  : 			match = i;

  00114	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00117	89 45 bc	 mov	 DWORD PTR _match$[ebp], eax
  0011a	eb 5b		 jmp	 SHORT $LN25@parse_long
$LN26@parse_long:

; 336  : 		else if (!IDENTICAL_INTERPRETATION(i, match))

  0011c	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  0011f	c1 e0 04	 shl	 eax, 4
  00122	8b 4d bc	 mov	 ecx, DWORD PTR _match$[ebp]
  00125	c1 e1 04	 shl	 ecx, 4
  00128	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  0012b	8b 75 10	 mov	 esi, DWORD PTR _long_options$[ebp]
  0012e	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  00132	3b 44 0e 04	 cmp	 eax, DWORD PTR [esi+ecx+4]
  00136	75 38		 jne	 SHORT $LN23@parse_long
  00138	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  0013b	c1 e0 04	 shl	 eax, 4
  0013e	8b 4d bc	 mov	 ecx, DWORD PTR _match$[ebp]
  00141	c1 e1 04	 shl	 ecx, 4
  00144	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  00147	8b 75 10	 mov	 esi, DWORD PTR _long_options$[ebp]
  0014a	8b 44 02 08	 mov	 eax, DWORD PTR [edx+eax+8]
  0014e	3b 44 0e 08	 cmp	 eax, DWORD PTR [esi+ecx+8]
  00152	75 1c		 jne	 SHORT $LN23@parse_long
  00154	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00157	c1 e0 04	 shl	 eax, 4
  0015a	8b 4d bc	 mov	 ecx, DWORD PTR _match$[ebp]
  0015d	c1 e1 04	 shl	 ecx, 4
  00160	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  00163	8b 75 10	 mov	 esi, DWORD PTR _long_options$[ebp]
  00166	8b 44 02 0c	 mov	 eax, DWORD PTR [edx+eax+12]
  0016a	3b 44 0e 0c	 cmp	 eax, DWORD PTR [esi+ecx+12]
  0016e	74 07		 je	 SHORT $LN25@parse_long
$LN23@parse_long:

; 337  : 			ambiguous = 1;

  00170	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _ambiguous$[ebp], 1
$LN25@parse_long:

; 338  : 	}

  00177	e9 12 ff ff ff	 jmp	 $LN31@parse_long
$LN30@parse_long:

; 339  : 	if (ambiguous) {

  0017c	83 7d c8 00	 cmp	 DWORD PTR _ambiguous$[ebp], 0
  00180	74 3d		 je	 SHORT $LN22@parse_long

; 340  : 		/* ambiguous abbreviation */
; 341  : 		if (PRINT_ERROR)

  00182	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _opterr, 0
  00189	74 20		 je	 SHORT $LN21@parse_long
  0018b	8b 45 0c	 mov	 eax, DWORD PTR _options$[ebp]
  0018e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00191	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  00194	74 15		 je	 SHORT $LN21@parse_long

; 342  : 			warnx(ambig, (int)current_argv_len,
; 343  : 			     current_argv);

  00196	8b 45 f8	 mov	 eax, DWORD PTR _current_argv$[ebp]
  00199	50		 push	 eax
  0019a	8b 4d e0	 mov	 ecx, DWORD PTR _current_argv_len$[ebp]
  0019d	51		 push	 ecx
  0019e	68 00 00 00 00	 push	 OFFSET _ambig
  001a3	e8 00 00 00 00	 call	 _warnx
  001a8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN21@parse_long:

; 344  : 		optopt = 0;

  001ab	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _optopt, 0

; 345  : 		return (BADCH);

  001b5	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  001ba	e9 24 02 00 00	 jmp	 $LN35@parse_long
$LN22@parse_long:

; 346  : 	}
; 347  : 	if (match != -1) {		/* option found */

  001bf	83 7d bc ff	 cmp	 DWORD PTR _match$[ebp], -1
  001c3	0f 84 7c 01 00
	00		 je	 $LN20@parse_long

; 348  : 		if (long_options[match].has_arg == no_argument
; 349  : 		    && has_equal) {

  001c9	8b 45 bc	 mov	 eax, DWORD PTR _match$[ebp]
  001cc	c1 e0 04	 shl	 eax, 4
  001cf	8b 4d 10	 mov	 ecx, DWORD PTR _long_options$[ebp]
  001d2	83 7c 01 04 00	 cmp	 DWORD PTR [ecx+eax+4], 0
  001d7	75 76		 jne	 SHORT $LN19@parse_long
  001d9	83 7d ec 00	 cmp	 DWORD PTR _has_equal$[ebp], 0
  001dd	74 70		 je	 SHORT $LN19@parse_long

; 350  : 			if (PRINT_ERROR)

  001df	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _opterr, 0
  001e6	74 20		 je	 SHORT $LN18@parse_long
  001e8	8b 45 0c	 mov	 eax, DWORD PTR _options$[ebp]
  001eb	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001ee	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  001f1	74 15		 je	 SHORT $LN18@parse_long

; 351  : 				warnx(noarg, (int)current_argv_len,
; 352  : 				     current_argv);

  001f3	8b 45 f8	 mov	 eax, DWORD PTR _current_argv$[ebp]
  001f6	50		 push	 eax
  001f7	8b 4d e0	 mov	 ecx, DWORD PTR _current_argv_len$[ebp]
  001fa	51		 push	 ecx
  001fb	68 00 00 00 00	 push	 OFFSET _noarg
  00200	e8 00 00 00 00	 call	 _warnx
  00205	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@parse_long:

; 353  : 			/*
; 354  : 			 * XXX: GNU sets optopt to val regardless of flag
; 355  : 			 */
; 356  : 			if (long_options[match].flag == NULL)

  00208	8b 45 bc	 mov	 eax, DWORD PTR _match$[ebp]
  0020b	c1 e0 04	 shl	 eax, 4
  0020e	8b 4d 10	 mov	 ecx, DWORD PTR _long_options$[ebp]
  00211	83 7c 01 08 00	 cmp	 DWORD PTR [ecx+eax+8], 0
  00216	75 15		 jne	 SHORT $LN17@parse_long

; 357  : 				optopt = long_options[match].val;

  00218	8b 45 bc	 mov	 eax, DWORD PTR _match$[ebp]
  0021b	c1 e0 04	 shl	 eax, 4
  0021e	8b 4d 10	 mov	 ecx, DWORD PTR _long_options$[ebp]
  00221	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  00225	89 15 00 00 00
	00		 mov	 DWORD PTR _optopt, edx

; 358  : 			else

  0022b	eb 0a		 jmp	 SHORT $LN16@parse_long
$LN17@parse_long:

; 359  : 				optopt = 0;

  0022d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _optopt, 0
$LN16@parse_long:

; 360  : 			return (BADARG);

  00237	8b 45 0c	 mov	 eax, DWORD PTR _options$[ebp]
  0023a	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0023d	83 e8 3a	 sub	 eax, 58			; 0000003aH
  00240	f7 d8		 neg	 eax
  00242	1b c0		 sbb	 eax, eax
  00244	83 e0 05	 and	 eax, 5
  00247	83 c0 3a	 add	 eax, 58			; 0000003aH
  0024a	e9 94 01 00 00	 jmp	 $LN35@parse_long
$LN19@parse_long:

; 361  : 		}
; 362  : 		if (long_options[match].has_arg == required_argument ||
; 363  : 		    long_options[match].has_arg == optional_argument) {

  0024f	8b 45 bc	 mov	 eax, DWORD PTR _match$[ebp]
  00252	c1 e0 04	 shl	 eax, 4
  00255	8b 4d 10	 mov	 ecx, DWORD PTR _long_options$[ebp]
  00258	83 7c 01 04 01	 cmp	 DWORD PTR [ecx+eax+4], 1
  0025d	74 10		 je	 SHORT $LN14@parse_long
  0025f	8b 45 bc	 mov	 eax, DWORD PTR _match$[ebp]
  00262	c1 e0 04	 shl	 eax, 4
  00265	8b 4d 10	 mov	 ecx, DWORD PTR _long_options$[ebp]
  00268	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  0026d	75 3e		 jne	 SHORT $LN15@parse_long
$LN14@parse_long:

; 364  : 			if (has_equal)

  0026f	83 7d ec 00	 cmp	 DWORD PTR _has_equal$[ebp], 0
  00273	74 0a		 je	 SHORT $LN13@parse_long

; 365  : 				optarg = has_equal;

  00275	8b 45 ec	 mov	 eax, DWORD PTR _has_equal$[ebp]
  00278	a3 00 00 00 00	 mov	 DWORD PTR _optarg, eax

; 366  : 			else if (long_options[match].has_arg ==

  0027d	eb 2e		 jmp	 SHORT $LN15@parse_long
$LN13@parse_long:

; 367  : 			    required_argument) {

  0027f	8b 45 bc	 mov	 eax, DWORD PTR _match$[ebp]
  00282	c1 e0 04	 shl	 eax, 4
  00285	8b 4d 10	 mov	 ecx, DWORD PTR _long_options$[ebp]
  00288	83 7c 01 04 01	 cmp	 DWORD PTR [ecx+eax+4], 1
  0028d	75 1e		 jne	 SHORT $LN15@parse_long

; 368  : 				/*
; 369  : 				 * optional argument doesn't use next nargv
; 370  : 				 */
; 371  : 				optarg = nargv[optind++];

  0028f	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  00294	8b 4d 08	 mov	 ecx, DWORD PTR _nargv$[ebp]
  00297	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0029a	89 15 00 00 00
	00		 mov	 DWORD PTR _optarg, edx
  002a0	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  002a5	83 c0 01	 add	 eax, 1
  002a8	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax
$LN15@parse_long:

; 372  : 			}
; 373  : 		}
; 374  : 		if ((long_options[match].has_arg == required_argument)
; 375  : 		    && (optarg == NULL)) {

  002ad	8b 45 bc	 mov	 eax, DWORD PTR _match$[ebp]
  002b0	c1 e0 04	 shl	 eax, 4
  002b3	8b 4d 10	 mov	 ecx, DWORD PTR _long_options$[ebp]
  002b6	83 7c 01 04 01	 cmp	 DWORD PTR [ecx+eax+4], 1
  002bb	0f 85 82 00 00
	00		 jne	 $LN10@parse_long
  002c1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _optarg, 0
  002c8	75 79		 jne	 SHORT $LN10@parse_long

; 376  : 			/*
; 377  : 			 * Missing argument; leading ':' indicates no error
; 378  : 			 * should be generated.
; 379  : 			 */
; 380  : 			if (PRINT_ERROR)

  002ca	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _opterr, 0
  002d1	74 1c		 je	 SHORT $LN9@parse_long
  002d3	8b 45 0c	 mov	 eax, DWORD PTR _options$[ebp]
  002d6	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  002d9	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  002dc	74 11		 je	 SHORT $LN9@parse_long

; 381  : 				warnx(recargstring,
; 382  : 				    current_argv);

  002de	8b 45 f8	 mov	 eax, DWORD PTR _current_argv$[ebp]
  002e1	50		 push	 eax
  002e2	68 00 00 00 00	 push	 OFFSET _recargstring
  002e7	e8 00 00 00 00	 call	 _warnx
  002ec	83 c4 08	 add	 esp, 8
$LN9@parse_long:

; 383  : 			/*
; 384  : 			 * XXX: GNU sets optopt to val regardless of flag
; 385  : 			 */
; 386  : 			if (long_options[match].flag == NULL)

  002ef	8b 45 bc	 mov	 eax, DWORD PTR _match$[ebp]
  002f2	c1 e0 04	 shl	 eax, 4
  002f5	8b 4d 10	 mov	 ecx, DWORD PTR _long_options$[ebp]
  002f8	83 7c 01 08 00	 cmp	 DWORD PTR [ecx+eax+8], 0
  002fd	75 15		 jne	 SHORT $LN8@parse_long

; 387  : 				optopt = long_options[match].val;

  002ff	8b 45 bc	 mov	 eax, DWORD PTR _match$[ebp]
  00302	c1 e0 04	 shl	 eax, 4
  00305	8b 4d 10	 mov	 ecx, DWORD PTR _long_options$[ebp]
  00308	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  0030c	89 15 00 00 00
	00		 mov	 DWORD PTR _optopt, edx

; 388  : 			else

  00312	eb 0a		 jmp	 SHORT $LN7@parse_long
$LN8@parse_long:

; 389  : 				optopt = 0;

  00314	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _optopt, 0
$LN7@parse_long:

; 390  : 			--optind;

  0031e	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  00323	83 e8 01	 sub	 eax, 1
  00326	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax

; 391  : 			return (BADARG);

  0032b	8b 45 0c	 mov	 eax, DWORD PTR _options$[ebp]
  0032e	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00331	83 e8 3a	 sub	 eax, 58			; 0000003aH
  00334	f7 d8		 neg	 eax
  00336	1b c0		 sbb	 eax, eax
  00338	83 e0 05	 and	 eax, 5
  0033b	83 c0 3a	 add	 eax, 58			; 0000003aH
  0033e	e9 a0 00 00 00	 jmp	 $LN35@parse_long
$LN10@parse_long:

; 392  : 		}
; 393  : 	} else {			/* unknown option */

  00343	eb 51		 jmp	 SHORT $LN6@parse_long
$LN20@parse_long:

; 394  : 		if (short_too) {

  00345	83 7d 18 00	 cmp	 DWORD PTR _short_too$[ebp], 0
  00349	74 15		 je	 SHORT $LN5@parse_long

; 395  : 			--optind;

  0034b	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  00350	83 e8 01	 sub	 eax, 1
  00353	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax

; 396  : 			return (-1);

  00358	83 c8 ff	 or	 eax, -1
  0035b	e9 83 00 00 00	 jmp	 $LN35@parse_long
$LN5@parse_long:

; 397  : 		}
; 398  : 		if (PRINT_ERROR)

  00360	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _opterr, 0
  00367	74 1c		 je	 SHORT $LN4@parse_long
  00369	8b 45 0c	 mov	 eax, DWORD PTR _options$[ebp]
  0036c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0036f	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  00372	74 11		 je	 SHORT $LN4@parse_long

; 399  : 			warnx(illoptstring, current_argv);

  00374	8b 45 f8	 mov	 eax, DWORD PTR _current_argv$[ebp]
  00377	50		 push	 eax
  00378	68 00 00 00 00	 push	 OFFSET _illoptstring
  0037d	e8 00 00 00 00	 call	 _warnx
  00382	83 c4 08	 add	 esp, 8
$LN4@parse_long:

; 400  : 		optopt = 0;

  00385	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _optopt, 0

; 401  : 		return (BADCH);

  0038f	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  00394	eb 4d		 jmp	 SHORT $LN35@parse_long
$LN6@parse_long:

; 402  : 	}
; 403  : 	if (idx)

  00396	83 7d 14 00	 cmp	 DWORD PTR _idx$[ebp], 0
  0039a	74 08		 je	 SHORT $LN3@parse_long

; 404  : 		*idx = match;

  0039c	8b 45 14	 mov	 eax, DWORD PTR _idx$[ebp]
  0039f	8b 4d bc	 mov	 ecx, DWORD PTR _match$[ebp]
  003a2	89 08		 mov	 DWORD PTR [eax], ecx
$LN3@parse_long:

; 405  : 	if (long_options[match].flag) {

  003a4	8b 45 bc	 mov	 eax, DWORD PTR _match$[ebp]
  003a7	c1 e0 04	 shl	 eax, 4
  003aa	8b 4d 10	 mov	 ecx, DWORD PTR _long_options$[ebp]
  003ad	83 7c 01 08 00	 cmp	 DWORD PTR [ecx+eax+8], 0
  003b2	74 22		 je	 SHORT $LN2@parse_long

; 406  : 		*long_options[match].flag = long_options[match].val;

  003b4	8b 45 bc	 mov	 eax, DWORD PTR _match$[ebp]
  003b7	c1 e0 04	 shl	 eax, 4
  003ba	8b 4d bc	 mov	 ecx, DWORD PTR _match$[ebp]
  003bd	c1 e1 04	 shl	 ecx, 4
  003c0	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  003c3	8b 4c 0a 08	 mov	 ecx, DWORD PTR [edx+ecx+8]
  003c7	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  003ca	8b 44 02 0c	 mov	 eax, DWORD PTR [edx+eax+12]
  003ce	89 01		 mov	 DWORD PTR [ecx], eax

; 407  : 		return (0);

  003d0	33 c0		 xor	 eax, eax
  003d2	eb 0f		 jmp	 SHORT $LN35@parse_long

; 408  : 	} else

  003d4	eb 0d		 jmp	 SHORT $LN35@parse_long
$LN2@parse_long:

; 409  : 		return (long_options[match].val);

  003d6	8b 45 bc	 mov	 eax, DWORD PTR _match$[ebp]
  003d9	c1 e0 04	 shl	 eax, 4
  003dc	8b 4d 10	 mov	 ecx, DWORD PTR _long_options$[ebp]
  003df	8b 44 01 0c	 mov	 eax, DWORD PTR [ecx+eax+12]
$LN35@parse_long:

; 410  : #undef IDENTICAL_INTERPRETATION
; 411  : }

  003e3	5f		 pop	 edi
  003e4	5e		 pop	 esi
  003e5	5b		 pop	 ebx
  003e6	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  003ec	3b ec		 cmp	 ebp, esp
  003ee	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003f3	8b e5		 mov	 esp, ebp
  003f5	5d		 pop	 ebp
  003f6	c3		 ret	 0
_parse_long_options ENDP
_TEXT	ENDS
PUBLIC	_getopt_long
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _getopt_long
_TEXT	SEGMENT
_nargc$ = 8						; size = 4
_nargv$ = 12						; size = 4
_options$ = 16						; size = 4
_long_options$ = 20					; size = 4
_idx$ = 24						; size = 4
_getopt_long PROC					; COMDAT

; 617  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 618  : 
; 619  : 	return (getopt_internal(nargc, nargv, options, long_options, idx,
; 620  : 	    FLAG_PERMUTE));

  0001e	6a 01		 push	 1
  00020	8b 45 18	 mov	 eax, DWORD PTR _idx$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 14	 mov	 ecx, DWORD PTR _long_options$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 10	 mov	 edx, DWORD PTR _options$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 0c	 mov	 eax, DWORD PTR _nargv$[ebp]
  0002f	50		 push	 eax
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _nargc$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 _getopt_internal
  00039	83 c4 18	 add	 esp, 24			; 00000018H

; 621  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_getopt_long ENDP
_TEXT	ENDS
PUBLIC	_getopt_long_only
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _getopt_long_only
_TEXT	SEGMENT
_nargc$ = 8						; size = 4
_nargv$ = 12						; size = 4
_options$ = 16						; size = 4
_long_options$ = 20					; size = 4
_idx$ = 24						; size = 4
_getopt_long_only PROC					; COMDAT

; 630  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 631  : 
; 632  : 	return (getopt_internal(nargc, nargv, options, long_options, idx,
; 633  : 	    FLAG_PERMUTE|FLAG_LONGONLY));

  0001e	6a 05		 push	 5
  00020	8b 45 18	 mov	 eax, DWORD PTR _idx$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 14	 mov	 ecx, DWORD PTR _long_options$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 10	 mov	 edx, DWORD PTR _options$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 0c	 mov	 eax, DWORD PTR _nargv$[ebp]
  0002f	50		 push	 eax
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _nargc$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 _getopt_internal
  00039	83 c4 18	 add	 esp, 24			; 00000018H

; 634  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_getopt_long_only ENDP
_TEXT	ENDS
_BSS	SEGMENT
_stk	DD	01H DUP (?)
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\a15\facultate\forth\atlast-2.0\atlast.c
_BSS	ENDS
;	COMDAT _P_plus
_TEXT	SEGMENT
_P_plus	PROC						; COMDAT

; 587  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 588  :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN1@P_plus
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 30		 jmp	 SHORT $LN2@P_plus
$LN1@P_plus:

; 589  : /* printf("PLUS %lx + %lx = %lx\n", S1, S0, (S1 + S0)); */
; 590  :     S1 += S0;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00043	8b 50 f0	 mov	 edx, DWORD PTR [eax-16]
  00046	03 51 f8	 add	 edx, DWORD PTR [ecx-8]
  00049	8b 40 f4	 mov	 eax, DWORD PTR [eax-12]
  0004c	13 41 fc	 adc	 eax, DWORD PTR [ecx-4]
  0004f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00055	89 51 f0	 mov	 DWORD PTR [ecx-16], edx
  00058	89 41 f4	 mov	 DWORD PTR [ecx-12], eax

; 591  :     Pop;

  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00060	83 e8 08	 sub	 eax, 8
  00063	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_plus:

; 592  : }

  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00071	3b ec		 cmp	 ebp, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
_P_plus	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_minus
_TEXT	SEGMENT
_P_minus PROC						; COMDAT

; 595  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 596  :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN1@P_minus
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 30		 jmp	 SHORT $LN2@P_minus
$LN1@P_minus:

; 597  :     S1 -= S0;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00043	8b 50 f0	 mov	 edx, DWORD PTR [eax-16]
  00046	2b 51 f8	 sub	 edx, DWORD PTR [ecx-8]
  00049	8b 40 f4	 mov	 eax, DWORD PTR [eax-12]
  0004c	1b 41 fc	 sbb	 eax, DWORD PTR [ecx-4]
  0004f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00055	89 51 f0	 mov	 DWORD PTR [ecx-16], edx
  00058	89 41 f4	 mov	 DWORD PTR [ecx-12], eax

; 598  :     Pop;

  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00060	83 e8 08	 sub	 eax, 8
  00063	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_minus:

; 599  : }

  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00071	3b ec		 cmp	 ebp, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
_P_minus ENDP
_TEXT	ENDS
EXTRN	__allmul:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_times
_TEXT	SEGMENT
_P_times PROC						; COMDAT

; 602  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 603  :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN1@P_times
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 39		 jmp	 SHORT $LN2@P_times
$LN1@P_times:

; 604  :     S1 *= S0;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00043	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  00046	52		 push	 edx
  00047	8b 49 f8	 mov	 ecx, DWORD PTR [ecx-8]
  0004a	51		 push	 ecx
  0004b	8b 50 f4	 mov	 edx, DWORD PTR [eax-12]
  0004e	52		 push	 edx
  0004f	8b 40 f0	 mov	 eax, DWORD PTR [eax-16]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __allmul
  00058	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0005e	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  00061	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 605  :     Pop;

  00064	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00069	83 e8 08	 sub	 eax, 8
  0006c	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_times:

; 606  : }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007a	3b ec		 cmp	 ebp, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
_P_times ENDP
_TEXT	ENDS
EXTRN	__alldiv:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_div
_TEXT	SEGMENT
tv76 = -196						; size = 4
_P_div	PROC						; COMDAT

; 609  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 610  :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN2@P_div
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 5f		 jmp	 SHORT $LN3@P_div
$LN2@P_div:

; 611  : #ifndef NOMEMCHECK
; 612  :     if (S0 == 0) {

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv76[ebp], eax
  00043	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv76[ebp]
  00049	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv76[ebp]
  0004f	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00052	0b 42 fc	 or	 eax, DWORD PTR [edx-4]
  00055	75 07		 jne	 SHORT $LN1@P_div

; 613  : 	divzero();

  00057	e8 00 00 00 00	 call	 _divzero

; 614  : 	return;

  0005c	eb 39		 jmp	 SHORT $LN3@P_div
$LN1@P_div:

; 615  :     }
; 616  : #endif /* NOMEMCHECK */
; 617  :     S1 /= S0;

  0005e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00063	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00069	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  0006c	52		 push	 edx
  0006d	8b 49 f8	 mov	 ecx, DWORD PTR [ecx-8]
  00070	51		 push	 ecx
  00071	8b 50 f4	 mov	 edx, DWORD PTR [eax-12]
  00074	52		 push	 edx
  00075	8b 40 f0	 mov	 eax, DWORD PTR [eax-16]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 __alldiv
  0007e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00084	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  00087	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 618  :     Pop;

  0008a	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0008f	83 e8 08	 sub	 eax, 8
  00092	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN3@P_div:

; 619  : }

  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	5b		 pop	 ebx
  0009a	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  000a0	3b ec		 cmp	 ebp, esp
  000a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
_P_div	ENDP
_TEXT	ENDS
EXTRN	__allrem:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_mod
_TEXT	SEGMENT
tv76 = -196						; size = 4
_P_mod	PROC						; COMDAT

; 622  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 623  :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN2@P_mod
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 5f		 jmp	 SHORT $LN3@P_mod
$LN2@P_mod:

; 624  : #ifndef NOMEMCHECK
; 625  :     if (S0 == 0) {

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv76[ebp], eax
  00043	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv76[ebp]
  00049	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv76[ebp]
  0004f	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00052	0b 42 fc	 or	 eax, DWORD PTR [edx-4]
  00055	75 07		 jne	 SHORT $LN1@P_mod

; 626  : 	divzero();

  00057	e8 00 00 00 00	 call	 _divzero

; 627  : 	return;

  0005c	eb 39		 jmp	 SHORT $LN3@P_mod
$LN1@P_mod:

; 628  :     }
; 629  : #endif /* NOMEMCHECK */
; 630  :     S1 %= S0;

  0005e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00063	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00069	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  0006c	52		 push	 edx
  0006d	8b 49 f8	 mov	 ecx, DWORD PTR [ecx-8]
  00070	51		 push	 ecx
  00071	8b 50 f4	 mov	 edx, DWORD PTR [eax-12]
  00074	52		 push	 edx
  00075	8b 40 f0	 mov	 eax, DWORD PTR [eax-16]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 __allrem
  0007e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00084	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  00087	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 631  :     Pop;

  0008a	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0008f	83 e8 08	 sub	 eax, 8
  00092	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN3@P_mod:

; 632  : }

  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	5b		 pop	 ebx
  0009a	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  000a0	3b ec		 cmp	 ebp, esp
  000a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
_P_mod	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_divmod
_TEXT	SEGMENT
tv79 = -212						; size = 4
_quot$ = -12						; size = 8
_P_divmod PROC						; COMDAT

; 635  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00012	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 636  :     stackitem quot;
; 637  : 
; 638  :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 0a		 jge	 SHORT $LN2@P_divmod
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 89 00 00 00	 jmp	 $LN3@P_divmod
$LN2@P_divmod:

; 639  : #ifndef NOMEMCHECK
; 640  :     if (S0 == 0) {

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv79[ebp], eax
  00046	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR tv79[ebp]
  0004c	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR tv79[ebp]
  00052	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00055	0b 42 fc	 or	 eax, DWORD PTR [edx-4]
  00058	75 07		 jne	 SHORT $LN1@P_divmod

; 641  : 	divzero();

  0005a	e8 00 00 00 00	 call	 _divzero

; 642  : 	return;

  0005f	eb 63		 jmp	 SHORT $LN3@P_divmod
$LN1@P_divmod:

; 643  :     }
; 644  : #endif /* NOMEMCHECK */
; 645  :     quot = S1 / S0;

  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00066	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0006c	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  0006f	52		 push	 edx
  00070	8b 49 f8	 mov	 ecx, DWORD PTR [ecx-8]
  00073	51		 push	 ecx
  00074	8b 50 f4	 mov	 edx, DWORD PTR [eax-12]
  00077	52		 push	 edx
  00078	8b 40 f0	 mov	 eax, DWORD PTR [eax-16]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 __alldiv
  00081	89 45 f4	 mov	 DWORD PTR _quot$[ebp], eax
  00084	89 55 f8	 mov	 DWORD PTR _quot$[ebp+4], edx

; 646  :     S1 %= S0;

  00087	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0008c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00092	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  00095	52		 push	 edx
  00096	8b 49 f8	 mov	 ecx, DWORD PTR [ecx-8]
  00099	51		 push	 ecx
  0009a	8b 50 f4	 mov	 edx, DWORD PTR [eax-12]
  0009d	52		 push	 edx
  0009e	8b 40 f0	 mov	 eax, DWORD PTR [eax-16]
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 __allrem
  000a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  000ad	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  000b0	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 647  :     S0 = quot;

  000b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000b8	8b 4d f4	 mov	 ecx, DWORD PTR _quot$[ebp]
  000bb	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  000be	8b 55 f8	 mov	 edx, DWORD PTR _quot$[ebp+4]
  000c1	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN3@P_divmod:

; 648  : }

  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	5b		 pop	 ebx
  000c7	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  000cd	3b ec		 cmp	 ebp, esp
  000cf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c3		 ret	 0
_P_divmod ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_min
_TEXT	SEGMENT
tv73 = -208						; size = 8
tv79 = -200						; size = 4
tv78 = -196						; size = 4
_P_min	PROC						; COMDAT

; 651  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 652  :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 0a		 jge	 SHORT $LN1@P_min
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 98 00 00 00	 jmp	 $LN2@P_min
$LN1@P_min:

; 653  :     S1 = min(S1, S0);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00046	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
  0004c	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv79[ebp], ecx
  00052	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv78[ebp]
  00058	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv79[ebp]
  0005e	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00061	3b 48 fc	 cmp	 ecx, DWORD PTR [eax-4]
  00064	7f 30		 jg	 SHORT $LN4@P_min
  00066	7c 14		 jl	 SHORT $LN6@P_min
  00068	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv78[ebp]
  0006e	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv79[ebp]
  00074	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00077	3b 48 f8	 cmp	 ecx, DWORD PTR [eax-8]
  0007a	77 1a		 ja	 SHORT $LN4@P_min
$LN6@P_min:
  0007c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00082	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  00085	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv73[ebp], eax
  0008b	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0008e	89 8d 34 ff ff
	ff		 mov	 DWORD PTR tv73[ebp+4], ecx
  00094	eb 18		 jmp	 SHORT $LN5@P_min
$LN4@P_min:
  00096	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0009c	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  0009f	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv73[ebp], eax
  000a5	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  000a8	89 8d 34 ff ff
	ff		 mov	 DWORD PTR tv73[ebp+4], ecx
$LN5@P_min:
  000ae	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  000b4	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv73[ebp]
  000ba	89 42 f0	 mov	 DWORD PTR [edx-16], eax
  000bd	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR tv73[ebp+4]
  000c3	89 4a f4	 mov	 DWORD PTR [edx-12], ecx

; 654  :     Pop;

  000c6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000cb	83 e8 08	 sub	 eax, 8
  000ce	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_min:

; 655  : }

  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	5b		 pop	 ebx
  000d6	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000dc	3b ec		 cmp	 ebp, esp
  000de	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
_P_min	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_max
_TEXT	SEGMENT
tv73 = -208						; size = 8
tv79 = -200						; size = 4
tv78 = -196						; size = 4
_P_max	PROC						; COMDAT

; 658  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 659  :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 0a		 jge	 SHORT $LN1@P_max
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 98 00 00 00	 jmp	 $LN2@P_max
$LN1@P_max:

; 660  :     S1 = max(S1, S0);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00046	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
  0004c	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv79[ebp], ecx
  00052	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv78[ebp]
  00058	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv79[ebp]
  0005e	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00061	3b 48 fc	 cmp	 ecx, DWORD PTR [eax-4]
  00064	7c 30		 jl	 SHORT $LN4@P_max
  00066	7f 14		 jg	 SHORT $LN6@P_max
  00068	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv78[ebp]
  0006e	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv79[ebp]
  00074	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00077	3b 48 f8	 cmp	 ecx, DWORD PTR [eax-8]
  0007a	76 1a		 jbe	 SHORT $LN4@P_max
$LN6@P_max:
  0007c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00082	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  00085	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv73[ebp], eax
  0008b	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0008e	89 8d 34 ff ff
	ff		 mov	 DWORD PTR tv73[ebp+4], ecx
  00094	eb 18		 jmp	 SHORT $LN5@P_max
$LN4@P_max:
  00096	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0009c	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  0009f	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv73[ebp], eax
  000a5	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  000a8	89 8d 34 ff ff
	ff		 mov	 DWORD PTR tv73[ebp+4], ecx
$LN5@P_max:
  000ae	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  000b4	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv73[ebp]
  000ba	89 42 f0	 mov	 DWORD PTR [edx-16], eax
  000bd	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR tv73[ebp+4]
  000c3	89 4a f4	 mov	 DWORD PTR [edx-12], ecx

; 661  :     Pop;

  000c6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000cb	83 e8 08	 sub	 eax, 8
  000ce	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_max:

; 662  : }

  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	5b		 pop	 ebx
  000d6	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000dc	3b ec		 cmp	 ebp, esp
  000de	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
_P_max	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_neg
_TEXT	SEGMENT
_P_neg	PROC						; COMDAT

; 665  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 666  :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_neg
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 1d		 jmp	 SHORT $LN2@P_neg
$LN1@P_neg:

; 667  :     S0 = - S0;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	f7 d9		 neg	 ecx
  00042	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00045	83 d2 00	 adc	 edx, 0
  00048	f7 da		 neg	 edx
  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004f	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  00052	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_neg:

; 668  : }

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
_P_neg	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_abs
_TEXT	SEGMENT
tv73 = -204						; size = 8
tv76 = -196						; size = 4
_P_abs	PROC						; COMDAT

; 671  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 672  :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_abs
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 73		 jmp	 SHORT $LN2@P_abs
$LN1@P_abs:

; 673  :     S0 = abs(S0);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv76[ebp], eax
  00043	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv76[ebp]
  00049	83 79 fc 00	 cmp	 DWORD PTR [ecx-4], 0
  0004d	7f 2e		 jg	 SHORT $LN4@P_abs
  0004f	7c 0c		 jl	 SHORT $LN6@P_abs
  00051	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv76[ebp]
  00057	83 7a f8 00	 cmp	 DWORD PTR [edx-8], 0
  0005b	73 20		 jae	 SHORT $LN4@P_abs
$LN6@P_abs:
  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00062	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00065	f7 d9		 neg	 ecx
  00067	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0006a	83 d2 00	 adc	 edx, 0
  0006d	f7 da		 neg	 edx
  0006f	89 8d 34 ff ff
	ff		 mov	 DWORD PTR tv73[ebp], ecx
  00075	89 95 38 ff ff
	ff		 mov	 DWORD PTR tv73[ebp+4], edx
  0007b	eb 17		 jmp	 SHORT $LN5@P_abs
$LN4@P_abs:
  0007d	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00082	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00085	89 8d 34 ff ff
	ff		 mov	 DWORD PTR tv73[ebp], ecx
  0008b	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0008e	89 95 38 ff ff
	ff		 mov	 DWORD PTR tv73[ebp+4], edx
$LN5@P_abs:
  00094	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00099	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR tv73[ebp]
  0009f	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  000a2	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR tv73[ebp+4]
  000a8	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_abs:

; 674  : }

  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx
  000ae	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000b4	3b ec		 cmp	 ebp, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
_P_abs	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_equal
_TEXT	SEGMENT
tv71 = -204						; size = 4
tv78 = -200						; size = 4
tv77 = -196						; size = 4
_P_equal PROC						; COMDAT

; 677  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 678  :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN1@P_equal
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 75		 jmp	 SHORT $LN2@P_equal
$LN1@P_equal:

; 679  :     S1 = (S1 == S0) ? Truth : Falsity;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00043	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv77[ebp], eax
  00049	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv78[ebp], ecx
  0004f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv77[ebp]
  00055	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv78[ebp]
  0005b	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0005e	3b 48 f8	 cmp	 ecx, DWORD PTR [eax-8]
  00061	75 20		 jne	 SHORT $LN4@P_equal
  00063	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv77[ebp]
  00069	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv78[ebp]
  0006f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00072	3b 48 fc	 cmp	 ecx, DWORD PTR [eax-4]
  00075	75 0c		 jne	 SHORT $LN4@P_equal
  00077	c7 85 34 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv71[ebp], -1
  00081	eb 0a		 jmp	 SHORT $LN5@P_equal
$LN4@P_equal:
  00083	c7 85 34 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], 0
$LN5@P_equal:
  0008d	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR tv71[ebp]
  00093	99		 cdq
  00094	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0009a	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  0009d	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 680  :     Pop;

  000a0	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000a5	83 e8 08	 sub	 eax, 8
  000a8	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_equal:

; 681  : }

  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000b6	3b ec		 cmp	 ebp, esp
  000b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
_P_equal ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_unequal
_TEXT	SEGMENT
tv71 = -204						; size = 4
tv78 = -200						; size = 4
tv77 = -196						; size = 4
_P_unequal PROC						; COMDAT

; 684  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 685  :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN1@P_unequal
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 75		 jmp	 SHORT $LN2@P_unequal
$LN1@P_unequal:

; 686  :     S1 = (S1 != S0) ? Truth : Falsity;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00043	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv77[ebp], eax
  00049	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv78[ebp], ecx
  0004f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv77[ebp]
  00055	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv78[ebp]
  0005b	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0005e	3b 48 f8	 cmp	 ecx, DWORD PTR [eax-8]
  00061	75 14		 jne	 SHORT $LN6@P_unequal
  00063	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv77[ebp]
  00069	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv78[ebp]
  0006f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00072	3b 48 fc	 cmp	 ecx, DWORD PTR [eax-4]
  00075	74 0c		 je	 SHORT $LN4@P_unequal
$LN6@P_unequal:
  00077	c7 85 34 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv71[ebp], -1
  00081	eb 0a		 jmp	 SHORT $LN5@P_unequal
$LN4@P_unequal:
  00083	c7 85 34 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], 0
$LN5@P_unequal:
  0008d	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR tv71[ebp]
  00093	99		 cdq
  00094	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0009a	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  0009d	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 687  :     Pop;

  000a0	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000a5	83 e8 08	 sub	 eax, 8
  000a8	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_unequal:

; 688  : }

  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000b6	3b ec		 cmp	 ebp, esp
  000b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
_P_unequal ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_gtr
_TEXT	SEGMENT
tv71 = -204						; size = 4
tv78 = -200						; size = 4
tv77 = -196						; size = 4
_P_gtr	PROC						; COMDAT

; 691  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 692  :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN1@P_gtr
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 77		 jmp	 SHORT $LN2@P_gtr
$LN1@P_gtr:

; 693  :     S1 = (S1 > S0) ? Truth : Falsity;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00043	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv77[ebp], eax
  00049	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv78[ebp], ecx
  0004f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv77[ebp]
  00055	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv78[ebp]
  0005b	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0005e	3b 48 fc	 cmp	 ecx, DWORD PTR [eax-4]
  00061	7c 22		 jl	 SHORT $LN4@P_gtr
  00063	7f 14		 jg	 SHORT $LN6@P_gtr
  00065	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv77[ebp]
  0006b	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv78[ebp]
  00071	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00074	3b 48 f8	 cmp	 ecx, DWORD PTR [eax-8]
  00077	76 0c		 jbe	 SHORT $LN4@P_gtr
$LN6@P_gtr:
  00079	c7 85 34 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv71[ebp], -1
  00083	eb 0a		 jmp	 SHORT $LN5@P_gtr
$LN4@P_gtr:
  00085	c7 85 34 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], 0
$LN5@P_gtr:
  0008f	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR tv71[ebp]
  00095	99		 cdq
  00096	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0009c	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  0009f	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 694  :     Pop;

  000a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000a7	83 e8 08	 sub	 eax, 8
  000aa	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_gtr:

; 695  : }

  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx
  000b2	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000b8	3b ec		 cmp	 ebp, esp
  000ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
_P_gtr	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_lss
_TEXT	SEGMENT
tv71 = -204						; size = 4
tv78 = -200						; size = 4
tv77 = -196						; size = 4
_P_lss	PROC						; COMDAT

; 698  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 699  :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN1@P_lss
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 77		 jmp	 SHORT $LN2@P_lss
$LN1@P_lss:

; 700  :     S1 = (S1 < S0) ? Truth : Falsity;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00043	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv77[ebp], eax
  00049	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv78[ebp], ecx
  0004f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv77[ebp]
  00055	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv78[ebp]
  0005b	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0005e	3b 48 fc	 cmp	 ecx, DWORD PTR [eax-4]
  00061	7f 22		 jg	 SHORT $LN4@P_lss
  00063	7c 14		 jl	 SHORT $LN6@P_lss
  00065	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv77[ebp]
  0006b	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv78[ebp]
  00071	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00074	3b 48 f8	 cmp	 ecx, DWORD PTR [eax-8]
  00077	73 0c		 jae	 SHORT $LN4@P_lss
$LN6@P_lss:
  00079	c7 85 34 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv71[ebp], -1
  00083	eb 0a		 jmp	 SHORT $LN5@P_lss
$LN4@P_lss:
  00085	c7 85 34 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], 0
$LN5@P_lss:
  0008f	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR tv71[ebp]
  00095	99		 cdq
  00096	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0009c	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  0009f	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 701  :     Pop;

  000a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000a7	83 e8 08	 sub	 eax, 8
  000aa	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_lss:

; 702  : }

  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx
  000b2	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000b8	3b ec		 cmp	 ebp, esp
  000ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
_P_lss	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_geq
_TEXT	SEGMENT
tv71 = -204						; size = 4
tv78 = -200						; size = 4
tv77 = -196						; size = 4
_P_geq	PROC						; COMDAT

; 705  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 706  :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN1@P_geq
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 77		 jmp	 SHORT $LN2@P_geq
$LN1@P_geq:

; 707  :     S1 = (S1 >= S0) ? Truth : Falsity;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00043	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv77[ebp], eax
  00049	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv78[ebp], ecx
  0004f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv77[ebp]
  00055	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv78[ebp]
  0005b	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0005e	3b 48 fc	 cmp	 ecx, DWORD PTR [eax-4]
  00061	7c 22		 jl	 SHORT $LN4@P_geq
  00063	7f 14		 jg	 SHORT $LN6@P_geq
  00065	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv77[ebp]
  0006b	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv78[ebp]
  00071	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00074	3b 48 f8	 cmp	 ecx, DWORD PTR [eax-8]
  00077	72 0c		 jb	 SHORT $LN4@P_geq
$LN6@P_geq:
  00079	c7 85 34 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv71[ebp], -1
  00083	eb 0a		 jmp	 SHORT $LN5@P_geq
$LN4@P_geq:
  00085	c7 85 34 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], 0
$LN5@P_geq:
  0008f	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR tv71[ebp]
  00095	99		 cdq
  00096	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0009c	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  0009f	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 708  :     Pop;

  000a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000a7	83 e8 08	 sub	 eax, 8
  000aa	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_geq:

; 709  : }

  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx
  000b2	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000b8	3b ec		 cmp	 ebp, esp
  000ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
_P_geq	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_leq
_TEXT	SEGMENT
tv71 = -204						; size = 4
tv78 = -200						; size = 4
tv77 = -196						; size = 4
_P_leq	PROC						; COMDAT

; 712  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 713  :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN1@P_leq
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 77		 jmp	 SHORT $LN2@P_leq
$LN1@P_leq:

; 714  :     S1 = (S1 <= S0) ? Truth : Falsity;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00043	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv77[ebp], eax
  00049	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv78[ebp], ecx
  0004f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv77[ebp]
  00055	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv78[ebp]
  0005b	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0005e	3b 48 fc	 cmp	 ecx, DWORD PTR [eax-4]
  00061	7f 22		 jg	 SHORT $LN4@P_leq
  00063	7c 14		 jl	 SHORT $LN6@P_leq
  00065	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv77[ebp]
  0006b	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv78[ebp]
  00071	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00074	3b 48 f8	 cmp	 ecx, DWORD PTR [eax-8]
  00077	77 0c		 ja	 SHORT $LN4@P_leq
$LN6@P_leq:
  00079	c7 85 34 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv71[ebp], -1
  00083	eb 0a		 jmp	 SHORT $LN5@P_leq
$LN4@P_leq:
  00085	c7 85 34 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], 0
$LN5@P_leq:
  0008f	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR tv71[ebp]
  00095	99		 cdq
  00096	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0009c	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  0009f	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 715  :     Pop;

  000a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000a7	83 e8 08	 sub	 eax, 8
  000aa	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_leq:

; 716  : }

  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx
  000b2	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000b8	3b ec		 cmp	 ebp, esp
  000ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
_P_leq	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_and
_TEXT	SEGMENT
_P_and	PROC						; COMDAT

; 719  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 720  :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN1@P_and
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 30		 jmp	 SHORT $LN2@P_and
$LN1@P_and:

; 721  : /* printf("AND %lx & %lx = %lx\n", S1, S0, (S1 & S0)); */
; 722  :     S1 &= S0;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00043	8b 50 f0	 mov	 edx, DWORD PTR [eax-16]
  00046	23 51 f8	 and	 edx, DWORD PTR [ecx-8]
  00049	8b 40 f4	 mov	 eax, DWORD PTR [eax-12]
  0004c	23 41 fc	 and	 eax, DWORD PTR [ecx-4]
  0004f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00055	89 51 f0	 mov	 DWORD PTR [ecx-16], edx
  00058	89 41 f4	 mov	 DWORD PTR [ecx-12], eax

; 723  :     Pop;

  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00060	83 e8 08	 sub	 eax, 8
  00063	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_and:

; 724  : }

  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00071	3b ec		 cmp	 ebp, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
_P_and	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_or
_TEXT	SEGMENT
_P_or	PROC						; COMDAT

; 727  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 728  :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN1@P_or
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 30		 jmp	 SHORT $LN2@P_or
$LN1@P_or:

; 729  :     S1 |= S0;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00043	8b 50 f0	 mov	 edx, DWORD PTR [eax-16]
  00046	0b 51 f8	 or	 edx, DWORD PTR [ecx-8]
  00049	8b 40 f4	 mov	 eax, DWORD PTR [eax-12]
  0004c	0b 41 fc	 or	 eax, DWORD PTR [ecx-4]
  0004f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00055	89 51 f0	 mov	 DWORD PTR [ecx-16], edx
  00058	89 41 f4	 mov	 DWORD PTR [ecx-12], eax

; 730  :     Pop;

  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00060	83 e8 08	 sub	 eax, 8
  00063	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_or:

; 731  : }

  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00071	3b ec		 cmp	 ebp, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
_P_or	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_xor
_TEXT	SEGMENT
_P_xor	PROC						; COMDAT

; 734  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 735  :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN1@P_xor
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 30		 jmp	 SHORT $LN2@P_xor
$LN1@P_xor:

; 736  :     S1 ^= S0;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00043	8b 50 f0	 mov	 edx, DWORD PTR [eax-16]
  00046	33 51 f8	 xor	 edx, DWORD PTR [ecx-8]
  00049	8b 40 f4	 mov	 eax, DWORD PTR [eax-12]
  0004c	33 41 fc	 xor	 eax, DWORD PTR [ecx-4]
  0004f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00055	89 51 f0	 mov	 DWORD PTR [ecx-16], edx
  00058	89 41 f4	 mov	 DWORD PTR [ecx-12], eax

; 737  :     Pop;

  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00060	83 e8 08	 sub	 eax, 8
  00063	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_xor:

; 738  : }

  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00071	3b ec		 cmp	 ebp, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
_P_xor	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_not
_TEXT	SEGMENT
_P_not	PROC						; COMDAT

; 741  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 742  :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_not
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 1a		 jmp	 SHORT $LN2@P_not
$LN1@P_not:

; 743  :     S0 = ~S0;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	f7 d1		 not	 ecx
  00042	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00045	f7 d2		 not	 edx
  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004c	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  0004f	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_not:

; 744  : }

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005b	3b ec		 cmp	 ebp, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
_P_not	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_shift
_TEXT	SEGMENT
tv81 = -200						; size = 4
tv86 = -196						; size = 4
_P_shift PROC						; COMDAT

; 747  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 748  :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 0a		 jge	 SHORT $LN1@P_shift
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 82 00 00 00	 jmp	 $LN2@P_shift
$LN1@P_shift:

; 749  :     S1 = (S0 < 0) ? (((unsigned long) S1) >> (-S0)) :
; 750  : 		    (((unsigned long) S1) <<   S0);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv86[ebp], eax
  00046	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv86[ebp]
  0004c	83 79 fc 00	 cmp	 DWORD PTR [ecx-4], 0
  00050	7f 32		 jg	 SHORT $LN4@P_shift
  00052	7c 0c		 jl	 SHORT $LN6@P_shift
  00054	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv86[ebp]
  0005a	83 7a f8 00	 cmp	 DWORD PTR [edx-8], 0
  0005e	73 24		 jae	 SHORT $LN4@P_shift
$LN6@P_shift:
  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00065	8b 50 f0	 mov	 edx, DWORD PTR [eax-16]
  00068	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0006d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00070	f7 d9		 neg	 ecx
  00072	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00075	83 d0 00	 adc	 eax, 0
  00078	f7 d8		 neg	 eax
  0007a	d3 ea		 shr	 edx, cl
  0007c	89 95 38 ff ff
	ff		 mov	 DWORD PTR tv81[ebp], edx
  00082	eb 19		 jmp	 SHORT $LN5@P_shift
$LN4@P_shift:
  00084	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0008a	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  0008d	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00092	8a 48 f8	 mov	 cl, BYTE PTR [eax-8]
  00095	d3 e2		 shl	 edx, cl
  00097	89 95 38 ff ff
	ff		 mov	 DWORD PTR tv81[ebp], edx
$LN5@P_shift:
  0009d	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR tv81[ebp]
  000a3	33 d2		 xor	 edx, edx
  000a5	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000aa	89 48 f0	 mov	 DWORD PTR [eax-16], ecx
  000ad	89 50 f4	 mov	 DWORD PTR [eax-12], edx

; 751  :     Pop;

  000b0	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000b5	83 e8 08	 sub	 eax, 8
  000b8	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_shift:

; 752  : }

  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  000c6	3b ec		 cmp	 ebp, esp
  000c8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c3		 ret	 0
_P_shift ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_1plus
_TEXT	SEGMENT
_P_1plus PROC						; COMDAT

; 757  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 758  :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_1plus
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 1c		 jmp	 SHORT $LN2@P_1plus
$LN1@P_1plus:

; 759  :     S0++;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	83 c1 01	 add	 ecx, 1
  00043	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00046	83 d2 00	 adc	 edx, 0
  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004e	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  00051	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_1plus:

; 760  : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005d	3b ec		 cmp	 ebp, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
_P_1plus ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_2plus
_TEXT	SEGMENT
_P_2plus PROC						; COMDAT

; 763  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 764  :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_2plus
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 1c		 jmp	 SHORT $LN2@P_2plus
$LN1@P_2plus:

; 765  :     S0 += 2;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	83 c1 02	 add	 ecx, 2
  00043	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00046	83 d2 00	 adc	 edx, 0
  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004e	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  00051	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_2plus:

; 766  : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005d	3b ec		 cmp	 ebp, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
_P_2plus ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_1minus
_TEXT	SEGMENT
_P_1minus PROC						; COMDAT

; 769  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 770  :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_1minus
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 1c		 jmp	 SHORT $LN2@P_1minus
$LN1@P_1minus:

; 771  :     S0--;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	83 e9 01	 sub	 ecx, 1
  00043	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00046	83 da 00	 sbb	 edx, 0
  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004e	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  00051	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_1minus:

; 772  : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005d	3b ec		 cmp	 ebp, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
_P_1minus ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_2minus
_TEXT	SEGMENT
_P_2minus PROC						; COMDAT

; 775  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 776  :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_2minus
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 1c		 jmp	 SHORT $LN2@P_2minus
$LN1@P_2minus:

; 777  :     S0 -= 2;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	83 e9 02	 sub	 ecx, 2
  00043	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00046	83 da 00	 sbb	 edx, 0
  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004e	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  00051	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_2minus:

; 778  : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005d	3b ec		 cmp	 ebp, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
_P_2minus ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_2times
_TEXT	SEGMENT
_P_2times PROC						; COMDAT

; 781  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 782  :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_2times
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 22		 jmp	 SHORT $LN2@P_2times
$LN1@P_2times:

; 783  :     S0 *= 2;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	6a 00		 push	 0
  0003f	6a 02		 push	 2
  00041	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00044	51		 push	 ecx
  00045	8b 50 f8	 mov	 edx, DWORD PTR [eax-8]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 __allmul
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00054	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  00057	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN2@P_2times:

; 784  : }

  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00063	3b ec		 cmp	 ebp, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
_P_2times ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_2div
_TEXT	SEGMENT
_P_2div	PROC						; COMDAT

; 787  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 788  :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_2div
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 22		 jmp	 SHORT $LN2@P_2div
$LN1@P_2div:

; 789  :     S0 /= 2;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	6a 00		 push	 0
  0003f	6a 02		 push	 2
  00041	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00044	51		 push	 ecx
  00045	8b 50 f8	 mov	 edx, DWORD PTR [eax-8]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 __alldiv
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00054	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  00057	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN2@P_2div:

; 790  : }

  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00063	3b ec		 cmp	 ebp, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
_P_2div	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_0equal
_TEXT	SEGMENT
tv70 = -200						; size = 4
tv74 = -196						; size = 4
_P_0equal PROC						; COMDAT

; 797  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 798  :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_0equal
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 48		 jmp	 SHORT $LN2@P_0equal
$LN1@P_0equal:

; 799  :     S0 = (S0 == 0) ? Truth : Falsity;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv74[ebp], eax
  00043	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv74[ebp]
  00049	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv74[ebp]
  0004f	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00052	0b 42 fc	 or	 eax, DWORD PTR [edx-4]
  00055	75 0c		 jne	 SHORT $LN4@P_0equal
  00057	c7 85 38 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv70[ebp], -1
  00061	eb 0a		 jmp	 SHORT $LN5@P_0equal
$LN4@P_0equal:
  00063	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_0equal:
  0006d	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  00073	99		 cdq
  00074	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0007a	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  0007d	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN2@P_0equal:

; 800  : }

  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00089	3b ec		 cmp	 ebp, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
_P_0equal ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_0notequal
_TEXT	SEGMENT
tv70 = -200						; size = 4
tv74 = -196						; size = 4
_P_0notequal PROC					; COMDAT

; 803  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 804  :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_0notequa
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 48		 jmp	 SHORT $LN2@P_0notequa
$LN1@P_0notequa:

; 805  :     S0 = (S0 != 0) ? Truth : Falsity;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv74[ebp], eax
  00043	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv74[ebp]
  00049	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv74[ebp]
  0004f	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00052	0b 42 fc	 or	 eax, DWORD PTR [edx-4]
  00055	74 0c		 je	 SHORT $LN4@P_0notequa
  00057	c7 85 38 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv70[ebp], -1
  00061	eb 0a		 jmp	 SHORT $LN5@P_0notequa
$LN4@P_0notequa:
  00063	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_0notequa:
  0006d	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  00073	99		 cdq
  00074	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0007a	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  0007d	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN2@P_0notequa:

; 806  : }

  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00089	3b ec		 cmp	 ebp, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
_P_0notequal ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_0gtr
_TEXT	SEGMENT
tv70 = -200						; size = 4
tv74 = -196						; size = 4
_P_0gtr	PROC						; COMDAT

; 809  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 810  :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_0gtr
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 4e		 jmp	 SHORT $LN2@P_0gtr
$LN1@P_0gtr:

; 811  :     S0 = (S0 > 0) ? Truth : Falsity;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv74[ebp], eax
  00043	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv74[ebp]
  00049	83 79 fc 00	 cmp	 DWORD PTR [ecx-4], 0
  0004d	7c 1a		 jl	 SHORT $LN4@P_0gtr
  0004f	7f 0c		 jg	 SHORT $LN6@P_0gtr
  00051	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv74[ebp]
  00057	83 7a f8 00	 cmp	 DWORD PTR [edx-8], 0
  0005b	76 0c		 jbe	 SHORT $LN4@P_0gtr
$LN6@P_0gtr:
  0005d	c7 85 38 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv70[ebp], -1
  00067	eb 0a		 jmp	 SHORT $LN5@P_0gtr
$LN4@P_0gtr:
  00069	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_0gtr:
  00073	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  00079	99		 cdq
  0007a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00080	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  00083	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN2@P_0gtr:

; 812  : }

  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx
  00089	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  0008f	3b ec		 cmp	 ebp, esp
  00091	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
_P_0gtr	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_0lss
_TEXT	SEGMENT
tv70 = -200						; size = 4
tv74 = -196						; size = 4
_P_0lss	PROC						; COMDAT

; 815  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 816  :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_0lss
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 4e		 jmp	 SHORT $LN2@P_0lss
$LN1@P_0lss:

; 817  :     S0 = (S0 < 0) ? Truth : Falsity;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv74[ebp], eax
  00043	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv74[ebp]
  00049	83 79 fc 00	 cmp	 DWORD PTR [ecx-4], 0
  0004d	7f 1a		 jg	 SHORT $LN4@P_0lss
  0004f	7c 0c		 jl	 SHORT $LN6@P_0lss
  00051	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv74[ebp]
  00057	83 7a f8 00	 cmp	 DWORD PTR [edx-8], 0
  0005b	73 0c		 jae	 SHORT $LN4@P_0lss
$LN6@P_0lss:
  0005d	c7 85 38 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv70[ebp], -1
  00067	eb 0a		 jmp	 SHORT $LN5@P_0lss
$LN4@P_0lss:
  00069	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_0lss:
  00073	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  00079	99		 cdq
  0007a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00080	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  00083	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN2@P_0lss:

; 818  : }

  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx
  00089	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  0008f	3b ec		 cmp	 ebp, esp
  00091	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
_P_0lss	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_hptr	DD	01H DUP (?)
_stacktop DD	01H DUP (?)
; Function compile flags: /Odtp /RTCsu /ZI
_BSS	ENDS
;	COMDAT _P_here
_TEXT	SEGMENT
_P_here	PROC						; COMDAT

; 825  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 826  :     So(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	83 c0 08	 add	 eax, 8
  00026	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  0002c	76 07		 jbe	 SHORT $LN1@P_here
  0002e	e8 00 00 00 00	 call	 _stakover
  00033	eb 20		 jmp	 SHORT $LN2@P_here
$LN1@P_here:

; 827  :     Push = (stackitem) hptr;

  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0003a	99		 cdq
  0003b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00041	89 01		 mov	 DWORD PTR [ecx], eax
  00043	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00046	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0004c	83 c2 08	 add	 edx, 8
  0004f	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN2@P_here:

; 828  : }

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
_P_here	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_heaptop DD	01H DUP (?)
_heapbot DD	01H DUP (?)
; Function compile flags: /Odtp /RTCsu /ZI
_BSS	ENDS
;	COMDAT _P_bang
_TEXT	SEGMENT
_P_bang	PROC						; COMDAT

; 831  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 832  :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN3@P_bang
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 4d		 jmp	 SHORT $LN4@P_bang
$LN3@P_bang:

; 833  :     Hpc(S0);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00046	72 10		 jb	 SHORT $LN1@P_bang
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00050	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00056	72 07		 jb	 SHORT $LN2@P_bang
$LN1@P_bang:
  00058	e8 00 00 00 00	 call	 _badpointer
  0005d	eb 26		 jmp	 SHORT $LN4@P_bang
$LN2@P_bang:

; 834  :     *((stackitem *) S0) = S1;

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00064	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00067	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0006d	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  00070	89 01		 mov	 DWORD PTR [ecx], eax
  00072	8b 52 f4	 mov	 edx, DWORD PTR [edx-12]
  00075	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 835  :     Pop2;

  00078	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0007d	83 e8 10	 sub	 eax, 16			; 00000010H
  00080	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN4@P_bang:

; 836  : }

  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx
  00088	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0008e	3b ec		 cmp	 ebp, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
_P_bang	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_at
_TEXT	SEGMENT
_P_at	PROC						; COMDAT

; 839  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 840  :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN3@P_at
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 40		 jmp	 SHORT $LN4@P_at
$LN3@P_at:

; 841  :     Hpc(S0);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00046	72 10		 jb	 SHORT $LN1@P_at
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00050	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00056	72 07		 jb	 SHORT $LN2@P_at
$LN1@P_at:
  00058	e8 00 00 00 00	 call	 _badpointer
  0005d	eb 19		 jmp	 SHORT $LN4@P_at
$LN2@P_at:

; 842  :     S0 = *((stackitem *) S0);

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00064	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00067	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0006d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006f	89 42 f8	 mov	 DWORD PTR [edx-8], eax
  00072	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00075	89 4a fc	 mov	 DWORD PTR [edx-4], ecx
$LN4@P_at:

; 843  : }

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00081	3b ec		 cmp	 ebp, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
_P_at	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_plusbang
_TEXT	SEGMENT
_P_plusbang PROC					; COMDAT

; 846  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 847  :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN3@P_plusbang
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 5b		 jmp	 SHORT $LN4@P_plusbang
$LN3@P_plusbang:

; 848  :     Hpc(S0);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00046	72 10		 jb	 SHORT $LN1@P_plusbang
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00050	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00056	72 07		 jb	 SHORT $LN2@P_plusbang
$LN1@P_plusbang:
  00058	e8 00 00 00 00	 call	 _badpointer
  0005d	eb 34		 jmp	 SHORT $LN4@P_plusbang
$LN2@P_plusbang:

; 849  :     *((stackitem *) S0) += S1;

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00064	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00067	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0006d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006f	03 42 f0	 add	 eax, DWORD PTR [edx-16]
  00072	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00075	13 4a f4	 adc	 ecx, DWORD PTR [edx-12]
  00078	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0007e	8b 52 f8	 mov	 edx, DWORD PTR [edx-8]
  00081	89 02		 mov	 DWORD PTR [edx], eax
  00083	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 850  :     Pop2;

  00086	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0008b	83 e8 10	 sub	 eax, 16			; 00000010H
  0008e	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN4@P_plusbang:

; 851  : }

  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx
  00096	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0009c	3b ec		 cmp	 ebp, esp
  0009e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
_P_plusbang ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_allot
_TEXT	SEGMENT
_n$ = -12						; size = 8
_P_allot PROC						; COMDAT

; 854  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 855  :     stackitem n;
; 856  : 
; 857  :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN2@P_allot
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 71		 jmp	 SHORT $LN3@P_allot
$LN2@P_allot:

; 858  :     n = (S0 + (sizeof(stackitem) - 1)) / sizeof(stackitem);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	83 c1 07	 add	 ecx, 7
  00043	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00046	83 d2 00	 adc	 edx, 0
  00049	6a 00		 push	 0
  0004b	6a 08		 push	 8
  0004d	52		 push	 edx
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 __alldiv
  00054	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax
  00057	89 55 f8	 mov	 DWORD PTR _n$[ebp+4], edx

; 859  :     Pop;

  0005a	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0005f	83 e8 08	 sub	 eax, 8
  00062	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 860  :     Ho(n);

  00067	6a 00		 push	 0
  00069	6a 08		 push	 8
  0006b	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp+4]
  0006e	50		 push	 eax
  0006f	8b 4d f4	 mov	 ecx, DWORD PTR _n$[ebp]
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 __allmul
  00078	03 05 00 00 00
	00		 add	 eax, DWORD PTR _hptr
  0007e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00084	76 07		 jbe	 SHORT $LN1@P_allot
  00086	e8 00 00 00 00	 call	 _heapover
  0008b	eb 1c		 jmp	 SHORT $LN3@P_allot
$LN1@P_allot:

; 861  :     hptr += n;

  0008d	6a 00		 push	 0
  0008f	6a 08		 push	 8
  00091	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp+4]
  00094	50		 push	 eax
  00095	8b 4d f4	 mov	 ecx, DWORD PTR _n$[ebp]
  00098	51		 push	 ecx
  00099	e8 00 00 00 00	 call	 __allmul
  0009e	03 05 00 00 00
	00		 add	 eax, DWORD PTR _hptr
  000a4	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax
$LN3@P_allot:

; 862  : }

  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000b2	3b ec		 cmp	 ebp, esp
  000b4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
_P_allot ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_comma
_TEXT	SEGMENT
_P_comma PROC						; COMDAT

; 865  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 866  :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN2@P_comma
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 49		 jmp	 SHORT $LN3@P_comma
$LN2@P_comma:

; 867  :     Ho(1);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0003d	83 c0 08	 add	 eax, 8
  00040	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00046	76 07		 jbe	 SHORT $LN1@P_comma
  00048	e8 00 00 00 00	 call	 _heapover
  0004d	eb 32		 jmp	 SHORT $LN3@P_comma
$LN1@P_comma:

; 868  :     Hstore = S0;

  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00054	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0005a	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  0005d	89 10		 mov	 DWORD PTR [eax], edx
  0005f	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00062	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00065	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  0006b	83 c2 08	 add	 edx, 8
  0006e	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 869  :     Pop;

  00074	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00079	83 e8 08	 sub	 eax, 8
  0007c	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN3@P_comma:

; 870  : }

  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx
  00084	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0008a	3b ec		 cmp	 ebp, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
_P_comma ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_cbang
_TEXT	SEGMENT
_P_cbang PROC						; COMDAT

; 873  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 874  :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN3@P_cbang
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 47		 jmp	 SHORT $LN4@P_cbang
$LN3@P_cbang:

; 875  :     Hpc(S0);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00046	72 10		 jb	 SHORT $LN1@P_cbang
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00050	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00056	72 07		 jb	 SHORT $LN2@P_cbang
$LN1@P_cbang:
  00058	e8 00 00 00 00	 call	 _badpointer
  0005d	eb 20		 jmp	 SHORT $LN4@P_cbang
$LN2@P_cbang:

; 876  :     *((unsigned char *) S0) = S1;

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00064	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00067	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0006d	8a 42 f0	 mov	 al, BYTE PTR [edx-16]
  00070	88 01		 mov	 BYTE PTR [ecx], al

; 877  :     Pop2;

  00072	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00077	83 e8 10	 sub	 eax, 16			; 00000010H
  0007a	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN4@P_cbang:

; 878  : }

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00088	3b ec		 cmp	 ebp, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
_P_cbang ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_cat
_TEXT	SEGMENT
_P_cat	PROC						; COMDAT

; 881  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 882  :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN3@P_cat
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 3f		 jmp	 SHORT $LN4@P_cat
$LN3@P_cat:

; 883  :     Hpc(S0);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00046	72 10		 jb	 SHORT $LN1@P_cat
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00050	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00056	72 07		 jb	 SHORT $LN2@P_cat
$LN1@P_cat:
  00058	e8 00 00 00 00	 call	 _badpointer
  0005d	eb 18		 jmp	 SHORT $LN4@P_cat
$LN2@P_cat:

; 884  :     S0 = *((unsigned char *) S0);

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00064	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00067	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  0006a	99		 cdq
  0006b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00071	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  00074	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN4@P_cat:

; 885  : }

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00080	3b ec		 cmp	 ebp, esp
  00082	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
_P_cat	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_ccomma
_TEXT	SEGMENT
_chp$ = -8						; size = 4
_P_ccomma PROC						; COMDAT

; 888  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 889  :     unsigned char *chp;
; 890  : 
; 891  :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN2@P_ccomma
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 4a		 jmp	 SHORT $LN3@P_ccomma
$LN2@P_ccomma:

; 892  :     Ho(1);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0003d	83 c0 08	 add	 eax, 8
  00040	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00046	76 07		 jbe	 SHORT $LN1@P_ccomma
  00048	e8 00 00 00 00	 call	 _heapover
  0004d	eb 33		 jmp	 SHORT $LN3@P_ccomma
$LN1@P_ccomma:

; 893  :     chp = ((unsigned char *) hptr);

  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00054	89 45 f8	 mov	 DWORD PTR _chp$[ebp], eax

; 894  :     *chp++ = S0;

  00057	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0005c	8a 48 f8	 mov	 cl, BYTE PTR [eax-8]
  0005f	8b 55 f8	 mov	 edx, DWORD PTR _chp$[ebp]
  00062	88 0a		 mov	 BYTE PTR [edx], cl
  00064	8b 45 f8	 mov	 eax, DWORD PTR _chp$[ebp]
  00067	83 c0 01	 add	 eax, 1
  0006a	89 45 f8	 mov	 DWORD PTR _chp$[ebp], eax

; 895  :     hptr = (stackitem *) chp;

  0006d	8b 45 f8	 mov	 eax, DWORD PTR _chp$[ebp]
  00070	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 896  :     Pop;

  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0007a	83 e8 08	 sub	 eax, 8
  0007d	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN3@P_ccomma:

; 897  : }

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0008b	3b ec		 cmp	 ebp, esp
  0008d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
_P_ccomma ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_cequal
_TEXT	SEGMENT
_chp$83220 = -24					; size = 4
_n$ = -12						; size = 8
_P_cequal PROC						; COMDAT

; 900  : {				      /* a series of bytes. */

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 901  :     stackitem n = (((stackitem) hptr) - ((stackitem) heap)) %
; 902  : 			(sizeof(stackitem));

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00023	99		 cdq
  00024	8b c8		 mov	 ecx, eax
  00026	8b f2		 mov	 esi, edx
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  0002d	99		 cdq
  0002e	2b c8		 sub	 ecx, eax
  00030	1b f2		 sbb	 esi, edx
  00032	6a 00		 push	 0
  00034	6a 08		 push	 8
  00036	56		 push	 esi
  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 __allrem
  0003d	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax
  00040	89 55 f8	 mov	 DWORD PTR _n$[ebp+4], edx

; 903  : 
; 904  :     if (n != 0) {

  00043	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  00046	0b 45 f8	 or	 eax, DWORD PTR _n$[ebp+4]
  00049	74 26		 je	 SHORT $LN2@P_cequal

; 905  : 	char *chp = ((char *) hptr);

  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00050	89 45 e8	 mov	 DWORD PTR _chp$83220[ebp], eax

; 906  : 
; 907  : 	chp += sizeof(stackitem) - n;

  00053	b8 08 00 00 00	 mov	 eax, 8
  00058	2b 45 f4	 sub	 eax, DWORD PTR _n$[ebp]
  0005b	b9 00 00 00 00	 mov	 ecx, 0
  00060	1b 4d f8	 sbb	 ecx, DWORD PTR _n$[ebp+4]
  00063	03 45 e8	 add	 eax, DWORD PTR _chp$83220[ebp]
  00066	89 45 e8	 mov	 DWORD PTR _chp$83220[ebp], eax

; 908  : 	hptr = ((stackitem *) chp);

  00069	8b 45 e8	 mov	 eax, DWORD PTR _chp$83220[ebp]
  0006c	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax
$LN2@P_cequal:

; 909  :     }
; 910  : }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0007a	3b ec		 cmp	 ebp, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
_P_cequal ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_create
_TEXT	SEGMENT
_P_create PROC						; COMDAT

; 921  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 922  :     defpend = True;		      /* Set definition pending */

  0001e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _defpend, 1

; 923  :     Ho(Dictwordl);

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0002d	83 c0 10	 add	 eax, 16			; 00000010H
  00030	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00036	76 07		 jbe	 SHORT $LN1@P_create
  00038	e8 00 00 00 00	 call	 _heapover
  0003d	eb 2f		 jmp	 SHORT $LN2@P_create
$LN1@P_create:

; 924  :     createword = (dictword *) hptr;   /* Develop address of word */

  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00044	a3 00 00 00 00	 mov	 DWORD PTR _createword, eax

; 925  :     createword->wname = NULL;	      /* Clear pointer to name string */

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _createword
  0004e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 926  :     createword->wcode = P_var;	      /* Store default code */

  00055	a1 00 00 00 00	 mov	 eax, DWORD PTR _createword
  0005a	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _P_var

; 927  :     hptr += Dictwordl;		      /* Allocate heap space for word */

  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00066	83 c0 10	 add	 eax, 16			; 00000010H
  00069	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax
$LN2@P_create:

; 928  : }

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00077	3b ec		 cmp	 ebp, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
_P_create ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_var
_TEXT	SEGMENT
_P_var	PROC						; COMDAT

; 915  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 916  :     So(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	83 c0 08	 add	 eax, 8
  00026	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  0002c	76 07		 jbe	 SHORT $LN1@P_var
  0002e	e8 00 00 00 00	 call	 _stakover
  00033	eb 23		 jmp	 SHORT $LN2@P_var
$LN1@P_var:

; 917  :     Push = (stackitem) (((stackitem *) curword) + Dictwordl);

  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR _curword
  0003a	83 c0 10	 add	 eax, 16			; 00000010H
  0003d	99		 cdq
  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00044	89 01		 mov	 DWORD PTR [ecx], eax
  00046	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00049	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0004f	83 c2 08	 add	 edx, 8
  00052	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN2@P_var:

; 918  : }

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
_P_var	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_forget
_TEXT	SEGMENT
_P_forget PROC						; COMDAT

; 931  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 932  :     forgetpend = True;		      /* Mark forget pending */

  0001e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _forgetpend, 1

; 933  : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
_P_forget ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_variable
_TEXT	SEGMENT
_P_variable PROC					; COMDAT

; 936  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 937  :     P_create(); 		      /* Create dictionary item */

  0001e	e8 00 00 00 00	 call	 _P_create

; 938  :     Ho(1);

  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00028	83 c0 08	 add	 eax, 8
  0002b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00031	76 07		 jbe	 SHORT $LN1@P_variable
  00033	e8 00 00 00 00	 call	 _heapover
  00038	eb 21		 jmp	 SHORT $LN2@P_variable
$LN1@P_variable:

; 939  :     Hstore = 0; 		      /* Initial value = 0 */

  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0003f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00045	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  00052	83 c1 08	 add	 ecx, 8
  00055	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx
$LN2@P_variable:

; 940  : }

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00064	3b ec		 cmp	 ebp, esp
  00066	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
_P_variable ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_constant
_TEXT	SEGMENT
_P_constant PROC					; COMDAT

; 949  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 950  :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN2@P_constant
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 5a		 jmp	 SHORT $LN3@P_constant
$LN2@P_constant:

; 951  :     P_create(); 		      /* Create dictionary item */

  00038	e8 00 00 00 00	 call	 _P_create

; 952  :     createword->wcode = P_con;	      /* Set code to constant push */

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR _createword
  00042	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _P_con

; 953  :     Ho(1);

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0004e	83 c0 08	 add	 eax, 8
  00051	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00057	76 07		 jbe	 SHORT $LN1@P_constant
  00059	e8 00 00 00 00	 call	 _heapover
  0005e	eb 32		 jmp	 SHORT $LN3@P_constant
$LN1@P_constant:

; 954  :     Hstore = S0;		      /* Store constant value in body */

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00065	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0006b	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  0006e	89 10		 mov	 DWORD PTR [eax], edx
  00070	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00073	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00076	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  0007c	83 c2 08	 add	 edx, 8
  0007f	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 955  :     Pop;

  00085	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0008a	83 e8 08	 sub	 eax, 8
  0008d	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN3@P_constant:

; 956  : }

  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0009b	3b ec		 cmp	 ebp, esp
  0009d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
_P_constant ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_con
_TEXT	SEGMENT
_P_con	PROC						; COMDAT

; 943  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 944  :     So(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	83 c0 08	 add	 eax, 8
  00026	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  0002c	76 07		 jbe	 SHORT $LN1@P_con
  0002e	e8 00 00 00 00	 call	 _stakover
  00033	eb 25		 jmp	 SHORT $LN2@P_con
$LN1@P_con:

; 945  :     Push = *(((stackitem *) curword) + Dictwordl);

  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _curword
  00040	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00043	89 10		 mov	 DWORD PTR [eax], edx
  00045	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00048	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0004b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00051	83 c2 08	 add	 edx, 8
  00054	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN2@P_con:

; 946  : }

  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00063	3b ec		 cmp	 ebp, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
_P_con	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@GHKBHBNP@Bad?5array?5dimension?$AA@	; `string'
PUBLIC	??_C@_0BK@JMNCJBO@Bad?5array?5subscript?5count?$AA@ ; `string'
PUBLIC	??_C@_0BH@PPFPMAMJ@Bad?5array?5element?5size?$AA@ ; `string'
;	COMDAT ??_C@_0BE@GHKBHBNP@Bad?5array?5dimension?$AA@
CONST	SEGMENT
??_C@_0BE@GHKBHBNP@Bad?5array?5dimension?$AA@ DB 'Bad array dimension', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JMNCJBO@Bad?5array?5subscript?5count?$AA@
CONST	SEGMENT
??_C@_0BK@JMNCJBO@Bad?5array?5subscript?5count?$AA@ DB 'Bad array subscri'
	DB	'pt count', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PPFPMAMJ@Bad?5array?5element?5size?$AA@
CONST	SEGMENT
??_C@_0BH@PPFPMAMJ@Bad?5array?5element?5size?$AA@ DB 'Bad array element s'
	DB	'ize', 00H					; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _P_array
_TEXT	SEGMENT
tv168 = -244						; size = 4
tv155 = -244						; size = 4
tv149 = -244						; size = 4
tv141 = -244						; size = 4
_isp$ = -44						; size = 4
_asize$ = -32						; size = 4
_nsubs$ = -20						; size = 4
_i$ = -8						; size = 4
_P_array PROC						; COMDAT

; 996  : {				      /* sub1 sub2 ... subn n esize -- array */

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00012	b9 3d 00 00 00	 mov	 ecx, 61			; 0000003dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 997  :     int i, nsubs, asize = 1;

  0001e	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _asize$[ebp], 1

; 998  :     stackitem *isp;
; 999  : 
; 1000 :     Sl(2);

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0002a	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00030	c1 f8 03	 sar	 eax, 3
  00033	83 f8 02	 cmp	 eax, 2
  00036	7d 0a		 jge	 SHORT $LN14@P_array
  00038	e8 00 00 00 00	 call	 _stakunder
  0003d	e9 50 02 00 00	 jmp	 $LN15@P_array
$LN14@P_array:

; 1001 : #ifndef NOMEMCHECK
; 1002 :     if (S0 <= 0)

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00047	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv149[ebp], eax
  0004d	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv149[ebp]
  00053	83 79 fc 00	 cmp	 DWORD PTR [ecx-4], 0
  00057	7f 1b		 jg	 SHORT $LN13@P_array
  00059	7c 0c		 jl	 SHORT $LN19@P_array
  0005b	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR tv149[ebp]
  00061	83 7a f8 00	 cmp	 DWORD PTR [edx-8], 0
  00065	77 0d		 ja	 SHORT $LN13@P_array
$LN19@P_array:

; 1003 :         trouble("Bad array element size");

  00067	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@PPFPMAMJ@Bad?5array?5element?5size?$AA@
  0006c	e8 00 00 00 00	 call	 _trouble
  00071	83 c4 04	 add	 esp, 4
$LN13@P_array:

; 1004 :     if (S1 <= 0)

  00074	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00079	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv155[ebp], eax
  0007f	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv155[ebp]
  00085	83 79 f4 00	 cmp	 DWORD PTR [ecx-12], 0
  00089	7f 1b		 jg	 SHORT $LN12@P_array
  0008b	7c 0c		 jl	 SHORT $LN20@P_array
  0008d	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR tv155[ebp]
  00093	83 7a f0 00	 cmp	 DWORD PTR [edx-16], 0
  00097	77 0d		 ja	 SHORT $LN12@P_array
$LN20@P_array:

; 1005 :         trouble("Bad array subscript count");

  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@JMNCJBO@Bad?5array?5subscript?5count?$AA@
  0009e	e8 00 00 00 00	 call	 _trouble
  000a3	83 c4 04	 add	 esp, 4
$LN12@P_array:

; 1006 : #endif /* NOMEMCHECK */
; 1007 : 
; 1008 :     nsubs = S1; 		      /* Number of subscripts */

  000a6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000ab	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  000ae	89 4d ec	 mov	 DWORD PTR _nsubs$[ebp], ecx

; 1009 :     Sl(nsubs + 2);		      /* Verify that dimensions are present */

  000b1	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000b6	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  000bc	c1 f8 03	 sar	 eax, 3
  000bf	8b 4d ec	 mov	 ecx, DWORD PTR _nsubs$[ebp]
  000c2	83 c1 02	 add	 ecx, 2
  000c5	3b c1		 cmp	 eax, ecx
  000c7	7d 0a		 jge	 SHORT $LN11@P_array
  000c9	e8 00 00 00 00	 call	 _stakunder
  000ce	e9 bf 01 00 00	 jmp	 $LN15@P_array
$LN11@P_array:

; 1010 : 
; 1011 :     /* Calculate size of array as the product of the subscripts */
; 1012 : 
; 1013 :     asize = S0; 		      /* Fundamental element size */

  000d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000d8	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000db	89 4d e0	 mov	 DWORD PTR _asize$[ebp], ecx

; 1014 :     isp = &S2;

  000de	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000e3	83 e8 18	 sub	 eax, 24			; 00000018H
  000e6	89 45 d4	 mov	 DWORD PTR _isp$[ebp], eax

; 1015 :     for (i = 0; i < nsubs; i++) {

  000e9	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000f0	eb 09		 jmp	 SHORT $LN10@P_array
$LN9@P_array:
  000f2	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000f5	83 c0 01	 add	 eax, 1
  000f8	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN10@P_array:
  000fb	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000fe	3b 45 ec	 cmp	 eax, DWORD PTR _nsubs$[ebp]
  00101	7d 52		 jge	 SHORT $LN8@P_array

; 1016 : #ifndef NOMEMCHECK
; 1017 : 	if (*isp <= 0)

  00103	8b 45 d4	 mov	 eax, DWORD PTR _isp$[ebp]
  00106	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv168[ebp], eax
  0010c	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv168[ebp]
  00112	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00116	7f 1a		 jg	 SHORT $LN7@P_array
  00118	7c 0b		 jl	 SHORT $LN21@P_array
  0011a	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR tv168[ebp]
  00120	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00123	77 0d		 ja	 SHORT $LN7@P_array
$LN21@P_array:

; 1018 :             trouble("Bad array dimension");

  00125	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@GHKBHBNP@Bad?5array?5dimension?$AA@
  0012a	e8 00 00 00 00	 call	 _trouble
  0012f	83 c4 04	 add	 esp, 4
$LN7@P_array:

; 1019 : #endif /* NOMEMCHECK */
; 1020 : 	asize *= *isp--;

  00132	8b 45 e0	 mov	 eax, DWORD PTR _asize$[ebp]
  00135	99		 cdq
  00136	8b 4d d4	 mov	 ecx, DWORD PTR _isp$[ebp]
  00139	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0013c	56		 push	 esi
  0013d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0013f	51		 push	 ecx
  00140	52		 push	 edx
  00141	50		 push	 eax
  00142	e8 00 00 00 00	 call	 __allmul
  00147	89 45 e0	 mov	 DWORD PTR _asize$[ebp], eax
  0014a	8b 55 d4	 mov	 edx, DWORD PTR _isp$[ebp]
  0014d	83 ea 08	 sub	 edx, 8
  00150	89 55 d4	 mov	 DWORD PTR _isp$[ebp], edx

; 1021 :     }

  00153	eb 9d		 jmp	 SHORT $LN9@P_array
$LN8@P_array:

; 1022 : 
; 1023 :     asize = (asize + (sizeof(stackitem) - 1)) / sizeof(stackitem);

  00155	8b 45 e0	 mov	 eax, DWORD PTR _asize$[ebp]
  00158	83 c0 07	 add	 eax, 7
  0015b	c1 e8 03	 shr	 eax, 3
  0015e	89 45 e0	 mov	 DWORD PTR _asize$[ebp], eax

; 1024 :     Ho(asize + nsubs + 2);	      /* Reserve space for array and header */

  00161	8b 45 e0	 mov	 eax, DWORD PTR _asize$[ebp]
  00164	03 45 ec	 add	 eax, DWORD PTR _nsubs$[ebp]
  00167	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  0016d	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  00171	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  00177	76 0a		 jbe	 SHORT $LN6@P_array
  00179	e8 00 00 00 00	 call	 _heapover
  0017e	e9 0f 01 00 00	 jmp	 $LN15@P_array
$LN6@P_array:

; 1025 :     P_create(); 		      /* Create variable */

  00183	e8 00 00 00 00	 call	 _P_create

; 1026 :     createword->wcode = P_arraysub;   /* Set method to subscript calculate */

  00188	a1 00 00 00 00	 mov	 eax, DWORD PTR _createword
  0018d	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _P_arraysub

; 1027 :     Hstore = nsubs;		      /* Header <- Number of subscripts */

  00194	8b 45 ec	 mov	 eax, DWORD PTR _nsubs$[ebp]
  00197	99		 cdq
  00198	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  0019e	89 01		 mov	 DWORD PTR [ecx], eax
  001a0	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  001a3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  001a9	83 c2 08	 add	 edx, 8
  001ac	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 1028 :     Hstore = S0;		      /* Header <- Fundamental element size */

  001b2	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  001b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  001bd	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  001c0	89 10		 mov	 DWORD PTR [eax], edx
  001c2	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001c5	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  001c8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  001ce	83 c2 08	 add	 edx, 8
  001d1	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 1029 :     isp = &S2;

  001d7	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  001dc	83 e8 18	 sub	 eax, 24			; 00000018H
  001df	89 45 d4	 mov	 DWORD PTR _isp$[ebp], eax

; 1030 :     for (i = 0; i < nsubs; i++) {     /* Header <- Store subscripts */

  001e2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001e9	eb 09		 jmp	 SHORT $LN5@P_array
$LN4@P_array:
  001eb	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  001ee	83 c0 01	 add	 eax, 1
  001f1	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN5@P_array:
  001f4	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  001f7	3b 45 ec	 cmp	 eax, DWORD PTR _nsubs$[ebp]
  001fa	7d 2c		 jge	 SHORT $LN2@P_array

; 1031 : 	Hstore = *isp--;

  001fc	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00201	8b 4d d4	 mov	 ecx, DWORD PTR _isp$[ebp]
  00204	8b 11		 mov	 edx, DWORD PTR [ecx]
  00206	89 10		 mov	 DWORD PTR [eax], edx
  00208	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0020b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0020e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  00214	83 c2 08	 add	 edx, 8
  00217	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx
  0021d	8b 45 d4	 mov	 eax, DWORD PTR _isp$[ebp]
  00220	83 e8 08	 sub	 eax, 8
  00223	89 45 d4	 mov	 DWORD PTR _isp$[ebp], eax

; 1032 :     }

  00226	eb c3		 jmp	 SHORT $LN4@P_array
$LN2@P_array:

; 1033 :     while (asize-- > 0) 	      /* Clear the array to zero */

  00228	8b 45 e0	 mov	 eax, DWORD PTR _asize$[ebp]
  0022b	8b 4d e0	 mov	 ecx, DWORD PTR _asize$[ebp]
  0022e	83 e9 01	 sub	 ecx, 1
  00231	89 4d e0	 mov	 DWORD PTR _asize$[ebp], ecx
  00234	85 c0		 test	 eax, eax
  00236	7e 0c		 jle	 SHORT $LN17@P_array
  00238	c7 85 0c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv141[ebp], 1
  00242	eb 0a		 jmp	 SHORT $LN18@P_array
$LN17@P_array:
  00244	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv141[ebp], 0
$LN18@P_array:
  0024e	83 bd 0c ff ff
	ff 00		 cmp	 DWORD PTR tv141[ebp], 0
  00255	74 23		 je	 SHORT $LN1@P_array

; 1034 : 	Hstore = 0;

  00257	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0025c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00262	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00269	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  0026f	83 c1 08	 add	 ecx, 8
  00272	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx
  00278	eb ae		 jmp	 SHORT $LN2@P_array
$LN1@P_array:

; 1035 :     Npop(nsubs + 2);

  0027a	8b 45 ec	 mov	 eax, DWORD PTR _nsubs$[ebp]
  0027d	8d 0c c5 10 00
	00 00		 lea	 ecx, DWORD PTR [eax*8+16]
  00284	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0028a	2b d1		 sub	 edx, ecx
  0028c	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN15@P_array:

; 1036 : }

  00292	5f		 pop	 edi
  00293	5e		 pop	 esi
  00294	5b		 pop	 ebx
  00295	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  0029b	3b ec		 cmp	 ebp, esp
  0029d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002a2	8b e5		 mov	 esp, ebp
  002a4	5d		 pop	 ebp
  002a5	c3		 ret	 0
_P_array ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@JCEAHPOB@Subscript?5out?5of?5range?$AA@ ; `string'
;	COMDAT ??_C@_0BH@JCEAHPOB@Subscript?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BH@JCEAHPOB@Subscript?5out?5of?5range?$AA@ DB 'Subscript out of ra'
	DB	'nge', 00H					; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _P_arraysub
_TEXT	SEGMENT
tv157 = -288						; size = 4
tv156 = -284						; size = 4
_subn$83279 = -84					; size = 8
_isp$ = -68						; size = 4
_array$ = -56						; size = 4
_nsubs$ = -44						; size = 4
_esize$ = -32						; size = 4
_offset$ = -20						; size = 4
_i$ = -8						; size = 4
_P_arraysub PROC					; COMDAT

; 962  : {				      /* sub1 sub2 ... subn -- addr */

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-288]
  00012	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 963  :     int i, offset, esize, nsubs;
; 964  :     stackitem *array;
; 965  :     stackitem *isp;
; 966  : 
; 967  :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 0a		 jge	 SHORT $LN11@P_arraysub
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 82 01 00 00	 jmp	 $LN12@P_arraysub
$LN11@P_arraysub:

; 968  :     array = (((stackitem *) curword) + Dictwordl);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _curword
  00040	83 c0 10	 add	 eax, 16			; 00000010H
  00043	89 45 c8	 mov	 DWORD PTR _array$[ebp], eax

; 969  :     Hpc(array);

  00046	8b 45 c8	 mov	 eax, DWORD PTR _array$[ebp]
  00049	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  0004f	72 0b		 jb	 SHORT $LN9@P_arraysub
  00051	8b 45 c8	 mov	 eax, DWORD PTR _array$[ebp]
  00054	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  0005a	72 0a		 jb	 SHORT $LN10@P_arraysub
$LN9@P_arraysub:
  0005c	e8 00 00 00 00	 call	 _badpointer
  00061	e9 57 01 00 00	 jmp	 $LN12@P_arraysub
$LN10@P_arraysub:

; 970  :     nsubs = *array++;		      /* Load number of subscripts */

  00066	8b 45 c8	 mov	 eax, DWORD PTR _array$[ebp]
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	89 4d d4	 mov	 DWORD PTR _nsubs$[ebp], ecx
  0006e	8b 55 c8	 mov	 edx, DWORD PTR _array$[ebp]
  00071	83 c2 08	 add	 edx, 8
  00074	89 55 c8	 mov	 DWORD PTR _array$[ebp], edx

; 971  :     esize = *array++;		      /* Load element size */

  00077	8b 45 c8	 mov	 eax, DWORD PTR _array$[ebp]
  0007a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007c	89 4d e0	 mov	 DWORD PTR _esize$[ebp], ecx
  0007f	8b 55 c8	 mov	 edx, DWORD PTR _array$[ebp]
  00082	83 c2 08	 add	 edx, 8
  00085	89 55 c8	 mov	 DWORD PTR _array$[ebp], edx

; 972  : #ifndef NOMEMCHECK
; 973  :     isp = &S0;

  00088	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0008d	83 e8 08	 sub	 eax, 8
  00090	89 45 bc	 mov	 DWORD PTR _isp$[ebp], eax

; 974  :     for (i = 0; i < nsubs; i++) {

  00093	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0009a	eb 09		 jmp	 SHORT $LN8@P_arraysub
$LN7@P_arraysub:
  0009c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0009f	83 c0 01	 add	 eax, 1
  000a2	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN8@P_arraysub:
  000a5	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000a8	3b 45 d4	 cmp	 eax, DWORD PTR _nsubs$[ebp]
  000ab	7d 74		 jge	 SHORT $LN6@P_arraysub

; 975  : 	stackitem subn = *isp--;

  000ad	8b 45 bc	 mov	 eax, DWORD PTR _isp$[ebp]
  000b0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b2	89 4d ac	 mov	 DWORD PTR _subn$83279[ebp], ecx
  000b5	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b8	89 55 b0	 mov	 DWORD PTR _subn$83279[ebp+4], edx
  000bb	8b 45 bc	 mov	 eax, DWORD PTR _isp$[ebp]
  000be	83 e8 08	 sub	 eax, 8
  000c1	89 45 bc	 mov	 DWORD PTR _isp$[ebp], eax

; 976  : 
; 977  : 	if (subn < 0 || subn >= array[i])

  000c4	83 7d b0 00	 cmp	 DWORD PTR _subn$83279[ebp+4], 0
  000c8	7c 45		 jl	 SHORT $LN4@P_arraysub
  000ca	7f 06		 jg	 SHORT $LN14@P_arraysub
  000cc	83 7d ac 00	 cmp	 DWORD PTR _subn$83279[ebp], 0
  000d0	72 3d		 jb	 SHORT $LN4@P_arraysub
$LN14@P_arraysub:
  000d2	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000d5	8b 4d c8	 mov	 ecx, DWORD PTR _array$[ebp]
  000d8	89 8d e4 fe ff
	ff		 mov	 DWORD PTR tv156[ebp], ecx
  000de	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv157[ebp], eax
  000e4	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR tv157[ebp]
  000ea	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR tv156[ebp]
  000f0	8b 4d b0	 mov	 ecx, DWORD PTR _subn$83279[ebp+4]
  000f3	3b 4c d0 04	 cmp	 ecx, DWORD PTR [eax+edx*8+4]
  000f7	7c 23		 jl	 SHORT $LN5@P_arraysub
  000f9	7f 14		 jg	 SHORT $LN4@P_arraysub
  000fb	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR tv157[ebp]
  00101	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR tv156[ebp]
  00107	8b 4d ac	 mov	 ecx, DWORD PTR _subn$83279[ebp]
  0010a	3b 0c d0	 cmp	 ecx, DWORD PTR [eax+edx*8]
  0010d	72 0d		 jb	 SHORT $LN5@P_arraysub
$LN4@P_arraysub:

; 978  :             trouble("Subscript out of range");

  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@JCEAHPOB@Subscript?5out?5of?5range?$AA@
  00114	e8 00 00 00 00	 call	 _trouble
  00119	83 c4 04	 add	 esp, 4
$LN5@P_arraysub:

; 979  :     }

  0011c	e9 7b ff ff ff	 jmp	 $LN7@P_arraysub
$LN6@P_arraysub:

; 980  : #endif /* NOMEMCHECK */
; 981  :     isp = &S0;

  00121	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00126	83 e8 08	 sub	 eax, 8
  00129	89 45 bc	 mov	 DWORD PTR _isp$[ebp], eax

; 982  :     offset = *isp;		      /* Load initial offset */

  0012c	8b 45 bc	 mov	 eax, DWORD PTR _isp$[ebp]
  0012f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00131	89 4d ec	 mov	 DWORD PTR _offset$[ebp], ecx

; 983  :     for (i = 1; i < nsubs; i++)

  00134	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  0013b	eb 09		 jmp	 SHORT $LN3@P_arraysub
$LN2@P_arraysub:
  0013d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00140	83 c0 01	 add	 eax, 1
  00143	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN3@P_arraysub:
  00146	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00149	3b 45 d4	 cmp	 eax, DWORD PTR _nsubs$[ebp]
  0014c	7d 34		 jge	 SHORT $LN1@P_arraysub

; 984  : 	offset = (offset * (*(++array))) + *(--isp);

  0014e	8b 45 c8	 mov	 eax, DWORD PTR _array$[ebp]
  00151	83 c0 08	 add	 eax, 8
  00154	89 45 c8	 mov	 DWORD PTR _array$[ebp], eax
  00157	8b 4d bc	 mov	 ecx, DWORD PTR _isp$[ebp]
  0015a	83 e9 08	 sub	 ecx, 8
  0015d	89 4d bc	 mov	 DWORD PTR _isp$[ebp], ecx
  00160	8b 45 ec	 mov	 eax, DWORD PTR _offset$[ebp]
  00163	99		 cdq
  00164	8b 4d c8	 mov	 ecx, DWORD PTR _array$[ebp]
  00167	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0016a	56		 push	 esi
  0016b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0016d	51		 push	 ecx
  0016e	52		 push	 edx
  0016f	50		 push	 eax
  00170	e8 00 00 00 00	 call	 __allmul
  00175	8b 4d bc	 mov	 ecx, DWORD PTR _isp$[ebp]
  00178	03 01		 add	 eax, DWORD PTR [ecx]
  0017a	13 51 04	 adc	 edx, DWORD PTR [ecx+4]
  0017d	89 45 ec	 mov	 DWORD PTR _offset$[ebp], eax
  00180	eb bb		 jmp	 SHORT $LN2@P_arraysub
$LN1@P_arraysub:

; 985  :     Npop(nsubs - 1);

  00182	8b 45 d4	 mov	 eax, DWORD PTR _nsubs$[ebp]
  00185	8d 0c c5 f8 ff
	ff ff		 lea	 ecx, DWORD PTR [eax*8-8]
  0018c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00192	2b d1		 sub	 edx, ecx
  00194	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 986  :     /* Calculate subscripted address.  We start at the current word,
; 987  :        advance to the body, skip two more words for the subscript count
; 988  :        and the fundamental element size, then skip the subscript bounds
; 989  :        words (as many as there are subscripts).  Then, finally, we
; 990  :        can add the calculated offset into the array. */
; 991  :     S0 = (stackitem) (((char *) (((stackitem *) curword) +
; 992  : 	    Dictwordl + 2 + nsubs)) + (esize * offset));

  0019a	8b 45 d4	 mov	 eax, DWORD PTR _nsubs$[ebp]
  0019d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _curword
  001a3	8d 44 c1 20	 lea	 eax, DWORD PTR [ecx+eax*8+32]
  001a7	8b 55 e0	 mov	 edx, DWORD PTR _esize$[ebp]
  001aa	0f af 55 ec	 imul	 edx, DWORD PTR _offset$[ebp]
  001ae	03 c2		 add	 eax, edx
  001b0	99		 cdq
  001b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  001b7	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  001ba	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN12@P_arraysub:

; 993  : }

  001bd	5f		 pop	 edi
  001be	5e		 pop	 esi
  001bf	5b		 pop	 ebx
  001c0	81 c4 20 01 00
	00		 add	 esp, 288		; 00000120H
  001c6	3b ec		 cmp	 ebp, esp
  001c8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001cd	8b e5		 mov	 esp, ebp
  001cf	5d		 pop	 ebp
  001d0	c3		 ret	 0
_P_arraysub ENDP
_TEXT	ENDS
PUBLIC	??_C@_05NKLPODEL@?$CC?$CFs?$CC?5?$AA@		; `string'
EXTRN	__imp__printf:PROC
;	COMDAT ??_C@_05NKLPODEL@?$CC?$CFs?$CC?5?$AA@
CONST	SEGMENT
??_C@_05NKLPODEL@?$CC?$CFs?$CC?5?$AA@ DB '"%s" ', 00H	; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _P_strlit
_TEXT	SEGMENT
_P_strlit PROC						; COMDAT

; 1044 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1045 :     So(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	83 c0 08	 add	 eax, 8
  00026	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  0002c	76 07		 jbe	 SHORT $LN2@P_strlit
  0002e	e8 00 00 00 00	 call	 _stakover
  00033	eb 66		 jmp	 SHORT $LN3@P_strlit
$LN2@P_strlit:

; 1046 :     Push = (stackitem) (((char *) ip) + 1);

  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  0003a	83 c0 01	 add	 eax, 1
  0003d	99		 cdq
  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00044	89 01		 mov	 DWORD PTR [ecx], eax
  00046	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00049	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0004f	83 c2 08	 add	 edx, 8
  00052	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 1047 : #ifdef TRACE
; 1048 :     if (atl_trace) {

  00058	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_trace
  0005d	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _atl_trace+4
  00063	74 20		 je	 SHORT $LN1@P_strlit

; 1049 :         V printf("\"%s\" ", (((char *) ip) + 1));

  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  0006a	83 c0 01	 add	 eax, 1
  0006d	8b f4		 mov	 esi, esp
  0006f	50		 push	 eax
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_05NKLPODEL@?$CC?$CFs?$CC?5?$AA@
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0007b	83 c4 08	 add	 esp, 8
  0007e	3b f4		 cmp	 esi, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@P_strlit:

; 1050 :     }
; 1051 : #endif /* TRACE */
; 1052 :     Skipstring; 		      /* Advance IP past it */

  00085	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  0008a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0008d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ip
  00093	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00096	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax
$LN3@P_strlit:

; 1053 : }

  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000a4	3b ec		 cmp	 ebp, esp
  000a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
_P_strlit ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_string
_TEXT	SEGMENT
_P_string PROC						; COMDAT

; 1056 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1057 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 0a		 jge	 SHORT $LN2@P_string
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 80 00 00 00	 jmp	 $LN3@P_string
$LN2@P_string:

; 1058 :     Ho((S0 + 1 + sizeof(stackitem)) / sizeof(stackitem));

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00043	83 c1 09	 add	 ecx, 9
  00046	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00049	83 d2 00	 adc	 edx, 0
  0004c	6a 00		 push	 0
  0004e	6a 08		 push	 8
  00050	52		 push	 edx
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 __alldiv
  00057	6a 00		 push	 0
  00059	6a 08		 push	 8
  0005b	52		 push	 edx
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 __allmul
  00062	03 05 00 00 00
	00		 add	 eax, DWORD PTR _hptr
  00068	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  0006e	76 07		 jbe	 SHORT $LN1@P_string
  00070	e8 00 00 00 00	 call	 _heapover
  00075	eb 44		 jmp	 SHORT $LN3@P_string
$LN1@P_string:

; 1059 :     P_create(); 		      /* Create variable */

  00077	e8 00 00 00 00	 call	 _P_create

; 1060 :     /* Allocate storage for string */
; 1061 :     hptr += (S0 + 1 + sizeof(stackitem)) / sizeof(stackitem);

  0007c	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00081	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00084	83 c1 09	 add	 ecx, 9
  00087	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0008a	83 d2 00	 adc	 edx, 0
  0008d	6a 00		 push	 0
  0008f	6a 08		 push	 8
  00091	52		 push	 edx
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 __alldiv
  00098	6a 00		 push	 0
  0009a	6a 08		 push	 8
  0009c	52		 push	 edx
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 __allmul
  000a3	03 05 00 00 00
	00		 add	 eax, DWORD PTR _hptr
  000a9	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 1062 :     Pop;

  000ae	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000b3	83 e8 08	 sub	 eax, 8
  000b6	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN3@P_string:

; 1063 : }

  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx
  000be	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000c4	3b ec		 cmp	 ebp, esp
  000c6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
_P_string ENDP
_TEXT	ENDS
EXTRN	_strcpy:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_strcpy
_TEXT	SEGMENT
_P_strcpy PROC						; COMDAT

; 1066 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1067 :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN5@P_strcpy
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 76		 jmp	 SHORT $LN6@P_strcpy
$LN5@P_strcpy:

; 1068 :     Hpc(S0);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00046	72 10		 jb	 SHORT $LN3@P_strcpy
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00050	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00056	72 07		 jb	 SHORT $LN4@P_strcpy
$LN3@P_strcpy:
  00058	e8 00 00 00 00	 call	 _badpointer
  0005d	eb 4f		 jmp	 SHORT $LN6@P_strcpy
$LN4@P_strcpy:

; 1069 :     Hpc(S1);

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00064	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00067	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  0006d	72 10		 jb	 SHORT $LN1@P_strcpy
  0006f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00074	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00077	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  0007d	72 07		 jb	 SHORT $LN2@P_strcpy
$LN1@P_strcpy:
  0007f	e8 00 00 00 00	 call	 _badpointer
  00084	eb 28		 jmp	 SHORT $LN6@P_strcpy
$LN2@P_strcpy:

; 1070 :     V strcpy((char *) S0, (char *) S1);

  00086	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0008b	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0008e	51		 push	 ecx
  0008f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00095	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _strcpy
  0009e	83 c4 08	 add	 esp, 8

; 1071 :     Pop2;

  000a1	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000a6	83 e8 10	 sub	 eax, 16			; 00000010H
  000a9	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN6@P_strcpy:

; 1072 : }

  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx
  000b1	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000b7	3b ec		 cmp	 ebp, esp
  000b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
_P_strcpy ENDP
_TEXT	ENDS
EXTRN	_strcat:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_strcat
_TEXT	SEGMENT
_P_strcat PROC						; COMDAT

; 1075 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1076 :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN5@P_strcat
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 76		 jmp	 SHORT $LN6@P_strcat
$LN5@P_strcat:

; 1077 :     Hpc(S0);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00046	72 10		 jb	 SHORT $LN3@P_strcat
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00050	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00056	72 07		 jb	 SHORT $LN4@P_strcat
$LN3@P_strcat:
  00058	e8 00 00 00 00	 call	 _badpointer
  0005d	eb 4f		 jmp	 SHORT $LN6@P_strcat
$LN4@P_strcat:

; 1078 :     Hpc(S1);

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00064	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00067	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  0006d	72 10		 jb	 SHORT $LN1@P_strcat
  0006f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00074	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00077	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  0007d	72 07		 jb	 SHORT $LN2@P_strcat
$LN1@P_strcat:
  0007f	e8 00 00 00 00	 call	 _badpointer
  00084	eb 28		 jmp	 SHORT $LN6@P_strcat
$LN2@P_strcat:

; 1079 :     V strcat((char *) S0, (char *) S1);

  00086	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0008b	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0008e	51		 push	 ecx
  0008f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00095	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _strcat
  0009e	83 c4 08	 add	 esp, 8

; 1080 :     Pop2;

  000a1	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000a6	83 e8 10	 sub	 eax, 16			; 00000010H
  000a9	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN6@P_strcat:

; 1081 : }

  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx
  000b1	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000b7	3b ec		 cmp	 ebp, esp
  000b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
_P_strcat ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_strlen
_TEXT	SEGMENT
_P_strlen PROC						; COMDAT

; 1084 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1085 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN3@P_strlen
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 46		 jmp	 SHORT $LN4@P_strlen
$LN3@P_strlen:

; 1086 :     Hpc(S0);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00046	72 10		 jb	 SHORT $LN1@P_strlen
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00050	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00056	72 07		 jb	 SHORT $LN2@P_strlen
$LN1@P_strlen:
  00058	e8 00 00 00 00	 call	 _badpointer
  0005d	eb 1f		 jmp	 SHORT $LN4@P_strlen
$LN2@P_strlen:

; 1087 :     S0 = strlen((char *) S0);

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00064	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 _strlen
  0006d	83 c4 04	 add	 esp, 4
  00070	33 d2		 xor	 edx, edx
  00072	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00078	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  0007b	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN4@P_strlen:

; 1088 : }

  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00087	3b ec		 cmp	 ebp, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
_P_strlen ENDP
_TEXT	ENDS
EXTRN	_strcmp:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_strcmp
_TEXT	SEGMENT
tv90 = -208						; size = 4
_i$ = -8						; size = 4
_P_strcmp PROC						; COMDAT

; 1091 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1092 :     int i;
; 1093 : 
; 1094 :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 0a		 jge	 SHORT $LN5@P_strcmp
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 b4 00 00 00	 jmp	 $LN6@P_strcmp
$LN5@P_strcmp:

; 1095 :     Hpc(S0);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00043	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00049	72 10		 jb	 SHORT $LN3@P_strcmp
  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00050	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00053	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00059	72 0a		 jb	 SHORT $LN4@P_strcmp
$LN3@P_strcmp:
  0005b	e8 00 00 00 00	 call	 _badpointer
  00060	e9 8a 00 00 00	 jmp	 $LN6@P_strcmp
$LN4@P_strcmp:

; 1096 :     Hpc(S1);

  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0006a	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0006d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00073	72 10		 jb	 SHORT $LN1@P_strcmp
  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0007a	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0007d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00083	72 07		 jb	 SHORT $LN2@P_strcmp
$LN1@P_strcmp:
  00085	e8 00 00 00 00	 call	 _badpointer
  0008a	eb 63		 jmp	 SHORT $LN6@P_strcmp
$LN2@P_strcmp:

; 1097 :     i = strcmp((char *) S1, (char *) S0);

  0008c	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00091	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00094	51		 push	 ecx
  00095	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0009b	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 _strcmp
  000a4	83 c4 08	 add	 esp, 8
  000a7	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax

; 1098 :     S1 = (i == 0) ? 0L : ((i > 0) ? 1L : -1L);

  000aa	83 7d f8 00	 cmp	 DWORD PTR _i$[ebp], 0
  000ae	75 0c		 jne	 SHORT $LN8@P_strcmp
  000b0	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv90[ebp], 0
  000ba	eb 13		 jmp	 SHORT $LN9@P_strcmp
$LN8@P_strcmp:
  000bc	33 c0		 xor	 eax, eax
  000be	83 7d f8 00	 cmp	 DWORD PTR _i$[ebp], 0
  000c2	0f 9f c0	 setg	 al
  000c5	8d 44 00 ff	 lea	 eax, DWORD PTR [eax+eax-1]
  000c9	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
$LN9@P_strcmp:
  000cf	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv90[ebp]
  000d5	99		 cdq
  000d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  000dc	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  000df	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 1099 :     Pop;

  000e2	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000e7	83 e8 08	 sub	 eax, 8
  000ea	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN6@P_strcmp:

; 1100 : }

  000ef	5f		 pop	 edi
  000f0	5e		 pop	 esi
  000f1	5b		 pop	 ebx
  000f2	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000f8	3b ec		 cmp	 ebp, esp
  000fa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
_P_strcmp ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_strchar
_TEXT	SEGMENT
_P_strchar PROC						; COMDAT

; 1103 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1104 :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 0a		 jge	 SHORT $LN5@P_strchar
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 8f 00 00 00	 jmp	 $LN6@P_strchar
$LN5@P_strchar:

; 1105 :     Hpc(S0);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00043	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00049	72 10		 jb	 SHORT $LN3@P_strchar
  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00050	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00053	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00059	72 07		 jb	 SHORT $LN4@P_strchar
$LN3@P_strchar:
  0005b	e8 00 00 00 00	 call	 _badpointer
  00060	eb 68		 jmp	 SHORT $LN6@P_strchar
$LN4@P_strchar:

; 1106 :     Hpc(S1);

  00062	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00067	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0006a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00070	72 10		 jb	 SHORT $LN1@P_strchar
  00072	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00077	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0007a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00080	72 07		 jb	 SHORT $LN2@P_strchar
$LN1@P_strchar:
  00082	e8 00 00 00 00	 call	 _badpointer
  00087	eb 41		 jmp	 SHORT $LN6@P_strchar
$LN2@P_strchar:

; 1107 :     S1 = (stackitem) strchr((char *) S1, *((char *) S0));

  00089	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0008e	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00091	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00094	8b f4		 mov	 esi, esp
  00096	52		 push	 edx
  00097	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0009c	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0009f	51		 push	 ecx
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strchr
  000a6	83 c4 08	 add	 esp, 8
  000a9	3b f4		 cmp	 esi, esp
  000ab	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b0	99		 cdq
  000b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  000b7	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  000ba	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 1108 :     Pop;

  000bd	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000c2	83 e8 08	 sub	 eax, 8
  000c5	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN6@P_strchar:

; 1109 : }

  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000d3	3b ec		 cmp	 ebp, esp
  000d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
_P_strchar ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_substr
_TEXT	SEGMENT
tv95 = -268						; size = 4
_ds$ = -68						; size = 4
_se$ = -56						; size = 4
_sp$ = -44						; size = 4
_ss$ = -32						; size = 4
_sn$ = -20						; size = 4
_sl$ = -8						; size = 4
_P_substr PROC						; COMDAT

; 1112 : {				      /* source start length/-1 dest -- */

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-268]
  00012	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1113 :     long sl, sn;
; 1114 :     char *ss, *sp, *se, *ds;
; 1115 : 
; 1116 :     Sl(4);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 04	 cmp	 eax, 4
  0002f	7d 0a		 jge	 SHORT $LN8@P_substr
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 0d 01 00 00	 jmp	 $LN9@P_substr
$LN8@P_substr:

; 1117 :     Hpc(S0);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00043	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00049	72 10		 jb	 SHORT $LN6@P_substr
  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00050	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00053	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00059	72 0a		 jb	 SHORT $LN7@P_substr
$LN6@P_substr:
  0005b	e8 00 00 00 00	 call	 _badpointer
  00060	e9 e3 00 00 00	 jmp	 $LN9@P_substr
$LN7@P_substr:

; 1118 :     Hpc(S3);

  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0006a	8b 48 e0	 mov	 ecx, DWORD PTR [eax-32]
  0006d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00073	72 10		 jb	 SHORT $LN4@P_substr
  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0007a	8b 48 e0	 mov	 ecx, DWORD PTR [eax-32]
  0007d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00083	72 0a		 jb	 SHORT $LN5@P_substr
$LN4@P_substr:
  00085	e8 00 00 00 00	 call	 _badpointer
  0008a	e9 b9 00 00 00	 jmp	 $LN9@P_substr
$LN5@P_substr:

; 1119 :     sl = strlen(ss = ((char *) S3));

  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00094	8b 48 e0	 mov	 ecx, DWORD PTR [eax-32]
  00097	89 4d e0	 mov	 DWORD PTR _ss$[ebp], ecx
  0009a	8b 55 e0	 mov	 edx, DWORD PTR _ss$[ebp]
  0009d	52		 push	 edx
  0009e	e8 00 00 00 00	 call	 _strlen
  000a3	83 c4 04	 add	 esp, 4
  000a6	89 45 f8	 mov	 DWORD PTR _sl$[ebp], eax

; 1120 :     se = ss + sl;

  000a9	8b 45 e0	 mov	 eax, DWORD PTR _ss$[ebp]
  000ac	03 45 f8	 add	 eax, DWORD PTR _sl$[ebp]
  000af	89 45 c8	 mov	 DWORD PTR _se$[ebp], eax

; 1121 :     sp = ((char *) S3) + S2;

  000b2	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000b7	8b 48 e0	 mov	 ecx, DWORD PTR [eax-32]
  000ba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  000c0	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  000c3	03 c8		 add	 ecx, eax
  000c5	89 4d d4	 mov	 DWORD PTR _sp$[ebp], ecx

; 1122 :     if ((sn = S1) < 0)

  000c8	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000cd	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  000d0	89 4d ec	 mov	 DWORD PTR _sn$[ebp], ecx
  000d3	83 7d ec 00	 cmp	 DWORD PTR _sn$[ebp], 0
  000d7	7d 07		 jge	 SHORT $LN3@P_substr

; 1123 : 	sn = 999999L;

  000d9	c7 45 ec 3f 42
	0f 00		 mov	 DWORD PTR _sn$[ebp], 999999 ; 000f423fH
$LN3@P_substr:

; 1124 :     ds = (char *) S0;

  000e0	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000e5	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000e8	89 4d bc	 mov	 DWORD PTR _ds$[ebp], ecx
$LN2@P_substr:

; 1125 :     while (sn-- && (sp < se))

  000eb	8b 45 ec	 mov	 eax, DWORD PTR _sn$[ebp]
  000ee	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv95[ebp], eax
  000f4	8b 4d ec	 mov	 ecx, DWORD PTR _sn$[ebp]
  000f7	83 e9 01	 sub	 ecx, 1
  000fa	89 4d ec	 mov	 DWORD PTR _sn$[ebp], ecx
  000fd	83 bd f4 fe ff
	ff 00		 cmp	 DWORD PTR tv95[ebp], 0
  00104	74 26		 je	 SHORT $LN1@P_substr
  00106	8b 45 d4	 mov	 eax, DWORD PTR _sp$[ebp]
  00109	3b 45 c8	 cmp	 eax, DWORD PTR _se$[ebp]
  0010c	73 1e		 jae	 SHORT $LN1@P_substr

; 1126 : 	*ds++ = *sp++;

  0010e	8b 45 bc	 mov	 eax, DWORD PTR _ds$[ebp]
  00111	8b 4d d4	 mov	 ecx, DWORD PTR _sp$[ebp]
  00114	8a 11		 mov	 dl, BYTE PTR [ecx]
  00116	88 10		 mov	 BYTE PTR [eax], dl
  00118	8b 45 bc	 mov	 eax, DWORD PTR _ds$[ebp]
  0011b	83 c0 01	 add	 eax, 1
  0011e	89 45 bc	 mov	 DWORD PTR _ds$[ebp], eax
  00121	8b 4d d4	 mov	 ecx, DWORD PTR _sp$[ebp]
  00124	83 c1 01	 add	 ecx, 1
  00127	89 4d d4	 mov	 DWORD PTR _sp$[ebp], ecx
  0012a	eb bf		 jmp	 SHORT $LN2@P_substr
$LN1@P_substr:

; 1127 :     *ds++ = EOS;

  0012c	8b 45 bc	 mov	 eax, DWORD PTR _ds$[ebp]
  0012f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00132	8b 4d bc	 mov	 ecx, DWORD PTR _ds$[ebp]
  00135	83 c1 01	 add	 ecx, 1
  00138	89 4d bc	 mov	 DWORD PTR _ds$[ebp], ecx

; 1128 :     Npop(4);

  0013b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00140	83 e8 20	 sub	 eax, 32			; 00000020H
  00143	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN9@P_substr:

; 1129 : }

  00148	5f		 pop	 edi
  00149	5e		 pop	 esi
  0014a	5b		 pop	 ebx
  0014b	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  00151	3b ec		 cmp	 ebp, esp
  00153	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c3		 ret	 0
_P_substr ENDP
_TEXT	ENDS
EXTRN	__imp__sprintf:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_strform
_TEXT	SEGMENT
_P_strform PROC						; COMDAT

; 1132 : {                                     /* value "%ld" str -- */

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1133 :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 0a		 jge	 SHORT $LN5@P_strform
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 8d 00 00 00	 jmp	 $LN6@P_strform
$LN5@P_strform:

; 1134 :     Hpc(S0);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00043	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00049	72 10		 jb	 SHORT $LN3@P_strform
  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00050	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00053	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00059	72 07		 jb	 SHORT $LN4@P_strform
$LN3@P_strform:
  0005b	e8 00 00 00 00	 call	 _badpointer
  00060	eb 66		 jmp	 SHORT $LN6@P_strform
$LN4@P_strform:

; 1135 :     Hpc(S1);

  00062	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00067	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0006a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00070	72 10		 jb	 SHORT $LN1@P_strform
  00072	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00077	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0007a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00080	72 07		 jb	 SHORT $LN2@P_strform
$LN1@P_strform:
  00082	e8 00 00 00 00	 call	 _badpointer
  00087	eb 3f		 jmp	 SHORT $LN6@P_strform
$LN2@P_strform:

; 1136 :     V sprintf((char *) S0, (char *) S1, S2);

  00089	8b f4		 mov	 esi, esp
  0008b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00090	8b 48 ec	 mov	 ecx, DWORD PTR [eax-20]
  00093	51		 push	 ecx
  00094	8b 50 e8	 mov	 edx, DWORD PTR [eax-24]
  00097	52		 push	 edx
  00098	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0009d	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  000a0	51		 push	 ecx
  000a1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  000a7	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  000aa	50		 push	 eax
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  000b1	83 c4 10	 add	 esp, 16			; 00000010H
  000b4	3b f4		 cmp	 esi, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1137 :     Npop(3);

  000bb	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000c0	83 e8 18	 sub	 eax, 24			; 00000018H
  000c3	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN6@P_strform:

; 1138 : }

  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi
  000ca	5b		 pop	 ebx
  000cb	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000d1	3b ec		 cmp	 ebp, esp
  000d3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
_P_strform ENDP
_TEXT	ENDS
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_fstrform
_TEXT	SEGMENT
_P_fstrform PROC					; COMDAT

; 1142 : {                                     /* rvalue "%6.2f" str -- */

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1143 :     Sl(2 + Realsize);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 03	 cmp	 eax, 3
  0002f	73 0a		 jae	 SHORT $LN5@P_fstrform
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 8e 00 00 00	 jmp	 $LN6@P_fstrform
$LN5@P_fstrform:

; 1144 :     Hpc(S0);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00043	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00049	72 10		 jb	 SHORT $LN3@P_fstrform
  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00050	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00053	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00059	72 07		 jb	 SHORT $LN4@P_fstrform
$LN3@P_fstrform:
  0005b	e8 00 00 00 00	 call	 _badpointer
  00060	eb 67		 jmp	 SHORT $LN6@P_fstrform
$LN4@P_fstrform:

; 1145 :     Hpc(S1);

  00062	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00067	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0006a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00070	72 10		 jb	 SHORT $LN1@P_fstrform
  00072	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00077	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0007a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00080	72 07		 jb	 SHORT $LN2@P_fstrform
$LN1@P_fstrform:
  00082	e8 00 00 00 00	 call	 _badpointer
  00087	eb 40		 jmp	 SHORT $LN6@P_fstrform
$LN2@P_fstrform:

; 1146 :     V sprintf((char *) S0, (char *) S1, REAL2);

  00089	8b f4		 mov	 esi, esp
  0008b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00090	83 ec 08	 sub	 esp, 8
  00093	dd 40 e8	 fld	 QWORD PTR [eax-24]
  00096	dd 1c 24	 fstp	 QWORD PTR [esp]
  00099	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0009f	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  000a2	52		 push	 edx
  000a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000a8	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000ab	51		 push	 ecx
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  000b2	83 c4 10	 add	 esp, 16			; 00000010H
  000b5	3b f4		 cmp	 esi, esp
  000b7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1147 :     Npop(2 + Realsize);

  000bc	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000c1	83 e8 18	 sub	 eax, 24			; 00000018H
  000c4	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN6@P_fstrform:

; 1148 : }

  000c9	5f		 pop	 edi
  000ca	5e		 pop	 esi
  000cb	5b		 pop	 ebx
  000cc	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000d2	3b ec		 cmp	 ebp, esp
  000d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
_P_fstrform ENDP
_TEXT	ENDS
EXTRN	__imp__strtoul:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_strint
_TEXT	SEGMENT
_eptr$ = -24						; size = 4
_is$ = -12						; size = 8
_P_strint PROC						; COMDAT

; 1152 : {				      /* str -- endptr value */

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1153 :     stackitem is;
; 1154 :     char *eptr;
; 1155 : 
; 1156 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 0a		 jge	 SHORT $LN4@P_strint
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 95 00 00 00	 jmp	 $LN5@P_strint
$LN4@P_strint:

; 1157 :     So(1);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	83 c0 08	 add	 eax, 8
  00043	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00049	76 07		 jbe	 SHORT $LN3@P_strint
  0004b	e8 00 00 00 00	 call	 _stakover
  00050	eb 7e		 jmp	 SHORT $LN5@P_strint
$LN3@P_strint:

; 1158 :     Hpc(S0);

  00052	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00057	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0005a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00060	72 10		 jb	 SHORT $LN1@P_strint
  00062	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00067	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0006a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00070	72 07		 jb	 SHORT $LN2@P_strint
$LN1@P_strint:
  00072	e8 00 00 00 00	 call	 _badpointer
  00077	eb 57		 jmp	 SHORT $LN5@P_strint
$LN2@P_strint:

; 1159 :     is = strtoul((char *) S0, &eptr, 0);

  00079	8b f4		 mov	 esi, esp
  0007b	6a 00		 push	 0
  0007d	8d 45 e8	 lea	 eax, DWORD PTR _eptr$[ebp]
  00080	50		 push	 eax
  00081	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00087	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  0008a	52		 push	 edx
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtoul
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH
  00094	3b f4		 cmp	 esi, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	33 c9		 xor	 ecx, ecx
  0009d	89 45 f4	 mov	 DWORD PTR _is$[ebp], eax
  000a0	89 4d f8	 mov	 DWORD PTR _is$[ebp+4], ecx

; 1160 :     S0 = (stackitem) eptr;

  000a3	8b 45 e8	 mov	 eax, DWORD PTR _eptr$[ebp]
  000a6	99		 cdq
  000a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  000ad	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  000b0	89 51 fc	 mov	 DWORD PTR [ecx-4], edx

; 1161 :     Push = is;

  000b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000b8	8b 4d f4	 mov	 ecx, DWORD PTR _is$[ebp]
  000bb	89 08		 mov	 DWORD PTR [eax], ecx
  000bd	8b 55 f8	 mov	 edx, DWORD PTR _is$[ebp+4]
  000c0	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000c8	83 c0 08	 add	 eax, 8
  000cb	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN5@P_strint:

; 1162 : }

  000d0	52		 push	 edx
  000d1	8b cd		 mov	 ecx, ebp
  000d3	50		 push	 eax
  000d4	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@P_strint
  000da	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000df	58		 pop	 eax
  000e0	5a		 pop	 edx
  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx
  000e4	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000ea	3b ec		 cmp	 ebp, esp
  000ec	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
  000f5	8d 49 00	 npad	 3
$LN9@P_strint:
  000f8	01 00 00 00	 DD	 1
  000fc	00 00 00 00	 DD	 $LN8@P_strint
$LN8@P_strint:
  00100	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00104	04 00 00 00	 DD	 4
  00108	00 00 00 00	 DD	 $LN7@P_strint
$LN7@P_strint:
  0010c	65		 DB	 101			; 00000065H
  0010d	70		 DB	 112			; 00000070H
  0010e	74		 DB	 116			; 00000074H
  0010f	72		 DB	 114			; 00000072H
  00110	00		 DB	 0
_P_strint ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	__imp__strtod:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_strreal
_TEXT	SEGMENT
_eptr$ = -40						; size = 4
_fsu$ = -28						; size = 8
_i$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_P_strreal PROC						; COMDAT

; 1166 : {				      /* str -- endptr value */

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 14 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-236]
  00012	b9 3b 00 00 00	 mov	 ecx, 59			; 0000003bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1167 :     int i;
; 1168 :     union {
; 1169 :     	atl_real fs;
; 1170 : 	stackitem fss[Realsize];
; 1171 :     } fsu;
; 1172 :     char *eptr;
; 1173 : 
; 1174 :     Sl(1);

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0002d	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00033	c1 f8 03	 sar	 eax, 3
  00036	83 f8 01	 cmp	 eax, 1
  00039	7d 0a		 jge	 SHORT $LN7@P_strreal
  0003b	e8 00 00 00 00	 call	 _stakunder
  00040	e9 b2 00 00 00	 jmp	 $LN1@P_strreal
$LN7@P_strreal:

; 1175 :     So(2);

  00045	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004a	83 c0 10	 add	 eax, 16			; 00000010H
  0004d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00053	76 0a		 jbe	 SHORT $LN6@P_strreal
  00055	e8 00 00 00 00	 call	 _stakover
  0005a	e9 98 00 00 00	 jmp	 $LN1@P_strreal
$LN6@P_strreal:

; 1176 :     Hpc(S0);

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00064	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00067	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  0006d	72 10		 jb	 SHORT $LN4@P_strreal
  0006f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00074	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00077	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  0007d	72 07		 jb	 SHORT $LN5@P_strreal
$LN4@P_strreal:
  0007f	e8 00 00 00 00	 call	 _badpointer
  00084	eb 71		 jmp	 SHORT $LN1@P_strreal
$LN5@P_strreal:

; 1177 :     fsu.fs = strtod((char *) S0, &eptr);

  00086	8b f4		 mov	 esi, esp
  00088	8d 45 d8	 lea	 eax, DWORD PTR _eptr$[ebp]
  0008b	50		 push	 eax
  0008c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00092	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  00095	52		 push	 edx
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtod
  0009c	83 c4 08	 add	 esp, 8
  0009f	3b f4		 cmp	 esi, esp
  000a1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a6	dd 5d e4	 fstp	 QWORD PTR _fsu$[ebp]

; 1178 :     S0 = (stackitem) eptr;

  000a9	8b 45 d8	 mov	 eax, DWORD PTR _eptr$[ebp]
  000ac	99		 cdq
  000ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  000b3	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  000b6	89 51 fc	 mov	 DWORD PTR [ecx-4], edx

; 1179 :     for (i = 0; i < Realsize; i++) {

  000b9	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000c0	eb 09		 jmp	 SHORT $LN3@P_strreal
$LN2@P_strreal:
  000c2	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000c5	83 c0 01	 add	 eax, 1
  000c8	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN3@P_strreal:
  000cb	83 7d f4 01	 cmp	 DWORD PTR _i$[ebp], 1
  000cf	73 26		 jae	 SHORT $LN1@P_strreal

; 1180 :     	Push = fsu.fss[i];

  000d1	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000d6	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  000d9	8b 54 cd e4	 mov	 edx, DWORD PTR _fsu$[ebp+ecx*8]
  000dd	89 10		 mov	 DWORD PTR [eax], edx
  000df	8b 4c cd e8	 mov	 ecx, DWORD PTR _fsu$[ebp+ecx*8+4]
  000e3	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000e6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  000ec	83 c2 08	 add	 edx, 8
  000ef	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 1181 :     }

  000f5	eb cb		 jmp	 SHORT $LN2@P_strreal
$LN1@P_strreal:

; 1182 : }

  000f7	52		 push	 edx
  000f8	8b cd		 mov	 ecx, ebp
  000fa	50		 push	 eax
  000fb	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@P_strreal
  00101	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00106	58		 pop	 eax
  00107	5a		 pop	 edx
  00108	5f		 pop	 edi
  00109	5e		 pop	 esi
  0010a	5b		 pop	 ebx
  0010b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010e	33 cd		 xor	 ecx, ebp
  00110	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00115	81 c4 ec 00 00
	00		 add	 esp, 236		; 000000ecH
  0011b	3b ec		 cmp	 ebp, esp
  0011d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c3		 ret	 0
  00126	8b ff		 npad	 2
$LN13@P_strreal:
  00128	02 00 00 00	 DD	 2
  0012c	00 00 00 00	 DD	 $LN12@P_strreal
$LN12@P_strreal:
  00130	e4 ff ff ff	 DD	 -28			; ffffffe4H
  00134	08 00 00 00	 DD	 8
  00138	00 00 00 00	 DD	 $LN10@P_strreal
  0013c	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00140	04 00 00 00	 DD	 4
  00144	00 00 00 00	 DD	 $LN11@P_strreal
$LN11@P_strreal:
  00148	65		 DB	 101			; 00000065H
  00149	70		 DB	 112			; 00000070H
  0014a	74		 DB	 116			; 00000074H
  0014b	72		 DB	 114			; 00000072H
  0014c	00		 DB	 0
$LN10@P_strreal:
  0014d	66		 DB	 102			; 00000066H
  0014e	73		 DB	 115			; 00000073H
  0014f	75		 DB	 117			; 00000075H
  00150	00		 DB	 0
_P_strreal ENDP
_TEXT	ENDS
PUBLIC	??_C@_03JBELIGOI@?$CFg?5?$AA@			; `string'
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_03JBELIGOI@?$CFg?5?$AA@
CONST	SEGMENT
??_C@_03JBELIGOI@?$CFg?5?$AA@ DB '%g ', 00H		; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _P_flit
_TEXT	SEGMENT
_tr$83499 = -24						; size = 8
_i$ = -8						; size = 4
_P_flit	PROC						; COMDAT

; 1191 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1192 :     int i;
; 1193 : 
; 1194 :     So(Realsize);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	83 c0 08	 add	 eax, 8
  00026	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  0002c	76 0a		 jbe	 SHORT $LN5@P_flit
  0002e	e8 00 00 00 00	 call	 _stakover
  00033	e9 8a 00 00 00	 jmp	 $LN1@P_flit
$LN5@P_flit:

; 1195 : #ifdef TRACE
; 1196 :     if (atl_trace) {

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_trace
  0003d	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _atl_trace+4
  00043	74 34		 je	 SHORT $LN4@P_flit

; 1197 : 	atl_real tr;
; 1198 : 
; 1199 : 	V memcpy((char *) &tr, (char *) ip, sizeof(atl_real));

  00045	6a 08		 push	 8
  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  0004c	50		 push	 eax
  0004d	8d 4d e8	 lea	 ecx, DWORD PTR _tr$83499[ebp]
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 _memcpy
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1200 :         V printf("%g ", tr);

  00059	8b f4		 mov	 esi, esp
  0005b	83 ec 08	 sub	 esp, 8
  0005e	dd 45 e8	 fld	 QWORD PTR _tr$83499[ebp]
  00061	dd 1c 24	 fstp	 QWORD PTR [esp]
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_03JBELIGOI@?$CFg?5?$AA@
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00072	3b f4		 cmp	 esi, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@P_flit:

; 1201 :     }
; 1202 : #endif /* TRACE */
; 1203 :     for (i = 0; i < Realsize; i++) {

  00079	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00080	eb 09		 jmp	 SHORT $LN3@P_flit
$LN2@P_flit:
  00082	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00085	83 c0 01	 add	 eax, 1
  00088	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN3@P_flit:
  0008b	83 7d f8 01	 cmp	 DWORD PTR _i$[ebp], 1
  0008f	73 31		 jae	 SHORT $LN1@P_flit

; 1204 : 	Push = (stackitem) *ip++;

  00091	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  00096	8b 00		 mov	 eax, DWORD PTR [eax]
  00098	99		 cdq
  00099	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0009f	89 01		 mov	 DWORD PTR [ecx], eax
  000a1	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  000a4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  000aa	83 c2 08	 add	 edx, 8
  000ad	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
  000b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  000b8	83 c0 04	 add	 eax, 4
  000bb	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax

; 1205 :     }

  000c0	eb c0		 jmp	 SHORT $LN2@P_flit
$LN1@P_flit:

; 1206 : }

  000c2	52		 push	 edx
  000c3	8b cd		 mov	 ecx, ebp
  000c5	50		 push	 eax
  000c6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@P_flit
  000cc	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000d1	58		 pop	 eax
  000d2	5a		 pop	 edx
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	5b		 pop	 ebx
  000d6	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000dc	3b ec		 cmp	 ebp, esp
  000de	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
  000e7	90		 npad	 1
$LN10@P_flit:
  000e8	01 00 00 00	 DD	 1
  000ec	00 00 00 00	 DD	 $LN9@P_flit
$LN9@P_flit:
  000f0	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000f4	08 00 00 00	 DD	 8
  000f8	00 00 00 00	 DD	 $LN8@P_flit
$LN8@P_flit:
  000fc	74		 DB	 116			; 00000074H
  000fd	72		 DB	 114			; 00000072H
  000fe	00		 DB	 0
_P_flit	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_fplus
_TEXT	SEGMENT
_P_fplus PROC						; COMDAT

; 1209 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1210 :     Sl(2 * Realsize);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	73 07		 jae	 SHORT $LN1@P_fplus
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 27		 jmp	 SHORT $LN2@P_fplus
$LN1@P_fplus:

; 1211 :     SREAL1(REAL1 + REAL0);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00043	dd 40 f0	 fld	 QWORD PTR [eax-16]
  00046	dc 41 f8	 fadd	 QWORD PTR [ecx-8]
  00049	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0004f	dd 5a f0	 fstp	 QWORD PTR [edx-16]

; 1212 :     Realpop;

  00052	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00057	83 e8 08	 sub	 eax, 8
  0005a	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_fplus:

; 1213 : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00068	3b ec		 cmp	 ebp, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_P_fplus ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_fminus
_TEXT	SEGMENT
_P_fminus PROC						; COMDAT

; 1216 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1217 :     Sl(2 * Realsize);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	73 07		 jae	 SHORT $LN1@P_fminus
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 27		 jmp	 SHORT $LN2@P_fminus
$LN1@P_fminus:

; 1218 :     SREAL1(REAL1 - REAL0);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00043	dd 40 f0	 fld	 QWORD PTR [eax-16]
  00046	dc 61 f8	 fsub	 QWORD PTR [ecx-8]
  00049	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0004f	dd 5a f0	 fstp	 QWORD PTR [edx-16]

; 1219 :     Realpop;

  00052	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00057	83 e8 08	 sub	 eax, 8
  0005a	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_fminus:

; 1220 : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00068	3b ec		 cmp	 ebp, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_P_fminus ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_ftimes
_TEXT	SEGMENT
_P_ftimes PROC						; COMDAT

; 1223 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1224 :     Sl(2 * Realsize);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	73 07		 jae	 SHORT $LN1@P_ftimes
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 27		 jmp	 SHORT $LN2@P_ftimes
$LN1@P_ftimes:

; 1225 :     SREAL1(REAL1 * REAL0);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00043	dd 40 f0	 fld	 QWORD PTR [eax-16]
  00046	dc 49 f8	 fmul	 QWORD PTR [ecx-8]
  00049	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0004f	dd 5a f0	 fstp	 QWORD PTR [edx-16]

; 1226 :     Realpop;

  00052	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00057	83 e8 08	 sub	 eax, 8
  0005a	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_ftimes:

; 1227 : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00068	3b ec		 cmp	 ebp, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_P_ftimes ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _P_fdiv
_TEXT	SEGMENT
_P_fdiv	PROC						; COMDAT

; 1230 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1231 :     Sl(2 * Realsize);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	73 07		 jae	 SHORT $LN2@P_fdiv
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 41		 jmp	 SHORT $LN3@P_fdiv
$LN2@P_fdiv:

; 1232 : #ifndef NOMEMCHECK
; 1233 :     if (REAL0 == 0.0) {

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	dd 40 f8	 fld	 QWORD PTR [eax-8]
  00040	d9 ee		 fldz
  00042	da e9		 fucompp
  00044	df e0		 fnstsw	 ax
  00046	f6 c4 44	 test	 ah, 68			; 00000044H
  00049	7a 07		 jp	 SHORT $LN1@P_fdiv

; 1234 : 	divzero();

  0004b	e8 00 00 00 00	 call	 _divzero

; 1235 : 	return;

  00050	eb 27		 jmp	 SHORT $LN3@P_fdiv
$LN1@P_fdiv:

; 1236 :     }
; 1237 : #endif /* NOMEMCHECK */
; 1238 :     SREAL1(REAL1 / REAL0);

  00052	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00057	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0005d	dd 40 f0	 fld	 QWORD PTR [eax-16]
  00060	dc 71 f8	 fdiv	 QWORD PTR [ecx-8]
  00063	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00069	dd 5a f0	 fstp	 QWORD PTR [edx-16]

; 1239 :     Realpop;

  0006c	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00071	83 e8 08	 sub	 eax, 8
  00074	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN3@P_fdiv:

; 1240 : }

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00082	3b ec		 cmp	 ebp, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
_P_fdiv	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_fmin
_TEXT	SEGMENT
tv77 = -200						; size = 8
_P_fmin	PROC						; COMDAT

; 1243 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1244 :     Sl(2 * Realsize);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	73 07		 jae	 SHORT $LN1@P_fmin
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 53		 jmp	 SHORT $LN2@P_fmin
$LN1@P_fmin:

; 1245 :     SREAL1(min(REAL1, REAL0));

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	dd 40 f0	 fld	 QWORD PTR [eax-16]
  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00046	dc 59 f8	 fcomp	 QWORD PTR [ecx-8]
  00049	df e0		 fnstsw	 ax
  0004b	f6 c4 41	 test	 ah, 65			; 00000041H
  0004e	7a 11		 jp	 SHORT $LN4@P_fmin
  00050	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00056	dd 42 f0	 fld	 QWORD PTR [edx-16]
  00059	dd 9d 38 ff ff
	ff		 fstp	 QWORD PTR tv77[ebp]
  0005f	eb 0e		 jmp	 SHORT $LN5@P_fmin
$LN4@P_fmin:
  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00066	dd 40 f8	 fld	 QWORD PTR [eax-8]
  00069	dd 9d 38 ff ff
	ff		 fstp	 QWORD PTR tv77[ebp]
$LN5@P_fmin:
  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00075	dd 85 38 ff ff
	ff		 fld	 QWORD PTR tv77[ebp]
  0007b	dd 59 f0	 fstp	 QWORD PTR [ecx-16]

; 1246 :     Realpop;

  0007e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00083	83 e8 08	 sub	 eax, 8
  00086	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_fmin:

; 1247 : }

  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00094	3b ec		 cmp	 ebp, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
_P_fmin	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_fmax
_TEXT	SEGMENT
tv77 = -200						; size = 8
_P_fmax	PROC						; COMDAT

; 1250 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1251 :     Sl(2 * Realsize);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	73 07		 jae	 SHORT $LN1@P_fmax
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 53		 jmp	 SHORT $LN2@P_fmax
$LN1@P_fmax:

; 1252 :     SREAL1(max(REAL1, REAL0));

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	dd 40 f0	 fld	 QWORD PTR [eax-16]
  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00046	dc 59 f8	 fcomp	 QWORD PTR [ecx-8]
  00049	df e0		 fnstsw	 ax
  0004b	f6 c4 41	 test	 ah, 65			; 00000041H
  0004e	75 11		 jne	 SHORT $LN4@P_fmax
  00050	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00056	dd 42 f0	 fld	 QWORD PTR [edx-16]
  00059	dd 9d 38 ff ff
	ff		 fstp	 QWORD PTR tv77[ebp]
  0005f	eb 0e		 jmp	 SHORT $LN5@P_fmax
$LN4@P_fmax:
  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00066	dd 40 f8	 fld	 QWORD PTR [eax-8]
  00069	dd 9d 38 ff ff
	ff		 fstp	 QWORD PTR tv77[ebp]
$LN5@P_fmax:
  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00075	dd 85 38 ff ff
	ff		 fld	 QWORD PTR tv77[ebp]
  0007b	dd 59 f0	 fstp	 QWORD PTR [ecx-16]

; 1253 :     Realpop;

  0007e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00083	83 e8 08	 sub	 eax, 8
  00086	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_fmax:

; 1254 : }

  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00094	3b ec		 cmp	 ebp, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
_P_fmax	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_fneg
_TEXT	SEGMENT
_P_fneg	PROC						; COMDAT

; 1257 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1258 :     Sl(Realsize);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	73 07		 jae	 SHORT $LN1@P_fneg
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 13		 jmp	 SHORT $LN2@P_fneg
$LN1@P_fneg:

; 1259 :     SREAL0(- REAL0);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	dd 40 f8	 fld	 QWORD PTR [eax-8]
  00040	d9 e0		 fchs
  00042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00048	dd 59 f8	 fstp	 QWORD PTR [ecx-8]
$LN2@P_fneg:

; 1260 : }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00054	3b ec		 cmp	 ebp, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
_P_fneg	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_fabs
_TEXT	SEGMENT
tv76 = -200						; size = 8
_P_fabs	PROC						; COMDAT

; 1263 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1264 :     Sl(Realsize);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	73 07		 jae	 SHORT $LN1@P_fabs
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 45		 jmp	 SHORT $LN2@P_fabs
$LN1@P_fabs:

; 1265 :     SREAL0(abs(REAL0));

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	dd 40 f8	 fld	 QWORD PTR [eax-8]
  00040	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  00046	df e0		 fnstsw	 ax
  00048	f6 c4 05	 test	 ah, 5
  0004b	7a 13		 jp	 SHORT $LN4@P_fabs
  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00053	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  00056	d9 e0		 fchs
  00058	dd 9d 38 ff ff
	ff		 fstp	 QWORD PTR tv76[ebp]
  0005e	eb 0f		 jmp	 SHORT $LN5@P_fabs
$LN4@P_fabs:
  00060	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00066	dd 42 f8	 fld	 QWORD PTR [edx-8]
  00069	dd 9d 38 ff ff
	ff		 fstp	 QWORD PTR tv76[ebp]
$LN5@P_fabs:
  0006f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00074	dd 85 38 ff ff
	ff		 fld	 QWORD PTR tv76[ebp]
  0007a	dd 58 f8	 fstp	 QWORD PTR [eax-8]
$LN2@P_fabs:

; 1266 : }

  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00086	3b ec		 cmp	 ebp, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
_P_fabs	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_fequal
_TEXT	SEGMENT
tv70 = -212						; size = 4
_t$ = -12						; size = 8
_P_fequal PROC						; COMDAT

; 1269 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00012	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1270 :     stackitem t;
; 1271 : 
; 1272 :     Sl(2 * Realsize);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	73 07		 jae	 SHORT $LN1@P_fequal
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 67		 jmp	 SHORT $LN2@P_fequal
$LN1@P_fequal:

; 1273 :     t = (REAL1 == REAL0) ? Truth : Falsity;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00043	dd 40 f0	 fld	 QWORD PTR [eax-16]
  00046	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  00049	da e9		 fucompp
  0004b	df e0		 fnstsw	 ax
  0004d	f6 c4 44	 test	 ah, 68			; 00000044H
  00050	7a 0c		 jp	 SHORT $LN4@P_fequal
  00052	c7 85 2c ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv70[ebp], -1
  0005c	eb 0a		 jmp	 SHORT $LN5@P_fequal
$LN4@P_fequal:
  0005e	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_fequal:
  00068	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0006e	99		 cdq
  0006f	89 45 f4	 mov	 DWORD PTR _t$[ebp], eax
  00072	89 55 f8	 mov	 DWORD PTR _t$[ebp+4], edx

; 1274 :     Realpop2;

  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0007a	83 e8 10	 sub	 eax, 16			; 00000010H
  0007d	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1275 :     Push = t;

  00082	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _t$[ebp]
  0008a	89 08		 mov	 DWORD PTR [eax], ecx
  0008c	8b 55 f8	 mov	 edx, DWORD PTR _t$[ebp+4]
  0008f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00092	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00097	83 c0 08	 add	 eax, 8
  0009a	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_fequal:

; 1276 : }

  0009f	5f		 pop	 edi
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
  000a2	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  000a8	3b ec		 cmp	 ebp, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
_P_fequal ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_funequal
_TEXT	SEGMENT
tv70 = -212						; size = 4
_t$ = -12						; size = 8
_P_funequal PROC					; COMDAT

; 1279 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00012	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1280 :     stackitem t;
; 1281 : 
; 1282 :     Sl(2 * Realsize);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	73 07		 jae	 SHORT $LN1@P_funequal
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 67		 jmp	 SHORT $LN2@P_funequal
$LN1@P_funequal:

; 1283 :     t = (REAL1 != REAL0) ? Truth : Falsity;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00043	dd 40 f0	 fld	 QWORD PTR [eax-16]
  00046	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  00049	da e9		 fucompp
  0004b	df e0		 fnstsw	 ax
  0004d	f6 c4 44	 test	 ah, 68			; 00000044H
  00050	7b 0c		 jnp	 SHORT $LN4@P_funequal
  00052	c7 85 2c ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv70[ebp], -1
  0005c	eb 0a		 jmp	 SHORT $LN5@P_funequal
$LN4@P_funequal:
  0005e	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_funequal:
  00068	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0006e	99		 cdq
  0006f	89 45 f4	 mov	 DWORD PTR _t$[ebp], eax
  00072	89 55 f8	 mov	 DWORD PTR _t$[ebp+4], edx

; 1284 :     Realpop2;

  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0007a	83 e8 10	 sub	 eax, 16			; 00000010H
  0007d	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1285 :     Push = t;

  00082	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _t$[ebp]
  0008a	89 08		 mov	 DWORD PTR [eax], ecx
  0008c	8b 55 f8	 mov	 edx, DWORD PTR _t$[ebp+4]
  0008f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00092	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00097	83 c0 08	 add	 eax, 8
  0009a	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_funequal:

; 1286 : }

  0009f	5f		 pop	 edi
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
  000a2	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  000a8	3b ec		 cmp	 ebp, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
_P_funequal ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_fgtr
_TEXT	SEGMENT
tv70 = -212						; size = 4
_t$ = -12						; size = 8
_P_fgtr	PROC						; COMDAT

; 1289 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00012	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1290 :     stackitem t;
; 1291 : 
; 1292 :     Sl(2 * Realsize);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	73 07		 jae	 SHORT $LN1@P_fgtr
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 65		 jmp	 SHORT $LN2@P_fgtr
$LN1@P_fgtr:

; 1293 :     t = (REAL1 > REAL0) ? Truth : Falsity;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00043	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  00046	dc 58 f0	 fcomp	 QWORD PTR [eax-16]
  00049	df e0		 fnstsw	 ax
  0004b	f6 c4 05	 test	 ah, 5
  0004e	7a 0c		 jp	 SHORT $LN4@P_fgtr
  00050	c7 85 2c ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv70[ebp], -1
  0005a	eb 0a		 jmp	 SHORT $LN5@P_fgtr
$LN4@P_fgtr:
  0005c	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_fgtr:
  00066	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0006c	99		 cdq
  0006d	89 45 f4	 mov	 DWORD PTR _t$[ebp], eax
  00070	89 55 f8	 mov	 DWORD PTR _t$[ebp+4], edx

; 1294 :     Realpop2;

  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00078	83 e8 10	 sub	 eax, 16			; 00000010H
  0007b	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1295 :     Push = t;

  00080	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00085	8b 4d f4	 mov	 ecx, DWORD PTR _t$[ebp]
  00088	89 08		 mov	 DWORD PTR [eax], ecx
  0008a	8b 55 f8	 mov	 edx, DWORD PTR _t$[ebp+4]
  0008d	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00090	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00095	83 c0 08	 add	 eax, 8
  00098	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_fgtr:

; 1296 : }

  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5b		 pop	 ebx
  000a0	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  000a6	3b ec		 cmp	 ebp, esp
  000a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
_P_fgtr	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_flss
_TEXT	SEGMENT
tv70 = -212						; size = 4
_t$ = -12						; size = 8
_P_flss	PROC						; COMDAT

; 1299 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00012	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1300 :     stackitem t;
; 1301 : 
; 1302 :     Sl(2 * Realsize);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	73 07		 jae	 SHORT $LN1@P_flss
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 65		 jmp	 SHORT $LN2@P_flss
$LN1@P_flss:

; 1303 :     t = (REAL1 < REAL0) ? Truth : Falsity;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00043	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  00046	dc 58 f0	 fcomp	 QWORD PTR [eax-16]
  00049	df e0		 fnstsw	 ax
  0004b	f6 c4 41	 test	 ah, 65			; 00000041H
  0004e	75 0c		 jne	 SHORT $LN4@P_flss
  00050	c7 85 2c ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv70[ebp], -1
  0005a	eb 0a		 jmp	 SHORT $LN5@P_flss
$LN4@P_flss:
  0005c	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_flss:
  00066	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0006c	99		 cdq
  0006d	89 45 f4	 mov	 DWORD PTR _t$[ebp], eax
  00070	89 55 f8	 mov	 DWORD PTR _t$[ebp+4], edx

; 1304 :     Realpop2;

  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00078	83 e8 10	 sub	 eax, 16			; 00000010H
  0007b	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1305 :     Push = t;

  00080	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00085	8b 4d f4	 mov	 ecx, DWORD PTR _t$[ebp]
  00088	89 08		 mov	 DWORD PTR [eax], ecx
  0008a	8b 55 f8	 mov	 edx, DWORD PTR _t$[ebp+4]
  0008d	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00090	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00095	83 c0 08	 add	 eax, 8
  00098	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_flss:

; 1306 : }

  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5b		 pop	 ebx
  000a0	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  000a6	3b ec		 cmp	 ebp, esp
  000a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
_P_flss	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_fgeq
_TEXT	SEGMENT
tv70 = -212						; size = 4
_t$ = -12						; size = 8
_P_fgeq	PROC						; COMDAT

; 1309 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00012	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1310 :     stackitem t;
; 1311 : 
; 1312 :     Sl(2 * Realsize);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	73 07		 jae	 SHORT $LN1@P_fgeq
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 65		 jmp	 SHORT $LN2@P_fgeq
$LN1@P_fgeq:

; 1313 :     t = (REAL1 >= REAL0) ? Truth : Falsity;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00043	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  00046	dc 58 f0	 fcomp	 QWORD PTR [eax-16]
  00049	df e0		 fnstsw	 ax
  0004b	f6 c4 41	 test	 ah, 65			; 00000041H
  0004e	7a 0c		 jp	 SHORT $LN4@P_fgeq
  00050	c7 85 2c ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv70[ebp], -1
  0005a	eb 0a		 jmp	 SHORT $LN5@P_fgeq
$LN4@P_fgeq:
  0005c	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_fgeq:
  00066	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0006c	99		 cdq
  0006d	89 45 f4	 mov	 DWORD PTR _t$[ebp], eax
  00070	89 55 f8	 mov	 DWORD PTR _t$[ebp+4], edx

; 1314 :     Realpop2;

  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00078	83 e8 10	 sub	 eax, 16			; 00000010H
  0007b	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1315 :     Push = t;

  00080	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00085	8b 4d f4	 mov	 ecx, DWORD PTR _t$[ebp]
  00088	89 08		 mov	 DWORD PTR [eax], ecx
  0008a	8b 55 f8	 mov	 edx, DWORD PTR _t$[ebp+4]
  0008d	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00090	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00095	83 c0 08	 add	 eax, 8
  00098	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_fgeq:

; 1316 : }

  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5b		 pop	 ebx
  000a0	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  000a6	3b ec		 cmp	 ebp, esp
  000a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
_P_fgeq	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_fleq
_TEXT	SEGMENT
tv70 = -212						; size = 4
_t$ = -12						; size = 8
_P_fleq	PROC						; COMDAT

; 1319 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00012	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1320 :     stackitem t;
; 1321 : 
; 1322 :     Sl(2 * Realsize);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	73 07		 jae	 SHORT $LN1@P_fleq
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 65		 jmp	 SHORT $LN2@P_fleq
$LN1@P_fleq:

; 1323 :     t = (REAL1 <= REAL0) ? Truth : Falsity;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00043	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  00046	dc 58 f0	 fcomp	 QWORD PTR [eax-16]
  00049	df e0		 fnstsw	 ax
  0004b	f6 c4 01	 test	 ah, 1
  0004e	75 0c		 jne	 SHORT $LN4@P_fleq
  00050	c7 85 2c ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv70[ebp], -1
  0005a	eb 0a		 jmp	 SHORT $LN5@P_fleq
$LN4@P_fleq:
  0005c	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_fleq:
  00066	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0006c	99		 cdq
  0006d	89 45 f4	 mov	 DWORD PTR _t$[ebp], eax
  00070	89 55 f8	 mov	 DWORD PTR _t$[ebp+4], edx

; 1324 :     Realpop2;

  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00078	83 e8 10	 sub	 eax, 16			; 00000010H
  0007b	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1325 :     Push = t;

  00080	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00085	8b 4d f4	 mov	 ecx, DWORD PTR _t$[ebp]
  00088	89 08		 mov	 DWORD PTR [eax], ecx
  0008a	8b 55 f8	 mov	 edx, DWORD PTR _t$[ebp+4]
  0008d	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00090	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00095	83 c0 08	 add	 eax, 8
  00098	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_fleq:

; 1326 : }

  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5b		 pop	 ebx
  000a0	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  000a6	3b ec		 cmp	 ebp, esp
  000a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
_P_fleq	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_fdot
_TEXT	SEGMENT
_P_fdot	PROC						; COMDAT

; 1329 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1330 :     Sl(Realsize);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	73 07		 jae	 SHORT $LN1@P_fdot
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 32		 jmp	 SHORT $LN2@P_fdot
$LN1@P_fdot:

; 1331 :     V printf("%g ", REAL0);

  00038	8b f4		 mov	 esi, esp
  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003f	83 ec 08	 sub	 esp, 8
  00042	dd 40 f8	 fld	 QWORD PTR [eax-8]
  00045	dd 1c 24	 fstp	 QWORD PTR [esp]
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_03JBELIGOI@?$CFg?5?$AA@
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	3b f4		 cmp	 esi, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1332 :     Realpop;

  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00062	83 e8 08	 sub	 eax, 8
  00065	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_fdot:

; 1333 : }

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
_P_fdot	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_float
_TEXT	SEGMENT
_r$ = -12						; size = 8
_P_float PROC						; COMDAT

; 1336 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1337 :     atl_real r;
; 1338 : 
; 1339 :     Sl(1)

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN2@P_float
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 34		 jmp	 SHORT $LN3@P_float
$LN2@P_float:

; 1340 :     So(Realsize - 1);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00043	76 07		 jbe	 SHORT $LN1@P_float
  00045	e8 00 00 00 00	 call	 _stakover
  0004a	eb 20		 jmp	 SHORT $LN3@P_float
$LN1@P_float:

; 1341 :     r = S0;

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00051	df 68 f8	 fild	 QWORD PTR [eax-8]
  00054	dd 5d f4	 fstp	 QWORD PTR _r$[ebp]

; 1342 :     stk += Realsize - 1;

  00057	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0005c	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1343 :     SREAL0(r);

  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00066	dd 45 f4	 fld	 QWORD PTR _r$[ebp]
  00069	dd 58 f8	 fstp	 QWORD PTR [eax-8]
$LN3@P_float:

; 1344 : }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00075	3b ec		 cmp	 ebp, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
_P_float ENDP
_TEXT	ENDS
EXTRN	__ftol2_sse:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_fix
_TEXT	SEGMENT
_i$ = -12						; size = 8
_P_fix	PROC						; COMDAT

; 1347 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1348 :     stackitem i;
; 1349 : 
; 1350 :     Sl(Realsize);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	73 07		 jae	 SHORT $LN1@P_fix
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 3e		 jmp	 SHORT $LN2@P_fix
$LN1@P_fix:

; 1351 :     i = (int) REAL0;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	dd 40 f8	 fld	 QWORD PTR [eax-8]
  00040	e8 00 00 00 00	 call	 __ftol2_sse
  00045	99		 cdq
  00046	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
  00049	89 55 f8	 mov	 DWORD PTR _i$[ebp+4], edx

; 1352 :     Realpop;

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00051	83 e8 08	 sub	 eax, 8
  00054	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1353 :     Push = i;

  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0005e	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00061	89 08		 mov	 DWORD PTR [eax], ecx
  00063	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp+4]
  00066	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00069	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0006e	83 c0 08	 add	 eax, 8
  00071	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_fix:

; 1354 : }

  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0007f	3b ec		 cmp	 ebp, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
_P_fix	ENDP
_TEXT	ENDS
EXTRN	_acos:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_acos
_TEXT	SEGMENT
_P_acos	PROC						; COMDAT

; 1361 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1362 :     Mathfunc(acos);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	73 07		 jae	 SHORT $LN1@P_acos
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 1f		 jmp	 SHORT $LN2@P_acos
$LN1@P_acos:
  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	83 ec 08	 sub	 esp, 8
  00040	dd 40 f8	 fld	 QWORD PTR [eax-8]
  00043	dd 1c 24	 fstp	 QWORD PTR [esp]
  00046	e8 00 00 00 00	 call	 _acos
  0004b	83 c4 08	 add	 esp, 8
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00054	dd 59 f8	 fstp	 QWORD PTR [ecx-8]
$LN2@P_acos:

; 1363 : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_P_acos	ENDP
_TEXT	ENDS
EXTRN	_asin:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_asin
_TEXT	SEGMENT
_P_asin	PROC						; COMDAT

; 1366 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1367 :     Mathfunc(asin);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	73 07		 jae	 SHORT $LN1@P_asin
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 1f		 jmp	 SHORT $LN2@P_asin
$LN1@P_asin:
  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	83 ec 08	 sub	 esp, 8
  00040	dd 40 f8	 fld	 QWORD PTR [eax-8]
  00043	dd 1c 24	 fstp	 QWORD PTR [esp]
  00046	e8 00 00 00 00	 call	 _asin
  0004b	83 c4 08	 add	 esp, 8
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00054	dd 59 f8	 fstp	 QWORD PTR [ecx-8]
$LN2@P_asin:

; 1368 : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_P_asin	ENDP
_TEXT	ENDS
EXTRN	_atan:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_atan
_TEXT	SEGMENT
_P_atan	PROC						; COMDAT

; 1371 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1372 :     Mathfunc(atan);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	73 07		 jae	 SHORT $LN1@P_atan
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 1f		 jmp	 SHORT $LN2@P_atan
$LN1@P_atan:
  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	83 ec 08	 sub	 esp, 8
  00040	dd 40 f8	 fld	 QWORD PTR [eax-8]
  00043	dd 1c 24	 fstp	 QWORD PTR [esp]
  00046	e8 00 00 00 00	 call	 _atan
  0004b	83 c4 08	 add	 esp, 8
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00054	dd 59 f8	 fstp	 QWORD PTR [ecx-8]
$LN2@P_atan:

; 1373 : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_P_atan	ENDP
_TEXT	ENDS
EXTRN	_atan2:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_atan2
_TEXT	SEGMENT
_P_atan2 PROC						; COMDAT

; 1376 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1377 :     Sl(2 * Realsize);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	73 07		 jae	 SHORT $LN1@P_atan2@2
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 3b		 jmp	 SHORT $LN2@P_atan2@2
$LN1@P_atan2@2:

; 1378 :     SREAL1(atan2(REAL1, REAL0));

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	83 ec 08	 sub	 esp, 8
  00040	dd 40 f8	 fld	 QWORD PTR [eax-8]
  00043	dd 1c 24	 fstp	 QWORD PTR [esp]
  00046	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0004c	83 ec 08	 sub	 esp, 8
  0004f	dd 41 f0	 fld	 QWORD PTR [ecx-16]
  00052	dd 1c 24	 fstp	 QWORD PTR [esp]
  00055	e8 00 00 00 00	 call	 _atan2
  0005a	83 c4 10	 add	 esp, 16			; 00000010H
  0005d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00063	dd 5a f0	 fstp	 QWORD PTR [edx-16]

; 1379 :     Realpop;

  00066	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0006b	83 e8 08	 sub	 eax, 8
  0006e	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_atan2@2:

; 1380 : }

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007c	3b ec		 cmp	 ebp, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
_P_atan2 ENDP
_TEXT	ENDS
EXTRN	_cos:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_cos
_TEXT	SEGMENT
_P_cos	PROC						; COMDAT

; 1383 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1384 :     Mathfunc(cos);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	73 07		 jae	 SHORT $LN1@P_cos
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 1f		 jmp	 SHORT $LN2@P_cos
$LN1@P_cos:
  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	83 ec 08	 sub	 esp, 8
  00040	dd 40 f8	 fld	 QWORD PTR [eax-8]
  00043	dd 1c 24	 fstp	 QWORD PTR [esp]
  00046	e8 00 00 00 00	 call	 _cos
  0004b	83 c4 08	 add	 esp, 8
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00054	dd 59 f8	 fstp	 QWORD PTR [ecx-8]
$LN2@P_cos:

; 1385 : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_P_cos	ENDP
_TEXT	ENDS
EXTRN	_exp:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_exp
_TEXT	SEGMENT
_P_exp	PROC						; COMDAT

; 1388 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1389 :     Mathfunc(exp);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	73 07		 jae	 SHORT $LN1@P_exp
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 1f		 jmp	 SHORT $LN2@P_exp
$LN1@P_exp:
  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	83 ec 08	 sub	 esp, 8
  00040	dd 40 f8	 fld	 QWORD PTR [eax-8]
  00043	dd 1c 24	 fstp	 QWORD PTR [esp]
  00046	e8 00 00 00 00	 call	 _exp
  0004b	83 c4 08	 add	 esp, 8
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00054	dd 59 f8	 fstp	 QWORD PTR [ecx-8]
$LN2@P_exp:

; 1390 : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_P_exp	ENDP
_TEXT	ENDS
EXTRN	_log:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_log
_TEXT	SEGMENT
_P_log	PROC						; COMDAT

; 1393 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1394 :     Mathfunc(log);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	73 07		 jae	 SHORT $LN1@P_log
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 1f		 jmp	 SHORT $LN2@P_log
$LN1@P_log:
  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	83 ec 08	 sub	 esp, 8
  00040	dd 40 f8	 fld	 QWORD PTR [eax-8]
  00043	dd 1c 24	 fstp	 QWORD PTR [esp]
  00046	e8 00 00 00 00	 call	 _log
  0004b	83 c4 08	 add	 esp, 8
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00054	dd 59 f8	 fstp	 QWORD PTR [ecx-8]
$LN2@P_log:

; 1395 : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_P_log	ENDP
_TEXT	ENDS
EXTRN	_pow:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_pow
_TEXT	SEGMENT
_P_pow	PROC						; COMDAT

; 1398 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1399 :     Sl(2 * Realsize);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	73 07		 jae	 SHORT $LN1@P_pow
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 3b		 jmp	 SHORT $LN2@P_pow
$LN1@P_pow:

; 1400 :     SREAL1(pow(REAL1, REAL0));

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	83 ec 08	 sub	 esp, 8
  00040	dd 40 f8	 fld	 QWORD PTR [eax-8]
  00043	dd 1c 24	 fstp	 QWORD PTR [esp]
  00046	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0004c	83 ec 08	 sub	 esp, 8
  0004f	dd 41 f0	 fld	 QWORD PTR [ecx-16]
  00052	dd 1c 24	 fstp	 QWORD PTR [esp]
  00055	e8 00 00 00 00	 call	 _pow
  0005a	83 c4 10	 add	 esp, 16			; 00000010H
  0005d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00063	dd 5a f0	 fstp	 QWORD PTR [edx-16]

; 1401 :     Realpop;

  00066	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0006b	83 e8 08	 sub	 eax, 8
  0006e	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_pow:

; 1402 : }

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007c	3b ec		 cmp	 ebp, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
_P_pow	ENDP
_TEXT	ENDS
EXTRN	_sin:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_sin
_TEXT	SEGMENT
_P_sin	PROC						; COMDAT

; 1405 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1406 :     Mathfunc(sin);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	73 07		 jae	 SHORT $LN1@P_sin
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 1f		 jmp	 SHORT $LN2@P_sin
$LN1@P_sin:
  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	83 ec 08	 sub	 esp, 8
  00040	dd 40 f8	 fld	 QWORD PTR [eax-8]
  00043	dd 1c 24	 fstp	 QWORD PTR [esp]
  00046	e8 00 00 00 00	 call	 _sin
  0004b	83 c4 08	 add	 esp, 8
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00054	dd 59 f8	 fstp	 QWORD PTR [ecx-8]
$LN2@P_sin:

; 1407 : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_P_sin	ENDP
_TEXT	ENDS
EXTRN	_sqrt:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_sqrt
_TEXT	SEGMENT
_P_sqrt	PROC						; COMDAT

; 1410 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1411 :     Mathfunc(sqrt);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	73 07		 jae	 SHORT $LN1@P_sqrt
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 1f		 jmp	 SHORT $LN2@P_sqrt
$LN1@P_sqrt:
  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	83 ec 08	 sub	 esp, 8
  00040	dd 40 f8	 fld	 QWORD PTR [eax-8]
  00043	dd 1c 24	 fstp	 QWORD PTR [esp]
  00046	e8 00 00 00 00	 call	 _sqrt
  0004b	83 c4 08	 add	 esp, 8
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00054	dd 59 f8	 fstp	 QWORD PTR [ecx-8]
$LN2@P_sqrt:

; 1412 : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_P_sqrt	ENDP
_TEXT	ENDS
EXTRN	_tan:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_tan
_TEXT	SEGMENT
_P_tan	PROC						; COMDAT

; 1415 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1416 :     Mathfunc(tan);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	73 07		 jae	 SHORT $LN1@P_tan
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 1f		 jmp	 SHORT $LN2@P_tan
$LN1@P_tan:
  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	83 ec 08	 sub	 esp, 8
  00040	dd 40 f8	 fld	 QWORD PTR [eax-8]
  00043	dd 1c 24	 fstp	 QWORD PTR [esp]
  00046	e8 00 00 00 00	 call	 _tan
  0004b	83 c4 08	 add	 esp, 8
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00054	dd 59 f8	 fstp	 QWORD PTR [ecx-8]
$LN2@P_tan:

; 1417 : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_P_tan	ENDP
_TEXT	ENDS
PUBLIC	??_C@_04JLFGKHHD@?$CFld?5?$AA@			; `string'
PUBLIC	??_C@_03HKPIJKPH@?$CFlX?$AA@			; `string'
;	COMDAT ??_C@_04JLFGKHHD@?$CFld?5?$AA@
CONST	SEGMENT
??_C@_04JLFGKHHD@?$CFld?5?$AA@ DB '%ld ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HKPIJKPH@?$CFlX?$AA@
CONST	SEGMENT
??_C@_03HKPIJKPH@?$CFlX?$AA@ DB '%lX', 00H		; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _P_dot
_TEXT	SEGMENT
tv71 = -196						; size = 4
_P_dot	PROC						; COMDAT

; 1427 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1428 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_dot
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 52		 jmp	 SHORT $LN2@P_dot
$LN1@P_dot:

; 1429 :     V printf(base == 16 ? "%lX" : "%ld ", S0);

  00038	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR _base, 16	; 00000010H
  0003f	75 0c		 jne	 SHORT $LN4@P_dot
  00041	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], OFFSET ??_C@_03HKPIJKPH@?$CFlX?$AA@
  0004b	eb 0a		 jmp	 SHORT $LN5@P_dot
$LN4@P_dot:
  0004d	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], OFFSET ??_C@_04JLFGKHHD@?$CFld?5?$AA@
$LN5@P_dot:
  00057	8b f4		 mov	 esi, esp
  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0005e	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00061	51		 push	 ecx
  00062	8b 50 f8	 mov	 edx, DWORD PTR [eax-8]
  00065	52		 push	 edx
  00066	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv71[ebp]
  0006c	50		 push	 eax
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	3b f4		 cmp	 esi, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1430 :     Pop;

  0007d	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00082	83 e8 08	 sub	 eax, 8
  00085	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_dot:

; 1431 : }

  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
  0008d	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00093	3b ec		 cmp	 ebp, esp
  00095	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
_P_dot	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_question
_TEXT	SEGMENT
tv78 = -196						; size = 4
_P_question PROC					; COMDAT

; 1434 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1435 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN3@P_question
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 7b		 jmp	 SHORT $LN4@P_question
$LN3@P_question:

; 1436 :     Hpc(S0);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00046	72 10		 jb	 SHORT $LN1@P_question
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00050	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00056	72 07		 jb	 SHORT $LN2@P_question
$LN1@P_question:
  00058	e8 00 00 00 00	 call	 _badpointer
  0005d	eb 54		 jmp	 SHORT $LN4@P_question
$LN2@P_question:

; 1437 :     V printf(base == 16 ? "%lX" : "%ld ", *((stackitem *) S0));

  0005f	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR _base, 16	; 00000010H
  00066	75 0c		 jne	 SHORT $LN6@P_question
  00068	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv78[ebp], OFFSET ??_C@_03HKPIJKPH@?$CFlX?$AA@
  00072	eb 0a		 jmp	 SHORT $LN7@P_question
$LN6@P_question:
  00074	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv78[ebp], OFFSET ??_C@_04JLFGKHHD@?$CFld?5?$AA@
$LN7@P_question:
  0007e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00083	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00086	8b f4		 mov	 esi, esp
  00088	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0008b	52		 push	 edx
  0008c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008e	50		 push	 eax
  0008f	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv78[ebp]
  00095	51		 push	 ecx
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009f	3b f4		 cmp	 esi, esp
  000a1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1438 :     Pop;

  000a6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000ab	83 e8 08	 sub	 eax, 8
  000ae	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN4@P_question:

; 1439 : }

  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi
  000b5	5b		 pop	 ebx
  000b6	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  000bc	3b ec		 cmp	 ebp, esp
  000be	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c3		 ret	 0
_P_question ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_cr
_TEXT	SEGMENT
_P_cr	PROC						; COMDAT

; 1442 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1443 :     V printf("\n");

  0001e	8b f4		 mov	 esi, esp
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b f4		 cmp	 esi, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1444 : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_P_cr	ENDP
_TEXT	ENDS
PUBLIC	??_C@_06INGCOLCM@Empty?4?$AA@			; `string'
PUBLIC	??_C@_07BEDGMFAP@Stack?3?5?$AA@			; `string'
_BSS	SEGMENT
_stackbot DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_06INGCOLCM@Empty?4?$AA@
CONST	SEGMENT
??_C@_06INGCOLCM@Empty?4?$AA@ DB 'Empty.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BEDGMFAP@Stack?3?5?$AA@
CONST	SEGMENT
??_C@_07BEDGMFAP@Stack?3?5?$AA@ DB 'Stack: ', 00H	; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _P_dots
_TEXT	SEGMENT
tv72 = -208						; size = 4
_tsp$ = -8						; size = 4
_P_dots	PROC						; COMDAT

; 1447 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1448 :     stackitem *tsp;
; 1449 : 
; 1450 :     V printf("Stack: ");

  0001e	8b f4		 mov	 esi, esp
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_07BEDGMFAP@Stack?3?5?$AA@
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b f4		 cmp	 esi, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1451 :     if (stk == stackbot)

  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stackbot
  00040	75 19		 jne	 SHORT $LN5@P_dots

; 1452 :         V printf("Empty.");

  00042	8b f4		 mov	 esi, esp
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_06INGCOLCM@Empty?4?$AA@
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0004f	83 c4 04	 add	 esp, 4
  00052	3b f4		 cmp	 esi, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1453 :     else {

  00059	eb 62		 jmp	 SHORT $LN6@P_dots
$LN5@P_dots:

; 1454 : 	for (tsp = stack; tsp < stk; tsp++) {

  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stack
  00060	89 45 f8	 mov	 DWORD PTR _tsp$[ebp], eax
  00063	eb 09		 jmp	 SHORT $LN3@P_dots
$LN2@P_dots:
  00065	8b 45 f8	 mov	 eax, DWORD PTR _tsp$[ebp]
  00068	83 c0 08	 add	 eax, 8
  0006b	89 45 f8	 mov	 DWORD PTR _tsp$[ebp], eax
$LN3@P_dots:
  0006e	8b 45 f8	 mov	 eax, DWORD PTR _tsp$[ebp]
  00071	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stk
  00077	73 44		 jae	 SHORT $LN6@P_dots

; 1455 :             V printf(base == 16 ? "%lX" : "%ld ", *tsp);

  00079	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR _base, 16	; 00000010H
  00080	75 0c		 jne	 SHORT $LN8@P_dots
  00082	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv72[ebp], OFFSET ??_C@_03HKPIJKPH@?$CFlX?$AA@
  0008c	eb 0a		 jmp	 SHORT $LN9@P_dots
$LN8@P_dots:
  0008e	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv72[ebp], OFFSET ??_C@_04JLFGKHHD@?$CFld?5?$AA@
$LN9@P_dots:
  00098	8b f4		 mov	 esi, esp
  0009a	8b 45 f8	 mov	 eax, DWORD PTR _tsp$[ebp]
  0009d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a0	51		 push	 ecx
  000a1	8b 10		 mov	 edx, DWORD PTR [eax]
  000a3	52		 push	 edx
  000a4	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  000aa	50		 push	 eax
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b4	3b f4		 cmp	 esi, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1456 : 	}

  000bb	eb a8		 jmp	 SHORT $LN2@P_dots
$LN6@P_dots:

; 1457 :     }
; 1458 : }

  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000c6	3b ec		 cmp	 ebp, esp
  000c8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c3		 ret	 0
_P_dots	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_dotparen DQ	01H DUP (?)
; Function compile flags: /Odtp /RTCsu /ZI
_BSS	ENDS
;	COMDAT _P_dotquote
_TEXT	SEGMENT
tv69 = -196						; size = 4
_P_dotquote PROC					; COMDAT

; 1461 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1462 :     Compiling;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
  00029	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv69[ebp]
  0002f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv69[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	75 07		 jne	 SHORT $LN2@P_dotquote
  0003c	e8 00 00 00 00	 call	 _notcomp
  00041	eb 44		 jmp	 SHORT $LN3@P_dotquote
$LN2@P_dotquote:

; 1463 :     stringlit = True;		      /* Set string literal expected */

  00043	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _stringlit, 1

; 1464 :     Compconst(s_dotparen);	      /* Compile .( word */

  0004d	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00052	83 c0 08	 add	 eax, 8
  00055	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  0005b	76 07		 jbe	 SHORT $LN1@P_dotquote
  0005d	e8 00 00 00 00	 call	 _heapover
  00062	eb 23		 jmp	 SHORT $LN3@P_dotquote
$LN1@P_dotquote:
  00064	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00069	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_dotparen
  0006f	89 08		 mov	 DWORD PTR [eax], ecx
  00071	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_dotparen+4
  00077	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0007f	83 c0 08	 add	 eax, 8
  00082	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax
$LN3@P_dotquote:

; 1465 : }

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00090	3b ec		 cmp	 ebp, esp
  00092	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
_P_dotquote ENDP
_TEXT	ENDS
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _P_dotparen
_TEXT	SEGMENT
_P_dotparen PROC					; COMDAT

; 1468 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1469 :     if (ip == NULL) {		      /* If interpreting */

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ip, 0
  00025	75 0c		 jne	 SHORT $LN2@P_dotparen

; 1470 : 	stringlit = True;	      /* Set to print next string constant */

  00027	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _stringlit, 1

; 1471 :     } else {			      /* Otherwise, */

  00031	eb 36		 jmp	 SHORT $LN3@P_dotparen
$LN2@P_dotparen:

; 1472 :         V printf("%s", ((char *) ip) + 1); /* print string literal

  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  00038	83 c0 01	 add	 eax, 1
  0003b	8b f4		 mov	 esi, esp
  0003d	50		 push	 eax
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00049	83 c4 08	 add	 esp, 8
  0004c	3b f4		 cmp	 esi, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1473 : 					 in in-line code. */
; 1474 : 	Skipstring;		      /* And advance IP past it */

  00053	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  00058	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0005b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ip
  00061	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00064	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax
$LN3@P_dotparen:

; 1475 :     }
; 1476 : }

  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00072	3b ec		 cmp	 ebp, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_P_dotparen ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_type
_TEXT	SEGMENT
_P_type	PROC						; COMDAT

; 1479 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1480 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN3@P_type
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 54		 jmp	 SHORT $LN4@P_type
$LN3@P_type:

; 1481 :     Hpc(S0);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00046	72 10		 jb	 SHORT $LN1@P_type
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00050	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00056	72 07		 jb	 SHORT $LN2@P_type
$LN1@P_type:
  00058	e8 00 00 00 00	 call	 _badpointer
  0005d	eb 2d		 jmp	 SHORT $LN4@P_type
$LN2@P_type:

; 1482 :     V printf("%s", (char *) S0);

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00064	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00067	8b f4		 mov	 esi, esp
  00069	51		 push	 ecx
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00075	83 c4 08	 add	 esp, 8
  00078	3b f4		 cmp	 esi, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1483 :     Pop;

  0007f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00084	83 e8 08	 sub	 eax, 8
  00087	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN4@P_type:

; 1484 : }

  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00095	3b ec		 cmp	 ebp, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
_P_type	ENDP
_TEXT	ENDS
PUBLIC	??_C@_03ILJCGOLJ@?6?$CFs?$AA@			; `string'
;	COMDAT ??_C@_03ILJCGOLJ@?6?$CFs?$AA@
CONST	SEGMENT
??_C@_03ILJCGOLJ@?6?$CFs?$AA@ DB 0aH, '%s', 00H		; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _P_words
_TEXT	SEGMENT
_dw$ = -20						; size = 4
_key$ = -8						; size = 4
_P_words PROC						; COMDAT

; 1487 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1488 : #ifndef Keyhit
; 1489 :     int key = 0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _key$[ebp], 0

; 1490 : #endif
; 1491 :     dictword *dw = dict;

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  0002a	89 45 ec	 mov	 DWORD PTR _dw$[ebp], eax
$LN3@P_words:

; 1492 : 
; 1493 :     while (dw != NULL) {

  0002d	83 7d ec 00	 cmp	 DWORD PTR _dw$[ebp], 0
  00031	74 3c		 je	 SHORT $LN2@P_words

; 1494 : 
; 1495 :         V printf("\n%s", dw->wname + 1);

  00033	8b 45 ec	 mov	 eax, DWORD PTR _dw$[ebp]
  00036	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00039	83 c1 01	 add	 ecx, 1
  0003c	8b f4		 mov	 esi, esp
  0003e	51		 push	 ecx
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_03ILJCGOLJ@?6?$CFs?$AA@
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1496 : 	dw = dw->wnext;

  00054	8b 45 ec	 mov	 eax, DWORD PTR _dw$[ebp]
  00057	8b 08		 mov	 ecx, DWORD PTR [eax]
  00059	89 4d ec	 mov	 DWORD PTR _dw$[ebp], ecx

; 1497 : #ifdef Keyhit
; 1498 : 	if (kbquit()) {
; 1499 : 	    break;
; 1500 : 	}
; 1501 : #else
; 1502 :         /* If this system can't trap keystrokes, just stop the WORDS
; 1503 : 	   listing after 20 words. */
; 1504 : 	if (++key >= 20)

  0005c	8b 45 f8	 mov	 eax, DWORD PTR _key$[ebp]
  0005f	83 c0 01	 add	 eax, 1
  00062	89 45 f8	 mov	 DWORD PTR _key$[ebp], eax
  00065	83 7d f8 14	 cmp	 DWORD PTR _key$[ebp], 20 ; 00000014H
  00069	7c 02		 jl	 SHORT $LN1@P_words

; 1505 : 	    break;

  0006b	eb 02		 jmp	 SHORT $LN2@P_words
$LN1@P_words:

; 1506 : #endif
; 1507 :     }

  0006d	eb be		 jmp	 SHORT $LN3@P_words
$LN2@P_words:

; 1508 :     V printf("\n");

  0006f	8b f4		 mov	 esi, esp
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0007c	83 c4 04	 add	 esp, 4
  0007f	3b f4		 cmp	 esi, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1509 : }

  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx
  00089	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0008f	3b ec		 cmp	 ebp, esp
  00091	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
_P_words ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_file
_TEXT	SEGMENT
_P_file	PROC						; COMDAT

; 1515 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1516 :     Ho(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00023	83 c0 10	 add	 eax, 16			; 00000010H
  00026	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  0002c	76 07		 jbe	 SHORT $LN1@P_file
  0002e	e8 00 00 00 00	 call	 _heapover
  00033	eb 47		 jmp	 SHORT $LN2@P_file
$LN1@P_file:

; 1517 :     P_create(); 		      /* Create variable */

  00035	e8 00 00 00 00	 call	 _P_create

; 1518 :     Hstore = FileSent;		      /* Store file sentinel */

  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0003f	c7 00 9d df 1f
	83		 mov	 DWORD PTR [eax], -2095063139 ; 831fdf9dH
  00045	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  00052	83 c1 08	 add	 ecx, 8
  00055	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx

; 1519 :     Hstore = 0; 		      /* Mark file not open */

  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00060	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00066	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  00073	83 c1 08	 add	 ecx, 8
  00076	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx
$LN2@P_file:

; 1520 : }

  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00085	3b ec		 cmp	 ebp, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
_P_file	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@PBIJLHDC@?6Not?5a?5file?6?$AA@		; `string'
EXTRN	__imp__fopen:PROC
;	COMDAT ??_C@_0N@PBIJLHDC@?6Not?5a?5file?6?$AA@
CONST	SEGMENT
??_C@_0N@PBIJLHDC@?6Not?5a?5file?6?$AA@ DB 0aH, 'Not a file', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _P_fopen
_TEXT	SEGMENT
tv145 = -224						; size = 4
_stat$ = -24						; size = 8
_fd$ = -8						; size = 4
_P_fopen PROC						; COMDAT

; 1523 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00012	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1524 :     FILE *fd;
; 1525 :     stackitem stat;
; 1526 : 
; 1527 :     Sl(3);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 03	 cmp	 eax, 3
  0002f	7d 0a		 jge	 SHORT $LN10@P_fopen
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 53 01 00 00	 jmp	 $LN11@P_fopen
$LN10@P_fopen:

; 1528 :     Hpc(S2);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	8b 48 e8	 mov	 ecx, DWORD PTR [eax-24]
  00043	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00049	72 10		 jb	 SHORT $LN8@P_fopen
  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00050	8b 48 e8	 mov	 ecx, DWORD PTR [eax-24]
  00053	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00059	72 0a		 jb	 SHORT $LN9@P_fopen
$LN8@P_fopen:
  0005b	e8 00 00 00 00	 call	 _badpointer
  00060	e9 29 01 00 00	 jmp	 $LN11@P_fopen
$LN9@P_fopen:

; 1529 :     Hpc(S0);

  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0006a	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0006d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00073	72 10		 jb	 SHORT $LN6@P_fopen
  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0007a	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0007d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00083	72 0a		 jb	 SHORT $LN7@P_fopen
$LN6@P_fopen:
  00085	e8 00 00 00 00	 call	 _badpointer
  0008a	e9 ff 00 00 00	 jmp	 $LN11@P_fopen
$LN7@P_fopen:

; 1530 :     Isfile(S0);

  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00094	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00097	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  0009d	72 10		 jb	 SHORT $LN4@P_fopen
  0009f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000a4	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000a7	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  000ad	72 0a		 jb	 SHORT $LN5@P_fopen
$LN4@P_fopen:
  000af	e8 00 00 00 00	 call	 _badpointer
  000b4	e9 d5 00 00 00	 jmp	 $LN11@P_fopen
$LN5@P_fopen:
  000b9	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000be	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000c1	89 8d 20 ff ff
	ff		 mov	 DWORD PTR tv145[ebp], ecx
  000c7	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv145[ebp]
  000cd	81 3a 9d df 1f
	83		 cmp	 DWORD PTR [edx], -2095063139 ; 831fdf9dH
  000d3	75 0c		 jne	 SHORT $LN13@P_fopen
  000d5	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv145[ebp]
  000db	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000df	74 1c		 je	 SHORT $LN3@P_fopen
$LN13@P_fopen:
  000e1	8b f4		 mov	 esi, esp
  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PBIJLHDC@?6Not?5a?5file?6?$AA@
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000ee	83 c4 04	 add	 esp, 4
  000f1	3b f4		 cmp	 esi, esp
  000f3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f8	e9 91 00 00 00	 jmp	 $LN11@P_fopen
$LN3@P_fopen:

; 1531 :     fd = fopen((char *) S2, fopenmodes[S1]);

  000fd	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00102	6a 00		 push	 0
  00104	6a 04		 push	 4
  00106	8b 48 f4	 mov	 ecx, DWORD PTR [eax-12]
  00109	51		 push	 ecx
  0010a	8b 50 f0	 mov	 edx, DWORD PTR [eax-16]
  0010d	52		 push	 edx
  0010e	e8 00 00 00 00	 call	 __allmul
  00113	8b f4		 mov	 esi, esp
  00115	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _fopenmodes[eax]
  0011b	50		 push	 eax
  0011c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00122	8b 51 e8	 mov	 edx, DWORD PTR [ecx-24]
  00125	52		 push	 edx
  00126	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0012c	83 c4 08	 add	 esp, 8
  0012f	3b f4		 cmp	 esi, esp
  00131	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00136	89 45 f8	 mov	 DWORD PTR _fd$[ebp], eax

; 1532 :     if (fd == NULL) {

  00139	83 7d f8 00	 cmp	 DWORD PTR _fd$[ebp], 0
  0013d	75 10		 jne	 SHORT $LN2@P_fopen

; 1533 : 	stat = Falsity;

  0013f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _stat$[ebp], 0
  00146	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _stat$[ebp+4], 0

; 1534 :     } else {

  0014d	eb 21		 jmp	 SHORT $LN1@P_fopen
$LN2@P_fopen:

; 1535 : 	*(((stackitem *) S0) + 1) = (stackitem) fd;

  0014f	8b 45 f8	 mov	 eax, DWORD PTR _fd$[ebp]
  00152	99		 cdq
  00153	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00159	8b 49 f8	 mov	 ecx, DWORD PTR [ecx-8]
  0015c	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0015f	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 1536 : 	stat = Truth;

  00162	c7 45 e8 ff ff
	ff ff		 mov	 DWORD PTR _stat$[ebp], -1
  00169	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _stat$[ebp+4], -1
$LN1@P_fopen:

; 1537 :     }
; 1538 :     Pop2;

  00170	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00175	83 e8 10	 sub	 eax, 16			; 00000010H
  00178	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1539 :     S0 = stat;

  0017d	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00182	8b 4d e8	 mov	 ecx, DWORD PTR _stat$[ebp]
  00185	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  00188	8b 55 ec	 mov	 edx, DWORD PTR _stat$[ebp+4]
  0018b	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN11@P_fopen:

; 1540 : }

  0018e	5f		 pop	 edi
  0018f	5e		 pop	 esi
  00190	5b		 pop	 ebx
  00191	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  00197	3b ec		 cmp	 ebp, esp
  00199	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0019e	8b e5		 mov	 esp, ebp
  001a0	5d		 pop	 ebp
  001a1	c3		 ret	 0
_P_fopen ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@JACEKOJL@?6File?5not?5open?6?$AA@	; `string'
EXTRN	__imp__fclose:PROC
;	COMDAT ??_C@_0BA@JACEKOJL@?6File?5not?5open?6?$AA@
CONST	SEGMENT
??_C@_0BA@JACEKOJL@?6File?5not?5open?6?$AA@ DB 0aH, 'File not open', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _P_fclose
_TEXT	SEGMENT
tv136 = -196						; size = 4
_P_fclose PROC						; COMDAT

; 1543 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1544 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 0a		 jge	 SHORT $LN7@P_fclose
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 fd 00 00 00	 jmp	 $LN8@P_fclose
$LN7@P_fclose:

; 1545 :     Hpc(S0);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00043	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00049	72 10		 jb	 SHORT $LN5@P_fclose
  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00050	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00053	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00059	72 0a		 jb	 SHORT $LN6@P_fclose
$LN5@P_fclose:
  0005b	e8 00 00 00 00	 call	 _badpointer
  00060	e9 d3 00 00 00	 jmp	 $LN8@P_fclose
$LN6@P_fclose:

; 1546 :     Isfile(S0);

  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0006a	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0006d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00073	72 10		 jb	 SHORT $LN3@P_fclose
  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0007a	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0007d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00083	72 0a		 jb	 SHORT $LN4@P_fclose
$LN3@P_fclose:
  00085	e8 00 00 00 00	 call	 _badpointer
  0008a	e9 a9 00 00 00	 jmp	 $LN8@P_fclose
$LN4@P_fclose:
  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00094	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00097	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv136[ebp], ecx
  0009d	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv136[ebp]
  000a3	81 3a 9d df 1f
	83		 cmp	 DWORD PTR [edx], -2095063139 ; 831fdf9dH
  000a9	75 0c		 jne	 SHORT $LN10@P_fclose
  000ab	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv136[ebp]
  000b1	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000b5	74 19		 je	 SHORT $LN2@P_fclose
$LN10@P_fclose:
  000b7	8b f4		 mov	 esi, esp
  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PBIJLHDC@?6Not?5a?5file?6?$AA@
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000c4	83 c4 04	 add	 esp, 4
  000c7	3b f4		 cmp	 esi, esp
  000c9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ce	eb 68		 jmp	 SHORT $LN8@P_fclose
$LN2@P_fclose:

; 1547 :     Isopen(S0);

  000d0	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000d5	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000d8	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  000dc	75 19		 jne	 SHORT $LN1@P_fclose
  000de	8b f4		 mov	 esi, esp
  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JACEKOJL@?6File?5not?5open?6?$AA@
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000eb	83 c4 04	 add	 esp, 4
  000ee	3b f4		 cmp	 esi, esp
  000f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f5	eb 41		 jmp	 SHORT $LN8@P_fclose
$LN1@P_fclose:

; 1548 :     V fclose(FileD(S0));

  000f7	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000fc	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000ff	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00102	8b f4		 mov	 esi, esp
  00104	52		 push	 edx
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0010b	83 c4 04	 add	 esp, 4
  0010e	3b f4		 cmp	 esi, esp
  00110	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1549 :     *(((stackitem *) S0) + 1) = (stackitem) NULL;

  00115	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0011a	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0011d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00124	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 1550 :     Pop;

  0012b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00130	83 e8 08	 sub	 eax, 8
  00133	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN8@P_fclose:

; 1551 : }

  00138	5f		 pop	 edi
  00139	5e		 pop	 esi
  0013a	5b		 pop	 ebx
  0013b	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00141	3b ec		 cmp	 ebp, esp
  00143	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00148	8b e5		 mov	 esp, ebp
  0014a	5d		 pop	 ebp
  0014b	c3		 ret	 0
_P_fclose ENDP
_TEXT	ENDS
EXTRN	__imp___unlink:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_fdelete
_TEXT	SEGMENT
_P_fdelete PROC						; COMDAT

; 1554 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1555 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN3@P_fdelete
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 58		 jmp	 SHORT $LN4@P_fdelete
$LN3@P_fdelete:

; 1556 :     Hpc(S0);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00046	72 10		 jb	 SHORT $LN1@P_fdelete
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00050	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00056	72 07		 jb	 SHORT $LN2@P_fdelete
$LN1@P_fdelete:
  00058	e8 00 00 00 00	 call	 _badpointer
  0005d	eb 31		 jmp	 SHORT $LN4@P_fdelete
$LN2@P_fdelete:

; 1557 :     S0 = (unlink((char *) S0) == 0) ? Truth : Falsity;

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00064	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00067	8b f4		 mov	 esi, esp
  00069	51		 push	 ecx
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___unlink
  00070	83 c4 04	 add	 esp, 4
  00073	3b f4		 cmp	 esi, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	f7 d8		 neg	 eax
  0007c	1b c0		 sbb	 eax, eax
  0007e	f7 d8		 neg	 eax
  00080	83 e8 01	 sub	 eax, 1
  00083	99		 cdq
  00084	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0008a	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  0008d	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN4@P_fdelete:

; 1558 : }

  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00099	3b ec		 cmp	 ebp, esp
  0009b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
_P_fdelete ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_fgetline
_TEXT	SEGMENT
tv141 = -196						; size = 4
_P_fgetline PROC					; COMDAT

; 1561 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1562 :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 0a		 jge	 SHORT $LN9@P_fgetline
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 1a 01 00 00	 jmp	 $LN10@P_fgetline
$LN9@P_fgetline:

; 1563 :     Hpc(S0);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00043	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00049	72 10		 jb	 SHORT $LN7@P_fgetline
  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00050	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00053	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00059	72 0a		 jb	 SHORT $LN8@P_fgetline
$LN7@P_fgetline:
  0005b	e8 00 00 00 00	 call	 _badpointer
  00060	e9 f0 00 00 00	 jmp	 $LN10@P_fgetline
$LN8@P_fgetline:

; 1564 :     Isfile(S1);

  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0006a	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0006d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00073	72 10		 jb	 SHORT $LN5@P_fgetline
  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0007a	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0007d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00083	72 0a		 jb	 SHORT $LN6@P_fgetline
$LN5@P_fgetline:
  00085	e8 00 00 00 00	 call	 _badpointer
  0008a	e9 c6 00 00 00	 jmp	 $LN10@P_fgetline
$LN6@P_fgetline:
  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00094	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00097	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv141[ebp], ecx
  0009d	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv141[ebp]
  000a3	81 3a 9d df 1f
	83		 cmp	 DWORD PTR [edx], -2095063139 ; 831fdf9dH
  000a9	75 0c		 jne	 SHORT $LN12@P_fgetline
  000ab	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv141[ebp]
  000b1	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000b5	74 1c		 je	 SHORT $LN4@P_fgetline
$LN12@P_fgetline:
  000b7	8b f4		 mov	 esi, esp
  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PBIJLHDC@?6Not?5a?5file?6?$AA@
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000c4	83 c4 04	 add	 esp, 4
  000c7	3b f4		 cmp	 esi, esp
  000c9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ce	e9 82 00 00 00	 jmp	 $LN10@P_fgetline
$LN4@P_fgetline:

; 1565 :     Isopen(S1);

  000d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000d8	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  000db	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  000df	75 19		 jne	 SHORT $LN3@P_fgetline
  000e1	8b f4		 mov	 esi, esp
  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JACEKOJL@?6File?5not?5open?6?$AA@
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000ee	83 c4 04	 add	 esp, 4
  000f1	3b f4		 cmp	 esi, esp
  000f3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f8	eb 5b		 jmp	 SHORT $LN10@P_fgetline
$LN3@P_fgetline:

; 1566 :     if (atl_fgetsp((char *) S0, 132, FileD(S1)) == NULL) {

  000fa	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000ff	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00102	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00105	52		 push	 edx
  00106	68 84 00 00 00	 push	 132			; 00000084H
  0010b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00110	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00113	51		 push	 ecx
  00114	e8 00 00 00 00	 call	 _atl_fgetsp
  00119	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011c	85 c0		 test	 eax, eax
  0011e	75 15		 jne	 SHORT $LN2@P_fgetline

; 1567 : 	S1 = Falsity;

  00120	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00125	c7 40 f0 00 00
	00 00		 mov	 DWORD PTR [eax-16], 0
  0012c	c7 40 f4 00 00
	00 00		 mov	 DWORD PTR [eax-12], 0

; 1568 :     } else {

  00133	eb 13		 jmp	 SHORT $LN1@P_fgetline
$LN2@P_fgetline:

; 1569 : 	S1 = Truth;

  00135	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0013a	c7 40 f0 ff ff
	ff ff		 mov	 DWORD PTR [eax-16], -1
  00141	c7 40 f4 ff ff
	ff ff		 mov	 DWORD PTR [eax-12], -1
$LN1@P_fgetline:

; 1570 :     }
; 1571 :     Pop;

  00148	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0014d	83 e8 08	 sub	 eax, 8
  00150	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN10@P_fgetline:

; 1572 : }

  00155	5f		 pop	 edi
  00156	5e		 pop	 esi
  00157	5b		 pop	 ebx
  00158	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0015e	3b ec		 cmp	 ebp, esp
  00160	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	c3		 ret	 0
_P_fgetline ENDP
_TEXT	ENDS
EXTRN	__imp__ungetc:PROC
EXTRN	__imp__getc:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _atl_fgetsp
_TEXT	SEGMENT
_ch$ = -20						; size = 4
_i$ = -8						; size = 4
_s$ = 8							; size = 4
_n$ = 12						; size = 4
_stream$ = 16						; size = 4
_atl_fgetsp PROC					; COMDAT

; 480  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 481  : 	int i = 0, ch;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN9@atl_fgetsp:

; 482  : 
; 483  : 	while (True) {

  00025	b8 01 00 00 00	 mov	 eax, 1
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 d7 00 00
	00		 je	 $LN8@atl_fgetsp

; 484  : 	   ch = getc(stream);

  00032	8b f4		 mov	 esi, esp
  00034	8b 45 10	 mov	 eax, DWORD PTR _stream$[ebp]
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__getc
  0003e	83 c4 04	 add	 esp, 4
  00041	3b f4		 cmp	 esi, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	89 45 ec	 mov	 DWORD PTR _ch$[ebp], eax

; 485  : 	   if (ch == EOF) {

  0004b	83 7d ec ff	 cmp	 DWORD PTR _ch$[ebp], -1
  0004f	75 12		 jne	 SHORT $LN7@atl_fgetsp

; 486  : 	      if (i == 0)

  00051	83 7d f8 00	 cmp	 DWORD PTR _i$[ebp], 0
  00055	75 07		 jne	 SHORT $LN6@atl_fgetsp

; 487  : 		 return NULL;

  00057	33 c0		 xor	 eax, eax
  00059	e9 b7 00 00 00	 jmp	 $LN10@atl_fgetsp
$LN6@atl_fgetsp:

; 488  : 	      break;

  0005e	e9 a6 00 00 00	 jmp	 $LN8@atl_fgetsp
$LN7@atl_fgetsp:

; 489  : 	   }
; 490  :            if (ch == '\r') {

  00063	83 7d ec 0d	 cmp	 DWORD PTR _ch$[ebp], 13	; 0000000dH
  00067	75 3b		 jne	 SHORT $LN5@atl_fgetsp

; 491  : 	      ch = getc(stream);

  00069	8b f4		 mov	 esi, esp
  0006b	8b 45 10	 mov	 eax, DWORD PTR _stream$[ebp]
  0006e	50		 push	 eax
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__getc
  00075	83 c4 04	 add	 esp, 4
  00078	3b f4		 cmp	 esi, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	89 45 ec	 mov	 DWORD PTR _ch$[ebp], eax

; 492  :               if (ch != '\n')

  00082	83 7d ec 0a	 cmp	 DWORD PTR _ch$[ebp], 10	; 0000000aH
  00086	74 1a		 je	 SHORT $LN4@atl_fgetsp

; 493  : 		 V ungetc(ch, stream);

  00088	8b f4		 mov	 esi, esp
  0008a	8b 45 10	 mov	 eax, DWORD PTR _stream$[ebp]
  0008d	50		 push	 eax
  0008e	8b 4d ec	 mov	 ecx, DWORD PTR _ch$[ebp]
  00091	51		 push	 ecx
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ungetc
  00098	83 c4 08	 add	 esp, 8
  0009b	3b f4		 cmp	 esi, esp
  0009d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@atl_fgetsp:

; 494  : 	      break;

  000a2	eb 65		 jmp	 SHORT $LN8@atl_fgetsp
$LN5@atl_fgetsp:

; 495  : 	   }
; 496  :            if (ch == '\n') {

  000a4	83 7d ec 0a	 cmp	 DWORD PTR _ch$[ebp], 10	; 0000000aH
  000a8	75 3b		 jne	 SHORT $LN3@atl_fgetsp

; 497  : 	      ch = getc(stream);

  000aa	8b f4		 mov	 esi, esp
  000ac	8b 45 10	 mov	 eax, DWORD PTR _stream$[ebp]
  000af	50		 push	 eax
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__getc
  000b6	83 c4 04	 add	 esp, 4
  000b9	3b f4		 cmp	 esi, esp
  000bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c0	89 45 ec	 mov	 DWORD PTR _ch$[ebp], eax

; 498  :               if (ch != '\r')

  000c3	83 7d ec 0d	 cmp	 DWORD PTR _ch$[ebp], 13	; 0000000dH
  000c7	74 1a		 je	 SHORT $LN2@atl_fgetsp

; 499  : 		 V ungetc(ch, stream);

  000c9	8b f4		 mov	 esi, esp
  000cb	8b 45 10	 mov	 eax, DWORD PTR _stream$[ebp]
  000ce	50		 push	 eax
  000cf	8b 4d ec	 mov	 ecx, DWORD PTR _ch$[ebp]
  000d2	51		 push	 ecx
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ungetc
  000d9	83 c4 08	 add	 esp, 8
  000dc	3b f4		 cmp	 esi, esp
  000de	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@atl_fgetsp:

; 500  : 	      break;

  000e3	eb 24		 jmp	 SHORT $LN8@atl_fgetsp
$LN3@atl_fgetsp:

; 501  : 	   }
; 502  : 	   if (i < (n - 1))

  000e5	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
  000e8	83 e8 01	 sub	 eax, 1
  000eb	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  000ee	7d 14		 jge	 SHORT $LN1@atl_fgetsp

; 503  : 	      s[i++] = ch;

  000f0	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000f3	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  000f6	8a 4d ec	 mov	 cl, BYTE PTR _ch$[ebp]
  000f9	88 08		 mov	 BYTE PTR [eax], cl
  000fb	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000fe	83 c2 01	 add	 edx, 1
  00101	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN1@atl_fgetsp:

; 504  : 	}

  00104	e9 1c ff ff ff	 jmp	 $LN9@atl_fgetsp
$LN8@atl_fgetsp:

; 505  : 	s[i] = EOS;

  00109	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0010c	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  0010f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 506  : 	return s;

  00112	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
$LN10@atl_fgetsp:

; 507  : }

  00115	5f		 pop	 edi
  00116	5e		 pop	 esi
  00117	5b		 pop	 ebx
  00118	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0011e	3b ec		 cmp	 ebp, esp
  00120	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c3		 ret	 0
_atl_fgetsp ENDP
_TEXT	ENDS
EXTRN	__imp__putc:PROC
EXTRN	__imp__fputs:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_fputline
_TEXT	SEGMENT
tv150 = -196						; size = 4
_P_fputline PROC					; COMDAT

; 1575 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1576 :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 0a		 jge	 SHORT $LN9@P_fputline
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 44 01 00 00	 jmp	 $LN10@P_fputline
$LN9@P_fputline:

; 1577 :     Hpc(S1);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00043	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00049	72 10		 jb	 SHORT $LN7@P_fputline
  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00050	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00053	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00059	72 0a		 jb	 SHORT $LN8@P_fputline
$LN7@P_fputline:
  0005b	e8 00 00 00 00	 call	 _badpointer
  00060	e9 1a 01 00 00	 jmp	 $LN10@P_fputline
$LN8@P_fputline:

; 1578 :     Isfile(S0);

  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0006a	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0006d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00073	72 10		 jb	 SHORT $LN5@P_fputline
  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0007a	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0007d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00083	72 0a		 jb	 SHORT $LN6@P_fputline
$LN5@P_fputline:
  00085	e8 00 00 00 00	 call	 _badpointer
  0008a	e9 f0 00 00 00	 jmp	 $LN10@P_fputline
$LN6@P_fputline:
  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00094	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00097	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv150[ebp], ecx
  0009d	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv150[ebp]
  000a3	81 3a 9d df 1f
	83		 cmp	 DWORD PTR [edx], -2095063139 ; 831fdf9dH
  000a9	75 0c		 jne	 SHORT $LN12@P_fputline
  000ab	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv150[ebp]
  000b1	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000b5	74 1c		 je	 SHORT $LN4@P_fputline
$LN12@P_fputline:
  000b7	8b f4		 mov	 esi, esp
  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PBIJLHDC@?6Not?5a?5file?6?$AA@
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000c4	83 c4 04	 add	 esp, 4
  000c7	3b f4		 cmp	 esi, esp
  000c9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ce	e9 ac 00 00 00	 jmp	 $LN10@P_fputline
$LN4@P_fputline:

; 1579 :     Isopen(S0);

  000d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000d8	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000db	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  000df	75 1c		 jne	 SHORT $LN3@P_fputline
  000e1	8b f4		 mov	 esi, esp
  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JACEKOJL@?6File?5not?5open?6?$AA@
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000ee	83 c4 04	 add	 esp, 4
  000f1	3b f4		 cmp	 esi, esp
  000f3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f8	e9 82 00 00 00	 jmp	 $LN10@P_fputline
$LN3@P_fputline:

; 1580 :     if (fputs((char *) S1, FileD(S0)) == EOF) {

  000fd	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00102	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00105	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00108	8b f4		 mov	 esi, esp
  0010a	52		 push	 edx
  0010b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00110	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00113	51		 push	 ecx
  00114	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fputs
  0011a	83 c4 08	 add	 esp, 8
  0011d	3b f4		 cmp	 esi, esp
  0011f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00124	83 f8 ff	 cmp	 eax, -1
  00127	75 15		 jne	 SHORT $LN2@P_fputline

; 1581 : 	S1 = Falsity;

  00129	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0012e	c7 40 f0 00 00
	00 00		 mov	 DWORD PTR [eax-16], 0
  00135	c7 40 f4 00 00
	00 00		 mov	 DWORD PTR [eax-12], 0

; 1582 :     } else {

  0013c	eb 34		 jmp	 SHORT $LN1@P_fputline
$LN2@P_fputline:

; 1583 :         S1 = putc('\n', FileD(S0)) == EOF ? Falsity : Truth;

  0013e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00143	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00146	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00149	8b f4		 mov	 esi, esp
  0014b	52		 push	 edx
  0014c	6a 0a		 push	 10			; 0000000aH
  0014e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__putc
  00154	83 c4 08	 add	 esp, 8
  00157	3b f4		 cmp	 esi, esp
  00159	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015e	83 e8 ff	 sub	 eax, -1
  00161	f7 d8		 neg	 eax
  00163	1b c0		 sbb	 eax, eax
  00165	99		 cdq
  00166	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0016c	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  0016f	89 51 f4	 mov	 DWORD PTR [ecx-12], edx
$LN1@P_fputline:

; 1584 :     }
; 1585 :     Pop;

  00172	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00177	83 e8 08	 sub	 eax, 8
  0017a	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN10@P_fputline:

; 1586 : }

  0017f	5f		 pop	 edi
  00180	5e		 pop	 esi
  00181	5b		 pop	 ebx
  00182	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00188	3b ec		 cmp	 ebp, esp
  0018a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018f	8b e5		 mov	 esp, ebp
  00191	5d		 pop	 ebp
  00192	c3		 ret	 0
_P_fputline ENDP
_TEXT	ENDS
EXTRN	__imp__fread:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_fread
_TEXT	SEGMENT
tv143 = -196						; size = 4
_P_fread PROC						; COMDAT

; 1589 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1590 :     Sl(3);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 03	 cmp	 eax, 3
  0002f	7d 0a		 jge	 SHORT $LN7@P_fread
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 0a 01 00 00	 jmp	 $LN8@P_fread
$LN7@P_fread:

; 1591 :     Hpc(S0);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00043	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00049	72 10		 jb	 SHORT $LN5@P_fread
  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00050	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00053	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00059	72 0a		 jb	 SHORT $LN6@P_fread
$LN5@P_fread:
  0005b	e8 00 00 00 00	 call	 _badpointer
  00060	e9 e0 00 00 00	 jmp	 $LN8@P_fread
$LN6@P_fread:

; 1592 :     Isfile(S2);

  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0006a	8b 48 e8	 mov	 ecx, DWORD PTR [eax-24]
  0006d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00073	72 10		 jb	 SHORT $LN3@P_fread
  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0007a	8b 48 e8	 mov	 ecx, DWORD PTR [eax-24]
  0007d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00083	72 0a		 jb	 SHORT $LN4@P_fread
$LN3@P_fread:
  00085	e8 00 00 00 00	 call	 _badpointer
  0008a	e9 b6 00 00 00	 jmp	 $LN8@P_fread
$LN4@P_fread:
  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00094	8b 48 e8	 mov	 ecx, DWORD PTR [eax-24]
  00097	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv143[ebp], ecx
  0009d	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv143[ebp]
  000a3	81 3a 9d df 1f
	83		 cmp	 DWORD PTR [edx], -2095063139 ; 831fdf9dH
  000a9	75 0c		 jne	 SHORT $LN10@P_fread
  000ab	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv143[ebp]
  000b1	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000b5	74 19		 je	 SHORT $LN2@P_fread
$LN10@P_fread:
  000b7	8b f4		 mov	 esi, esp
  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PBIJLHDC@?6Not?5a?5file?6?$AA@
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000c4	83 c4 04	 add	 esp, 4
  000c7	3b f4		 cmp	 esi, esp
  000c9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ce	eb 75		 jmp	 SHORT $LN8@P_fread
$LN2@P_fread:

; 1593 :     Isopen(S2);

  000d0	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000d5	8b 48 e8	 mov	 ecx, DWORD PTR [eax-24]
  000d8	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  000dc	75 19		 jne	 SHORT $LN1@P_fread
  000de	8b f4		 mov	 esi, esp
  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JACEKOJL@?6File?5not?5open?6?$AA@
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000eb	83 c4 04	 add	 esp, 4
  000ee	3b f4		 cmp	 esi, esp
  000f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f5	eb 4e		 jmp	 SHORT $LN8@P_fread
$LN1@P_fread:

; 1594 :     S2 = fread((char *) S0, 1, ((int) S1), FileD(S2));

  000f7	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000fc	8b 48 e8	 mov	 ecx, DWORD PTR [eax-24]
  000ff	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00102	8b f4		 mov	 esi, esp
  00104	52		 push	 edx
  00105	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0010a	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0010d	51		 push	 ecx
  0010e	6a 01		 push	 1
  00110	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00116	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  00119	50		 push	 eax
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00120	83 c4 10	 add	 esp, 16			; 00000010H
  00123	3b f4		 cmp	 esi, esp
  00125	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012a	33 c9		 xor	 ecx, ecx
  0012c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00132	89 42 e8	 mov	 DWORD PTR [edx-24], eax
  00135	89 4a ec	 mov	 DWORD PTR [edx-20], ecx

; 1595 :     Pop2;

  00138	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0013d	83 e8 10	 sub	 eax, 16			; 00000010H
  00140	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN8@P_fread:

; 1596 : }

  00145	5f		 pop	 edi
  00146	5e		 pop	 esi
  00147	5b		 pop	 ebx
  00148	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0014e	3b ec		 cmp	 ebp, esp
  00150	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00155	8b e5		 mov	 esp, ebp
  00157	5d		 pop	 ebp
  00158	c3		 ret	 0
_P_fread ENDP
_TEXT	ENDS
EXTRN	__imp__fwrite:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_fwrite
_TEXT	SEGMENT
tv143 = -196						; size = 4
_P_fwrite PROC						; COMDAT

; 1599 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1600 :     Sl(3);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 03	 cmp	 eax, 3
  0002f	7d 0a		 jge	 SHORT $LN7@P_fwrite
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 0a 01 00 00	 jmp	 $LN8@P_fwrite
$LN7@P_fwrite:

; 1601 :     Hpc(S1);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00043	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00049	72 10		 jb	 SHORT $LN5@P_fwrite
  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00050	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00053	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00059	72 0a		 jb	 SHORT $LN6@P_fwrite
$LN5@P_fwrite:
  0005b	e8 00 00 00 00	 call	 _badpointer
  00060	e9 e0 00 00 00	 jmp	 $LN8@P_fwrite
$LN6@P_fwrite:

; 1602 :     Isfile(S0);

  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0006a	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0006d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00073	72 10		 jb	 SHORT $LN3@P_fwrite
  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0007a	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0007d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00083	72 0a		 jb	 SHORT $LN4@P_fwrite
$LN3@P_fwrite:
  00085	e8 00 00 00 00	 call	 _badpointer
  0008a	e9 b6 00 00 00	 jmp	 $LN8@P_fwrite
$LN4@P_fwrite:
  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00094	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00097	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv143[ebp], ecx
  0009d	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv143[ebp]
  000a3	81 3a 9d df 1f
	83		 cmp	 DWORD PTR [edx], -2095063139 ; 831fdf9dH
  000a9	75 0c		 jne	 SHORT $LN10@P_fwrite
  000ab	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv143[ebp]
  000b1	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000b5	74 19		 je	 SHORT $LN2@P_fwrite
$LN10@P_fwrite:
  000b7	8b f4		 mov	 esi, esp
  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PBIJLHDC@?6Not?5a?5file?6?$AA@
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000c4	83 c4 04	 add	 esp, 4
  000c7	3b f4		 cmp	 esi, esp
  000c9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ce	eb 75		 jmp	 SHORT $LN8@P_fwrite
$LN2@P_fwrite:

; 1603 :     Isopen(S0);

  000d0	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000d5	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000d8	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  000dc	75 19		 jne	 SHORT $LN1@P_fwrite
  000de	8b f4		 mov	 esi, esp
  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JACEKOJL@?6File?5not?5open?6?$AA@
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000eb	83 c4 04	 add	 esp, 4
  000ee	3b f4		 cmp	 esi, esp
  000f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f5	eb 4e		 jmp	 SHORT $LN8@P_fwrite
$LN1@P_fwrite:

; 1604 :     S2 = fwrite((char *) S1, 1, ((int) S2), FileD(S0));

  000f7	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000fc	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000ff	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00102	8b f4		 mov	 esi, esp
  00104	52		 push	 edx
  00105	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0010a	8b 48 e8	 mov	 ecx, DWORD PTR [eax-24]
  0010d	51		 push	 ecx
  0010e	6a 01		 push	 1
  00110	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00116	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  00119	50		 push	 eax
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00120	83 c4 10	 add	 esp, 16			; 00000010H
  00123	3b f4		 cmp	 esi, esp
  00125	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012a	33 c9		 xor	 ecx, ecx
  0012c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00132	89 42 e8	 mov	 DWORD PTR [edx-24], eax
  00135	89 4a ec	 mov	 DWORD PTR [edx-20], ecx

; 1605 :     Pop2;

  00138	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0013d	83 e8 10	 sub	 eax, 16			; 00000010H
  00140	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN8@P_fwrite:

; 1606 : }

  00145	5f		 pop	 edi
  00146	5e		 pop	 esi
  00147	5b		 pop	 ebx
  00148	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0014e	3b ec		 cmp	 ebp, esp
  00150	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00155	8b e5		 mov	 esp, ebp
  00157	5d		 pop	 ebp
  00158	c3		 ret	 0
_P_fwrite ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_fgetc
_TEXT	SEGMENT
tv95 = -196						; size = 4
_P_fgetc PROC						; COMDAT

; 1609 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1610 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 0a		 jge	 SHORT $LN5@P_fgetc
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 bd 00 00 00	 jmp	 $LN6@P_fgetc
$LN5@P_fgetc:

; 1611 :     Isfile(S0);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00043	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00049	72 10		 jb	 SHORT $LN3@P_fgetc
  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00050	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00053	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00059	72 0a		 jb	 SHORT $LN4@P_fgetc
$LN3@P_fgetc:
  0005b	e8 00 00 00 00	 call	 _badpointer
  00060	e9 93 00 00 00	 jmp	 $LN6@P_fgetc
$LN4@P_fgetc:
  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0006a	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0006d	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv95[ebp], ecx
  00073	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv95[ebp]
  00079	81 3a 9d df 1f
	83		 cmp	 DWORD PTR [edx], -2095063139 ; 831fdf9dH
  0007f	75 0c		 jne	 SHORT $LN8@P_fgetc
  00081	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv95[ebp]
  00087	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0008b	74 19		 je	 SHORT $LN2@P_fgetc
$LN8@P_fgetc:
  0008d	8b f4		 mov	 esi, esp
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PBIJLHDC@?6Not?5a?5file?6?$AA@
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0009a	83 c4 04	 add	 esp, 4
  0009d	3b f4		 cmp	 esi, esp
  0009f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a4	eb 52		 jmp	 SHORT $LN6@P_fgetc
$LN2@P_fgetc:

; 1612 :     Isopen(S0);

  000a6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000ab	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000ae	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  000b2	75 19		 jne	 SHORT $LN1@P_fgetc
  000b4	8b f4		 mov	 esi, esp
  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JACEKOJL@?6File?5not?5open?6?$AA@
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000c1	83 c4 04	 add	 esp, 4
  000c4	3b f4		 cmp	 esi, esp
  000c6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cb	eb 2b		 jmp	 SHORT $LN6@P_fgetc
$LN1@P_fgetc:

; 1613 :     S0 = getc(FileD(S0));	      /* Returns -1 if EOF hit */

  000cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000d2	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000d5	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000d8	8b f4		 mov	 esi, esp
  000da	52		 push	 edx
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__getc
  000e1	83 c4 04	 add	 esp, 4
  000e4	3b f4		 cmp	 esi, esp
  000e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000eb	99		 cdq
  000ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  000f2	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  000f5	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN6@P_fgetc:

; 1614 : }

  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi
  000fa	5b		 pop	 ebx
  000fb	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00101	3b ec		 cmp	 ebp, esp
  00103	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c3		 ret	 0
_P_fgetc ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_fputc
_TEXT	SEGMENT
tv132 = -196						; size = 4
_P_fputc PROC						; COMDAT

; 1617 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1618 :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 0a		 jge	 SHORT $LN5@P_fputc
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 d4 00 00 00	 jmp	 $LN6@P_fputc
$LN5@P_fputc:

; 1619 :     Isfile(S0);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00043	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00049	72 10		 jb	 SHORT $LN3@P_fputc
  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00050	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00053	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00059	72 0a		 jb	 SHORT $LN4@P_fputc
$LN3@P_fputc:
  0005b	e8 00 00 00 00	 call	 _badpointer
  00060	e9 aa 00 00 00	 jmp	 $LN6@P_fputc
$LN4@P_fputc:
  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0006a	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0006d	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv132[ebp], ecx
  00073	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv132[ebp]
  00079	81 3a 9d df 1f
	83		 cmp	 DWORD PTR [edx], -2095063139 ; 831fdf9dH
  0007f	75 0c		 jne	 SHORT $LN8@P_fputc
  00081	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv132[ebp]
  00087	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0008b	74 19		 je	 SHORT $LN2@P_fputc
$LN8@P_fputc:
  0008d	8b f4		 mov	 esi, esp
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PBIJLHDC@?6Not?5a?5file?6?$AA@
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0009a	83 c4 04	 add	 esp, 4
  0009d	3b f4		 cmp	 esi, esp
  0009f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a4	eb 69		 jmp	 SHORT $LN6@P_fputc
$LN2@P_fputc:

; 1620 :     Isopen(S0);

  000a6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000ab	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000ae	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  000b2	75 19		 jne	 SHORT $LN1@P_fputc
  000b4	8b f4		 mov	 esi, esp
  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JACEKOJL@?6File?5not?5open?6?$AA@
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000c1	83 c4 04	 add	 esp, 4
  000c4	3b f4		 cmp	 esi, esp
  000c6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cb	eb 42		 jmp	 SHORT $LN6@P_fputc
$LN1@P_fputc:

; 1621 :     S1 = putc((char) S1, FileD(S0));

  000cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000d2	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000d5	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000d8	8b f4		 mov	 esi, esp
  000da	52		 push	 edx
  000db	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000e0	0f be 48 f0	 movsx	 ecx, BYTE PTR [eax-16]
  000e4	51		 push	 ecx
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__putc
  000eb	83 c4 08	 add	 esp, 8
  000ee	3b f4		 cmp	 esi, esp
  000f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f5	99		 cdq
  000f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  000fc	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  000ff	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 1622 :     Pop;

  00102	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00107	83 e8 08	 sub	 eax, 8
  0010a	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN6@P_fputc:

; 1623 : }

  0010f	5f		 pop	 edi
  00110	5e		 pop	 esi
  00111	5b		 pop	 ebx
  00112	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00118	3b ec		 cmp	 ebp, esp
  0011a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
_P_fputc ENDP
_TEXT	ENDS
EXTRN	__imp__ftell:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_ftell
_TEXT	SEGMENT
tv95 = -196						; size = 4
_P_ftell PROC						; COMDAT

; 1626 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1627 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 0a		 jge	 SHORT $LN5@P_ftell
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 bd 00 00 00	 jmp	 $LN6@P_ftell
$LN5@P_ftell:

; 1628 :     Isfile(S0);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00043	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00049	72 10		 jb	 SHORT $LN3@P_ftell
  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00050	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00053	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00059	72 0a		 jb	 SHORT $LN4@P_ftell
$LN3@P_ftell:
  0005b	e8 00 00 00 00	 call	 _badpointer
  00060	e9 93 00 00 00	 jmp	 $LN6@P_ftell
$LN4@P_ftell:
  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0006a	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0006d	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv95[ebp], ecx
  00073	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv95[ebp]
  00079	81 3a 9d df 1f
	83		 cmp	 DWORD PTR [edx], -2095063139 ; 831fdf9dH
  0007f	75 0c		 jne	 SHORT $LN8@P_ftell
  00081	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv95[ebp]
  00087	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0008b	74 19		 je	 SHORT $LN2@P_ftell
$LN8@P_ftell:
  0008d	8b f4		 mov	 esi, esp
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PBIJLHDC@?6Not?5a?5file?6?$AA@
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0009a	83 c4 04	 add	 esp, 4
  0009d	3b f4		 cmp	 esi, esp
  0009f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a4	eb 52		 jmp	 SHORT $LN6@P_ftell
$LN2@P_ftell:

; 1629 :     Isopen(S0);

  000a6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000ab	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000ae	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  000b2	75 19		 jne	 SHORT $LN1@P_ftell
  000b4	8b f4		 mov	 esi, esp
  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JACEKOJL@?6File?5not?5open?6?$AA@
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000c1	83 c4 04	 add	 esp, 4
  000c4	3b f4		 cmp	 esi, esp
  000c6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cb	eb 2b		 jmp	 SHORT $LN6@P_ftell
$LN1@P_ftell:

; 1630 :     S0 = (stackitem) ftell(FileD(S0));

  000cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000d2	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000d5	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000d8	8b f4		 mov	 esi, esp
  000da	52		 push	 edx
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  000e1	83 c4 04	 add	 esp, 4
  000e4	3b f4		 cmp	 esi, esp
  000e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000eb	99		 cdq
  000ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  000f2	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  000f5	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN6@P_ftell:

; 1631 : }

  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi
  000fa	5b		 pop	 ebx
  000fb	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00101	3b ec		 cmp	 ebp, esp
  00103	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c3		 ret	 0
_P_ftell ENDP
_TEXT	ENDS
EXTRN	__imp__fseek:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_fseek
_TEXT	SEGMENT
tv131 = -196						; size = 4
_P_fseek PROC						; COMDAT

; 1634 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1635 :     Sl(3);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 03	 cmp	 eax, 3
  0002f	7d 0a		 jge	 SHORT $LN5@P_fseek
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 d1 00 00 00	 jmp	 $LN6@P_fseek
$LN5@P_fseek:

; 1636 :     Isfile(S0);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00043	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00049	72 10		 jb	 SHORT $LN3@P_fseek
  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00050	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00053	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00059	72 0a		 jb	 SHORT $LN4@P_fseek
$LN3@P_fseek:
  0005b	e8 00 00 00 00	 call	 _badpointer
  00060	e9 a7 00 00 00	 jmp	 $LN6@P_fseek
$LN4@P_fseek:
  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0006a	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0006d	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv131[ebp], ecx
  00073	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv131[ebp]
  00079	81 3a 9d df 1f
	83		 cmp	 DWORD PTR [edx], -2095063139 ; 831fdf9dH
  0007f	75 0c		 jne	 SHORT $LN8@P_fseek
  00081	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv131[ebp]
  00087	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0008b	74 19		 je	 SHORT $LN2@P_fseek
$LN8@P_fseek:
  0008d	8b f4		 mov	 esi, esp
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PBIJLHDC@?6Not?5a?5file?6?$AA@
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0009a	83 c4 04	 add	 esp, 4
  0009d	3b f4		 cmp	 esi, esp
  0009f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a4	eb 66		 jmp	 SHORT $LN6@P_fseek
$LN2@P_fseek:

; 1637 :     Isopen(S0);

  000a6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000ab	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000ae	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  000b2	75 19		 jne	 SHORT $LN1@P_fseek
  000b4	8b f4		 mov	 esi, esp
  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JACEKOJL@?6File?5not?5open?6?$AA@
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000c1	83 c4 04	 add	 esp, 4
  000c4	3b f4		 cmp	 esi, esp
  000c6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cb	eb 3f		 jmp	 SHORT $LN6@P_fseek
$LN1@P_fseek:

; 1638 :     V fseek(FileD(S0), (long) S2, (int) S1);

  000cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000d2	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  000d5	8b f4		 mov	 esi, esp
  000d7	51		 push	 ecx
  000d8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  000de	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  000e1	50		 push	 eax
  000e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  000e8	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  000eb	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000ee	50		 push	 eax
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  000f5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f8	3b f4		 cmp	 esi, esp
  000fa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1639 :     Npop(3);

  000ff	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00104	83 e8 18	 sub	 eax, 24			; 00000018H
  00107	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN6@P_fseek:

; 1640 : }

  0010c	5f		 pop	 edi
  0010d	5e		 pop	 esi
  0010e	5b		 pop	 ebx
  0010f	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00115	3b ec		 cmp	 ebp, esp
  00117	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c3		 ret	 0
_P_fseek ENDP
_TEXT	ENDS
PUBLIC	_atl_load
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_fload
_TEXT	SEGMENT
tv130 = -220						; size = 4
_fd$ = -20						; size = 4
_estat$ = -8						; size = 4
_P_fload PROC						; COMDAT

; 1643 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1644 :     int estat;
; 1645 :     FILE *fd;
; 1646 : 
; 1647 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 0a		 jge	 SHORT $LN6@P_fload
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 f4 00 00 00	 jmp	 $LN7@P_fload
$LN6@P_fload:

; 1648 :     Isfile(S0);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00043	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00049	72 10		 jb	 SHORT $LN4@P_fload
  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00050	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00053	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00059	72 0a		 jb	 SHORT $LN5@P_fload
$LN4@P_fload:
  0005b	e8 00 00 00 00	 call	 _badpointer
  00060	e9 ca 00 00 00	 jmp	 $LN7@P_fload
$LN5@P_fload:
  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0006a	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv130[ebp], ecx
  00073	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR tv130[ebp]
  00079	81 3a 9d df 1f
	83		 cmp	 DWORD PTR [edx], -2095063139 ; 831fdf9dH
  0007f	75 0c		 jne	 SHORT $LN9@P_fload
  00081	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv130[ebp]
  00087	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0008b	74 1c		 je	 SHORT $LN3@P_fload
$LN9@P_fload:
  0008d	8b f4		 mov	 esi, esp
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PBIJLHDC@?6Not?5a?5file?6?$AA@
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0009a	83 c4 04	 add	 esp, 4
  0009d	3b f4		 cmp	 esi, esp
  0009f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a4	e9 86 00 00 00	 jmp	 $LN7@P_fload
$LN3@P_fload:

; 1649 :     Isopen(S0);

  000a9	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000ae	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000b1	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  000b5	75 19		 jne	 SHORT $LN2@P_fload
  000b7	8b f4		 mov	 esi, esp
  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JACEKOJL@?6File?5not?5open?6?$AA@
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000c4	83 c4 04	 add	 esp, 4
  000c7	3b f4		 cmp	 esi, esp
  000c9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ce	eb 5f		 jmp	 SHORT $LN7@P_fload
$LN2@P_fload:

; 1650 :     fd = FileD(S0);

  000d0	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000d5	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000d8	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000db	89 55 ec	 mov	 DWORD PTR _fd$[ebp], edx

; 1651 :     Pop;

  000de	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000e3	83 e8 08	 sub	 eax, 8
  000e6	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1652 :     estat = atl_load(fd);

  000eb	8b 45 ec	 mov	 eax, DWORD PTR _fd$[ebp]
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 _atl_load
  000f4	83 c4 04	 add	 esp, 4
  000f7	89 45 f8	 mov	 DWORD PTR _estat$[ebp], eax

; 1653 :     So(1);

  000fa	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000ff	83 c0 08	 add	 eax, 8
  00102	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00108	76 07		 jbe	 SHORT $LN1@P_fload
  0010a	e8 00 00 00 00	 call	 _stakover
  0010f	eb 1e		 jmp	 SHORT $LN7@P_fload
$LN1@P_fload:

; 1654 :     Push = estat;

  00111	8b 45 f8	 mov	 eax, DWORD PTR _estat$[ebp]
  00114	99		 cdq
  00115	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0011b	89 01		 mov	 DWORD PTR [ecx], eax
  0011d	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00120	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00126	83 c2 08	 add	 edx, 8
  00129	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN7@P_fload:

; 1655 : }

  0012f	5f		 pop	 edi
  00130	5e		 pop	 esi
  00131	5b		 pop	 ebx
  00132	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00138	3b ec		 cmp	 ebp, esp
  0013a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013f	8b e5		 mov	 esp, ebp
  00141	5d		 pop	 ebp
  00142	c3		 ret	 0
_P_fload ENDP
_TEXT	ENDS
PUBLIC	_atl_unwind
PUBLIC	_atl_eval
PUBLIC	_atl_mark
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_evaluate
_TEXT	SEGMENT
_estring$ = -84						; size = 4
_sinstr$ = -72						; size = 4
_sip$ = -60						; size = 4
_scomm$ = -48						; size = 8
_mk$ = -32						; size = 16
_es$ = -8						; size = 4
_P_evaluate PROC					; COMDAT

; 1661 : {				      /* string -- status */

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00012	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1662 :     int es = ATL_SNORM;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _es$[ebp], 0

; 1663 :     atl_statemark mk;
; 1664 :     atl_int scomm = atl_comment;      /* Stack comment pending state */

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_comment
  0002a	89 45 d0	 mov	 DWORD PTR _scomm$[ebp], eax
  0002d	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _atl_comment+4
  00033	89 4d d4	 mov	 DWORD PTR _scomm$[ebp+4], ecx

; 1665 :     dictword **sip = ip;	      /* Stack instruction pointer */

  00036	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  0003b	89 45 c4	 mov	 DWORD PTR _sip$[ebp], eax

; 1666 :     char *sinstr = instream;	      /* Stack input stream */

  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR _instream
  00043	89 45 b8	 mov	 DWORD PTR _sinstr$[ebp], eax

; 1667 :     char *estring;
; 1668 : 
; 1669 :     Sl(1);

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00051	c1 f8 03	 sar	 eax, 3
  00054	83 f8 01	 cmp	 eax, 1
  00057	7d 0a		 jge	 SHORT $LN6@P_evaluate
  00059	e8 00 00 00 00	 call	 _stakunder
  0005e	e9 f5 00 00 00	 jmp	 $LN7@P_evaluate
$LN6@P_evaluate:

; 1670 :     Hpc(S0);

  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00068	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0006b	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00071	72 10		 jb	 SHORT $LN4@P_evaluate
  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00078	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0007b	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00081	72 0a		 jb	 SHORT $LN5@P_evaluate
$LN4@P_evaluate:
  00083	e8 00 00 00 00	 call	 _badpointer
  00088	e9 cb 00 00 00	 jmp	 $LN7@P_evaluate
$LN5@P_evaluate:

; 1671 :     estring = (char *) S0;	      /* Get string to evaluate */

  0008d	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00092	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00095	89 4d ac	 mov	 DWORD PTR _estring$[ebp], ecx

; 1672 :     Pop;			      /* Pop so it sees arguments below it */

  00098	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0009d	83 e8 08	 sub	 eax, 8
  000a0	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1673 :     atl_mark(&mk);		      /* Mark in case of error */

  000a5	8d 45 e0	 lea	 eax, DWORD PTR _mk$[ebp]
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 _atl_mark
  000ae	83 c4 04	 add	 esp, 4

; 1674 :     ip = NULL;			      /* Fool atl_eval into interp state */

  000b1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ip, 0

; 1675 :     if ((es = atl_eval(estring)) != ATL_SNORM) {

  000bb	8b 45 ac	 mov	 eax, DWORD PTR _estring$[ebp]
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _atl_eval
  000c4	83 c4 04	 add	 esp, 4
  000c7	89 45 f8	 mov	 DWORD PTR _es$[ebp], eax
  000ca	83 7d f8 00	 cmp	 DWORD PTR _es$[ebp], 0
  000ce	74 0c		 je	 SHORT $LN3@P_evaluate

; 1676 : 	atl_unwind(&mk);

  000d0	8d 45 e0	 lea	 eax, DWORD PTR _mk$[ebp]
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 _atl_unwind
  000d9	83 c4 04	 add	 esp, 4
$LN3@P_evaluate:

; 1677 :     }
; 1678 :     /* If there were no other errors, check for a runaway comment.  If
; 1679 :        we ended the file in comment-ignore mode, set the runaway comment
; 1680 :        error status and unwind the file.  */
; 1681 :     if ((es == ATL_SNORM) && (atl_comment != 0)) {

  000dc	83 7d f8 00	 cmp	 DWORD PTR _es$[ebp], 0
  000e0	75 20		 jne	 SHORT $LN2@P_evaluate
  000e2	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_comment
  000e7	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _atl_comment+4
  000ed	74 13		 je	 SHORT $LN2@P_evaluate

; 1682 : 	es = ATL_RUNCOMM;

  000ef	c7 45 f8 f5 ff
	ff ff		 mov	 DWORD PTR _es$[ebp], -11 ; fffffff5H

; 1683 : 	atl_unwind(&mk);

  000f6	8d 45 e0	 lea	 eax, DWORD PTR _mk$[ebp]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 _atl_unwind
  000ff	83 c4 04	 add	 esp, 4
$LN2@P_evaluate:

; 1684 :     }
; 1685 :     atl_comment = scomm;	      /* Unstack comment pending status */

  00102	8b 45 d0	 mov	 eax, DWORD PTR _scomm$[ebp]
  00105	a3 00 00 00 00	 mov	 DWORD PTR _atl_comment, eax
  0010a	8b 4d d4	 mov	 ecx, DWORD PTR _scomm$[ebp+4]
  0010d	89 0d 04 00 00
	00		 mov	 DWORD PTR _atl_comment+4, ecx

; 1686 :     ip = sip;			      /* Unstack instruction pointer */

  00113	8b 45 c4	 mov	 eax, DWORD PTR _sip$[ebp]
  00116	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax

; 1687 :     instream = sinstr;		      /* Unstack input stream */

  0011b	8b 45 b8	 mov	 eax, DWORD PTR _sinstr$[ebp]
  0011e	a3 00 00 00 00	 mov	 DWORD PTR _instream, eax

; 1688 :     So(1);

  00123	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00128	83 c0 08	 add	 eax, 8
  0012b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00131	76 07		 jbe	 SHORT $LN1@P_evaluate
  00133	e8 00 00 00 00	 call	 _stakover
  00138	eb 1e		 jmp	 SHORT $LN7@P_evaluate
$LN1@P_evaluate:

; 1689 :     Push = es;			      /* Return eval status on top of stack */

  0013a	8b 45 f8	 mov	 eax, DWORD PTR _es$[ebp]
  0013d	99		 cdq
  0013e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00144	89 01		 mov	 DWORD PTR [ecx], eax
  00146	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00149	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0014f	83 c2 08	 add	 edx, 8
  00152	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN7@P_evaluate:

; 1690 : }

  00158	52		 push	 edx
  00159	8b cd		 mov	 ecx, ebp
  0015b	50		 push	 eax
  0015c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@P_evaluate
  00162	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00167	58		 pop	 eax
  00168	5a		 pop	 edx
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	5b		 pop	 ebx
  0016c	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  00172	3b ec		 cmp	 ebp, esp
  00174	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00179	8b e5		 mov	 esp, ebp
  0017b	5d		 pop	 ebp
  0017c	c3		 ret	 0
  0017d	8d 49 00	 npad	 3
$LN11@P_evaluate:
  00180	01 00 00 00	 DD	 1
  00184	00 00 00 00	 DD	 $LN10@P_evaluate
$LN10@P_evaluate:
  00188	e0 ff ff ff	 DD	 -32			; ffffffe0H
  0018c	10 00 00 00	 DD	 16			; 00000010H
  00190	00 00 00 00	 DD	 $LN9@P_evaluate
$LN9@P_evaluate:
  00194	6d		 DB	 109			; 0000006dH
  00195	6b		 DB	 107			; 0000006bH
  00196	00		 DB	 0
_P_evaluate ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_depth
_TEXT	SEGMENT
_s$ = -12						; size = 8
_P_depth PROC						; COMDAT

; 1696 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1697 :     stackitem s = stk - stack;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	99		 cdq
  0002d	89 45 f4	 mov	 DWORD PTR _s$[ebp], eax
  00030	89 55 f8	 mov	 DWORD PTR _s$[ebp+4], edx

; 1698 : 
; 1699 :     So(1);

  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00038	83 c0 08	 add	 eax, 8
  0003b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00041	76 07		 jbe	 SHORT $LN1@P_depth
  00043	e8 00 00 00 00	 call	 _stakover
  00048	eb 1d		 jmp	 SHORT $LN2@P_depth
$LN1@P_depth:

; 1700 :     Push = s;

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  00052	89 08		 mov	 DWORD PTR [eax], ecx
  00054	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp+4]
  00057	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0005a	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0005f	83 c0 08	 add	 eax, 8
  00062	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_depth:

; 1701 : }

  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00070	3b ec		 cmp	 ebp, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
_P_depth ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_clear
_TEXT	SEGMENT
_P_clear PROC						; COMDAT

; 1704 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1705 :     stk = stack;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stack
  00023	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1706 : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
_P_clear ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_dup
_TEXT	SEGMENT
_s$ = -12						; size = 8
_P_dup	PROC						; COMDAT

; 1709 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1710 :     stackitem s;
; 1711 : 
; 1712 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN2@P_dup
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 45		 jmp	 SHORT $LN3@P_dup
$LN2@P_dup:

; 1713 :     So(1);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	83 c0 08	 add	 eax, 8
  00040	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00046	76 07		 jbe	 SHORT $LN1@P_dup
  00048	e8 00 00 00 00	 call	 _stakover
  0004d	eb 2e		 jmp	 SHORT $LN3@P_dup
$LN1@P_dup:

; 1714 :     s = S0;

  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00054	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00057	89 4d f4	 mov	 DWORD PTR _s$[ebp], ecx
  0005a	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0005d	89 55 f8	 mov	 DWORD PTR _s$[ebp+4], edx

; 1715 :     Push = s;

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00065	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  00068	89 08		 mov	 DWORD PTR [eax], ecx
  0006a	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp+4]
  0006d	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00070	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00075	83 c0 08	 add	 eax, 8
  00078	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN3@P_dup:

; 1716 : }

  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00086	3b ec		 cmp	 ebp, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
_P_dup	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_drop
_TEXT	SEGMENT
_P_drop	PROC						; COMDAT

; 1719 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1720 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_drop
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 0d		 jmp	 SHORT $LN2@P_drop
$LN1@P_drop:

; 1721 :     Pop;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	83 e8 08	 sub	 eax, 8
  00040	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_drop:

; 1722 : }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004e	3b ec		 cmp	 ebp, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
_P_drop	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_swap
_TEXT	SEGMENT
_t$ = -12						; size = 8
_P_swap	PROC						; COMDAT

; 1725 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1726 :     stackitem t;
; 1727 : 
; 1728 :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN1@P_swap
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 39		 jmp	 SHORT $LN2@P_swap
$LN1@P_swap:

; 1729 :     t = S1;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00040	89 4d f4	 mov	 DWORD PTR _t$[ebp], ecx
  00043	8b 50 f4	 mov	 edx, DWORD PTR [eax-12]
  00046	89 55 f8	 mov	 DWORD PTR _t$[ebp+4], edx

; 1730 :     S1 = S0;

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00054	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  00057	89 50 f0	 mov	 DWORD PTR [eax-16], edx
  0005a	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0005d	89 48 f4	 mov	 DWORD PTR [eax-12], ecx

; 1731 :     S0 = t;

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00065	8b 4d f4	 mov	 ecx, DWORD PTR _t$[ebp]
  00068	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  0006b	8b 55 f8	 mov	 edx, DWORD PTR _t$[ebp+4]
  0006e	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_swap:

; 1732 : }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0007a	3b ec		 cmp	 ebp, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
_P_swap	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_over
_TEXT	SEGMENT
_s$ = -12						; size = 8
_P_over	PROC						; COMDAT

; 1735 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1736 :     stackitem s;
; 1737 : 
; 1738 :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN2@P_over
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 45		 jmp	 SHORT $LN3@P_over
$LN2@P_over:

; 1739 :     So(1);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	83 c0 08	 add	 eax, 8
  00040	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00046	76 07		 jbe	 SHORT $LN1@P_over
  00048	e8 00 00 00 00	 call	 _stakover
  0004d	eb 2e		 jmp	 SHORT $LN3@P_over
$LN1@P_over:

; 1740 :     s = S1;

  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00054	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00057	89 4d f4	 mov	 DWORD PTR _s$[ebp], ecx
  0005a	8b 50 f4	 mov	 edx, DWORD PTR [eax-12]
  0005d	89 55 f8	 mov	 DWORD PTR _s$[ebp+4], edx

; 1741 :     Push = s;

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00065	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  00068	89 08		 mov	 DWORD PTR [eax], ecx
  0006a	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp+4]
  0006d	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00070	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00075	83 c0 08	 add	 eax, 8
  00078	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN3@P_over:

; 1742 : }

  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00086	3b ec		 cmp	 ebp, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
_P_over	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_pick
_TEXT	SEGMENT
_P_pick	PROC						; COMDAT

; 1745 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1746 :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN1@P_pick
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 3c		 jmp	 SHORT $LN2@P_pick
$LN1@P_pick:

; 1747 :     S0 = stk[-(2 + S0)];

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	83 c1 02	 add	 ecx, 2
  00043	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00046	83 d2 00	 adc	 edx, 0
  00049	f7 d9		 neg	 ecx
  0004b	83 d2 00	 adc	 edx, 0
  0004e	f7 da		 neg	 edx
  00050	6a 00		 push	 0
  00052	6a 08		 push	 8
  00054	52		 push	 edx
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 __allmul
  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00061	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00067	8b 34 02	 mov	 esi, DWORD PTR [edx+eax]
  0006a	89 71 f8	 mov	 DWORD PTR [ecx-8], esi
  0006d	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  00071	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN2@P_pick:

; 1748 : }

  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007d	3b ec		 cmp	 ebp, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
_P_pick	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_rot
_TEXT	SEGMENT
_t$ = -12						; size = 8
_P_rot	PROC						; COMDAT

; 1751 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1752 :     stackitem t;
; 1753 : 
; 1754 :     Sl(3);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 03	 cmp	 eax, 3
  0002f	7d 07		 jge	 SHORT $LN1@P_rot
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 50		 jmp	 SHORT $LN2@P_rot
$LN1@P_rot:

; 1755 :     t = S0;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	89 4d f4	 mov	 DWORD PTR _t$[ebp], ecx
  00043	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00046	89 55 f8	 mov	 DWORD PTR _t$[ebp+4], edx

; 1756 :     S0 = S2;

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00054	8b 51 e8	 mov	 edx, DWORD PTR [ecx-24]
  00057	89 50 f8	 mov	 DWORD PTR [eax-8], edx
  0005a	8b 49 ec	 mov	 ecx, DWORD PTR [ecx-20]
  0005d	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 1757 :     S2 = S1;

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00065	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0006b	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  0006e	89 50 e8	 mov	 DWORD PTR [eax-24], edx
  00071	8b 49 f4	 mov	 ecx, DWORD PTR [ecx-12]
  00074	89 48 ec	 mov	 DWORD PTR [eax-20], ecx

; 1758 :     S1 = t;

  00077	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0007c	8b 4d f4	 mov	 ecx, DWORD PTR _t$[ebp]
  0007f	89 48 f0	 mov	 DWORD PTR [eax-16], ecx
  00082	8b 55 f8	 mov	 edx, DWORD PTR _t$[ebp+4]
  00085	89 50 f4	 mov	 DWORD PTR [eax-12], edx
$LN2@P_rot:

; 1759 : }

  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx
  0008b	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00091	3b ec		 cmp	 ebp, esp
  00093	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
_P_rot	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_minusrot
_TEXT	SEGMENT
_t$ = -12						; size = 8
_P_minusrot PROC					; COMDAT

; 1762 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1763 :     stackitem t;
; 1764 : 
; 1765 :     Sl(3);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 03	 cmp	 eax, 3
  0002f	7d 07		 jge	 SHORT $LN1@P_minusrot
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 50		 jmp	 SHORT $LN2@P_minusrot
$LN1@P_minusrot:

; 1766 :     t = S0;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	89 4d f4	 mov	 DWORD PTR _t$[ebp], ecx
  00043	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00046	89 55 f8	 mov	 DWORD PTR _t$[ebp+4], edx

; 1767 :     S0 = S1;

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00054	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  00057	89 50 f8	 mov	 DWORD PTR [eax-8], edx
  0005a	8b 49 f4	 mov	 ecx, DWORD PTR [ecx-12]
  0005d	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 1768 :     S1 = S2;

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00065	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0006b	8b 51 e8	 mov	 edx, DWORD PTR [ecx-24]
  0006e	89 50 f0	 mov	 DWORD PTR [eax-16], edx
  00071	8b 49 ec	 mov	 ecx, DWORD PTR [ecx-20]
  00074	89 48 f4	 mov	 DWORD PTR [eax-12], ecx

; 1769 :     S2 = t;

  00077	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0007c	8b 4d f4	 mov	 ecx, DWORD PTR _t$[ebp]
  0007f	89 48 e8	 mov	 DWORD PTR [eax-24], ecx
  00082	8b 55 f8	 mov	 edx, DWORD PTR _t$[ebp+4]
  00085	89 50 ec	 mov	 DWORD PTR [eax-20], edx
$LN2@P_minusrot:

; 1770 : }

  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx
  0008b	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00091	3b ec		 cmp	 ebp, esp
  00093	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
_P_minusrot ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_roll
_TEXT	SEGMENT
tv144 = -256						; size = 8
tv141 = -248						; size = 8
_t$ = -44						; size = 8
_j$ = -28						; size = 8
_i$ = -12						; size = 8
_P_roll	PROC						; COMDAT

; 1773 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 00 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-256]
  00012	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1774 :     stackitem i, j, t;
; 1775 : 
; 1776 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 0a		 jge	 SHORT $LN5@P_roll
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 3c 01 00 00	 jmp	 $LN6@P_roll
$LN5@P_roll:

; 1777 :     i = S0;

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00043	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
  00046	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00049	89 55 f8	 mov	 DWORD PTR _i$[ebp+4], edx

; 1778 :     Pop;

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00051	83 e8 08	 sub	 eax, 8
  00054	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1779 :     Sl(i + 1);

  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0005e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00064	c1 f8 03	 sar	 eax, 3
  00067	99		 cdq
  00068	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0006b	83 c1 01	 add	 ecx, 1
  0006e	8b 75 f8	 mov	 esi, DWORD PTR _i$[ebp+4]
  00071	83 d6 00	 adc	 esi, 0
  00074	89 85 08 ff ff
	ff		 mov	 DWORD PTR tv141[ebp], eax
  0007a	89 95 0c ff ff
	ff		 mov	 DWORD PTR tv141[ebp+4], edx
  00080	89 8d 00 ff ff
	ff		 mov	 DWORD PTR tv144[ebp], ecx
  00086	89 b5 04 ff ff
	ff		 mov	 DWORD PTR tv144[ebp+4], esi
  0008c	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR tv141[ebp+4]
  00092	3b 95 04 ff ff
	ff		 cmp	 edx, DWORD PTR tv144[ebp+4]
  00098	7f 1a		 jg	 SHORT $LN4@P_roll
  0009a	7c 0e		 jl	 SHORT $LN8@P_roll
  0009c	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR tv141[ebp]
  000a2	3b 85 00 ff ff
	ff		 cmp	 eax, DWORD PTR tv144[ebp]
  000a8	73 0a		 jae	 SHORT $LN4@P_roll
$LN8@P_roll:
  000aa	e8 00 00 00 00	 call	 _stakunder
  000af	e9 c3 00 00 00	 jmp	 $LN6@P_roll
$LN4@P_roll:

; 1780 :     t = stk[-(i + 1)];

  000b4	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000b7	83 c0 01	 add	 eax, 1
  000ba	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp+4]
  000bd	83 d1 00	 adc	 ecx, 0
  000c0	f7 d8		 neg	 eax
  000c2	83 d1 00	 adc	 ecx, 0
  000c5	f7 d9		 neg	 ecx
  000c7	6a 00		 push	 0
  000c9	6a 08		 push	 8
  000cb	51		 push	 ecx
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 __allmul
  000d2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  000d8	8b 0c 02	 mov	 ecx, DWORD PTR [edx+eax]
  000db	89 4d d4	 mov	 DWORD PTR _t$[ebp], ecx
  000de	8b 54 02 04	 mov	 edx, DWORD PTR [edx+eax+4]
  000e2	89 55 d8	 mov	 DWORD PTR _t$[ebp+4], edx

; 1781 :     for (j = -(i + 1); j < -1; j++)

  000e5	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000e8	83 c0 01	 add	 eax, 1
  000eb	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp+4]
  000ee	83 d1 00	 adc	 ecx, 0
  000f1	f7 d8		 neg	 eax
  000f3	83 d1 00	 adc	 ecx, 0
  000f6	f7 d9		 neg	 ecx
  000f8	89 45 e4	 mov	 DWORD PTR _j$[ebp], eax
  000fb	89 4d e8	 mov	 DWORD PTR _j$[ebp+4], ecx
  000fe	eb 12		 jmp	 SHORT $LN3@P_roll
$LN2@P_roll:
  00100	8b 45 e4	 mov	 eax, DWORD PTR _j$[ebp]
  00103	83 c0 01	 add	 eax, 1
  00106	8b 4d e8	 mov	 ecx, DWORD PTR _j$[ebp+4]
  00109	83 d1 00	 adc	 ecx, 0
  0010c	89 45 e4	 mov	 DWORD PTR _j$[ebp], eax
  0010f	89 4d e8	 mov	 DWORD PTR _j$[ebp+4], ecx
$LN3@P_roll:
  00112	83 7d e8 ff	 cmp	 DWORD PTR _j$[ebp+4], -1
  00116	7f 4e		 jg	 SHORT $LN1@P_roll
  00118	7c 06		 jl	 SHORT $LN9@P_roll
  0011a	83 7d e4 ff	 cmp	 DWORD PTR _j$[ebp], -1
  0011e	73 46		 jae	 SHORT $LN1@P_roll
$LN9@P_roll:

; 1782 : 	stk[j] = stk[j + 1];

  00120	8b 45 e4	 mov	 eax, DWORD PTR _j$[ebp]
  00123	83 c0 01	 add	 eax, 1
  00126	8b 4d e8	 mov	 ecx, DWORD PTR _j$[ebp+4]
  00129	83 d1 00	 adc	 ecx, 0
  0012c	6a 00		 push	 0
  0012e	6a 08		 push	 8
  00130	51		 push	 ecx
  00131	50		 push	 eax
  00132	e8 00 00 00 00	 call	 __allmul
  00137	8b f0		 mov	 esi, eax
  00139	6a 00		 push	 0
  0013b	6a 08		 push	 8
  0013d	8b 55 e8	 mov	 edx, DWORD PTR _j$[ebp+4]
  00140	52		 push	 edx
  00141	8b 45 e4	 mov	 eax, DWORD PTR _j$[ebp]
  00144	50		 push	 eax
  00145	e8 00 00 00 00	 call	 __allmul
  0014a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00150	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00156	8b 3c 32	 mov	 edi, DWORD PTR [edx+esi]
  00159	89 3c 01	 mov	 DWORD PTR [ecx+eax], edi
  0015c	8b 54 32 04	 mov	 edx, DWORD PTR [edx+esi+4]
  00160	89 54 01 04	 mov	 DWORD PTR [ecx+eax+4], edx
  00164	eb 9a		 jmp	 SHORT $LN2@P_roll
$LN1@P_roll:

; 1783 :     S0 = t;

  00166	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0016b	8b 4d d4	 mov	 ecx, DWORD PTR _t$[ebp]
  0016e	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  00171	8b 55 d8	 mov	 edx, DWORD PTR _t$[ebp+4]
  00174	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN6@P_roll:

; 1784 : }

  00177	5f		 pop	 edi
  00178	5e		 pop	 esi
  00179	5b		 pop	 ebx
  0017a	81 c4 00 01 00
	00		 add	 esp, 256		; 00000100H
  00180	3b ec		 cmp	 ebp, esp
  00182	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00187	8b e5		 mov	 esp, ebp
  00189	5d		 pop	 ebp
  0018a	c3		 ret	 0
_P_roll	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_rstacktop DD	01H DUP (?)
_rstk	DD	01H DUP (?)
; Function compile flags: /Odtp /RTCsu /ZI
_BSS	ENDS
;	COMDAT _P_tor
_TEXT	SEGMENT
_P_tor	PROC						; COMDAT

; 1787 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1788 :     Rso(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00023	83 c0 04	 add	 eax, 4
  00026	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _rstacktop
  0002c	76 07		 jbe	 SHORT $LN2@P_tor@2
  0002e	e8 00 00 00 00	 call	 _rstakover
  00033	eb 44		 jmp	 SHORT $LN3@P_tor@2
$LN2@P_tor@2:

; 1789 :     Sl(1);

  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003a	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00040	c1 f8 03	 sar	 eax, 3
  00043	83 f8 01	 cmp	 eax, 1
  00046	7d 07		 jge	 SHORT $LN1@P_tor@2
  00048	e8 00 00 00 00	 call	 _stakunder
  0004d	eb 2a		 jmp	 SHORT $LN3@P_tor@2
$LN1@P_tor@2:

; 1790 :     Rpush = (rstackitem) S0;

  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00054	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00057	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  0005d	89 0a		 mov	 DWORD PTR [edx], ecx
  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00064	83 c0 04	 add	 eax, 4
  00067	a3 00 00 00 00	 mov	 DWORD PTR _rstk, eax

; 1791 :     Pop;

  0006c	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00071	83 e8 08	 sub	 eax, 8
  00074	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN3@P_tor@2:

; 1792 : }

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00082	3b ec		 cmp	 ebp, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
_P_tor	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_rfrom
_TEXT	SEGMENT
_P_rfrom PROC						; COMDAT

; 1795 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1796 :     Rsl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _rstack
  00029	c1 f8 02	 sar	 eax, 2
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN2@P_rfrom
  00031	e8 00 00 00 00	 call	 _rstakunder
  00036	eb 47		 jmp	 SHORT $LN3@P_rfrom
$LN2@P_rfrom:

; 1797 :     So(1);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	83 c0 08	 add	 eax, 8
  00040	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00046	76 07		 jbe	 SHORT $LN1@P_rfrom
  00048	e8 00 00 00 00	 call	 _stakover
  0004d	eb 30		 jmp	 SHORT $LN3@P_rfrom
$LN1@P_rfrom:

; 1798 :     Push = (stackitem) R0;

  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00054	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00057	99		 cdq
  00058	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0005e	89 01		 mov	 DWORD PTR [ecx], eax
  00060	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00063	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00069	83 c2 08	 add	 edx, 8
  0006c	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 1799 :     Rpop;

  00072	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00077	83 e8 04	 sub	 eax, 4
  0007a	a3 00 00 00 00	 mov	 DWORD PTR _rstk, eax
$LN3@P_rfrom:

; 1800 : }

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00088	3b ec		 cmp	 ebp, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
_P_rfrom ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_rfetch
_TEXT	SEGMENT
_P_rfetch PROC						; COMDAT

; 1803 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1804 :     Rsl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _rstack
  00029	c1 f8 02	 sar	 eax, 2
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN2@P_rfetch
  00031	e8 00 00 00 00	 call	 _rstakunder
  00036	eb 3a		 jmp	 SHORT $LN3@P_rfetch
$LN2@P_rfetch:

; 1805 :     So(1);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	83 c0 08	 add	 eax, 8
  00040	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00046	76 07		 jbe	 SHORT $LN1@P_rfetch
  00048	e8 00 00 00 00	 call	 _stakover
  0004d	eb 23		 jmp	 SHORT $LN3@P_rfetch
$LN1@P_rfetch:

; 1806 :     Push = (stackitem) R0;

  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00054	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00057	99		 cdq
  00058	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0005e	89 01		 mov	 DWORD PTR [ecx], eax
  00060	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00063	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00069	83 c2 08	 add	 edx, 8
  0006c	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN3@P_rfetch:

; 1807 : }

  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_P_rfetch ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_2dup
_TEXT	SEGMENT
_s$ = -12						; size = 8
_P_2dup	PROC						; COMDAT

; 1814 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1815 :     stackitem s;
; 1816 : 
; 1817 :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN2@P_2dup
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 73		 jmp	 SHORT $LN3@P_2dup
$LN2@P_2dup:

; 1818 :     So(2);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	83 c0 10	 add	 eax, 16			; 00000010H
  00040	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00046	76 07		 jbe	 SHORT $LN1@P_2dup
  00048	e8 00 00 00 00	 call	 _stakover
  0004d	eb 5c		 jmp	 SHORT $LN3@P_2dup
$LN1@P_2dup:

; 1819 :     s = S1;

  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00054	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00057	89 4d f4	 mov	 DWORD PTR _s$[ebp], ecx
  0005a	8b 50 f4	 mov	 edx, DWORD PTR [eax-12]
  0005d	89 55 f8	 mov	 DWORD PTR _s$[ebp+4], edx

; 1820 :     Push = s;

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00065	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  00068	89 08		 mov	 DWORD PTR [eax], ecx
  0006a	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp+4]
  0006d	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00070	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00075	83 c0 08	 add	 eax, 8
  00078	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1821 :     s = S1;

  0007d	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00082	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00085	89 4d f4	 mov	 DWORD PTR _s$[ebp], ecx
  00088	8b 50 f4	 mov	 edx, DWORD PTR [eax-12]
  0008b	89 55 f8	 mov	 DWORD PTR _s$[ebp+4], edx

; 1822 :     Push = s;

  0008e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00093	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  00096	89 08		 mov	 DWORD PTR [eax], ecx
  00098	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp+4]
  0009b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0009e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000a3	83 c0 08	 add	 eax, 8
  000a6	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN3@P_2dup:

; 1823 : }

  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx
  000ae	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000b4	3b ec		 cmp	 ebp, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
_P_2dup	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_2drop
_TEXT	SEGMENT
_P_2drop PROC						; COMDAT

; 1826 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1827 :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN1@P_2drop
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 0d		 jmp	 SHORT $LN2@P_2drop
$LN1@P_2drop:

; 1828 :     stk -= 2;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	83 e8 10	 sub	 eax, 16			; 00000010H
  00040	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_2drop:

; 1829 : }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004e	3b ec		 cmp	 ebp, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
_P_2drop ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_2swap
_TEXT	SEGMENT
_t$ = -12						; size = 8
_P_2swap PROC						; COMDAT

; 1832 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1833 :     stackitem t;
; 1834 : 
; 1835 :     Sl(4);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 04	 cmp	 eax, 4
  0002f	7d 07		 jge	 SHORT $LN1@P_2swap
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 72		 jmp	 SHORT $LN2@P_2swap
$LN1@P_2swap:

; 1836 :     t = S2;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 e8	 mov	 ecx, DWORD PTR [eax-24]
  00040	89 4d f4	 mov	 DWORD PTR _t$[ebp], ecx
  00043	8b 50 ec	 mov	 edx, DWORD PTR [eax-20]
  00046	89 55 f8	 mov	 DWORD PTR _t$[ebp+4], edx

; 1837 :     S2 = S0;

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00054	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  00057	89 50 e8	 mov	 DWORD PTR [eax-24], edx
  0005a	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0005d	89 48 ec	 mov	 DWORD PTR [eax-20], ecx

; 1838 :     S0 = t;

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00065	8b 4d f4	 mov	 ecx, DWORD PTR _t$[ebp]
  00068	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  0006b	8b 55 f8	 mov	 edx, DWORD PTR _t$[ebp+4]
  0006e	89 50 fc	 mov	 DWORD PTR [eax-4], edx

; 1839 :     t = S3;

  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00076	8b 48 e0	 mov	 ecx, DWORD PTR [eax-32]
  00079	89 4d f4	 mov	 DWORD PTR _t$[ebp], ecx
  0007c	8b 50 e4	 mov	 edx, DWORD PTR [eax-28]
  0007f	89 55 f8	 mov	 DWORD PTR _t$[ebp+4], edx

; 1840 :     S3 = S1;

  00082	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00087	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0008d	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  00090	89 50 e0	 mov	 DWORD PTR [eax-32], edx
  00093	8b 49 f4	 mov	 ecx, DWORD PTR [ecx-12]
  00096	89 48 e4	 mov	 DWORD PTR [eax-28], ecx

; 1841 :     S1 = t;

  00099	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR _t$[ebp]
  000a1	89 48 f0	 mov	 DWORD PTR [eax-16], ecx
  000a4	8b 55 f8	 mov	 edx, DWORD PTR _t$[ebp+4]
  000a7	89 50 f4	 mov	 DWORD PTR [eax-12], edx
$LN2@P_2swap:

; 1842 : }

  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000b3	3b ec		 cmp	 ebp, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
_P_2swap ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_2over
_TEXT	SEGMENT
_s$ = -12						; size = 8
_P_2over PROC						; COMDAT

; 1845 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1846 :     stackitem s;
; 1847 : 
; 1848 :     Sl(4);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 04	 cmp	 eax, 4
  0002f	7d 07		 jge	 SHORT $LN2@P_2over
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 73		 jmp	 SHORT $LN3@P_2over
$LN2@P_2over:

; 1849 :     So(2);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	83 c0 10	 add	 eax, 16			; 00000010H
  00040	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00046	76 07		 jbe	 SHORT $LN1@P_2over
  00048	e8 00 00 00 00	 call	 _stakover
  0004d	eb 5c		 jmp	 SHORT $LN3@P_2over
$LN1@P_2over:

; 1850 :     s = S3;

  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00054	8b 48 e0	 mov	 ecx, DWORD PTR [eax-32]
  00057	89 4d f4	 mov	 DWORD PTR _s$[ebp], ecx
  0005a	8b 50 e4	 mov	 edx, DWORD PTR [eax-28]
  0005d	89 55 f8	 mov	 DWORD PTR _s$[ebp+4], edx

; 1851 :     Push = s;

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00065	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  00068	89 08		 mov	 DWORD PTR [eax], ecx
  0006a	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp+4]
  0006d	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00070	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00075	83 c0 08	 add	 eax, 8
  00078	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1852 :     s = S3;

  0007d	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00082	8b 48 e0	 mov	 ecx, DWORD PTR [eax-32]
  00085	89 4d f4	 mov	 DWORD PTR _s$[ebp], ecx
  00088	8b 50 e4	 mov	 edx, DWORD PTR [eax-28]
  0008b	89 55 f8	 mov	 DWORD PTR _s$[ebp+4], edx

; 1853 :     Push = s;

  0008e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00093	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  00096	89 08		 mov	 DWORD PTR [eax], ecx
  00098	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp+4]
  0009b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0009e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000a3	83 c0 08	 add	 eax, 8
  000a6	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN3@P_2over:

; 1854 : }

  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx
  000ae	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000b4	3b ec		 cmp	 ebp, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
_P_2over ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_2rot
_TEXT	SEGMENT
_t2$ = -28						; size = 8
_t1$ = -12						; size = 8
_P_2rot	PROC						; COMDAT

; 1857 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00012	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1858 :     stackitem t1, t2;
; 1859 : 
; 1860 :     Sl(6);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 06	 cmp	 eax, 6
  0002f	7d 0a		 jge	 SHORT $LN1@P_2rot
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 a0 00 00 00	 jmp	 $LN2@P_2rot
$LN1@P_2rot:

; 1861 :     t2 = S5;

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	8b 48 d0	 mov	 ecx, DWORD PTR [eax-48]
  00043	89 4d e4	 mov	 DWORD PTR _t2$[ebp], ecx
  00046	8b 50 d4	 mov	 edx, DWORD PTR [eax-44]
  00049	89 55 e8	 mov	 DWORD PTR _t2$[ebp+4], edx

; 1862 :     t1 = S4;

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00051	8b 48 d8	 mov	 ecx, DWORD PTR [eax-40]
  00054	89 4d f4	 mov	 DWORD PTR _t1$[ebp], ecx
  00057	8b 50 dc	 mov	 edx, DWORD PTR [eax-36]
  0005a	89 55 f8	 mov	 DWORD PTR _t1$[ebp+4], edx

; 1863 :     S5 = S3;

  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00068	8b 51 e0	 mov	 edx, DWORD PTR [ecx-32]
  0006b	89 50 d0	 mov	 DWORD PTR [eax-48], edx
  0006e	8b 49 e4	 mov	 ecx, DWORD PTR [ecx-28]
  00071	89 48 d4	 mov	 DWORD PTR [eax-44], ecx

; 1864 :     S4 = S2;

  00074	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00079	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0007f	8b 51 e8	 mov	 edx, DWORD PTR [ecx-24]
  00082	89 50 d8	 mov	 DWORD PTR [eax-40], edx
  00085	8b 49 ec	 mov	 ecx, DWORD PTR [ecx-20]
  00088	89 48 dc	 mov	 DWORD PTR [eax-36], ecx

; 1865 :     S3 = S1;

  0008b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00090	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00096	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  00099	89 50 e0	 mov	 DWORD PTR [eax-32], edx
  0009c	8b 49 f4	 mov	 ecx, DWORD PTR [ecx-12]
  0009f	89 48 e4	 mov	 DWORD PTR [eax-28], ecx

; 1866 :     S2 = S0;

  000a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  000ad	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  000b0	89 50 e8	 mov	 DWORD PTR [eax-24], edx
  000b3	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  000b6	89 48 ec	 mov	 DWORD PTR [eax-20], ecx

; 1867 :     S1 = t2;

  000b9	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000be	8b 4d e4	 mov	 ecx, DWORD PTR _t2$[ebp]
  000c1	89 48 f0	 mov	 DWORD PTR [eax-16], ecx
  000c4	8b 55 e8	 mov	 edx, DWORD PTR _t2$[ebp+4]
  000c7	89 50 f4	 mov	 DWORD PTR [eax-12], edx

; 1868 :     S0 = t1;

  000ca	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000cf	8b 4d f4	 mov	 ecx, DWORD PTR _t1$[ebp]
  000d2	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  000d5	8b 55 f8	 mov	 edx, DWORD PTR _t1$[ebp+4]
  000d8	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_2rot:

; 1869 : }

  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx
  000de	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  000e4	3b ec		 cmp	 ebp, esp
  000e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
_P_2rot	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_2variable
_TEXT	SEGMENT
_P_2variable PROC					; COMDAT

; 1872 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1873 :     P_create(); 		      /* Create dictionary item */

  0001e	e8 00 00 00 00	 call	 _P_create

; 1874 :     Ho(2);

  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00028	83 c0 10	 add	 eax, 16			; 00000010H
  0002b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00031	76 07		 jbe	 SHORT $LN1@P_2variabl
  00033	e8 00 00 00 00	 call	 _heapover
  00038	eb 42		 jmp	 SHORT $LN2@P_2variabl
$LN1@P_2variabl:

; 1875 :     Hstore = 0; 		      /* Initial value = 0... */

  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0003f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00045	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  00052	83 c1 08	 add	 ecx, 8
  00055	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx

; 1876 :     Hstore = 0; 		      /* ...in both words */

  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00060	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00066	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  00073	83 c1 08	 add	 ecx, 8
  00076	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx
$LN2@P_2variabl:

; 1877 : }

  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00085	3b ec		 cmp	 ebp, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
_P_2variable ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_2constant
_TEXT	SEGMENT
_P_2constant PROC					; COMDAT

; 1887 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1888 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN2@P_2constan
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 7f		 jmp	 SHORT $LN3@P_2constan
$LN2@P_2constan:

; 1889 :     P_create(); 		      /* Create dictionary item */

  00038	e8 00 00 00 00	 call	 _P_create

; 1890 :     createword->wcode = P_2con;       /* Set code to constant push */

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR _createword
  00042	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _P_2con

; 1891 :     Ho(2);

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0004e	83 c0 10	 add	 eax, 16			; 00000010H
  00051	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00057	76 07		 jbe	 SHORT $LN1@P_2constan
  00059	e8 00 00 00 00	 call	 _heapover
  0005e	eb 57		 jmp	 SHORT $LN3@P_2constan
$LN1@P_2constan:

; 1892 :     Hstore = S1;		      /* Store double word constant value */

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00065	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0006b	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  0006e	89 10		 mov	 DWORD PTR [eax], edx
  00070	8b 49 f4	 mov	 ecx, DWORD PTR [ecx-12]
  00073	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00076	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  0007c	83 c2 08	 add	 edx, 8
  0007f	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 1893 :     Hstore = S0;		      /* in the two words of body */

  00085	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0008a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00090	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  00093	89 10		 mov	 DWORD PTR [eax], edx
  00095	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00098	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0009b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  000a1	83 c2 08	 add	 edx, 8
  000a4	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 1894 :     Pop2;

  000aa	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000af	83 e8 10	 sub	 eax, 16			; 00000010H
  000b2	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN3@P_2constan:

; 1895 : }

  000b7	5f		 pop	 edi
  000b8	5e		 pop	 esi
  000b9	5b		 pop	 ebx
  000ba	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000c0	3b ec		 cmp	 ebp, esp
  000c2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
_P_2constant ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_2con
_TEXT	SEGMENT
_P_2con	PROC						; COMDAT

; 1880 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1881 :     So(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	83 c0 10	 add	 eax, 16			; 00000010H
  00026	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  0002c	76 07		 jbe	 SHORT $LN1@P_2con
  0002e	e8 00 00 00 00	 call	 _stakover
  00033	eb 4a		 jmp	 SHORT $LN2@P_2con
$LN1@P_2con:

; 1882 :     Push = *(((stackitem *) curword) + Dictwordl);

  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _curword
  00040	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00043	89 10		 mov	 DWORD PTR [eax], edx
  00045	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00048	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0004b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00051	83 c2 08	 add	 edx, 8
  00054	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 1883 :     Push = *(((stackitem *) curword) + Dictwordl + 1);

  0005a	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0005f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _curword
  00065	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00068	89 10		 mov	 DWORD PTR [eax], edx
  0006a	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0006d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00070	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00076	83 c2 08	 add	 edx, 8
  00079	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN2@P_2con:

; 1884 : }

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00088	3b ec		 cmp	 ebp, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
_P_2con	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_2bang
_TEXT	SEGMENT
_sp$ = -8						; size = 4
_P_2bang PROC						; COMDAT

; 1898 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1899 :     stackitem *sp;
; 1900 : 
; 1901 :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN3@P_2bang
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 70		 jmp	 SHORT $LN4@P_2bang
$LN3@P_2bang:

; 1902 :     Hpc(S0);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00046	72 10		 jb	 SHORT $LN1@P_2bang
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00050	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00056	72 07		 jb	 SHORT $LN2@P_2bang
$LN1@P_2bang:
  00058	e8 00 00 00 00	 call	 _badpointer
  0005d	eb 49		 jmp	 SHORT $LN4@P_2bang
$LN2@P_2bang:

; 1903 :     sp = (stackitem *) S0;

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00064	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00067	89 4d f8	 mov	 DWORD PTR _sp$[ebp], ecx

; 1904 :     *sp++ = S2;

  0006a	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00073	8b 51 e8	 mov	 edx, DWORD PTR [ecx-24]
  00076	89 10		 mov	 DWORD PTR [eax], edx
  00078	8b 49 ec	 mov	 ecx, DWORD PTR [ecx-20]
  0007b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0007e	8b 55 f8	 mov	 edx, DWORD PTR _sp$[ebp]
  00081	83 c2 08	 add	 edx, 8
  00084	89 55 f8	 mov	 DWORD PTR _sp$[ebp], edx

; 1905 :     *sp = S1;

  00087	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  0008a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00090	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  00093	89 10		 mov	 DWORD PTR [eax], edx
  00095	8b 49 f4	 mov	 ecx, DWORD PTR [ecx-12]
  00098	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1906 :     Npop(3);

  0009b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000a0	83 e8 18	 sub	 eax, 24			; 00000018H
  000a3	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN4@P_2bang:

; 1907 : }

  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	5b		 pop	 ebx
  000ab	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000b1	3b ec		 cmp	 ebp, esp
  000b3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c3		 ret	 0
_P_2bang ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_2at
_TEXT	SEGMENT
_sp$ = -8						; size = 4
_P_2at	PROC						; COMDAT

; 1910 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1911 :     stackitem *sp;
; 1912 : 
; 1913 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 0a		 jge	 SHORT $LN4@P_2at
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 86 00 00 00	 jmp	 $LN5@P_2at
$LN4@P_2at:

; 1914 :     So(1);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	83 c0 08	 add	 eax, 8
  00043	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00049	76 07		 jbe	 SHORT $LN3@P_2at
  0004b	e8 00 00 00 00	 call	 _stakover
  00050	eb 6f		 jmp	 SHORT $LN5@P_2at
$LN3@P_2at:

; 1915 :     Hpc(S0);

  00052	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00057	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0005a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00060	72 10		 jb	 SHORT $LN1@P_2at
  00062	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00067	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0006a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00070	72 07		 jb	 SHORT $LN2@P_2at
$LN1@P_2at:
  00072	e8 00 00 00 00	 call	 _badpointer
  00077	eb 48		 jmp	 SHORT $LN5@P_2at
$LN2@P_2at:

; 1916 :     sp = (stackitem *) S0;

  00079	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0007e	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00081	89 4d f8	 mov	 DWORD PTR _sp$[ebp], ecx

; 1917 :     S0 = *sp++;

  00084	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00089	8b 4d f8	 mov	 ecx, DWORD PTR _sp$[ebp]
  0008c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008e	89 50 f8	 mov	 DWORD PTR [eax-8], edx
  00091	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00094	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
  00097	8b 55 f8	 mov	 edx, DWORD PTR _sp$[ebp]
  0009a	83 c2 08	 add	 edx, 8
  0009d	89 55 f8	 mov	 DWORD PTR _sp$[ebp], edx

; 1918 :     Push = *sp;

  000a0	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000a5	8b 4d f8	 mov	 ecx, DWORD PTR _sp$[ebp]
  000a8	8b 11		 mov	 edx, DWORD PTR [ecx]
  000aa	89 10		 mov	 DWORD PTR [eax], edx
  000ac	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000af	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000b2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  000b8	83 c2 08	 add	 edx, 8
  000bb	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN5@P_2at:

; 1919 : }

  000c1	5f		 pop	 edi
  000c2	5e		 pop	 esi
  000c3	5b		 pop	 ebx
  000c4	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000ca	3b ec		 cmp	 ebp, esp
  000cc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
_P_2at	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_dolit
_TEXT	SEGMENT
_P_dolit PROC						; COMDAT

; 1925 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1926 :     So(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	83 c0 08	 add	 eax, 8
  00026	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  0002c	76 07		 jbe	 SHORT $LN2@P_dolit
  0002e	e8 00 00 00 00	 call	 _stakover
  00033	eb 5b		 jmp	 SHORT $LN3@P_dolit
$LN2@P_dolit:

; 1927 : #ifdef TRACE
; 1928 :     if (atl_trace) {

  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_trace
  0003a	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _atl_trace+4
  00040	74 1f		 je	 SHORT $LN1@P_dolit

; 1929 :         V printf("%ld ", (long) *ip);

  00042	8b f4		 mov	 esi, esp
  00044	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	51		 push	 ecx
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_04JLFGKHHD@?$CFld?5?$AA@
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00057	83 c4 08	 add	 esp, 8
  0005a	3b f4		 cmp	 esi, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@P_dolit:

; 1930 :     }
; 1931 : #endif
; 1932 :     Push = (stackitem) *ip++;	      /* Push the next datum from the

  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  00066	8b 00		 mov	 eax, DWORD PTR [eax]
  00068	99		 cdq
  00069	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0006f	89 01		 mov	 DWORD PTR [ecx], eax
  00071	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00074	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0007a	83 c2 08	 add	 edx, 8
  0007d	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
  00083	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  00088	83 c0 04	 add	 eax, 4
  0008b	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax
$LN3@P_dolit:

; 1933 : 					 instruction stream. */
; 1934 : }

  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00099	3b ec		 cmp	 ebp, esp
  0009b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
_P_dolit ENDP
_TEXT	ENDS
_BSS	SEGMENT
_wbptr	DD	01H DUP (?)
; Function compile flags: /Odtp /RTCsu /ZI
_BSS	ENDS
;	COMDAT _P_nest
_TEXT	SEGMENT
_P_nest	PROC						; COMDAT

; 1939 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1940 :     Rso(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00023	83 c0 04	 add	 eax, 4
  00026	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _rstacktop
  0002c	76 07		 jbe	 SHORT $LN1@P_nest
  0002e	e8 00 00 00 00	 call	 _rstakover
  00033	eb 45		 jmp	 SHORT $LN2@P_nest
$LN1@P_nest:

; 1941 : #ifdef WALKBACK
; 1942 :     *wbptr++ = curword; 	      /* Place word on walkback stack */

  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR _wbptr
  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _curword
  00040	89 08		 mov	 DWORD PTR [eax], ecx
  00042	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _wbptr
  00048	83 c2 04	 add	 edx, 4
  0004b	89 15 00 00 00
	00		 mov	 DWORD PTR _wbptr, edx

; 1943 : #endif
; 1944 :     Rpush = ip; 		      /* Push instruction pointer */

  00051	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ip
  0005c	89 08		 mov	 DWORD PTR [eax], ecx
  0005e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  00064	83 c2 04	 add	 edx, 4
  00067	89 15 00 00 00
	00		 mov	 DWORD PTR _rstk, edx

; 1945 :     ip = (((dictword **) curword) + Dictwordl);

  0006d	a1 00 00 00 00	 mov	 eax, DWORD PTR _curword
  00072	83 c0 08	 add	 eax, 8
  00075	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax
$LN2@P_nest:

; 1946 : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
_P_nest	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_exit
_TEXT	SEGMENT
tv69 = -196						; size = 4
_P_exit	PROC						; COMDAT

; 1949 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1950 :     Rsl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _rstack
  00029	c1 f8 02	 sar	 eax, 2
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_exit
  00031	e8 00 00 00 00	 call	 _rstakunder
  00036	eb 50		 jmp	 SHORT $LN2@P_exit
$LN1@P_exit:

; 1951 : #ifdef WALKBACK
; 1952 :     wbptr = (wbptr > wback) ? wbptr - 1 : wback;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _wbptr
  0003d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _wback
  00043	76 11		 jbe	 SHORT $LN4@P_exit
  00045	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _wbptr
  0004b	83 e9 04	 sub	 ecx, 4
  0004e	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv69[ebp], ecx
  00054	eb 0c		 jmp	 SHORT $LN5@P_exit
$LN4@P_exit:
  00056	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _wback
  0005c	89 95 3c ff ff
	ff		 mov	 DWORD PTR tv69[ebp], edx
$LN5@P_exit:
  00062	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv69[ebp]
  00068	a3 00 00 00 00	 mov	 DWORD PTR _wbptr, eax

; 1953 : #endif
; 1954 :     ip = R0;			      /* Set IP to top of return stack */

  0006d	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00072	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00075	89 0d 00 00 00
	00		 mov	 DWORD PTR _ip, ecx

; 1955 :     Rpop;

  0007b	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00080	83 e8 04	 sub	 eax, 4
  00083	a3 00 00 00 00	 mov	 DWORD PTR _rstk, eax
$LN2@P_exit:

; 1956 : }

  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx
  0008b	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00091	3b ec		 cmp	 ebp, esp
  00093	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
_P_exit	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_branch
_TEXT	SEGMENT
_P_branch PROC						; COMDAT

; 1959 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1960 :     ip += (stackitem) *ip;	      /* Jump addresses are IP-relative */

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
  00025	99		 cdq
  00026	6a 00		 push	 0
  00028	6a 04		 push	 4
  0002a	52		 push	 edx
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 __allmul
  00031	03 05 00 00 00
	00		 add	 eax, DWORD PTR _ip
  00037	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax

; 1961 : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_P_branch ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_qbranch
_TEXT	SEGMENT
tv77 = -196						; size = 4
_P_qbranch PROC						; COMDAT

; 1964 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1965 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN3@P_qbranch
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 59		 jmp	 SHORT $LN4@P_qbranch
$LN3@P_qbranch:

; 1966 :     if (S0 == 0)		      /* If flag is false */

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv77[ebp], eax
  00043	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv77[ebp]
  00049	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv77[ebp]
  0004f	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00052	0b 42 fc	 or	 eax, DWORD PTR [edx-4]
  00055	75 20		 jne	 SHORT $LN2@P_qbranch

; 1967 : 	ip += (stackitem) *ip;	      /* then branch. */

  00057	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  0005c	8b 00		 mov	 eax, DWORD PTR [eax]
  0005e	99		 cdq
  0005f	6a 00		 push	 0
  00061	6a 04		 push	 4
  00063	52		 push	 edx
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 __allmul
  0006a	03 05 00 00 00
	00		 add	 eax, DWORD PTR _ip
  00070	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax

; 1968 :     else			      /* Otherwise */

  00075	eb 0d		 jmp	 SHORT $LN1@P_qbranch
$LN2@P_qbranch:

; 1969 : 	ip++;			      /* skip the in-line address. */

  00077	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  0007c	83 c0 04	 add	 eax, 4
  0007f	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax
$LN1@P_qbranch:

; 1970 :     Pop;

  00084	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00089	83 e8 08	 sub	 eax, 8
  0008c	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN4@P_qbranch:

; 1971 : }

  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx
  00094	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0009a	3b ec		 cmp	 ebp, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
_P_qbranch ENDP
_TEXT	ENDS
_BSS	SEGMENT
	ALIGN	8

_s_qbranch DQ	01H DUP (?)
; Function compile flags: /Odtp /RTCsu /ZI
_BSS	ENDS
;	COMDAT _P_if
_TEXT	SEGMENT
tv76 = -196						; size = 4
_P_if	PROC						; COMDAT

; 1974 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1975 :     Compiling;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv76[ebp], eax
  00029	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv76[ebp]
  0002f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv76[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	75 0a		 jne	 SHORT $LN4@P_if
  0003c	e8 00 00 00 00	 call	 _notcomp
  00041	e9 ac 00 00 00	 jmp	 $LN5@P_if
$LN4@P_if:

; 1976 :     Compconst(s_qbranch);	      /* Compile question branch */

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0004b	83 c0 08	 add	 eax, 8
  0004e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00054	76 0a		 jbe	 SHORT $LN3@P_if
  00056	e8 00 00 00 00	 call	 _heapover
  0005b	e9 92 00 00 00	 jmp	 $LN5@P_if
$LN3@P_if:
  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00065	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_qbranch
  0006b	89 08		 mov	 DWORD PTR [eax], ecx
  0006d	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_qbranch+4
  00073	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00076	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0007b	83 c0 08	 add	 eax, 8
  0007e	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 1977 :     So(1);

  00083	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00088	83 c0 08	 add	 eax, 8
  0008b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00091	76 07		 jbe	 SHORT $LN2@P_if
  00093	e8 00 00 00 00	 call	 _stakover
  00098	eb 58		 jmp	 SHORT $LN5@P_if
$LN2@P_if:

; 1978 :     Push = (stackitem) hptr;	      /* Save backpatch address on stack */

  0009a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0009f	99		 cdq
  000a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  000a6	89 01		 mov	 DWORD PTR [ecx], eax
  000a8	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  000ab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  000b1	83 c2 08	 add	 edx, 8
  000b4	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 1979 :     Compconst(0);		      /* Compile place-holder address cell */

  000ba	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000bf	83 c0 08	 add	 eax, 8
  000c2	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  000c8	76 07		 jbe	 SHORT $LN1@P_if
  000ca	e8 00 00 00 00	 call	 _heapover
  000cf	eb 21		 jmp	 SHORT $LN5@P_if
$LN1@P_if:
  000d1	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000d6	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000dc	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  000e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  000e9	83 c1 08	 add	 ecx, 8
  000ec	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx
$LN5@P_if:

; 1980 : }

  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
  000f4	5b		 pop	 ebx
  000f5	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  000fb	3b ec		 cmp	 ebp, esp
  000fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c3		 ret	 0
_P_if	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_branch DQ	01H DUP (?)
; Function compile flags: /Odtp /RTCsu /ZI
_BSS	ENDS
;	COMDAT _P_else
_TEXT	SEGMENT
tv89 = -208						; size = 4
_bp$ = -8						; size = 4
_P_else	PROC						; COMDAT

; 1983 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1984 :     stackitem *bp;
; 1985 : 
; 1986 :     Compiling;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv89[ebp], eax
  00029	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv89[ebp]
  0002f	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR tv89[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	75 0a		 jne	 SHORT $LN6@P_else
  0003c	e8 00 00 00 00	 call	 _notcomp
  00041	e9 ed 00 00 00	 jmp	 $LN7@P_else
$LN6@P_else:

; 1987 :     Sl(1);

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00051	c1 f8 03	 sar	 eax, 3
  00054	83 f8 01	 cmp	 eax, 1
  00057	7d 0a		 jge	 SHORT $LN5@P_else
  00059	e8 00 00 00 00	 call	 _stakunder
  0005e	e9 d0 00 00 00	 jmp	 $LN7@P_else
$LN5@P_else:

; 1988 :     Compconst(s_branch);	      /* Compile branch around other clause */

  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00068	83 c0 08	 add	 eax, 8
  0006b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00071	76 0a		 jbe	 SHORT $LN4@P_else
  00073	e8 00 00 00 00	 call	 _heapover
  00078	e9 b6 00 00 00	 jmp	 $LN7@P_else
$LN4@P_else:
  0007d	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00082	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_branch
  00088	89 08		 mov	 DWORD PTR [eax], ecx
  0008a	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_branch+4
  00090	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00093	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00098	83 c0 08	 add	 eax, 8
  0009b	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 1989 :     Compconst(0);		      /* Compile place-holder address cell */

  000a0	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000a5	83 c0 08	 add	 eax, 8
  000a8	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  000ae	76 07		 jbe	 SHORT $LN3@P_else
  000b0	e8 00 00 00 00	 call	 _heapover
  000b5	eb 7c		 jmp	 SHORT $LN7@P_else
$LN3@P_else:
  000b7	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000bc	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000c2	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  000c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  000cf	83 c1 08	 add	 ecx, 8
  000d2	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx

; 1990 :     Hpc(S0);

  000d8	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000dd	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000e0	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  000e6	72 10		 jb	 SHORT $LN1@P_else
  000e8	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000ed	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000f0	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  000f6	72 07		 jb	 SHORT $LN2@P_else
$LN1@P_else:
  000f8	e8 00 00 00 00	 call	 _badpointer
  000fd	eb 34		 jmp	 SHORT $LN7@P_else
$LN2@P_else:

; 1991 :     bp = (stackitem *) S0;	      /* Get IF backpatch address */

  000ff	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00104	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00107	89 4d f8	 mov	 DWORD PTR _bp$[ebp], ecx

; 1992 :     *bp = hptr - bp;

  0010a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0010f	2b 45 f8	 sub	 eax, DWORD PTR _bp$[ebp]
  00112	c1 f8 03	 sar	 eax, 3
  00115	99		 cdq
  00116	8b 4d f8	 mov	 ecx, DWORD PTR _bp$[ebp]
  00119	89 01		 mov	 DWORD PTR [ecx], eax
  0011b	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 1993 :     S0 = (stackitem) (hptr - 1);      /* Update backpatch for THEN */

  0011e	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00123	83 e8 08	 sub	 eax, 8
  00126	99		 cdq
  00127	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0012d	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  00130	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN7@P_else:

; 1994 : }

  00133	5f		 pop	 edi
  00134	5e		 pop	 esi
  00135	5b		 pop	 ebx
  00136	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0013c	3b ec		 cmp	 ebp, esp
  0013e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00143	8b e5		 mov	 esp, ebp
  00145	5d		 pop	 ebp
  00146	c3		 ret	 0
_P_else	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_then
_TEXT	SEGMENT
tv81 = -208						; size = 4
_bp$ = -8						; size = 4
_P_then	PROC						; COMDAT

; 1997 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1998 :     stackitem *bp;
; 1999 : 
; 2000 :     Compiling;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv81[ebp], eax
  00029	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv81[ebp]
  0002f	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR tv81[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	75 07		 jne	 SHORT $LN4@P_then
  0003c	e8 00 00 00 00	 call	 _notcomp
  00041	eb 6d		 jmp	 SHORT $LN5@P_then
$LN4@P_then:

; 2001 :     Sl(1);

  00043	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00048	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0004e	c1 f8 03	 sar	 eax, 3
  00051	83 f8 01	 cmp	 eax, 1
  00054	7d 07		 jge	 SHORT $LN3@P_then
  00056	e8 00 00 00 00	 call	 _stakunder
  0005b	eb 53		 jmp	 SHORT $LN5@P_then
$LN3@P_then:

; 2002 :     Hpc(S0);

  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00062	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00065	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  0006b	72 10		 jb	 SHORT $LN1@P_then
  0006d	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00072	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00075	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  0007b	72 07		 jb	 SHORT $LN2@P_then
$LN1@P_then:
  0007d	e8 00 00 00 00	 call	 _badpointer
  00082	eb 2c		 jmp	 SHORT $LN5@P_then
$LN2@P_then:

; 2003 :     bp = (stackitem *) S0;	      /* Get IF/ELSE backpatch address */

  00084	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00089	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0008c	89 4d f8	 mov	 DWORD PTR _bp$[ebp], ecx

; 2004 :     *bp = hptr - bp;

  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00094	2b 45 f8	 sub	 eax, DWORD PTR _bp$[ebp]
  00097	c1 f8 03	 sar	 eax, 3
  0009a	99		 cdq
  0009b	8b 4d f8	 mov	 ecx, DWORD PTR _bp$[ebp]
  0009e	89 01		 mov	 DWORD PTR [ecx], eax
  000a0	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 2005 :     Pop;

  000a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000a8	83 e8 08	 sub	 eax, 8
  000ab	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN5@P_then:

; 2006 : }

  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	5b		 pop	 ebx
  000b3	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000b9	3b ec		 cmp	 ebp, esp
  000bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_P_then	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_qdup
_TEXT	SEGMENT
tv75 = -212						; size = 4
_s$84286 = -12						; size = 8
_P_qdup	PROC						; COMDAT

; 2009 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00012	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2010 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN3@P_qdup
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 64		 jmp	 SHORT $LN4@P_qdup
$LN3@P_qdup:

; 2011 :     if (S0 != 0) {

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv75[ebp], eax
  00043	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR tv75[ebp]
  00049	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR tv75[ebp]
  0004f	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00052	0b 42 fc	 or	 eax, DWORD PTR [edx-4]
  00055	74 45		 je	 SHORT $LN4@P_qdup

; 2012 : 	stackitem s = S0;

  00057	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0005c	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0005f	89 4d f4	 mov	 DWORD PTR _s$84286[ebp], ecx
  00062	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00065	89 55 f8	 mov	 DWORD PTR _s$84286[ebp+4], edx

; 2013 : 	So(1);

  00068	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0006d	83 c0 08	 add	 eax, 8
  00070	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00076	76 07		 jbe	 SHORT $LN1@P_qdup
  00078	e8 00 00 00 00	 call	 _stakover
  0007d	eb 1d		 jmp	 SHORT $LN4@P_qdup
$LN1@P_qdup:

; 2014 : 	Push = s;

  0007f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00084	8b 4d f4	 mov	 ecx, DWORD PTR _s$84286[ebp]
  00087	89 08		 mov	 DWORD PTR [eax], ecx
  00089	8b 55 f8	 mov	 edx, DWORD PTR _s$84286[ebp+4]
  0008c	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00094	83 c0 08	 add	 eax, 8
  00097	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN4@P_qdup:

; 2015 :     }
; 2016 : }

  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	5b		 pop	 ebx
  0009f	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  000a5	3b ec		 cmp	 ebp, esp
  000a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
_P_qdup	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_begin
_TEXT	SEGMENT
tv70 = -196						; size = 4
_P_begin PROC						; COMDAT

; 2019 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2020 :     Compiling;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  00029	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv70[ebp]
  0002f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv70[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	75 07		 jne	 SHORT $LN2@P_begin
  0003c	e8 00 00 00 00	 call	 _notcomp
  00041	eb 37		 jmp	 SHORT $LN3@P_begin
$LN2@P_begin:

; 2021 :     So(1);

  00043	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00048	83 c0 08	 add	 eax, 8
  0004b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00051	76 07		 jbe	 SHORT $LN1@P_begin
  00053	e8 00 00 00 00	 call	 _stakover
  00058	eb 20		 jmp	 SHORT $LN3@P_begin
$LN1@P_begin:

; 2022 :     Push = (stackitem) hptr;	      /* Save jump back address on stack */

  0005a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0005f	99		 cdq
  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00066	89 01		 mov	 DWORD PTR [ecx], eax
  00068	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0006b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00071	83 c2 08	 add	 edx, 8
  00074	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN3@P_begin:

; 2023 : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
_P_begin ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_until
_TEXT	SEGMENT
tv88 = -224						; size = 4
_bp$ = -24						; size = 4
_off$ = -12						; size = 8
_P_until PROC						; COMDAT

; 2026 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00012	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2027 :     stackitem off;
; 2028 :     stackitem *bp;
; 2029 : 
; 2030 :     Compiling;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv88[ebp], eax
  00029	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv88[ebp]
  0002f	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv88[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	75 0a		 jne	 SHORT $LN6@P_until
  0003c	e8 00 00 00 00	 call	 _notcomp
  00041	e9 e1 00 00 00	 jmp	 $LN7@P_until
$LN6@P_until:

; 2031 :     Sl(1);

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00051	c1 f8 03	 sar	 eax, 3
  00054	83 f8 01	 cmp	 eax, 1
  00057	7d 0a		 jge	 SHORT $LN5@P_until
  00059	e8 00 00 00 00	 call	 _stakunder
  0005e	e9 c4 00 00 00	 jmp	 $LN7@P_until
$LN5@P_until:

; 2032 :     Compconst(s_qbranch);	      /* Compile question branch */

  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00068	83 c0 08	 add	 eax, 8
  0006b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00071	76 0a		 jbe	 SHORT $LN4@P_until
  00073	e8 00 00 00 00	 call	 _heapover
  00078	e9 aa 00 00 00	 jmp	 $LN7@P_until
$LN4@P_until:
  0007d	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00082	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_qbranch
  00088	89 08		 mov	 DWORD PTR [eax], ecx
  0008a	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_qbranch+4
  00090	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00093	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00098	83 c0 08	 add	 eax, 8
  0009b	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2033 :     Hpc(S0);

  000a0	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000a5	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000a8	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  000ae	72 10		 jb	 SHORT $LN2@P_until
  000b0	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000b5	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000b8	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  000be	72 07		 jb	 SHORT $LN3@P_until
$LN2@P_until:
  000c0	e8 00 00 00 00	 call	 _badpointer
  000c5	eb 60		 jmp	 SHORT $LN7@P_until
$LN3@P_until:

; 2034 :     bp = (stackitem *) S0;	      /* Get BEGIN address */

  000c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000cc	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000cf	89 4d e8	 mov	 DWORD PTR _bp$[ebp], ecx

; 2035 :     off = -(hptr - bp);

  000d2	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000d7	2b 45 e8	 sub	 eax, DWORD PTR _bp$[ebp]
  000da	c1 f8 03	 sar	 eax, 3
  000dd	f7 d8		 neg	 eax
  000df	99		 cdq
  000e0	89 45 f4	 mov	 DWORD PTR _off$[ebp], eax
  000e3	89 55 f8	 mov	 DWORD PTR _off$[ebp+4], edx

; 2036 :     Compconst(off);		      /* Compile negative jumpback address */

  000e6	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000eb	83 c0 08	 add	 eax, 8
  000ee	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  000f4	76 07		 jbe	 SHORT $LN1@P_until
  000f6	e8 00 00 00 00	 call	 _heapover
  000fb	eb 2a		 jmp	 SHORT $LN7@P_until
$LN1@P_until:
  000fd	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00102	8b 4d f4	 mov	 ecx, DWORD PTR _off$[ebp]
  00105	89 08		 mov	 DWORD PTR [eax], ecx
  00107	8b 55 f8	 mov	 edx, DWORD PTR _off$[ebp+4]
  0010a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0010d	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00112	83 c0 08	 add	 eax, 8
  00115	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2037 :     Pop;

  0011a	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0011f	83 e8 08	 sub	 eax, 8
  00122	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN7@P_until:

; 2038 : }

  00127	5f		 pop	 edi
  00128	5e		 pop	 esi
  00129	5b		 pop	 ebx
  0012a	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  00130	3b ec		 cmp	 ebp, esp
  00132	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c3		 ret	 0
_P_until ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_again
_TEXT	SEGMENT
tv85 = -224						; size = 4
_bp$ = -24						; size = 4
_off$ = -12						; size = 8
_P_again PROC						; COMDAT

; 2041 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00012	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2042 :     stackitem off;
; 2043 :     stackitem *bp;
; 2044 : 
; 2045 :     Compiling;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv85[ebp], eax
  00029	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv85[ebp]
  0002f	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv85[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	75 0a		 jne	 SHORT $LN5@P_again
  0003c	e8 00 00 00 00	 call	 _notcomp
  00041	e9 c4 00 00 00	 jmp	 $LN6@P_again
$LN5@P_again:

; 2046 :     Compconst(s_branch);	      /* Compile unconditional branch */

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0004b	83 c0 08	 add	 eax, 8
  0004e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00054	76 0a		 jbe	 SHORT $LN4@P_again
  00056	e8 00 00 00 00	 call	 _heapover
  0005b	e9 aa 00 00 00	 jmp	 $LN6@P_again
$LN4@P_again:
  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00065	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_branch
  0006b	89 08		 mov	 DWORD PTR [eax], ecx
  0006d	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_branch+4
  00073	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00076	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0007b	83 c0 08	 add	 eax, 8
  0007e	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2047 :     Hpc(S0);

  00083	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00088	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0008b	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00091	72 10		 jb	 SHORT $LN2@P_again
  00093	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00098	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0009b	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  000a1	72 07		 jb	 SHORT $LN3@P_again
$LN2@P_again:
  000a3	e8 00 00 00 00	 call	 _badpointer
  000a8	eb 60		 jmp	 SHORT $LN6@P_again
$LN3@P_again:

; 2048 :     bp = (stackitem *) S0;	      /* Get BEGIN address */

  000aa	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000af	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000b2	89 4d e8	 mov	 DWORD PTR _bp$[ebp], ecx

; 2049 :     off = -(hptr - bp);

  000b5	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000ba	2b 45 e8	 sub	 eax, DWORD PTR _bp$[ebp]
  000bd	c1 f8 03	 sar	 eax, 3
  000c0	f7 d8		 neg	 eax
  000c2	99		 cdq
  000c3	89 45 f4	 mov	 DWORD PTR _off$[ebp], eax
  000c6	89 55 f8	 mov	 DWORD PTR _off$[ebp+4], edx

; 2050 :     Compconst(off);		      /* Compile negative jumpback address */

  000c9	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000ce	83 c0 08	 add	 eax, 8
  000d1	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  000d7	76 07		 jbe	 SHORT $LN1@P_again
  000d9	e8 00 00 00 00	 call	 _heapover
  000de	eb 2a		 jmp	 SHORT $LN6@P_again
$LN1@P_again:
  000e0	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000e5	8b 4d f4	 mov	 ecx, DWORD PTR _off$[ebp]
  000e8	89 08		 mov	 DWORD PTR [eax], ecx
  000ea	8b 55 f8	 mov	 edx, DWORD PTR _off$[ebp+4]
  000ed	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000f0	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000f5	83 c0 08	 add	 eax, 8
  000f8	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2051 :     Pop;

  000fd	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00102	83 e8 08	 sub	 eax, 8
  00105	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN6@P_again:

; 2052 : }

  0010a	5f		 pop	 edi
  0010b	5e		 pop	 esi
  0010c	5b		 pop	 ebx
  0010d	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  00113	3b ec		 cmp	 ebp, esp
  00115	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c3		 ret	 0
_P_again ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_while
_TEXT	SEGMENT
tv77 = -196						; size = 4
_P_while PROC						; COMDAT

; 2055 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2056 :     Compiling;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv77[ebp], eax
  00029	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv77[ebp]
  0002f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv77[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	75 0a		 jne	 SHORT $LN4@P_while
  0003c	e8 00 00 00 00	 call	 _notcomp
  00041	e9 af 00 00 00	 jmp	 $LN5@P_while
$LN4@P_while:

; 2057 :     So(1);

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004b	83 c0 08	 add	 eax, 8
  0004e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00054	76 0a		 jbe	 SHORT $LN3@P_while
  00056	e8 00 00 00 00	 call	 _stakover
  0005b	e9 95 00 00 00	 jmp	 $LN5@P_while
$LN3@P_while:

; 2058 :     Compconst(s_qbranch);	      /* Compile question branch */

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00065	83 c0 08	 add	 eax, 8
  00068	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  0006e	76 07		 jbe	 SHORT $LN2@P_while
  00070	e8 00 00 00 00	 call	 _heapover
  00075	eb 7e		 jmp	 SHORT $LN5@P_while
$LN2@P_while:
  00077	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0007c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_qbranch
  00082	89 08		 mov	 DWORD PTR [eax], ecx
  00084	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_qbranch+4
  0008a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0008d	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00092	83 c0 08	 add	 eax, 8
  00095	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2059 :     Compconst(0);		      /* Compile place-holder address cell */

  0009a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0009f	83 c0 08	 add	 eax, 8
  000a2	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  000a8	76 07		 jbe	 SHORT $LN1@P_while
  000aa	e8 00 00 00 00	 call	 _heapover
  000af	eb 44		 jmp	 SHORT $LN5@P_while
$LN1@P_while:
  000b1	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000b6	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000bc	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  000c9	83 c1 08	 add	 ecx, 8
  000cc	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx

; 2060 :     Push = (stackitem) (hptr - 1);    /* Queue backpatch for REPEAT */

  000d2	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000d7	83 e8 08	 sub	 eax, 8
  000da	99		 cdq
  000db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  000e1	89 01		 mov	 DWORD PTR [ecx], eax
  000e3	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  000e6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  000ec	83 c2 08	 add	 edx, 8
  000ef	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN5@P_while:

; 2061 : }

  000f5	5f		 pop	 edi
  000f6	5e		 pop	 esi
  000f7	5b		 pop	 ebx
  000f8	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  000fe	3b ec		 cmp	 ebp, esp
  00100	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c3		 ret	 0
_P_while ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_repeat
_TEXT	SEGMENT
tv132 = -236						; size = 4
_bp$ = -36						; size = 4
_bp1$ = -24						; size = 4
_off$ = -12						; size = 8
_P_repeat PROC						; COMDAT

; 2064 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 14 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-236]
  00012	b9 3b 00 00 00	 mov	 ecx, 59			; 0000003bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2065 :     stackitem off;
; 2066 :     stackitem *bp1, *bp;
; 2067 : 
; 2068 :     Compiling;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv132[ebp], eax
  00029	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR tv132[ebp]
  0002f	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR tv132[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	75 0a		 jne	 SHORT $LN8@P_repeat
  0003c	e8 00 00 00 00	 call	 _notcomp
  00041	e9 37 01 00 00	 jmp	 $LN9@P_repeat
$LN8@P_repeat:

; 2069 :     Sl(2);

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00051	c1 f8 03	 sar	 eax, 3
  00054	83 f8 02	 cmp	 eax, 2
  00057	7d 0a		 jge	 SHORT $LN7@P_repeat
  00059	e8 00 00 00 00	 call	 _stakunder
  0005e	e9 1a 01 00 00	 jmp	 $LN9@P_repeat
$LN7@P_repeat:

; 2070 :     Hpc(S0);

  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00068	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0006b	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00071	72 10		 jb	 SHORT $LN5@P_repeat
  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00078	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0007b	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00081	72 0a		 jb	 SHORT $LN6@P_repeat
$LN5@P_repeat:
  00083	e8 00 00 00 00	 call	 _badpointer
  00088	e9 f0 00 00 00	 jmp	 $LN9@P_repeat
$LN6@P_repeat:

; 2071 :     bp1 = (stackitem *) S0;	      /* Get WHILE backpatch address */

  0008d	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00092	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00095	89 4d e8	 mov	 DWORD PTR _bp1$[ebp], ecx

; 2072 :     Pop;

  00098	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0009d	83 e8 08	 sub	 eax, 8
  000a0	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 2073 :     Compconst(s_branch);	      /* Compile unconditional branch */

  000a5	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000aa	83 c0 08	 add	 eax, 8
  000ad	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  000b3	76 0a		 jbe	 SHORT $LN4@P_repeat
  000b5	e8 00 00 00 00	 call	 _heapover
  000ba	e9 be 00 00 00	 jmp	 $LN9@P_repeat
$LN4@P_repeat:
  000bf	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_branch
  000ca	89 08		 mov	 DWORD PTR [eax], ecx
  000cc	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_branch+4
  000d2	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000d5	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000da	83 c0 08	 add	 eax, 8
  000dd	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2074 :     Hpc(S0);

  000e2	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000e7	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000ea	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  000f0	72 10		 jb	 SHORT $LN2@P_repeat
  000f2	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000f7	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000fa	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00100	72 07		 jb	 SHORT $LN3@P_repeat
$LN2@P_repeat:
  00102	e8 00 00 00 00	 call	 _badpointer
  00107	eb 74		 jmp	 SHORT $LN9@P_repeat
$LN3@P_repeat:

; 2075 :     bp = (stackitem *) S0;	      /* Get BEGIN address */

  00109	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0010e	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00111	89 4d dc	 mov	 DWORD PTR _bp$[ebp], ecx

; 2076 :     off = -(hptr - bp);

  00114	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00119	2b 45 dc	 sub	 eax, DWORD PTR _bp$[ebp]
  0011c	c1 f8 03	 sar	 eax, 3
  0011f	f7 d8		 neg	 eax
  00121	99		 cdq
  00122	89 45 f4	 mov	 DWORD PTR _off$[ebp], eax
  00125	89 55 f8	 mov	 DWORD PTR _off$[ebp+4], edx

; 2077 :     Compconst(off);		      /* Compile negative jumpback address */

  00128	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0012d	83 c0 08	 add	 eax, 8
  00130	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00136	76 07		 jbe	 SHORT $LN1@P_repeat
  00138	e8 00 00 00 00	 call	 _heapover
  0013d	eb 3e		 jmp	 SHORT $LN9@P_repeat
$LN1@P_repeat:
  0013f	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00144	8b 4d f4	 mov	 ecx, DWORD PTR _off$[ebp]
  00147	89 08		 mov	 DWORD PTR [eax], ecx
  00149	8b 55 f8	 mov	 edx, DWORD PTR _off$[ebp+4]
  0014c	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0014f	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00154	83 c0 08	 add	 eax, 8
  00157	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2078 :     *bp1 = hptr - bp1;                /* Backpatch REPEAT's jump out of loop */

  0015c	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00161	2b 45 e8	 sub	 eax, DWORD PTR _bp1$[ebp]
  00164	c1 f8 03	 sar	 eax, 3
  00167	99		 cdq
  00168	8b 4d e8	 mov	 ecx, DWORD PTR _bp1$[ebp]
  0016b	89 01		 mov	 DWORD PTR [ecx], eax
  0016d	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 2079 :     Pop;

  00170	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00175	83 e8 08	 sub	 eax, 8
  00178	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN9@P_repeat:

; 2080 : }

  0017d	5f		 pop	 edi
  0017e	5e		 pop	 esi
  0017f	5b		 pop	 ebx
  00180	81 c4 ec 00 00
	00		 add	 esp, 236		; 000000ecH
  00186	3b ec		 cmp	 ebp, esp
  00188	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018d	8b e5		 mov	 esp, ebp
  0018f	5d		 pop	 ebp
  00190	c3		 ret	 0
_P_repeat ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_xdo	DQ	01H DUP (?)
; Function compile flags: /Odtp /RTCsu /ZI
_BSS	ENDS
;	COMDAT _P_do
_TEXT	SEGMENT
tv76 = -196						; size = 4
_P_do	PROC						; COMDAT

; 2083 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2084 :     Compiling;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv76[ebp], eax
  00029	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv76[ebp]
  0002f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv76[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	75 0a		 jne	 SHORT $LN4@P_do
  0003c	e8 00 00 00 00	 call	 _notcomp
  00041	e9 ac 00 00 00	 jmp	 $LN5@P_do
$LN4@P_do:

; 2085 :     Compconst(s_xdo);		      /* Compile runtime DO word */

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0004b	83 c0 08	 add	 eax, 8
  0004e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00054	76 0a		 jbe	 SHORT $LN3@P_do
  00056	e8 00 00 00 00	 call	 _heapover
  0005b	e9 92 00 00 00	 jmp	 $LN5@P_do
$LN3@P_do:
  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00065	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_xdo
  0006b	89 08		 mov	 DWORD PTR [eax], ecx
  0006d	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_xdo+4
  00073	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00076	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0007b	83 c0 08	 add	 eax, 8
  0007e	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2086 :     So(1);

  00083	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00088	83 c0 08	 add	 eax, 8
  0008b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00091	76 07		 jbe	 SHORT $LN2@P_do
  00093	e8 00 00 00 00	 call	 _stakover
  00098	eb 58		 jmp	 SHORT $LN5@P_do
$LN2@P_do:

; 2087 :     Compconst(0);		      /* Reserve cell for LEAVE-taking */

  0009a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0009f	83 c0 08	 add	 eax, 8
  000a2	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  000a8	76 07		 jbe	 SHORT $LN1@P_do
  000aa	e8 00 00 00 00	 call	 _heapover
  000af	eb 41		 jmp	 SHORT $LN5@P_do
$LN1@P_do:
  000b1	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000b6	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000bc	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  000c9	83 c1 08	 add	 ecx, 8
  000cc	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx

; 2088 :     Push = (stackitem) hptr;	      /* Save jump back address on stack */

  000d2	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000d7	99		 cdq
  000d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  000de	89 01		 mov	 DWORD PTR [ecx], eax
  000e0	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  000e3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  000e9	83 c2 08	 add	 edx, 8
  000ec	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN5@P_do:

; 2089 : }

  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
  000f4	5b		 pop	 ebx
  000f5	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  000fb	3b ec		 cmp	 ebp, esp
  000fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c3		 ret	 0
_P_do	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_xdo
_TEXT	SEGMENT
_P_xdo	PROC						; COMDAT

; 2092 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2093 :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 0a		 jge	 SHORT $LN2@P_xdo
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 9e 00 00 00	 jmp	 $LN3@P_xdo
$LN2@P_xdo:

; 2094 :     Rso(3);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00040	83 c0 0c	 add	 eax, 12			; 0000000cH
  00043	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _rstacktop
  00049	76 0a		 jbe	 SHORT $LN1@P_xdo
  0004b	e8 00 00 00 00	 call	 _rstakover
  00050	e9 84 00 00 00	 jmp	 $LN3@P_xdo
$LN1@P_xdo:

; 2095 :     Rpush = ip + ((stackitem) *ip);   /* Push exit address from loop */

  00055	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  0005a	8b 00		 mov	 eax, DWORD PTR [eax]
  0005c	99		 cdq
  0005d	6a 00		 push	 0
  0005f	6a 04		 push	 4
  00061	52		 push	 edx
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 __allmul
  00068	03 05 00 00 00
	00		 add	 eax, DWORD PTR _ip
  0006e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  00074	89 01		 mov	 DWORD PTR [ecx], eax
  00076	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  0007c	83 c2 04	 add	 edx, 4
  0007f	89 15 00 00 00
	00		 mov	 DWORD PTR _rstk, edx

; 2096 :     ip++;			      /* Increment past exit address word */

  00085	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  0008a	83 c0 04	 add	 eax, 4
  0008d	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax

; 2097 :     Rpush = (rstackitem) S1;	      /* Push loop limit on return stack */

  00092	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00097	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0009a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  000a0	89 0a		 mov	 DWORD PTR [edx], ecx
  000a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  000a7	83 c0 04	 add	 eax, 4
  000aa	a3 00 00 00 00	 mov	 DWORD PTR _rstk, eax

; 2098 :     Rpush = (rstackitem) S0;	      /* Iteration variable initial value to

  000af	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000b4	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000b7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  000bd	89 0a		 mov	 DWORD PTR [edx], ecx
  000bf	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  000c4	83 c0 04	 add	 eax, 4
  000c7	a3 00 00 00 00	 mov	 DWORD PTR _rstk, eax

; 2099 : 					 return stack */
; 2100 :     stk -= 2;

  000cc	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000d1	83 e8 10	 sub	 eax, 16			; 00000010H
  000d4	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN3@P_xdo:

; 2101 : }

  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi
  000db	5b		 pop	 ebx
  000dc	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000e2	3b ec		 cmp	 ebp, esp
  000e4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c3		 ret	 0
_P_xdo	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_xqdo	DQ	01H DUP (?)
; Function compile flags: /Odtp /RTCsu /ZI
_BSS	ENDS
;	COMDAT _P_qdo
_TEXT	SEGMENT
tv76 = -196						; size = 4
_P_qdo	PROC						; COMDAT

; 2104 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2105 :     Compiling;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv76[ebp], eax
  00029	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv76[ebp]
  0002f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv76[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	75 0a		 jne	 SHORT $LN4@P_qdo
  0003c	e8 00 00 00 00	 call	 _notcomp
  00041	e9 ac 00 00 00	 jmp	 $LN5@P_qdo
$LN4@P_qdo:

; 2106 :     Compconst(s_xqdo);		      /* Compile runtime ?DO word */

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0004b	83 c0 08	 add	 eax, 8
  0004e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00054	76 0a		 jbe	 SHORT $LN3@P_qdo
  00056	e8 00 00 00 00	 call	 _heapover
  0005b	e9 92 00 00 00	 jmp	 $LN5@P_qdo
$LN3@P_qdo:
  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00065	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_xqdo
  0006b	89 08		 mov	 DWORD PTR [eax], ecx
  0006d	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_xqdo+4
  00073	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00076	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0007b	83 c0 08	 add	 eax, 8
  0007e	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2107 :     So(1);

  00083	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00088	83 c0 08	 add	 eax, 8
  0008b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00091	76 07		 jbe	 SHORT $LN2@P_qdo
  00093	e8 00 00 00 00	 call	 _stakover
  00098	eb 58		 jmp	 SHORT $LN5@P_qdo
$LN2@P_qdo:

; 2108 :     Compconst(0);		      /* Reserve cell for LEAVE-taking */

  0009a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0009f	83 c0 08	 add	 eax, 8
  000a2	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  000a8	76 07		 jbe	 SHORT $LN1@P_qdo
  000aa	e8 00 00 00 00	 call	 _heapover
  000af	eb 41		 jmp	 SHORT $LN5@P_qdo
$LN1@P_qdo:
  000b1	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000b6	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000bc	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  000c9	83 c1 08	 add	 ecx, 8
  000cc	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx

; 2109 :     Push = (stackitem) hptr;	      /* Save jump back address on stack */

  000d2	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000d7	99		 cdq
  000d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  000de	89 01		 mov	 DWORD PTR [ecx], eax
  000e0	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  000e3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  000e9	83 c2 08	 add	 edx, 8
  000ec	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN5@P_qdo:

; 2110 : }

  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
  000f4	5b		 pop	 ebx
  000f5	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  000fb	3b ec		 cmp	 ebp, esp
  000fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c3		 ret	 0
_P_qdo	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_xqdo
_TEXT	SEGMENT
tv93 = -200						; size = 4
tv92 = -196						; size = 4
_P_xqdo	PROC						; COMDAT

; 2113 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2114 :     Sl(2);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 0a		 jge	 SHORT $LN4@P_xqdo
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 00 01 00 00	 jmp	 $LN5@P_xqdo
$LN4@P_xqdo:

; 2115 :     if (S0 == S1) {

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00046	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv92[ebp], eax
  0004c	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], ecx
  00052	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv92[ebp]
  00058	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv93[ebp]
  0005e	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00061	3b 48 f0	 cmp	 ecx, DWORD PTR [eax-16]
  00064	75 37		 jne	 SHORT $LN3@P_xqdo
  00066	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv92[ebp]
  0006c	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv93[ebp]
  00072	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00075	3b 48 f4	 cmp	 ecx, DWORD PTR [eax-12]
  00078	75 23		 jne	 SHORT $LN3@P_xqdo

; 2116 : 	ip += (stackitem) *ip;

  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  0007f	8b 00		 mov	 eax, DWORD PTR [eax]
  00081	99		 cdq
  00082	6a 00		 push	 0
  00084	6a 04		 push	 4
  00086	52		 push	 edx
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 __allmul
  0008d	03 05 00 00 00
	00		 add	 eax, DWORD PTR _ip
  00093	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax

; 2117 :     } else {

  00098	e9 91 00 00 00	 jmp	 $LN2@P_xqdo
$LN3@P_xqdo:

; 2118 : 	Rso(3);

  0009d	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  000a2	83 c0 0c	 add	 eax, 12			; 0000000cH
  000a5	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _rstacktop
  000ab	76 0a		 jbe	 SHORT $LN1@P_xqdo
  000ad	e8 00 00 00 00	 call	 _rstakover
  000b2	e9 84 00 00 00	 jmp	 $LN5@P_xqdo
$LN1@P_xqdo:

; 2119 : 	Rpush = ip + ((stackitem) *ip);/* Push exit address from loop */

  000b7	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  000bc	8b 00		 mov	 eax, DWORD PTR [eax]
  000be	99		 cdq
  000bf	6a 00		 push	 0
  000c1	6a 04		 push	 4
  000c3	52		 push	 edx
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 __allmul
  000ca	03 05 00 00 00
	00		 add	 eax, DWORD PTR _ip
  000d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  000d6	89 01		 mov	 DWORD PTR [ecx], eax
  000d8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  000de	83 c2 04	 add	 edx, 4
  000e1	89 15 00 00 00
	00		 mov	 DWORD PTR _rstk, edx

; 2120 : 	ip++;			      /* Increment past exit address word */

  000e7	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  000ec	83 c0 04	 add	 eax, 4
  000ef	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax

; 2121 : 	Rpush = (rstackitem) S1;      /* Push loop limit on return stack */

  000f4	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000f9	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  000fc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  00102	89 0a		 mov	 DWORD PTR [edx], ecx
  00104	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00109	83 c0 04	 add	 eax, 4
  0010c	a3 00 00 00 00	 mov	 DWORD PTR _rstk, eax

; 2122 : 	Rpush = (rstackitem) S0;      /* Iteration variable initial value to

  00111	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00116	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00119	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  0011f	89 0a		 mov	 DWORD PTR [edx], ecx
  00121	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00126	83 c0 04	 add	 eax, 4
  00129	a3 00 00 00 00	 mov	 DWORD PTR _rstk, eax
$LN2@P_xqdo:

; 2123 : 					 return stack */
; 2124 :     }
; 2125 :     stk -= 2;

  0012e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00133	83 e8 10	 sub	 eax, 16			; 00000010H
  00136	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN5@P_xqdo:

; 2126 : }

  0013b	5f		 pop	 edi
  0013c	5e		 pop	 esi
  0013d	5b		 pop	 ebx
  0013e	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00144	3b ec		 cmp	 ebp, esp
  00146	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014b	8b e5		 mov	 esp, ebp
  0014d	5d		 pop	 ebp
  0014e	c3		 ret	 0
_P_xqdo	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_xloop DQ	01H DUP (?)
; Function compile flags: /Odtp /RTCsu /ZI
_BSS	ENDS
;	COMDAT _P_loop
_TEXT	SEGMENT
tv93 = -224						; size = 4
_bp$ = -24						; size = 4
_off$ = -12						; size = 8
_P_loop	PROC						; COMDAT

; 2129 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00012	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2130 :     stackitem off;
; 2131 :     stackitem *bp;
; 2132 : 
; 2133 :     Compiling;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], eax
  00029	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv93[ebp]
  0002f	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv93[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	75 0a		 jne	 SHORT $LN6@P_loop
  0003c	e8 00 00 00 00	 call	 _notcomp
  00041	e9 f9 00 00 00	 jmp	 $LN7@P_loop
$LN6@P_loop:

; 2134 :     Sl(1);

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00051	c1 f8 03	 sar	 eax, 3
  00054	83 f8 01	 cmp	 eax, 1
  00057	7d 0a		 jge	 SHORT $LN5@P_loop
  00059	e8 00 00 00 00	 call	 _stakunder
  0005e	e9 dc 00 00 00	 jmp	 $LN7@P_loop
$LN5@P_loop:

; 2135 :     Compconst(s_xloop); 	      /* Compile runtime loop */

  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00068	83 c0 08	 add	 eax, 8
  0006b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00071	76 0a		 jbe	 SHORT $LN4@P_loop
  00073	e8 00 00 00 00	 call	 _heapover
  00078	e9 c2 00 00 00	 jmp	 $LN7@P_loop
$LN4@P_loop:
  0007d	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00082	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_xloop
  00088	89 08		 mov	 DWORD PTR [eax], ecx
  0008a	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_xloop+4
  00090	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00093	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00098	83 c0 08	 add	 eax, 8
  0009b	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2136 :     Hpc(S0);

  000a0	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000a5	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000a8	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  000ae	72 10		 jb	 SHORT $LN2@P_loop
  000b0	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000b5	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000b8	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  000be	72 07		 jb	 SHORT $LN3@P_loop
$LN2@P_loop:
  000c0	e8 00 00 00 00	 call	 _badpointer
  000c5	eb 78		 jmp	 SHORT $LN7@P_loop
$LN3@P_loop:

; 2137 :     bp = (stackitem *) S0;	      /* Get DO address */

  000c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000cc	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000cf	89 4d e8	 mov	 DWORD PTR _bp$[ebp], ecx

; 2138 :     off = -(hptr - bp);

  000d2	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000d7	2b 45 e8	 sub	 eax, DWORD PTR _bp$[ebp]
  000da	c1 f8 03	 sar	 eax, 3
  000dd	f7 d8		 neg	 eax
  000df	99		 cdq
  000e0	89 45 f4	 mov	 DWORD PTR _off$[ebp], eax
  000e3	89 55 f8	 mov	 DWORD PTR _off$[ebp+4], edx

; 2139 :     Compconst(off);		      /* Compile negative jumpback address */

  000e6	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000eb	83 c0 08	 add	 eax, 8
  000ee	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  000f4	76 07		 jbe	 SHORT $LN1@P_loop
  000f6	e8 00 00 00 00	 call	 _heapover
  000fb	eb 42		 jmp	 SHORT $LN7@P_loop
$LN1@P_loop:
  000fd	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00102	8b 4d f4	 mov	 ecx, DWORD PTR _off$[ebp]
  00105	89 08		 mov	 DWORD PTR [eax], ecx
  00107	8b 55 f8	 mov	 edx, DWORD PTR _off$[ebp+4]
  0010a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0010d	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00112	83 c0 08	 add	 eax, 8
  00115	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2140 :     *(bp - 1) = (hptr - bp) + 1;      /* Backpatch exit address offset */

  0011a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0011f	2b 45 e8	 sub	 eax, DWORD PTR _bp$[ebp]
  00122	c1 f8 03	 sar	 eax, 3
  00125	83 c0 01	 add	 eax, 1
  00128	99		 cdq
  00129	8b 4d e8	 mov	 ecx, DWORD PTR _bp$[ebp]
  0012c	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  0012f	89 51 fc	 mov	 DWORD PTR [ecx-4], edx

; 2141 :     Pop;

  00132	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00137	83 e8 08	 sub	 eax, 8
  0013a	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN7@P_loop:

; 2142 : }

  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  00148	3b ec		 cmp	 ebp, esp
  0014a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014f	8b e5		 mov	 esp, ebp
  00151	5d		 pop	 ebp
  00152	c3		 ret	 0
_P_loop	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_pxloop DQ	01H DUP (?)
; Function compile flags: /Odtp /RTCsu /ZI
_BSS	ENDS
;	COMDAT _P_ploop
_TEXT	SEGMENT
tv93 = -224						; size = 4
_bp$ = -24						; size = 4
_off$ = -12						; size = 8
_P_ploop PROC						; COMDAT

; 2145 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00012	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2146 :     stackitem off;
; 2147 :     stackitem *bp;
; 2148 : 
; 2149 :     Compiling;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], eax
  00029	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv93[ebp]
  0002f	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv93[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	75 0a		 jne	 SHORT $LN6@P_ploop
  0003c	e8 00 00 00 00	 call	 _notcomp
  00041	e9 f9 00 00 00	 jmp	 $LN7@P_ploop
$LN6@P_ploop:

; 2150 :     Sl(1);

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00051	c1 f8 03	 sar	 eax, 3
  00054	83 f8 01	 cmp	 eax, 1
  00057	7d 0a		 jge	 SHORT $LN5@P_ploop
  00059	e8 00 00 00 00	 call	 _stakunder
  0005e	e9 dc 00 00 00	 jmp	 $LN7@P_ploop
$LN5@P_ploop:

; 2151 :     Compconst(s_pxloop);	      /* Compile runtime +loop */

  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00068	83 c0 08	 add	 eax, 8
  0006b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00071	76 0a		 jbe	 SHORT $LN4@P_ploop
  00073	e8 00 00 00 00	 call	 _heapover
  00078	e9 c2 00 00 00	 jmp	 $LN7@P_ploop
$LN4@P_ploop:
  0007d	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00082	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_pxloop
  00088	89 08		 mov	 DWORD PTR [eax], ecx
  0008a	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_pxloop+4
  00090	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00093	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00098	83 c0 08	 add	 eax, 8
  0009b	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2152 :     Hpc(S0);

  000a0	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000a5	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000a8	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  000ae	72 10		 jb	 SHORT $LN2@P_ploop
  000b0	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000b5	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000b8	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  000be	72 07		 jb	 SHORT $LN3@P_ploop
$LN2@P_ploop:
  000c0	e8 00 00 00 00	 call	 _badpointer
  000c5	eb 78		 jmp	 SHORT $LN7@P_ploop
$LN3@P_ploop:

; 2153 :     bp = (stackitem *) S0;	      /* Get DO address */

  000c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000cc	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000cf	89 4d e8	 mov	 DWORD PTR _bp$[ebp], ecx

; 2154 :     off = -(hptr - bp);

  000d2	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000d7	2b 45 e8	 sub	 eax, DWORD PTR _bp$[ebp]
  000da	c1 f8 03	 sar	 eax, 3
  000dd	f7 d8		 neg	 eax
  000df	99		 cdq
  000e0	89 45 f4	 mov	 DWORD PTR _off$[ebp], eax
  000e3	89 55 f8	 mov	 DWORD PTR _off$[ebp+4], edx

; 2155 :     Compconst(off);		      /* Compile negative jumpback address */

  000e6	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000eb	83 c0 08	 add	 eax, 8
  000ee	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  000f4	76 07		 jbe	 SHORT $LN1@P_ploop
  000f6	e8 00 00 00 00	 call	 _heapover
  000fb	eb 42		 jmp	 SHORT $LN7@P_ploop
$LN1@P_ploop:
  000fd	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00102	8b 4d f4	 mov	 ecx, DWORD PTR _off$[ebp]
  00105	89 08		 mov	 DWORD PTR [eax], ecx
  00107	8b 55 f8	 mov	 edx, DWORD PTR _off$[ebp+4]
  0010a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0010d	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00112	83 c0 08	 add	 eax, 8
  00115	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2156 :     *(bp - 1) = (hptr - bp) + 1;      /* Backpatch exit address offset */

  0011a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0011f	2b 45 e8	 sub	 eax, DWORD PTR _bp$[ebp]
  00122	c1 f8 03	 sar	 eax, 3
  00125	83 c0 01	 add	 eax, 1
  00128	99		 cdq
  00129	8b 4d e8	 mov	 ecx, DWORD PTR _bp$[ebp]
  0012c	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  0012f	89 51 fc	 mov	 DWORD PTR [ecx-4], edx

; 2157 :     Pop;

  00132	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00137	83 e8 08	 sub	 eax, 8
  0013a	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN7@P_ploop:

; 2158 : }

  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  00148	3b ec		 cmp	 ebp, esp
  0014a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014f	8b e5		 mov	 esp, ebp
  00151	5d		 pop	 ebp
  00152	c3		 ret	 0
_P_ploop ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_xloop
_TEXT	SEGMENT
tv144 = -208						; size = 8
tv141 = -200						; size = 8
_P_xloop PROC						; COMDAT

; 2161 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2162 :     Rsl(3);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _rstack
  00029	c1 f8 02	 sar	 eax, 2
  0002c	83 f8 03	 cmp	 eax, 3
  0002f	7d 0a		 jge	 SHORT $LN3@P_xloop
  00031	e8 00 00 00 00	 call	 _rstakunder
  00036	e9 9d 00 00 00	 jmp	 $LN4@P_xloop
$LN3@P_xloop:

; 2163 :     R0 = (rstackitem) (((stackitem) R0) + 1);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00040	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00043	99		 cdq
  00044	83 c0 01	 add	 eax, 1
  00047	83 d2 00	 adc	 edx, 0
  0004a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  00050	89 41 fc	 mov	 DWORD PTR [ecx-4], eax

; 2164 :     if (((stackitem) R0) == ((stackitem) R1)) {

  00053	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00058	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  0005b	99		 cdq
  0005c	8b c8		 mov	 ecx, eax
  0005e	8b f2		 mov	 esi, edx
  00060	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  00066	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  00069	99		 cdq
  0006a	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv141[ebp], ecx
  00070	89 b5 3c ff ff
	ff		 mov	 DWORD PTR tv141[ebp+4], esi
  00076	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv144[ebp], eax
  0007c	89 95 34 ff ff
	ff		 mov	 DWORD PTR tv144[ebp+4], edx
  00082	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv141[ebp]
  00088	3b 85 30 ff ff
	ff		 cmp	 eax, DWORD PTR tv144[ebp]
  0008e	75 2a		 jne	 SHORT $LN2@P_xloop
  00090	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv141[ebp+4]
  00096	3b 8d 34 ff ff
	ff		 cmp	 ecx, DWORD PTR tv144[ebp+4]
  0009c	75 1c		 jne	 SHORT $LN2@P_xloop

; 2165 : 	rstk -= 3;		      /* Pop iteration variable and limit */

  0009e	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  000a3	83 e8 0c	 sub	 eax, 12			; 0000000cH
  000a6	a3 00 00 00 00	 mov	 DWORD PTR _rstk, eax

; 2166 : 	ip++;			      /* Skip the jump address */

  000ab	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  000b0	83 c0 04	 add	 eax, 4
  000b3	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax

; 2167 :     } else {

  000b8	eb 1e		 jmp	 SHORT $LN4@P_xloop
$LN2@P_xloop:

; 2168 : 	ip += (stackitem) *ip;

  000ba	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  000bf	8b 00		 mov	 eax, DWORD PTR [eax]
  000c1	99		 cdq
  000c2	6a 00		 push	 0
  000c4	6a 04		 push	 4
  000c6	52		 push	 edx
  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 __allmul
  000cd	03 05 00 00 00
	00		 add	 eax, DWORD PTR _ip
  000d3	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax
$LN4@P_xloop:

; 2169 :     }
; 2170 : }

  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi
  000da	5b		 pop	 ebx
  000db	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000e1	3b ec		 cmp	 ebp, esp
  000e3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c3		 ret	 0
_P_xloop ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_xploop
_TEXT	SEGMENT
tv169 = -224						; size = 8
tv166 = -216						; size = 8
tv145 = -216						; size = 8
_niter$ = -12						; size = 8
_P_xploop PROC						; COMDAT

; 2173 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00012	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2174 :     stackitem niter;
; 2175 : 
; 2176 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 0a		 jge	 SHORT $LN4@P_xploop
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 05 01 00 00	 jmp	 $LN5@P_xploop
$LN4@P_xploop:

; 2177 :     Rsl(3);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00040	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _rstack
  00046	c1 f8 02	 sar	 eax, 2
  00049	83 f8 03	 cmp	 eax, 3
  0004c	7d 0a		 jge	 SHORT $LN3@P_xploop
  0004e	e8 00 00 00 00	 call	 _rstakunder
  00053	e9 e8 00 00 00	 jmp	 $LN5@P_xploop
$LN3@P_xploop:

; 2178 : 
; 2179 :     niter = ((stackitem) R0) + S0;

  00058	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  0005d	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00060	99		 cdq
  00061	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00067	03 41 f8	 add	 eax, DWORD PTR [ecx-8]
  0006a	13 51 fc	 adc	 edx, DWORD PTR [ecx-4]
  0006d	89 45 f4	 mov	 DWORD PTR _niter$[ebp], eax
  00070	89 55 f8	 mov	 DWORD PTR _niter$[ebp+4], edx

; 2180 :     Pop;

  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00078	83 e8 08	 sub	 eax, 8
  0007b	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 2181 :     if ((niter >= ((stackitem) R1)) &&
; 2182 : 	(((stackitem) R0) < ((stackitem) R1))) {

  00080	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00085	8b 40 f8	 mov	 eax, DWORD PTR [eax-8]
  00088	99		 cdq
  00089	89 85 28 ff ff
	ff		 mov	 DWORD PTR tv145[ebp], eax
  0008f	89 95 2c ff ff
	ff		 mov	 DWORD PTR tv145[ebp+4], edx
  00095	8b 4d f8	 mov	 ecx, DWORD PTR _niter$[ebp+4]
  00098	3b 8d 2c ff ff
	ff		 cmp	 ecx, DWORD PTR tv145[ebp+4]
  0009e	7c 76		 jl	 SHORT $LN2@P_xploop
  000a0	7f 0b		 jg	 SHORT $LN7@P_xploop
  000a2	8b 55 f4	 mov	 edx, DWORD PTR _niter$[ebp]
  000a5	3b 95 28 ff ff
	ff		 cmp	 edx, DWORD PTR tv145[ebp]
  000ab	72 69		 jb	 SHORT $LN2@P_xploop
$LN7@P_xploop:
  000ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  000b2	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  000b5	99		 cdq
  000b6	8b c8		 mov	 ecx, eax
  000b8	8b f2		 mov	 esi, edx
  000ba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  000c0	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  000c3	99		 cdq
  000c4	89 8d 28 ff ff
	ff		 mov	 DWORD PTR tv166[ebp], ecx
  000ca	89 b5 2c ff ff
	ff		 mov	 DWORD PTR tv166[ebp+4], esi
  000d0	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv169[ebp], eax
  000d6	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv169[ebp+4], edx
  000dc	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR tv166[ebp+4]
  000e2	3b 85 24 ff ff
	ff		 cmp	 eax, DWORD PTR tv169[ebp+4]
  000e8	7f 2c		 jg	 SHORT $LN2@P_xploop
  000ea	7c 0e		 jl	 SHORT $LN8@P_xploop
  000ec	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR tv166[ebp]
  000f2	3b 8d 20 ff ff
	ff		 cmp	 ecx, DWORD PTR tv169[ebp]
  000f8	73 1c		 jae	 SHORT $LN2@P_xploop
$LN8@P_xploop:

; 2183 : 	rstk -= 3;		      /* Pop iteration variable and limit */

  000fa	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  000ff	83 e8 0c	 sub	 eax, 12			; 0000000cH
  00102	a3 00 00 00 00	 mov	 DWORD PTR _rstk, eax

; 2184 : 	ip++;			      /* Skip the jump address */

  00107	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  0010c	83 c0 04	 add	 eax, 4
  0010f	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax

; 2185 :     } else {

  00114	eb 2a		 jmp	 SHORT $LN5@P_xploop
$LN2@P_xploop:

; 2186 : 	ip += (stackitem) *ip;

  00116	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  0011b	8b 00		 mov	 eax, DWORD PTR [eax]
  0011d	99		 cdq
  0011e	6a 00		 push	 0
  00120	6a 04		 push	 4
  00122	52		 push	 edx
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 __allmul
  00129	03 05 00 00 00
	00		 add	 eax, DWORD PTR _ip
  0012f	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax

; 2187 : 	R0 = (rstackitem) niter;

  00134	8b 45 f4	 mov	 eax, DWORD PTR _niter$[ebp]
  00137	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  0013d	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN5@P_xploop:

; 2188 :     }
; 2189 : }

  00140	5f		 pop	 edi
  00141	5e		 pop	 esi
  00142	5b		 pop	 ebx
  00143	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  00149	3b ec		 cmp	 ebp, esp
  0014b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
_P_xploop ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_leave
_TEXT	SEGMENT
_P_leave PROC						; COMDAT

; 2192 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2193 :     Rsl(3);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _rstack
  00029	c1 f8 02	 sar	 eax, 2
  0002c	83 f8 03	 cmp	 eax, 3
  0002f	7d 07		 jge	 SHORT $LN1@P_leave
  00031	e8 00 00 00 00	 call	 _rstakunder
  00036	eb 1b		 jmp	 SHORT $LN2@P_leave
$LN1@P_leave:

; 2194 :     ip = R2;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  0003d	8b 48 f4	 mov	 ecx, DWORD PTR [eax-12]
  00040	89 0d 00 00 00
	00		 mov	 DWORD PTR _ip, ecx

; 2195 :     rstk -= 3;

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  0004b	83 e8 0c	 sub	 eax, 12			; 0000000cH
  0004e	a3 00 00 00 00	 mov	 DWORD PTR _rstk, eax
$LN2@P_leave:

; 2196 : }

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005c	3b ec		 cmp	 ebp, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
_P_leave ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_i
_TEXT	SEGMENT
_P_i	PROC						; COMDAT

; 2199 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2200 :     Rsl(3);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _rstack
  00029	c1 f8 02	 sar	 eax, 2
  0002c	83 f8 03	 cmp	 eax, 3
  0002f	7d 07		 jge	 SHORT $LN2@P_i
  00031	e8 00 00 00 00	 call	 _rstakunder
  00036	eb 3a		 jmp	 SHORT $LN3@P_i
$LN2@P_i:

; 2201 :     So(1);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	83 c0 08	 add	 eax, 8
  00040	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00046	76 07		 jbe	 SHORT $LN1@P_i
  00048	e8 00 00 00 00	 call	 _stakover
  0004d	eb 23		 jmp	 SHORT $LN3@P_i
$LN1@P_i:

; 2202 :     Push = (stackitem) R0;            /* It's the top item on return stack */

  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00054	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00057	99		 cdq
  00058	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0005e	89 01		 mov	 DWORD PTR [ecx], eax
  00060	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00063	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00069	83 c2 08	 add	 edx, 8
  0006c	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN3@P_i:

; 2203 : }

  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_P_i	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_j
_TEXT	SEGMENT
_P_j	PROC						; COMDAT

; 2206 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2207 :     Rsl(6);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _rstack
  00029	c1 f8 02	 sar	 eax, 2
  0002c	83 f8 06	 cmp	 eax, 6
  0002f	7d 07		 jge	 SHORT $LN2@P_j
  00031	e8 00 00 00 00	 call	 _rstakunder
  00036	eb 3a		 jmp	 SHORT $LN3@P_j
$LN2@P_j:

; 2208 :     So(1);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	83 c0 08	 add	 eax, 8
  00040	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00046	76 07		 jbe	 SHORT $LN1@P_j
  00048	e8 00 00 00 00	 call	 _stakover
  0004d	eb 23		 jmp	 SHORT $LN3@P_j
$LN1@P_j:

; 2209 :     Push = (stackitem) rstk[-4];      /* It's the 4th item on return stack */

  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00054	8b 40 f0	 mov	 eax, DWORD PTR [eax-16]
  00057	99		 cdq
  00058	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0005e	89 01		 mov	 DWORD PTR [ecx], eax
  00060	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00063	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00069	83 c2 08	 add	 edx, 8
  0006c	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN3@P_j:

; 2210 : }

  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_P_j	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_quit
_TEXT	SEGMENT
_P_quit	PROC						; COMDAT

; 2213 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2214 :     rstk = rstack;		      /* Clear return stack */

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstack
  00023	a3 00 00 00 00	 mov	 DWORD PTR _rstk, eax

; 2215 : #ifdef WALKBACK
; 2216 :     wbptr = wback;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR _wback
  0002d	a3 00 00 00 00	 mov	 DWORD PTR _wbptr, eax

; 2217 : #endif
; 2218 :     ip = NULL;			      /* Stop execution of current word */

  00032	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ip, 0

; 2219 : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
_P_quit	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_abort
_TEXT	SEGMENT
_P_abort PROC						; COMDAT

; 2222 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2223 :     P_clear();			      /* Clear the data stack */

  0001e	e8 00 00 00 00	 call	 _P_clear

; 2224 :     P_quit();			      /* Shut down execution */

  00023	e8 00 00 00 00	 call	 _P_quit

; 2225 : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
_P_abort ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_abortq DQ	01H DUP (?)
; Function compile flags: /Odtp /RTCsu /ZI
_BSS	ENDS
;	COMDAT _P_abortq
_TEXT	SEGMENT
tv71 = -196						; size = 4
_P_abortq PROC						; COMDAT

; 2228 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2229 :     if (state) {

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv71[ebp], eax
  00029	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv71[ebp]
  0002f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv71[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	74 4c		 je	 SHORT $LN3@P_abortq

; 2230 : 	stringlit = True;	      /* Set string literal expected */

  0003c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _stringlit, 1

; 2231 : 	Compconst(s_abortq);	      /* Compile ourselves */

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0004b	83 c0 08	 add	 eax, 8
  0004e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00054	76 0a		 jbe	 SHORT $LN2@P_abortq
  00056	e8 00 00 00 00	 call	 _heapover
  0005b	e9 ab 00 00 00	 jmp	 $LN4@P_abortq
$LN2@P_abortq:
  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00065	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_abortq
  0006b	89 08		 mov	 DWORD PTR [eax], ecx
  0006d	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_abortq+4
  00073	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00076	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0007b	83 c0 08	 add	 eax, 8
  0007e	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2232 :     } else {

  00083	e9 83 00 00 00	 jmp	 $LN4@P_abortq
$LN3@P_abortq:

; 2233 :         V printf("%s", (char *) ip);  /* Otherwise, print string literal

  00088	8b f4		 mov	 esi, esp
  0008a	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  0008f	50		 push	 eax
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0009b	83 c4 08	 add	 esp, 8
  0009e	3b f4		 cmp	 esi, esp
  000a0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2234 : 					 in in-line code. */
; 2235 : #ifdef WALKBACK
; 2236 : 	pwalkback();

  000a5	e8 00 00 00 00	 call	 _pwalkback

; 2237 : #endif /* WALKBACK */
; 2238 : 	P_abort();		      /* Abort */

  000aa	e8 00 00 00 00	 call	 _P_abort

; 2239 : 	atl_comment = state = Falsity;/* Reset all interpretation state */

  000af	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  000b4	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000ba	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  000c1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl_comment, 0
  000cb	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl_comment+4, 0

; 2240 : 	forgetpend = defpend = stringlit =
; 2241 : 		     tickpend = ctickpend = False;

  000d5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ctickpend, 0
  000df	a1 00 00 00 00	 mov	 eax, DWORD PTR _ctickpend
  000e4	a3 00 00 00 00	 mov	 DWORD PTR _tickpend, eax
  000e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tickpend
  000ef	89 0d 00 00 00
	00		 mov	 DWORD PTR _stringlit, ecx
  000f5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stringlit
  000fb	89 15 00 00 00
	00		 mov	 DWORD PTR _defpend, edx
  00101	a1 00 00 00 00	 mov	 eax, DWORD PTR _defpend
  00106	a3 00 00 00 00	 mov	 DWORD PTR _forgetpend, eax
$LN4@P_abortq:

; 2242 :     }
; 2243 : }

  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx
  0010e	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00114	3b ec		 cmp	 ebp, esp
  00116	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c3		 ret	 0
_P_abortq ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_immediate
_TEXT	SEGMENT
_P_immediate PROC					; COMDAT

; 2248 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2249 :     dict->wname[0] |= IMMEDIATE;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  00023	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00026	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00029	83 ca 01	 or	 edx, 1
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  00031	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00034	88 11		 mov	 BYTE PTR [ecx], dl

; 2250 : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
_P_immediate ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_lbrack
_TEXT	SEGMENT
tv66 = -196						; size = 4
_P_lbrack PROC						; COMDAT

; 2253 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2254 :     Compiling;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv66[ebp], eax
  00029	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv66[ebp]
  0002f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv66[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	75 07		 jne	 SHORT $LN1@P_lbrack
  0003c	e8 00 00 00 00	 call	 _notcomp
  00041	eb 12		 jmp	 SHORT $LN2@P_lbrack
$LN1@P_lbrack:

; 2255 :     state = Falsity;

  00043	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00048	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0004e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN2@P_lbrack:

; 2256 : }

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
_P_lbrack ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_rbrack
_TEXT	SEGMENT
_P_rbrack PROC						; COMDAT

; 2259 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2260 :     state = Truth;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00029	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1

; 2261 : }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
_P_rbrack ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_does
_TEXT	SEGMENT
tv81 = -220						; size = 4
_hp$84490 = -20						; size = 4
_sp$84488 = -8						; size = 4
_P_does	PROC						; COMDAT

; 2283 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2284 : 
; 2285 :     /* O.K., we were compiling our way through this definition and we've
; 2286 :        encountered the Dreaded and Dastardly Does.  Here's what we do
; 2287 :        about it.  The problem is that when we execute the word, we
; 2288 :        want to push its address on the stack and call the code for the
; 2289 :        DOES> clause by diverting the IP to that address.  But...how
; 2290 :        are we to know where the DOES> clause goes without adding a
; 2291 :        field to every word in the system just to remember it.  Recall
; 2292 :        that since this system is portable we can't cop-out through
; 2293 :        machine code.  Further, we can't compile something into the
; 2294 :        word because the defining code may have already allocated heap
; 2295 :        for the word's body.  Yukkkk.  Oh well, how about this?  Let's
; 2296 :        copy any and all heap allocated for the word down one stackitem
; 2297 :        and then jam the DOES> code address BEFORE the link field in
; 2298 :        the word we're defining.
; 2299 : 
; 2300 :        Then, when (DOES>) (P_dodoes) is called to execute the word, it
; 2301 :        will fetch that code address by backing up past the start of
; 2302 :        the word and seting IP to it.  Note that FORGET must recognise
; 2303 :        such words (by the presence of the pointer to P_dodoes() in
; 2304 :        their wcode field, in case you're wondering), and make sure to
; 2305 :        deallocate the heap word containing the link when a
; 2306 :        DOES>-defined word is deleted.  */
; 2307 : 
; 2308 :     if (createword != NULL) {

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _createword, 0
  00025	0f 84 f8 00 00
	00		 je	 $LN7@P_does

; 2309 : 	stackitem *sp = ((stackitem *) createword), *hp;

  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR _createword
  00030	89 45 f8	 mov	 DWORD PTR _sp$84488[ebp], eax

; 2310 : 
; 2311 : 	Rsl(1);

  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00038	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _rstack
  0003e	c1 f8 02	 sar	 eax, 2
  00041	83 f8 01	 cmp	 eax, 1
  00044	7d 0a		 jge	 SHORT $LN5@P_does
  00046	e8 00 00 00 00	 call	 _rstakunder
  0004b	e9 d3 00 00 00	 jmp	 $LN7@P_does
$LN5@P_does:

; 2312 : 	Ho(1);

  00050	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00055	83 c0 08	 add	 eax, 8
  00058	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  0005e	76 0a		 jbe	 SHORT $LN4@P_does
  00060	e8 00 00 00 00	 call	 _heapover
  00065	e9 b9 00 00 00	 jmp	 $LN7@P_does
$LN4@P_does:

; 2313 : 
; 2314 : 	/* Copy the word definition one word down in the heap to
; 2315 : 	   permit us to prefix it with the DOES clause address. */
; 2316 : 
; 2317 : 	for (hp = hptr - 1; hp >= sp; hp--)

  0006a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0006f	83 e8 08	 sub	 eax, 8
  00072	89 45 ec	 mov	 DWORD PTR _hp$84490[ebp], eax
  00075	eb 09		 jmp	 SHORT $LN3@P_does
$LN2@P_does:
  00077	8b 45 ec	 mov	 eax, DWORD PTR _hp$84490[ebp]
  0007a	83 e8 08	 sub	 eax, 8
  0007d	89 45 ec	 mov	 DWORD PTR _hp$84490[ebp], eax
$LN3@P_does:
  00080	8b 45 ec	 mov	 eax, DWORD PTR _hp$84490[ebp]
  00083	3b 45 f8	 cmp	 eax, DWORD PTR _sp$84488[ebp]
  00086	72 13		 jb	 SHORT $LN1@P_does

; 2318 : 	    *(hp + 1) = *hp;

  00088	8b 45 ec	 mov	 eax, DWORD PTR _hp$84490[ebp]
  0008b	8b 4d ec	 mov	 ecx, DWORD PTR _hp$84490[ebp]
  0008e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00090	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00093	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00096	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00099	eb dc		 jmp	 SHORT $LN2@P_does
$LN1@P_does:

; 2319 : 	hptr++; 		      /* Expand allocated length of word */

  0009b	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000a0	83 c0 08	 add	 eax, 8
  000a3	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2320 : 	*sp++ = (stackitem) ip;       /* Store DOES> clause address before

  000a8	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  000ad	99		 cdq
  000ae	8b 4d f8	 mov	 ecx, DWORD PTR _sp$84488[ebp]
  000b1	89 01		 mov	 DWORD PTR [ecx], eax
  000b3	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  000b6	8b 55 f8	 mov	 edx, DWORD PTR _sp$84488[ebp]
  000b9	83 c2 08	 add	 edx, 8
  000bc	89 55 f8	 mov	 DWORD PTR _sp$84488[ebp], edx

; 2321 :                                          word's definition structure. */
; 2322 : 	createword = (dictword *) sp; /* Move word definition down 1 item */

  000bf	8b 45 f8	 mov	 eax, DWORD PTR _sp$84488[ebp]
  000c2	a3 00 00 00 00	 mov	 DWORD PTR _createword, eax

; 2323 : 	createword->wcode = P_dodoes; /* Set code field to indirect jump */

  000c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _createword
  000cc	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _P_dodoes

; 2324 : 
; 2325 : 	/* Now simulate an EXIT to bail out of the definition without
; 2326 : 	   executing the DOES> clause at definition time. */
; 2327 : 
; 2328 : 	ip = R0;		      /* Set IP to top of return stack */

  000d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  000d8	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  000db	89 0d 00 00 00
	00		 mov	 DWORD PTR _ip, ecx

; 2329 : #ifdef WALKBACK
; 2330 : 	wbptr = (wbptr > wback) ? wbptr - 1 : wback;

  000e1	a1 00 00 00 00	 mov	 eax, DWORD PTR _wbptr
  000e6	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _wback
  000ec	76 11		 jbe	 SHORT $LN9@P_does
  000ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _wbptr
  000f4	83 e9 04	 sub	 ecx, 4
  000f7	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv81[ebp], ecx
  000fd	eb 0c		 jmp	 SHORT $LN10@P_does
$LN9@P_does:
  000ff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _wback
  00105	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv81[ebp], edx
$LN10@P_does:
  0010b	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv81[ebp]
  00111	a3 00 00 00 00	 mov	 DWORD PTR _wbptr, eax

; 2331 : #endif
; 2332 : 	Rpop;			      /* Pop the return stack */

  00116	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  0011b	83 e8 04	 sub	 eax, 4
  0011e	a3 00 00 00 00	 mov	 DWORD PTR _rstk, eax
$LN7@P_does:

; 2333 :     }
; 2334 : }

  00123	5f		 pop	 edi
  00124	5e		 pop	 esi
  00125	5b		 pop	 ebx
  00126	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0012c	3b ec		 cmp	 ebp, esp
  0012e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00133	8b e5		 mov	 esp, ebp
  00135	5d		 pop	 ebp
  00136	c3		 ret	 0
_P_does	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_dodoes
_TEXT	SEGMENT
_P_dodoes PROC						; COMDAT

; 2264 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2265 :     Rso(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00023	83 c0 04	 add	 eax, 4
  00026	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _rstacktop
  0002c	76 0a		 jbe	 SHORT $LN2@P_dodoes
  0002e	e8 00 00 00 00	 call	 _rstakover
  00033	e9 80 00 00 00	 jmp	 $LN3@P_dodoes
$LN2@P_dodoes:

; 2266 :     So(1);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	83 c0 08	 add	 eax, 8
  00040	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00046	76 07		 jbe	 SHORT $LN1@P_dodoes
  00048	e8 00 00 00 00	 call	 _stakover
  0004d	eb 69		 jmp	 SHORT $LN3@P_dodoes
$LN1@P_dodoes:

; 2267 :     Rpush = ip; 		      /* Push instruction pointer */

  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00054	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ip
  0005a	89 08		 mov	 DWORD PTR [eax], ecx
  0005c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  00062	83 c2 04	 add	 edx, 4
  00065	89 15 00 00 00
	00		 mov	 DWORD PTR _rstk, edx

; 2268 : #ifdef WALKBACK
; 2269 :     *wbptr++ = curword; 	      /* Place word on walkback stack */

  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR _wbptr
  00070	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _curword
  00076	89 08		 mov	 DWORD PTR [eax], ecx
  00078	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _wbptr
  0007e	83 c2 04	 add	 edx, 4
  00081	89 15 00 00 00
	00		 mov	 DWORD PTR _wbptr, edx

; 2270 : #endif
; 2271 :     /* The compiler having craftily squirreled away the DOES> clause
; 2272 :        address before the word definition on the heap, we back up to
; 2273 :        the heap cell before the current word and load the pointer from
; 2274 :        there.  This is an ABSOLUTE heap address, not a relative offset. */
; 2275 :     ip = *((dictword ***) (((stackitem *) curword) - 1));

  00087	a1 00 00 00 00	 mov	 eax, DWORD PTR _curword
  0008c	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0008f	89 0d 00 00 00
	00		 mov	 DWORD PTR _ip, ecx

; 2276 : 
; 2277 :     /* Push the address of this word's body as the argument to the
; 2278 :        DOES> clause. */
; 2279 :     Push = (stackitem) (((stackitem *) curword) + Dictwordl);

  00095	a1 00 00 00 00	 mov	 eax, DWORD PTR _curword
  0009a	83 c0 10	 add	 eax, 16			; 00000010H
  0009d	99		 cdq
  0009e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  000a4	89 01		 mov	 DWORD PTR [ecx], eax
  000a6	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  000a9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  000af	83 c2 08	 add	 edx, 8
  000b2	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN3@P_dodoes:

; 2280 : }

  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx
  000bb	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000c1	3b ec		 cmp	 ebp, esp
  000c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
_P_dodoes ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_colon
_TEXT	SEGMENT
_P_colon PROC						; COMDAT

; 2337 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2338 :     state = Truth;		      /* Set compilation underway */

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00029	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1

; 2339 :     P_create(); 		      /* Create conventional word */

  00030	e8 00 00 00 00	 call	 _P_create

; 2340 : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_P_colon ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_exit	DQ	01H DUP (?)
; Function compile flags: /Odtp /RTCsu /ZI
_BSS	ENDS
;	COMDAT _P_semicolon
_TEXT	SEGMENT
tv71 = -196						; size = 4
_P_semicolon PROC					; COMDAT

; 2343 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2344 :     Compiling;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv71[ebp], eax
  00029	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv71[ebp]
  0002f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv71[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	75 07		 jne	 SHORT $LN3@P_semicolo
  0003c	e8 00 00 00 00	 call	 _notcomp
  00041	eb 6b		 jmp	 SHORT $LN4@P_semicolo
$LN3@P_semicolo:

; 2345 :     Ho(1);

  00043	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00048	83 c0 08	 add	 eax, 8
  0004b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00051	76 07		 jbe	 SHORT $LN2@P_semicolo
  00053	e8 00 00 00 00	 call	 _heapover
  00058	eb 54		 jmp	 SHORT $LN4@P_semicolo
$LN2@P_semicolo:

; 2346 :     Hstore = s_exit;

  0005a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0005f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_exit
  00065	89 08		 mov	 DWORD PTR [eax], ecx
  00067	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_exit+4
  0006d	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00070	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00075	83 c0 08	 add	 eax, 8
  00078	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2347 :     state = Falsity;		      /* No longer compiling */

  0007d	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00082	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00088	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 2348 :     /* We wait until now to plug the P_nest code so that it will be
; 2349 :        present only in completed definitions. */
; 2350 :     if (createword != NULL)

  0008f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _createword, 0
  00096	74 0c		 je	 SHORT $LN1@P_semicolo

; 2351 : 	createword->wcode = P_nest;   /* Use P_nest for code */

  00098	a1 00 00 00 00	 mov	 eax, DWORD PTR _createword
  0009d	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _P_nest
$LN1@P_semicolo:

; 2352 :     createword = NULL;		      /* Flag no word being created */

  000a4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _createword, 0
$LN4@P_semicolo:

; 2353 : }

  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx
  000b1	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  000b7	3b ec		 cmp	 ebp, esp
  000b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
_P_semicolon ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@JGGOCGGA@?6Word?5requested?5by?5?$GA?5not?5on?5same@ ; `string'
PUBLIC	??_C@_0CE@MDBGKFCP@?6Word?5not?5specified?5when?5expecte@ ; `string'
PUBLIC	??_C@_0BB@OHOHCFGF@?5?8?$CFs?8?5undefined?5?$AA@ ; `string'
_BSS	SEGMENT
_tokbuf	DB	080H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CO@JGGOCGGA@?6Word?5requested?5by?5?$GA?5not?5on?5same@
CONST	SEGMENT
??_C@_0CO@JGGOCGGA@?6Word?5requested?5by?5?$GA?5not?5on?5same@ DB 0aH, 'W'
	DB	'ord requested by ` not on same input line.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MDBGKFCP@?6Word?5not?5specified?5when?5expecte@
CONST	SEGMENT
??_C@_0CE@MDBGKFCP@?6Word?5not?5specified?5when?5expecte@ DB 0aH, 'Word n'
	DB	'ot specified when expected.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OHOHCFGF@?5?8?$CFs?8?5undefined?5?$AA@
CONST	SEGMENT
??_C@_0BB@OHOHCFGF@?5?8?$CFs?8?5undefined?5?$AA@ DB ' ''%s'' undefined ', 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _P_tick
_TEXT	SEGMENT
_di$84512 = -20						; size = 4
_i$ = -8						; size = 4
_P_tick	PROC						; COMDAT

; 2356 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2357 :     int i;
; 2358 : 
; 2359 :     /* Try to get next symbol from the input stream.  If
; 2360 :        we can't, and we're executing a compiled word,
; 2361 :        report an error.  Since we can't call back to the
; 2362 :        calling program for more input, we're stuck. */
; 2363 : 
; 2364 :     i = token(&instream);	      /* Scan for next token */

  0001e	68 00 00 00 00	 push	 OFFSET _instream
  00023	e8 00 00 00 00	 call	 _token
  00028	83 c4 04	 add	 esp, 4
  0002b	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax

; 2365 :     if (i != TokNull) {

  0002e	83 7d f8 00	 cmp	 DWORD PTR _i$[ebp], 0
  00032	0f 84 9f 00 00
	00		 je	 $LN9@P_tick

; 2366 : 	if (i == TokWord) {

  00038	83 7d f8 01	 cmp	 DWORD PTR _i$[ebp], 1
  0003c	75 7b		 jne	 SHORT $LN8@P_tick

; 2367 : 	    dictword *di;
; 2368 : 
; 2369 : 	    ucase(tokbuf);

  0003e	68 00 00 00 00	 push	 OFFSET _tokbuf
  00043	e8 00 00 00 00	 call	 _ucase
  00048	83 c4 04	 add	 esp, 4

; 2370 : 	    if ((di = lookup(tokbuf)) != NULL) {

  0004b	68 00 00 00 00	 push	 OFFSET _tokbuf
  00050	e8 00 00 00 00	 call	 _lookup
  00055	83 c4 04	 add	 esp, 4
  00058	89 45 ec	 mov	 DWORD PTR _di$84512[ebp], eax
  0005b	83 7d ec 00	 cmp	 DWORD PTR _di$84512[ebp], 0
  0005f	74 3a		 je	 SHORT $LN7@P_tick

; 2371 : 		So(1);

  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00066	83 c0 08	 add	 eax, 8
  00069	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  0006f	76 0a		 jbe	 SHORT $LN6@P_tick
  00071	e8 00 00 00 00	 call	 _stakover
  00076	e9 8d 00 00 00	 jmp	 $LN10@P_tick
$LN6@P_tick:

; 2372 : 		Push = (stackitem) di; /* Push word compile address */

  0007b	8b 45 ec	 mov	 eax, DWORD PTR _di$84512[ebp]
  0007e	99		 cdq
  0007f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00085	89 01		 mov	 DWORD PTR [ecx], eax
  00087	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0008a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00090	83 c2 08	 add	 edx, 8
  00093	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 2373 : 	    } else {

  00099	eb 1c		 jmp	 SHORT $LN5@P_tick
$LN7@P_tick:

; 2374 :                 V printf(" '%s' undefined ", tokbuf);

  0009b	8b f4		 mov	 esi, esp
  0009d	68 00 00 00 00	 push	 OFFSET _tokbuf
  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@OHOHCFGF@?5?8?$CFs?8?5undefined?5?$AA@
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000ad	83 c4 08	 add	 esp, 8
  000b0	3b f4		 cmp	 esi, esp
  000b2	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@P_tick:

; 2375 : 	    }
; 2376 : 	} else {

  000b7	eb 1c		 jmp	 SHORT $LN4@P_tick
$LN8@P_tick:

; 2377 :             V printf("\nWord not specified when expected.\n");

  000b9	8b f4		 mov	 esi, esp
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@MDBGKFCP@?6Word?5not?5specified?5when?5expecte@
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000c6	83 c4 04	 add	 esp, 4
  000c9	3b f4		 cmp	 esi, esp
  000cb	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2378 : 	    P_abort();

  000d0	e8 00 00 00 00	 call	 _P_abort
$LN4@P_tick:

; 2379 : 	}
; 2380 :     } else {

  000d5	eb 31		 jmp	 SHORT $LN10@P_tick
$LN9@P_tick:

; 2381 : 	/* O.K., there was nothing in the input stream.  Set the
; 2382 : 	   tickpend flag to cause the compilation address of the next
; 2383 :            token to be pushed when it's supplied on a subsequent input
; 2384 : 	   line. */
; 2385 : 	if (ip == NULL) {

  000d7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ip, 0
  000de	75 0c		 jne	 SHORT $LN2@P_tick

; 2386 : 	    tickpend = True;	      /* Set tick pending */

  000e0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _tickpend, 1

; 2387 : 	} else {

  000ea	eb 1c		 jmp	 SHORT $LN10@P_tick
$LN2@P_tick:

; 2388 :             V printf("\nWord requested by ` not on same input line.\n");

  000ec	8b f4		 mov	 esi, esp
  000ee	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@JGGOCGGA@?6Word?5requested?5by?5?$GA?5not?5on?5same@
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000f9	83 c4 04	 add	 esp, 4
  000fc	3b f4		 cmp	 esi, esp
  000fe	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2389 : 	    P_abort();

  00103	e8 00 00 00 00	 call	 _P_abort
$LN10@P_tick:

; 2390 : 	}
; 2391 :     }
; 2392 : }

  00108	5f		 pop	 edi
  00109	5e		 pop	 esi
  0010a	5b		 pop	 ebx
  0010b	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00111	3b ec		 cmp	 ebp, esp
  00113	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c3		 ret	 0
_P_tick	ENDP
_TEXT	ENDS
EXTRN	__imp__toupper:PROC
EXTRN	__imp__islower:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _ucase
_TEXT	SEGMENT
_ch$ = -5						; size = 1
_c$ = 8							; size = 4
_ucase	PROC						; COMDAT

; 260  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
$LN3@ucase:

; 261  :     char ch;
; 262  : 
; 263  :     while ((ch = *c) != EOS) {

  0001e	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00021	8a 08		 mov	 cl, BYTE PTR [eax]
  00023	88 4d fb	 mov	 BYTE PTR _ch$[ebp], cl
  00026	0f be 55 fb	 movsx	 edx, BYTE PTR _ch$[ebp]
  0002a	85 d2		 test	 edx, edx
  0002c	74 42		 je	 SHORT $LN4@ucase

; 264  : 	if (islower(ch))

  0002e	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00032	8b f4		 mov	 esi, esp
  00034	50		 push	 eax
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__islower
  0003b	83 c4 04	 add	 esp, 4
  0003e	3b f4		 cmp	 esi, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	85 c0		 test	 eax, eax
  00047	74 1c		 je	 SHORT $LN1@ucase

; 265  : 	    *c = toupper(ch);

  00049	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0004d	8b f4		 mov	 esi, esp
  0004f	50		 push	 eax
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__toupper
  00056	83 c4 04	 add	 esp, 4
  00059	3b f4		 cmp	 esi, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00063	88 01		 mov	 BYTE PTR [ecx], al
$LN1@ucase:

; 266  : 	c++;

  00065	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00068	83 c0 01	 add	 eax, 1
  0006b	89 45 08	 mov	 DWORD PTR _c$[ebp], eax

; 267  :     }

  0006e	eb ae		 jmp	 SHORT $LN3@ucase
$LN4@ucase:

; 268  : }

  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx
  00073	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00079	3b ec		 cmp	 ebp, esp
  0007b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
_ucase	ENDP
_TEXT	ENDS
PUBLIC	??_C@_05CLIFEECF@?$CFlf?$CFc?$AA@		; `string'
PUBLIC	??_C@_01ODHLEDKK@?$CI?$AA@			; `string'
PUBLIC	??_C@_01KICIPPFI@?2?$AA@			; `string'
PUBLIC	??_C@_0BF@MJHGENMC@?6Runaway?5string?3?5?$CFs?6?$AA@ ; `string'
EXTRN	__imp__sscanf:PROC
EXTRN	__imp__isdigit:PROC
EXTRN	__imp__isspace:PROC
_BSS	SEGMENT
_tokreal DQ	01H DUP (?)
_tokint	DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_05CLIFEECF@?$CFlf?$CFc?$AA@
CONST	SEGMENT
??_C@_05CLIFEECF@?$CFlf?$CFc?$AA@ DB '%lf%c', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01ODHLEDKK@?$CI?$AA@
CONST	SEGMENT
??_C@_01ODHLEDKK@?$CI?$AA@ DB '(', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2?$AA@
CONST	SEGMENT
??_C@_01KICIPPFI@?2?$AA@ DB '\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MJHGENMC@?6Runaway?5string?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BF@MJHGENMC@?6Runaway?5string?3?5?$CFs?6?$AA@ DB 0aH, 'Runaway str'
	DB	'ing: %s', 0aH, 00H				; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _token
_TEXT	SEGMENT
tv95 = -304						; size = 4
_tcp$83010 = -104					; size = 4
_tc$83009 = -89						; size = 1
_c$82986 = -77						; size = 1
_c$82965 = -65						; size = 1
_rstring$82952 = -56					; size = 4
_istring$82951 = -44					; size = 4
_tl$82950 = -32						; size = 4
_tp$82949 = -20						; size = 4
_sp$ = -8						; size = 4
_cp$ = 8						; size = 4
_token	PROC						; COMDAT

; 274  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd d0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-304]
  00012	b9 4c 00 00 00	 mov	 ecx, 76			; 0000004cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 275  :     char *sp = *cp;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _cp$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	89 4d f8	 mov	 DWORD PTR _sp$[ebp], ecx
$LN46@token:

; 276  : 
; 277  :     while (True) {

  00026	b8 01 00 00 00	 mov	 eax, 1
  0002b	85 c0		 test	 eax, eax
  0002d	0f 84 ea 03 00
	00		 je	 $LN47@token

; 278  : 	char *tp = tokbuf;

  00033	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _tp$82949[ebp], OFFSET _tokbuf

; 279  : 	int tl = 0;

  0003a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _tl$82950[ebp], 0

; 280  : 	Boolean istring = False, rstring = False;

  00041	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _istring$82951[ebp], 0
  00048	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _rstring$82952[ebp], 0

; 281  : 
; 282  : 	if (atl_comment) {

  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_comment
  00054	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _atl_comment+4
  0005a	74 4c		 je	 SHORT $LN40@token
$LN43@token:

; 283  :             while (*sp != ')') {

  0005c	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  0005f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00062	83 f9 29	 cmp	 ecx, 41			; 00000029H
  00065	74 24		 je	 SHORT $LN42@token

; 284  : 		if (*sp == EOS) {

  00067	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  0006a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0006d	85 c9		 test	 ecx, ecx
  0006f	75 0f		 jne	 SHORT $LN41@token

; 285  : 		    *cp = sp;

  00071	8b 45 08	 mov	 eax, DWORD PTR _cp$[ebp]
  00074	8b 4d f8	 mov	 ecx, DWORD PTR _sp$[ebp]
  00077	89 08		 mov	 DWORD PTR [eax], ecx

; 286  : 		    return TokNull;

  00079	33 c0		 xor	 eax, eax
  0007b	e9 9d 03 00 00	 jmp	 $LN47@token
$LN41@token:

; 287  : 		}
; 288  : 		sp++;

  00080	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  00083	83 c0 01	 add	 eax, 1
  00086	89 45 f8	 mov	 DWORD PTR _sp$[ebp], eax

; 289  : 	    }

  00089	eb d1		 jmp	 SHORT $LN43@token
$LN42@token:

; 290  : 	    sp++;

  0008b	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  0008e	83 c0 01	 add	 eax, 1
  00091	89 45 f8	 mov	 DWORD PTR _sp$[ebp], eax

; 291  : 	    atl_comment = Falsity;

  00094	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl_comment, 0
  0009e	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl_comment+4, 0
$LN40@token:

; 292  : 	}
; 293  : 
; 294  : 	while (isspace(*sp))		  /* Skip leading blanks */

  000a8	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  000ab	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000ae	8b f4		 mov	 esi, esp
  000b0	51		 push	 ecx
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__isspace
  000b7	83 c4 04	 add	 esp, 4
  000ba	3b f4		 cmp	 esi, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c1	85 c0		 test	 eax, eax
  000c3	74 0b		 je	 SHORT $LN39@token

; 295  : 	    sp++;

  000c5	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  000c8	83 c0 01	 add	 eax, 1
  000cb	89 45 f8	 mov	 DWORD PTR _sp$[ebp], eax
  000ce	eb d8		 jmp	 SHORT $LN40@token
$LN39@token:

; 296  : 
; 297  :         if (*sp == '"') {                 /* Is this a string ? */

  000d0	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  000d3	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000d6	83 f9 22	 cmp	 ecx, 34			; 00000022H
  000d9	0f 85 20 01 00
	00		 jne	 $LN20@token

; 298  : 
; 299  : 	    /* Assemble string token. */
; 300  : 
; 301  : 	    sp++;

  000df	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  000e2	83 c0 01	 add	 eax, 1
  000e5	89 45 f8	 mov	 DWORD PTR _sp$[ebp], eax
$LN37@token:

; 302  : 	    while (True) {

  000e8	b8 01 00 00 00	 mov	 eax, 1
  000ed	85 c0		 test	 eax, eax
  000ef	0f 84 01 01 00
	00		 je	 $LN36@token

; 303  : 		char c = *sp++;

  000f5	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  000f8	8a 08		 mov	 cl, BYTE PTR [eax]
  000fa	88 4d bf	 mov	 BYTE PTR _c$82965[ebp], cl
  000fd	8b 55 f8	 mov	 edx, DWORD PTR _sp$[ebp]
  00100	83 c2 01	 add	 edx, 1
  00103	89 55 f8	 mov	 DWORD PTR _sp$[ebp], edx

; 304  : 
; 305  :                 if (c == '"') {

  00106	0f be 45 bf	 movsx	 eax, BYTE PTR _c$82965[ebp]
  0010a	83 f8 22	 cmp	 eax, 34			; 00000022H
  0010d	75 1f		 jne	 SHORT $LN35@token

; 306  : 		    sp++;

  0010f	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  00112	83 c0 01	 add	 eax, 1
  00115	89 45 f8	 mov	 DWORD PTR _sp$[ebp], eax

; 307  : 		    *tp++ = EOS;

  00118	8b 45 ec	 mov	 eax, DWORD PTR _tp$82949[ebp]
  0011b	c6 00 00	 mov	 BYTE PTR [eax], 0
  0011e	8b 4d ec	 mov	 ecx, DWORD PTR _tp$82949[ebp]
  00121	83 c1 01	 add	 ecx, 1
  00124	89 4d ec	 mov	 DWORD PTR _tp$82949[ebp], ecx

; 308  : 		    break;

  00127	e9 ca 00 00 00	 jmp	 $LN36@token
  0012c	eb 23		 jmp	 SHORT $LN34@token
$LN35@token:

; 309  : 		} else if (c == EOS) {

  0012e	0f be 45 bf	 movsx	 eax, BYTE PTR _c$82965[ebp]
  00132	85 c0		 test	 eax, eax
  00134	75 1b		 jne	 SHORT $LN34@token

; 310  : 		    rstring = True;

  00136	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _rstring$82952[ebp], 1

; 311  : 		    *tp++ = EOS;

  0013d	8b 45 ec	 mov	 eax, DWORD PTR _tp$82949[ebp]
  00140	c6 00 00	 mov	 BYTE PTR [eax], 0
  00143	8b 4d ec	 mov	 ecx, DWORD PTR _tp$82949[ebp]
  00146	83 c1 01	 add	 ecx, 1
  00149	89 4d ec	 mov	 DWORD PTR _tp$82949[ebp], ecx

; 312  : 		    break;

  0014c	e9 a5 00 00 00	 jmp	 $LN36@token
$LN34@token:

; 313  : 		}
; 314  :                 if (c == '\\') {

  00151	0f be 45 bf	 movsx	 eax, BYTE PTR _c$82965[ebp]
  00155	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  00158	75 6e		 jne	 SHORT $LN32@token

; 315  : 		    c = *sp++;

  0015a	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  0015d	8a 08		 mov	 cl, BYTE PTR [eax]
  0015f	88 4d bf	 mov	 BYTE PTR _c$82965[ebp], cl
  00162	8b 55 f8	 mov	 edx, DWORD PTR _sp$[ebp]
  00165	83 c2 01	 add	 edx, 1
  00168	89 55 f8	 mov	 DWORD PTR _sp$[ebp], edx

; 316  : 		    if (c == EOS) {

  0016b	0f be 45 bf	 movsx	 eax, BYTE PTR _c$82965[ebp]
  0016f	85 c0		 test	 eax, eax
  00171	75 09		 jne	 SHORT $LN31@token

; 317  : 			rstring = True;

  00173	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _rstring$82952[ebp], 1

; 318  : 			break;

  0017a	eb 7a		 jmp	 SHORT $LN36@token
$LN31@token:

; 319  : 		    }
; 320  : 		    switch (c) {

  0017c	0f be 45 bf	 movsx	 eax, BYTE PTR _c$82965[ebp]
  00180	89 85 d0 fe ff
	ff		 mov	 DWORD PTR tv95[ebp], eax
  00186	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv95[ebp]
  0018c	83 e9 62	 sub	 ecx, 98			; 00000062H
  0018f	89 8d d0 fe ff
	ff		 mov	 DWORD PTR tv95[ebp], ecx
  00195	83 bd d0 fe ff
	ff 12		 cmp	 DWORD PTR tv95[ebp], 18	; 00000012H
  0019c	77 2a		 ja	 SHORT $LN32@token
  0019e	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR tv95[ebp]
  001a4	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN49@token[edx]
  001ab	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN54@token[eax*4]
$LN28@token:

; 321  :                         case 'b':
; 322  :                             c = '\b';

  001b2	c6 45 bf 08	 mov	 BYTE PTR _c$82965[ebp], 8

; 323  : 			    break;

  001b6	eb 10		 jmp	 SHORT $LN32@token
$LN27@token:

; 324  :                         case 'n':
; 325  :                             c = '\n';

  001b8	c6 45 bf 0a	 mov	 BYTE PTR _c$82965[ebp], 10 ; 0000000aH

; 326  : 			    break;

  001bc	eb 0a		 jmp	 SHORT $LN32@token
$LN26@token:

; 327  :                         case 'r':
; 328  :                             c = '\r';

  001be	c6 45 bf 0d	 mov	 BYTE PTR _c$82965[ebp], 13 ; 0000000dH

; 329  : 			    break;

  001c2	eb 04		 jmp	 SHORT $LN32@token
$LN25@token:

; 330  :                         case 't':
; 331  :                             c = '\t';

  001c4	c6 45 bf 09	 mov	 BYTE PTR _c$82965[ebp], 9
$LN32@token:

; 332  : 			    break;
; 333  : 			default:
; 334  : 			    break;
; 335  : 		    }
; 336  : 		}
; 337  : 		if (tl < (sizeof tokbuf) - 1) {

  001c8	83 7d e0 7f	 cmp	 DWORD PTR _tl$82950[ebp], 127 ; 0000007fH
  001cc	73 1c		 jae	 SHORT $LN23@token

; 338  : 		   *tp++ = c;

  001ce	8b 45 ec	 mov	 eax, DWORD PTR _tp$82949[ebp]
  001d1	8a 4d bf	 mov	 cl, BYTE PTR _c$82965[ebp]
  001d4	88 08		 mov	 BYTE PTR [eax], cl
  001d6	8b 55 ec	 mov	 edx, DWORD PTR _tp$82949[ebp]
  001d9	83 c2 01	 add	 edx, 1
  001dc	89 55 ec	 mov	 DWORD PTR _tp$82949[ebp], edx

; 339  : 		   tl++;

  001df	8b 45 e0	 mov	 eax, DWORD PTR _tl$82950[ebp]
  001e2	83 c0 01	 add	 eax, 1
  001e5	89 45 e0	 mov	 DWORD PTR _tl$82950[ebp], eax

; 340  : 		} else {

  001e8	eb 07		 jmp	 SHORT $LN22@token
$LN23@token:

; 341  : 		    rstring = True;

  001ea	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _rstring$82952[ebp], 1
$LN22@token:

; 342  : 		}
; 343  : 	    }

  001f1	e9 f2 fe ff ff	 jmp	 $LN37@token
$LN36@token:

; 344  : 	    istring = True;

  001f6	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _istring$82951[ebp], 1

; 345  : 	} else {

  001fd	eb 70		 jmp	 SHORT $LN21@token
$LN20@token:

; 346  : 
; 347  : 	    /* Scan the next raw token */
; 348  : 
; 349  : 	    while (True) {

  001ff	b8 01 00 00 00	 mov	 eax, 1
  00204	85 c0		 test	 eax, eax
  00206	74 67		 je	 SHORT $LN21@token

; 350  : 		char c = *sp++;

  00208	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  0020b	8a 08		 mov	 cl, BYTE PTR [eax]
  0020d	88 4d b3	 mov	 BYTE PTR _c$82986[ebp], cl
  00210	8b 55 f8	 mov	 edx, DWORD PTR _sp$[ebp]
  00213	83 c2 01	 add	 edx, 1
  00216	89 55 f8	 mov	 DWORD PTR _sp$[ebp], edx

; 351  : 
; 352  : 		if (c == EOS || isspace(c)) {

  00219	0f be 45 b3	 movsx	 eax, BYTE PTR _c$82986[ebp]
  0021d	85 c0		 test	 eax, eax
  0021f	74 1b		 je	 SHORT $LN17@token
  00221	0f be 45 b3	 movsx	 eax, BYTE PTR _c$82986[ebp]
  00225	8b f4		 mov	 esi, esp
  00227	50		 push	 eax
  00228	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__isspace
  0022e	83 c4 04	 add	 esp, 4
  00231	3b f4		 cmp	 esi, esp
  00233	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00238	85 c0		 test	 eax, eax
  0023a	74 11		 je	 SHORT $LN18@token
$LN17@token:

; 353  : 		    *tp++ = EOS;

  0023c	8b 45 ec	 mov	 eax, DWORD PTR _tp$82949[ebp]
  0023f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00242	8b 4d ec	 mov	 ecx, DWORD PTR _tp$82949[ebp]
  00245	83 c1 01	 add	 ecx, 1
  00248	89 4d ec	 mov	 DWORD PTR _tp$82949[ebp], ecx

; 354  : 		    break;

  0024b	eb 22		 jmp	 SHORT $LN21@token
$LN18@token:

; 355  : 		}
; 356  : 		if (tl < (sizeof tokbuf) - 1) {

  0024d	83 7d e0 7f	 cmp	 DWORD PTR _tl$82950[ebp], 127 ; 0000007fH
  00251	73 1a		 jae	 SHORT $LN16@token

; 357  : 		    *tp++ = c;

  00253	8b 45 ec	 mov	 eax, DWORD PTR _tp$82949[ebp]
  00256	8a 4d b3	 mov	 cl, BYTE PTR _c$82986[ebp]
  00259	88 08		 mov	 BYTE PTR [eax], cl
  0025b	8b 55 ec	 mov	 edx, DWORD PTR _tp$82949[ebp]
  0025e	83 c2 01	 add	 edx, 1
  00261	89 55 ec	 mov	 DWORD PTR _tp$82949[ebp], edx

; 358  : 		    tl++;

  00264	8b 45 e0	 mov	 eax, DWORD PTR _tl$82950[ebp]
  00267	83 c0 01	 add	 eax, 1
  0026a	89 45 e0	 mov	 DWORD PTR _tl$82950[ebp], eax
$LN16@token:

; 359  : 		}
; 360  : 	    }

  0026d	eb 90		 jmp	 SHORT $LN20@token
$LN21@token:

; 361  : 	}
; 362  : 	*cp = --sp;			  /* Store end of scan pointer */

  0026f	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  00272	83 e8 01	 sub	 eax, 1
  00275	89 45 f8	 mov	 DWORD PTR _sp$[ebp], eax
  00278	8b 4d 08	 mov	 ecx, DWORD PTR _cp$[ebp]
  0027b	8b 55 f8	 mov	 edx, DWORD PTR _sp$[ebp]
  0027e	89 11		 mov	 DWORD PTR [ecx], edx

; 363  : 
; 364  : 	if (istring) {

  00280	83 7d d4 00	 cmp	 DWORD PTR _istring$82951[ebp], 0
  00284	74 3d		 je	 SHORT $LN15@token

; 365  : 	    if (rstring) {

  00286	83 7d c8 00	 cmp	 DWORD PTR _rstring$82952[ebp], 0
  0028a	74 2d		 je	 SHORT $LN14@token

; 366  : #ifdef MEMMESSAGE
; 367  :                 V printf("\nRunaway string: %s\n", tokbuf);

  0028c	8b f4		 mov	 esi, esp
  0028e	68 00 00 00 00	 push	 OFFSET _tokbuf
  00293	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MJHGENMC@?6Runaway?5string?3?5?$CFs?6?$AA@
  00298	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0029e	83 c4 08	 add	 esp, 8
  002a1	3b f4		 cmp	 esi, esp
  002a3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 368  : #endif
; 369  : 		evalstat = ATL_RUNSTRING;

  002a8	c7 05 00 00 00
	00 f6 ff ff ff	 mov	 DWORD PTR _evalstat, -10 ; fffffff6H

; 370  : 		return TokNull;

  002b2	33 c0		 xor	 eax, eax
  002b4	e9 64 01 00 00	 jmp	 $LN47@token
$LN14@token:

; 371  : 	    }
; 372  : 	    return TokString;

  002b9	b8 04 00 00 00	 mov	 eax, 4
  002be	e9 5a 01 00 00	 jmp	 $LN47@token
$LN15@token:

; 373  : 	}
; 374  : 
; 375  : 	if (tokbuf[0] == EOS)

  002c3	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR _tokbuf
  002ca	85 c0		 test	 eax, eax
  002cc	75 07		 jne	 SHORT $LN13@token

; 376  : 	    return TokNull;

  002ce	33 c0		 xor	 eax, eax
  002d0	e9 48 01 00 00	 jmp	 $LN47@token
$LN13@token:

; 377  : 
; 378  : 	/* See if token is a comment to end of line character.	If so, discard
; 379  : 	   the rest of the line and return null for this token request. */
; 380  : 
; 381  :         if (strcmp(tokbuf, "\\") == 0) {

  002d5	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2?$AA@
  002da	68 00 00 00 00	 push	 OFFSET _tokbuf
  002df	e8 00 00 00 00	 call	 _strcmp
  002e4	83 c4 08	 add	 esp, 8
  002e7	85 c0		 test	 eax, eax
  002e9	75 24		 jne	 SHORT $LN12@token
$LN11@token:

; 382  : 	    while (*sp != EOS)

  002eb	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  002ee	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  002f1	85 c9		 test	 ecx, ecx
  002f3	74 0b		 je	 SHORT $LN10@token

; 383  : 		sp++;

  002f5	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  002f8	83 c0 01	 add	 eax, 1
  002fb	89 45 f8	 mov	 DWORD PTR _sp$[ebp], eax
  002fe	eb eb		 jmp	 SHORT $LN11@token
$LN10@token:

; 384  : 	    *cp = sp;

  00300	8b 45 08	 mov	 eax, DWORD PTR _cp$[ebp]
  00303	8b 4d f8	 mov	 ecx, DWORD PTR _sp$[ebp]
  00306	89 08		 mov	 DWORD PTR [eax], ecx

; 385  : 	    return TokNull;

  00308	33 c0		 xor	 eax, eax
  0030a	e9 0e 01 00 00	 jmp	 $LN47@token
$LN12@token:

; 386  : 	}
; 387  : 
; 388  : 	/* See if this token is a comment open delimiter.  If so, set to
; 389  : 	   ignore all characters until the matching comment close delimiter. */
; 390  : 
; 391  :         if (strcmp(tokbuf, "(") == 0) {

  0030f	68 00 00 00 00	 push	 OFFSET ??_C@_01ODHLEDKK@?$CI?$AA@
  00314	68 00 00 00 00	 push	 OFFSET _tokbuf
  00319	e8 00 00 00 00	 call	 _strcmp
  0031e	83 c4 08	 add	 esp, 8
  00321	85 c0		 test	 eax, eax
  00323	75 5e		 jne	 SHORT $LN9@token
$LN8@token:

; 392  : 	    while (*sp != EOS) {

  00325	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  00328	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0032b	85 c9		 test	 ecx, ecx
  0032d	74 18		 je	 SHORT $LN7@token

; 393  :                 if (*sp == ')')

  0032f	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  00332	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00335	83 f9 29	 cmp	 ecx, 41			; 00000029H
  00338	75 02		 jne	 SHORT $LN6@token

; 394  : 		    break;

  0033a	eb 0b		 jmp	 SHORT $LN7@token
$LN6@token:

; 395  : 		sp++;

  0033c	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  0033f	83 c0 01	 add	 eax, 1
  00342	89 45 f8	 mov	 DWORD PTR _sp$[ebp], eax

; 396  : 	    }

  00345	eb de		 jmp	 SHORT $LN8@token
$LN7@token:

; 397  :             if (*sp == ')') {

  00347	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  0034a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0034d	83 f9 29	 cmp	 ecx, 41			; 00000029H
  00350	75 0e		 jne	 SHORT $LN5@token

; 398  : 		sp++;

  00352	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  00355	83 c0 01	 add	 eax, 1
  00358	89 45 f8	 mov	 DWORD PTR _sp$[ebp], eax

; 399  : 		continue;

  0035b	e9 c6 fc ff ff	 jmp	 $LN46@token
$LN5@token:

; 400  : 	    }
; 401  : 	    atl_comment = Truth;

  00360	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _atl_comment, -1
  0036a	c7 05 04 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _atl_comment+4, -1

; 402  : 	    *cp = sp;

  00374	8b 45 08	 mov	 eax, DWORD PTR _cp$[ebp]
  00377	8b 4d f8	 mov	 ecx, DWORD PTR _sp$[ebp]
  0037a	89 08		 mov	 DWORD PTR [eax], ecx

; 403  : 	    return TokNull;

  0037c	33 c0		 xor	 eax, eax
  0037e	e9 9a 00 00 00	 jmp	 $LN47@token
$LN9@token:

; 404  : 	}
; 405  : 
; 406  : 	/* See if the token is a number. */
; 407  : 
; 408  :         if (isdigit(tokbuf[0]) || tokbuf[0] == '-') {

  00383	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR _tokbuf
  0038a	8b f4		 mov	 esi, esp
  0038c	50		 push	 eax
  0038d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__isdigit
  00393	83 c4 04	 add	 esp, 4
  00396	3b f4		 cmp	 esi, esp
  00398	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0039d	85 c0		 test	 eax, eax
  0039f	75 0c		 jne	 SHORT $LN3@token
  003a1	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR _tokbuf
  003a8	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  003ab	75 64		 jne	 SHORT $LN4@token
$LN3@token:

; 409  : 	    char tc;
; 410  : 	    char *tcp;
; 411  : 
; 412  : #ifdef USE_SSCANF
; 413  :             if (sscanf(tokbuf, "%li%c", &tokint, &tc) == 1)
; 414  : 		return TokInt;
; 415  : #else
; 416  :     	    tokint = strtoul(tokbuf, &tcp, 0);

  003ad	8b f4		 mov	 esi, esp
  003af	6a 00		 push	 0
  003b1	8d 45 98	 lea	 eax, DWORD PTR _tcp$83010[ebp]
  003b4	50		 push	 eax
  003b5	68 00 00 00 00	 push	 OFFSET _tokbuf
  003ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtoul
  003c0	83 c4 0c	 add	 esp, 12			; 0000000cH
  003c3	3b f4		 cmp	 esi, esp
  003c5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003ca	a3 00 00 00 00	 mov	 DWORD PTR _tokint, eax

; 417  : 	    if (*tcp == 0) {

  003cf	8b 45 98	 mov	 eax, DWORD PTR _tcp$83010[ebp]
  003d2	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  003d5	85 c9		 test	 ecx, ecx
  003d7	75 07		 jne	 SHORT $LN2@token

; 418  : 	    	return TokInt;

  003d9	b8 02 00 00 00	 mov	 eax, 2
  003de	eb 3d		 jmp	 SHORT $LN47@token
$LN2@token:

; 419  : 	    }
; 420  : #endif
; 421  : #ifdef REAL
; 422  :             if (sscanf(tokbuf, "%lf%c", &tokreal, &tc) == 1)

  003e0	8b f4		 mov	 esi, esp
  003e2	8d 45 a7	 lea	 eax, DWORD PTR _tc$83009[ebp]
  003e5	50		 push	 eax
  003e6	68 00 00 00 00	 push	 OFFSET _tokreal
  003eb	68 00 00 00 00	 push	 OFFSET ??_C@_05CLIFEECF@?$CFlf?$CFc?$AA@
  003f0	68 00 00 00 00	 push	 OFFSET _tokbuf
  003f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sscanf
  003fb	83 c4 10	 add	 esp, 16			; 00000010H
  003fe	3b f4		 cmp	 esi, esp
  00400	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00405	83 f8 01	 cmp	 eax, 1
  00408	75 07		 jne	 SHORT $LN4@token

; 423  : 		return TokReal;

  0040a	b8 03 00 00 00	 mov	 eax, 3
  0040f	eb 0c		 jmp	 SHORT $LN47@token
$LN4@token:

; 424  : #endif
; 425  : 	}
; 426  : 	return TokWord;

  00411	b8 01 00 00 00	 mov	 eax, 1
  00416	eb 05		 jmp	 SHORT $LN47@token

; 427  :     }

  00418	e9 09 fc ff ff	 jmp	 $LN46@token
$LN47@token:

; 428  : }

  0041d	52		 push	 edx
  0041e	8b cd		 mov	 ecx, ebp
  00420	50		 push	 eax
  00421	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN53@token
  00427	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0042c	58		 pop	 eax
  0042d	5a		 pop	 edx
  0042e	5f		 pop	 edi
  0042f	5e		 pop	 esi
  00430	5b		 pop	 ebx
  00431	81 c4 30 01 00
	00		 add	 esp, 304		; 00000130H
  00437	3b ec		 cmp	 ebp, esp
  00439	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0043e	8b e5		 mov	 esp, ebp
  00440	5d		 pop	 ebp
  00441	c3		 ret	 0
  00442	8b ff		 npad	 2
$LN53@token:
  00444	02 00 00 00	 DD	 2
  00448	00 00 00 00	 DD	 $LN52@token
$LN52@token:
  0044c	a7 ff ff ff	 DD	 -89			; ffffffa7H
  00450	01 00 00 00	 DD	 1
  00454	00 00 00 00	 DD	 $LN50@token
  00458	98 ff ff ff	 DD	 -104			; ffffff98H
  0045c	04 00 00 00	 DD	 4
  00460	00 00 00 00	 DD	 $LN51@token
$LN51@token:
  00464	74		 DB	 116			; 00000074H
  00465	63		 DB	 99			; 00000063H
  00466	70		 DB	 112			; 00000070H
  00467	00		 DB	 0
$LN50@token:
  00468	74		 DB	 116			; 00000074H
  00469	63		 DB	 99			; 00000063H
  0046a	00		 DB	 0
  0046b	90		 npad	 1
$LN54@token:
  0046c	00 00 00 00	 DD	 $LN28@token
  00470	00 00 00 00	 DD	 $LN27@token
  00474	00 00 00 00	 DD	 $LN26@token
  00478	00 00 00 00	 DD	 $LN25@token
  0047c	00 00 00 00	 DD	 $LN32@token
$LN49@token:
  00480	00		 DB	 0
  00481	04		 DB	 4
  00482	04		 DB	 4
  00483	04		 DB	 4
  00484	04		 DB	 4
  00485	04		 DB	 4
  00486	04		 DB	 4
  00487	04		 DB	 4
  00488	04		 DB	 4
  00489	04		 DB	 4
  0048a	04		 DB	 4
  0048b	04		 DB	 4
  0048c	01		 DB	 1
  0048d	04		 DB	 4
  0048e	04		 DB	 4
  0048f	04		 DB	 4
  00490	02		 DB	 2
  00491	04		 DB	 4
  00492	03		 DB	 3
_token	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _lookup
_TEXT	SEGMENT
_dw$ = -8						; size = 4
_tkname$ = 8						; size = 4
_lookup	PROC						; COMDAT

; 434  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 435  :     dictword *dw = dict;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  00023	89 45 f8	 mov	 DWORD PTR _dw$[ebp], eax

; 436  : 	char a;
; 437  :     ucase(tkname);		      /* Force name to upper case */

  00026	8b 45 08	 mov	 eax, DWORD PTR _tkname$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _ucase
  0002f	83 c4 04	 add	 esp, 4
$LN3@lookup:

; 438  :     while (dw != NULL) {

  00032	83 7d f8 00	 cmp	 DWORD PTR _dw$[ebp], 0
  00036	74 48		 je	 SHORT $LN2@lookup

; 439  : 	if (!(dw->wname[0] & WORDHIDDEN) &&
; 440  : 	     (strcmp(dw->wname + 1, tkname) == 0)) {

  00038	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  0003b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003e	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00041	83 e2 04	 and	 edx, 4
  00044	75 30		 jne	 SHORT $LN1@lookup
  00046	8b 45 08	 mov	 eax, DWORD PTR _tkname$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _dw$[ebp]
  0004d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00050	83 c2 01	 add	 edx, 1
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 _strcmp
  00059	83 c4 08	 add	 esp, 8
  0005c	85 c0		 test	 eax, eax
  0005e	75 16		 jne	 SHORT $LN1@lookup

; 441  : #ifdef WORDSUSED
; 442  : 		/*a=dw->wname[0] | WORDUSED;
; 443  : 	    memcpy(&dw->wname[0],&a ,1);*/ /* Mark this word used */
; 444  : 	 *(dw->wname) |= WORDUSED;   /* bug access violation with msvc */

  00060	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  00063	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00066	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00069	83 ca 02	 or	 edx, 2
  0006c	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  0006f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00072	88 11		 mov	 BYTE PTR [ecx], dl

; 445  : #endif
; 446  : 	    break;

  00074	eb 0a		 jmp	 SHORT $LN2@lookup
$LN1@lookup:

; 447  : 	}
; 448  : 	dw = dw->wnext;

  00076	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  00079	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007b	89 4d f8	 mov	 DWORD PTR _dw$[ebp], ecx

; 449  :     }

  0007e	eb b2		 jmp	 SHORT $LN3@lookup
$LN2@lookup:

; 450  :     return dw;

  00080	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]

; 451  : }

  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0008c	3b ec		 cmp	 ebp, esp
  0008e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
_lookup	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_bracktick
_TEXT	SEGMENT
tv66 = -196						; size = 4
_P_bracktick PROC					; COMDAT

; 2395 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2396 :     Compiling;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv66[ebp], eax
  00029	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv66[ebp]
  0002f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv66[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	75 07		 jne	 SHORT $LN1@P_bracktic
  0003c	e8 00 00 00 00	 call	 _notcomp
  00041	eb 0a		 jmp	 SHORT $LN2@P_bracktic
$LN1@P_bracktic:

; 2397 :     ctickpend = True;		      /* Force literal treatment of next

  00043	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _ctickpend, 1
$LN2@P_bracktic:

; 2398 : 					 word in compile stream */
; 2399 : }

  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_P_bracktick ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_execute
_TEXT	SEGMENT
_wp$ = -8						; size = 4
_P_execute PROC						; COMDAT

; 2402 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2403 :     dictword *wp;
; 2404 : 
; 2405 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_execute
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 24		 jmp	 SHORT $LN2@P_execute
$LN1@P_execute:

; 2406 :     wp = (dictword *) S0;	      /* Load word address from stack */

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	89 4d f8	 mov	 DWORD PTR _wp$[ebp], ecx

; 2407 :     Pop;			      /* Pop data stack before execution */

  00043	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00048	83 e8 08	 sub	 eax, 8
  0004b	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 2408 :     exword(wp); 		      /* Recursively call exword() to run

  00050	8b 45 f8	 mov	 eax, DWORD PTR _wp$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 _exword
  00059	83 c4 04	 add	 esp, 4
$LN2@P_execute:

; 2409 : 					 the word. */
; 2410 : }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00065	3b ec		 cmp	 ebp, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
_P_execute ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_body
_TEXT	SEGMENT
_P_body	PROC						; COMDAT

; 2413 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2414 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_body
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 1c		 jmp	 SHORT $LN2@P_body
$LN1@P_body:

; 2415 :     S0 += Dictwordl * sizeof(stackitem);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	83 c1 10	 add	 ecx, 16			; 00000010H
  00043	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00046	83 d2 00	 adc	 edx, 0
  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004e	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  00051	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_body:

; 2416 : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005d	3b ec		 cmp	 ebp, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
_P_body	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_state
_TEXT	SEGMENT
_P_state PROC						; COMDAT

; 2419 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2420 :     So(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	83 c0 08	 add	 eax, 8
  00026	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  0002c	76 07		 jbe	 SHORT $LN1@P_state
  0002e	e8 00 00 00 00	 call	 _stakover
  00033	eb 20		 jmp	 SHORT $LN2@P_state
$LN1@P_state:

; 2421 :     Push = (stackitem) &state;

  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  0003a	99		 cdq
  0003b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00041	89 01		 mov	 DWORD PTR [ecx], eax
  00043	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00046	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0004c	83 c2 08	 add	 edx, 8
  0004f	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN2@P_state:

; 2422 : }

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
_P_state ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_find
_TEXT	SEGMENT
_dw$ = -8						; size = 4
_P_find	PROC						; COMDAT

; 2429 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2430 :     dictword *dw;
; 2431 : 
; 2432 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 0a		 jge	 SHORT $LN6@P_find
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 d4 00 00 00	 jmp	 $LN7@P_find
$LN6@P_find:

; 2433 :     So(1);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	83 c0 08	 add	 eax, 8
  00043	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00049	76 0a		 jbe	 SHORT $LN5@P_find
  0004b	e8 00 00 00 00	 call	 _stakover
  00050	e9 ba 00 00 00	 jmp	 $LN7@P_find
$LN5@P_find:

; 2434 :     Hpc(S0);

  00055	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0005a	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0005d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00063	72 10		 jb	 SHORT $LN3@P_find
  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0006a	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0006d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00073	72 0a		 jb	 SHORT $LN4@P_find
$LN3@P_find:
  00075	e8 00 00 00 00	 call	 _badpointer
  0007a	e9 90 00 00 00	 jmp	 $LN7@P_find
$LN4@P_find:

; 2435 :     V strcpy(tokbuf, (char *) S0);    /* Use built-in token buffer... */

  0007f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00084	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00087	51		 push	 ecx
  00088	68 00 00 00 00	 push	 OFFSET _tokbuf
  0008d	e8 00 00 00 00	 call	 _strcpy
  00092	83 c4 08	 add	 esp, 8

; 2436 :     dw = lookup(tokbuf);              /* So ucase() in lookup() doesn't wipe */

  00095	68 00 00 00 00	 push	 OFFSET _tokbuf
  0009a	e8 00 00 00 00	 call	 _lookup
  0009f	83 c4 04	 add	 esp, 4
  000a2	89 45 f8	 mov	 DWORD PTR _dw$[ebp], eax

; 2437 : 				      /* the token on the stack */
; 2438 :     if (dw != NULL) {

  000a5	83 7d f8 00	 cmp	 DWORD PTR _dw$[ebp], 0
  000a9	74 43		 je	 SHORT $LN2@P_find

; 2439 : 	S0 = (stackitem) dw;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  000ae	99		 cdq
  000af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  000b5	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  000b8	89 51 fc	 mov	 DWORD PTR [ecx-4], edx

; 2440 : 	/* Push immediate flag */
; 2441 : 	Push = (dw->wname[0] & IMMEDIATE) ? 1 : -1;

  000bb	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  000be	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c1	0f be 01	 movsx	 eax, BYTE PTR [ecx]
  000c4	83 e0 01	 and	 eax, 1
  000c7	f7 d8		 neg	 eax
  000c9	1b c0		 sbb	 eax, eax
  000cb	83 e0 02	 and	 eax, 2
  000ce	83 c0 ff	 add	 eax, -1
  000d1	99		 cdq
  000d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  000d8	89 01		 mov	 DWORD PTR [ecx], eax
  000da	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  000dd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  000e3	83 c2 08	 add	 edx, 8
  000e6	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 2442 :     } else {

  000ec	eb 21		 jmp	 SHORT $LN7@P_find
$LN2@P_find:

; 2443 : 	Push = 0;

  000ee	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000f3	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000f9	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00100	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00106	83 c1 08	 add	 ecx, 8
  00109	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN7@P_find:

; 2444 :     }
; 2445 : }

  0010f	5f		 pop	 edi
  00110	5e		 pop	 esi
  00111	5b		 pop	 ebx
  00112	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00118	3b ec		 cmp	 ebp, esp
  0011a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
_P_find	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_toname
_TEXT	SEGMENT
_P_toname PROC						; COMDAT

; 2450 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2451 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_toname
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 27		 jmp	 SHORT $LN2@P_toname
$LN1@P_toname:

; 2452 :     S0 += DfOff(wname);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  0003d	83 c0 04	 add	 eax, 4
  00040	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dict
  00046	99		 cdq
  00047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0004d	03 41 f8	 add	 eax, DWORD PTR [ecx-8]
  00050	13 51 fc	 adc	 edx, DWORD PTR [ecx-4]
  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00059	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  0005c	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN2@P_toname:

; 2453 : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00068	3b ec		 cmp	 ebp, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_P_toname ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@OOBANHEI@?6?$DOLINK?5Foulup?9?9wnext?5is?5not?5at?5z@ ; `string'
;	COMDAT ??_C@_0CG@OOBANHEI@?6?$DOLINK?5Foulup?9?9wnext?5is?5not?5at?5z@
CONST	SEGMENT
??_C@_0CG@OOBANHEI@?6?$DOLINK?5Foulup?9?9wnext?5is?5not?5at?5z@ DB 0aH, '>'
	DB	'LINK Foulup--wnext is not at zero!', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _P_tolink
_TEXT	SEGMENT
_P_tolink PROC						; COMDAT

; 2456 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2457 : if (DfOff(wnext) != 0) V printf("\n>LINK Foulup--wnext is not at zero!\n");

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dict
  00029	74 17		 je	 SHORT $LN2@P_tolink
  0002b	8b f4		 mov	 esi, esp
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@OOBANHEI@?6?$DOLINK?5Foulup?9?9wnext?5is?5not?5at?5z@
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00038	83 c4 04	 add	 esp, 4
  0003b	3b f4		 cmp	 esi, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@P_tolink:

; 2458 : /*  Sl(1);
; 2459 :     S0 += DfOff(wnext);  */	      /* Null operation.  Wnext is first */
; 2460 : }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_P_tolink ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_frombody
_TEXT	SEGMENT
_P_frombody PROC					; COMDAT

; 2463 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2464 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_frombody
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 1c		 jmp	 SHORT $LN2@P_frombody
$LN1@P_frombody:

; 2465 :     S0 -= Dictwordl * sizeof(stackitem);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	83 e9 10	 sub	 ecx, 16			; 00000010H
  00043	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00046	83 da 00	 sbb	 edx, 0
  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004e	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  00051	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_frombody:

; 2466 : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005d	3b ec		 cmp	 ebp, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
_P_frombody ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_fromname
_TEXT	SEGMENT
_P_fromname PROC					; COMDAT

; 2469 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2470 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_fromname
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 2b		 jmp	 SHORT $LN2@P_fromname
$LN1@P_fromname:

; 2471 :     S0 -= DfOff(wname);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  0003d	83 c0 04	 add	 eax, 4
  00040	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dict
  00046	99		 cdq
  00047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0004d	8b 71 f8	 mov	 esi, DWORD PTR [ecx-8]
  00050	2b f0		 sub	 esi, eax
  00052	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00055	1b c2		 sbb	 eax, edx
  00057	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0005d	89 71 f8	 mov	 DWORD PTR [ecx-8], esi
  00060	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN2@P_fromname:

; 2472 : }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_P_fromname ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@FEHNEJPA@?6LINK?$DO?5Foulup?9?9wnext?5is?5not?5at?5z@ ; `string'
;	COMDAT ??_C@_0CG@FEHNEJPA@?6LINK?$DO?5Foulup?9?9wnext?5is?5not?5at?5z@
CONST	SEGMENT
??_C@_0CG@FEHNEJPA@?6LINK?$DO?5Foulup?9?9wnext?5is?5not?5at?5z@ DB 0aH, 'L'
	DB	'INK> Foulup--wnext is not at zero!', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _P_fromlink
_TEXT	SEGMENT
_P_fromlink PROC					; COMDAT

; 2475 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2476 : if (DfOff(wnext) != 0) V printf("\nLINK> Foulup--wnext is not at zero!\n");

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dict
  00029	74 17		 je	 SHORT $LN2@P_fromlink
  0002b	8b f4		 mov	 esi, esp
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@FEHNEJPA@?6LINK?$DO?5Foulup?9?9wnext?5is?5not?5at?5z@
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00038	83 c4 04	 add	 esp, 4
  0003b	3b f4		 cmp	 esi, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@P_fromlink:

; 2477 : /*  Sl(1);
; 2478 :     S0 -= DfOff(wnext);  */	      /* Null operation.  Wnext is first */
; 2479 : }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_P_fromlink ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_nametolink
_TEXT	SEGMENT
_to$ = -20						; size = 4
_from$ = -8						; size = 4
_P_nametolink PROC					; COMDAT

; 2486 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2487 :     char *from, *to;
; 2488 : 
; 2489 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_nametoli
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 36		 jmp	 SHORT $LN2@P_nametoli
$LN1@P_nametoli:

; 2490 :     /*
; 2491 :     S0 -= DfTran(wnext, wname);
; 2492 :     */
; 2493 :     from = (char *) &(dict->wnext);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  0003d	89 45 f8	 mov	 DWORD PTR _from$[ebp], eax

; 2494 :     to = (char *) &(dict->wname);

  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  00045	83 c0 04	 add	 eax, 4
  00048	89 45 ec	 mov	 DWORD PTR _to$[ebp], eax

; 2495 :     S0 -= (to - from);

  0004b	8b 45 ec	 mov	 eax, DWORD PTR _to$[ebp]
  0004e	2b 45 f8	 sub	 eax, DWORD PTR _from$[ebp]
  00051	99		 cdq
  00052	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00058	8b 71 f8	 mov	 esi, DWORD PTR [ecx-8]
  0005b	2b f0		 sub	 esi, eax
  0005d	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00060	1b c2		 sbb	 eax, edx
  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00068	89 71 f8	 mov	 DWORD PTR [ecx-8], esi
  0006b	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN2@P_nametoli:

; 2496 : }

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00077	3b ec		 cmp	 ebp, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
_P_nametolink ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_linktoname
_TEXT	SEGMENT
_to$ = -20						; size = 4
_from$ = -8						; size = 4
_P_linktoname PROC					; COMDAT

; 2499 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2500 :     char *from, *to;
; 2501 : 
; 2502 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_linktona
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 32		 jmp	 SHORT $LN2@P_linktona
$LN1@P_linktona:

; 2503 :     /*
; 2504 :     S0 += DfTran(wnext, wname);
; 2505 :     */
; 2506 :     from = (char *) &(dict->wnext);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  0003d	89 45 f8	 mov	 DWORD PTR _from$[ebp], eax

; 2507 :     to = (char *) &(dict->wname);

  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  00045	83 c0 04	 add	 eax, 4
  00048	89 45 ec	 mov	 DWORD PTR _to$[ebp], eax

; 2508 :     S0 += (to - from);

  0004b	8b 45 ec	 mov	 eax, DWORD PTR _to$[ebp]
  0004e	2b 45 f8	 sub	 eax, DWORD PTR _from$[ebp]
  00051	99		 cdq
  00052	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00058	03 41 f8	 add	 eax, DWORD PTR [ecx-8]
  0005b	13 51 fc	 adc	 edx, DWORD PTR [ecx-4]
  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00064	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  00067	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN2@P_linktona:

; 2509 : }

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
_P_linktoname ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_fetchname
_TEXT	SEGMENT
_P_fetchname PROC					; COMDAT

; 2512 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2513 :     Sl(2);			      /* nfa string -- */

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 07		 jge	 SHORT $LN5@P_fetchnam
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 7a		 jmp	 SHORT $LN6@P_fetchnam
$LN5@P_fetchnam:

; 2514 :     Hpc(S0);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00046	72 10		 jb	 SHORT $LN3@P_fetchnam
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00050	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00056	72 07		 jb	 SHORT $LN4@P_fetchnam
$LN3@P_fetchnam:
  00058	e8 00 00 00 00	 call	 _badpointer
  0005d	eb 53		 jmp	 SHORT $LN6@P_fetchnam
$LN4@P_fetchnam:

; 2515 :     Hpc(S1);

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00064	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00067	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  0006d	72 10		 jb	 SHORT $LN1@P_fetchnam
  0006f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00074	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00077	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  0007d	72 07		 jb	 SHORT $LN2@P_fetchnam
$LN1@P_fetchnam:
  0007f	e8 00 00 00 00	 call	 _badpointer
  00084	eb 2c		 jmp	 SHORT $LN6@P_fetchnam
$LN2@P_fetchnam:

; 2516 :     /* Since the name buffers aren't in the system heap, but
; 2517 :        rather are separately allocated with alloc(), we can't
; 2518 :        check the name pointer references.  But, hey, if the user's
; 2519 :        futzing with word dictionary items on the heap in the first
; 2520 :        place, there's a billion other ways to bring us down at
; 2521 :        his command. */
; 2522 :     V strcpy((char *) S0, *((char **) S1) + 1);

  00086	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0008b	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0008e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00090	83 c2 01	 add	 edx, 1
  00093	52		 push	 edx
  00094	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00099	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0009c	51		 push	 ecx
  0009d	e8 00 00 00 00	 call	 _strcpy
  000a2	83 c4 08	 add	 esp, 8

; 2523 :     Pop2;

  000a5	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000aa	83 e8 10	 sub	 eax, 16			; 00000010H
  000ad	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN6@P_fetchnam:

; 2524 : }

  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000bb	3b ec		 cmp	 ebp, esp
  000bd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c3		 ret	 0
_P_fetchname ENDP
_TEXT	ENDS
EXTRN	__imp__free:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_storename
_TEXT	SEGMENT
_cp$ = -20						; size = 4
_tflags$ = -5						; size = 1
_P_storename PROC					; COMDAT

; 2527 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2528 :     char tflags;
; 2529 :     char *cp;
; 2530 : 
; 2531 :     Sl(2);			      /* string nfa -- */

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 02	 cmp	 eax, 2
  0002f	7d 0a		 jge	 SHORT $LN5@P_storenam
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	e9 db 00 00 00	 jmp	 $LN6@P_storenam
$LN5@P_storenam:

; 2532 :     Hpc(S0);			      /* See comments in P_fetchname above */

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00040	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00043	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00049	72 10		 jb	 SHORT $LN3@P_storenam
  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00050	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00053	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00059	72 0a		 jb	 SHORT $LN4@P_storenam
$LN3@P_storenam:
  0005b	e8 00 00 00 00	 call	 _badpointer
  00060	e9 b1 00 00 00	 jmp	 $LN6@P_storenam
$LN4@P_storenam:

; 2533 :     Hpc(S1);			      /* checking name pointers */

  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0006a	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0006d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00073	72 10		 jb	 SHORT $LN1@P_storenam
  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0007a	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0007d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00083	72 0a		 jb	 SHORT $LN2@P_storenam
$LN1@P_storenam:
  00085	e8 00 00 00 00	 call	 _badpointer
  0008a	e9 87 00 00 00	 jmp	 $LN6@P_storenam
$LN2@P_storenam:

; 2534 :     tflags = **((char **) S0);

  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00094	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00097	8b 11		 mov	 edx, DWORD PTR [ecx]
  00099	8a 02		 mov	 al, BYTE PTR [edx]
  0009b	88 45 fb	 mov	 BYTE PTR _tflags$[ebp], al

; 2535 :     free(*((char **) S0));

  0009e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000a3	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000a6	8b f4		 mov	 esi, esp
  000a8	8b 11		 mov	 edx, DWORD PTR [ecx]
  000aa	52		 push	 edx
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000b1	83 c4 04	 add	 esp, 4
  000b4	3b f4		 cmp	 esi, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2536 :     *((char **) S0) = cp = alloc((unsigned int) (strlen((char *) S1) + 2));

  000bb	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000c0	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  000c3	51		 push	 ecx
  000c4	e8 00 00 00 00	 call	 _strlen
  000c9	83 c4 04	 add	 esp, 4
  000cc	83 c0 02	 add	 eax, 2
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 _alloc
  000d5	83 c4 04	 add	 esp, 4
  000d8	89 45 ec	 mov	 DWORD PTR _cp$[ebp], eax
  000db	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  000e1	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  000e4	8b 4d ec	 mov	 ecx, DWORD PTR _cp$[ebp]
  000e7	89 08		 mov	 DWORD PTR [eax], ecx

; 2537 :     V strcpy(cp + 1, (char *) S1);

  000e9	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000ee	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  000f1	51		 push	 ecx
  000f2	8b 55 ec	 mov	 edx, DWORD PTR _cp$[ebp]
  000f5	83 c2 01	 add	 edx, 1
  000f8	52		 push	 edx
  000f9	e8 00 00 00 00	 call	 _strcpy
  000fe	83 c4 08	 add	 esp, 8

; 2538 :     *cp = tflags;

  00101	8b 45 ec	 mov	 eax, DWORD PTR _cp$[ebp]
  00104	8a 4d fb	 mov	 cl, BYTE PTR _tflags$[ebp]
  00107	88 08		 mov	 BYTE PTR [eax], cl

; 2539 :     Pop2;

  00109	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0010e	83 e8 10	 sub	 eax, 16			; 00000010H
  00111	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN6@P_storenam:

; 2540 : }

  00116	5f		 pop	 edi
  00117	5e		 pop	 esi
  00118	5b		 pop	 ebx
  00119	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0011f	3b ec		 cmp	 ebp, esp
  00121	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c3		 ret	 0
_P_storename ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@DMBENMFN@?6?6Out?5of?5memory?$CB?5?5?$CFu?5bytes?5reque@ ; `string'
EXTRN	__imp__abort:PROC
EXTRN	__imp__malloc:PROC
;	COMDAT ??_C@_0CH@DMBENMFN@?6?6Out?5of?5memory?$CB?5?5?$CFu?5bytes?5reque@
CONST	SEGMENT
??_C@_0CH@DMBENMFN@?6?6Out?5of?5memory?$CB?5?5?$CFu?5bytes?5reque@ DB 0aH
	DB	0aH, 'Out of memory!  %u bytes requested.', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _alloc
_TEXT	SEGMENT
_cp$ = -8						; size = 4
_size$ = 8						; size = 4
_alloc	PROC						; COMDAT

; 245  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 246  :     char *cp = malloc(size);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00023	50		 push	 eax
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0002a	83 c4 04	 add	 esp, 4
  0002d	3b f4		 cmp	 esi, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	89 45 f8	 mov	 DWORD PTR _cp$[ebp], eax

; 247  : 
; 248  : /* printf("\nAlloc %u", size); */
; 249  :     if (cp == NULL) {

  00037	83 7d f8 00	 cmp	 DWORD PTR _cp$[ebp], 0
  0003b	75 3d		 jne	 SHORT $LN1@alloc

; 250  :         V fprintf(stderr, "\n\nOut of memory!  %u bytes requested.\n", size);

  0003d	8b f4		 mov	 esi, esp
  0003f	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00042	50		 push	 eax
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@DMBENMFN@?6?6Out?5of?5memory?$CB?5?5?$CFu?5bytes?5reque@
  00048	8b fc		 mov	 edi, esp
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00050	3b fc		 cmp	 edi, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	83 c0 40	 add	 eax, 64			; 00000040H
  0005a	50		 push	 eax
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
  00064	3b f4		 cmp	 esi, esp
  00066	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 251  : 	abort();

  0006b	8b f4		 mov	 esi, esp
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__abort
  00073	3b f4		 cmp	 esi, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@alloc:

; 252  :     }
; 253  :     return cp;

  0007a	8b 45 f8	 mov	 eax, DWORD PTR _cp$[ebp]

; 254  : }

  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00086	3b ec		 cmp	 ebp, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
_alloc	ENDP
_TEXT	ENDS
EXTRN	__imp__system:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _P_system
_TEXT	SEGMENT
_P_system PROC						; COMDAT

; 2546 : {				      /* string -- status */

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2547 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN3@P_system
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 4f		 jmp	 SHORT $LN4@P_system
$LN3@P_system:

; 2548 :     Hpc(S0);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00040	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00046	72 10		 jb	 SHORT $LN1@P_system
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00050	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00056	72 07		 jb	 SHORT $LN2@P_system
$LN1@P_system:
  00058	e8 00 00 00 00	 call	 _badpointer
  0005d	eb 28		 jmp	 SHORT $LN4@P_system
$LN2@P_system:

; 2549 :     S0 = system((char *) S0);

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00064	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00067	8b f4		 mov	 esi, esp
  00069	51		 push	 ecx
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__system
  00070	83 c4 04	 add	 esp, 4
  00073	3b f4		 cmp	 esi, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	99		 cdq
  0007b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00081	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  00084	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN4@P_system:

; 2550 : }

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00090	3b ec		 cmp	 ebp, esp
  00092	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
_P_system ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_trace
_TEXT	SEGMENT
tv69 = -200						; size = 4
tv74 = -196						; size = 4
_P_trace PROC						; COMDAT

; 2555 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2556 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_trace
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 54		 jmp	 SHORT $LN2@P_trace
$LN1@P_trace:

; 2557 :     atl_trace = (S0 == 0) ? Falsity : Truth;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv74[ebp], eax
  00043	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv74[ebp]
  00049	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv74[ebp]
  0004f	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00052	0b 42 fc	 or	 eax, DWORD PTR [edx-4]
  00055	75 0c		 jne	 SHORT $LN4@P_trace
  00057	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
  00061	eb 0a		 jmp	 SHORT $LN5@P_trace
$LN4@P_trace:
  00063	c7 85 38 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv69[ebp], -1
$LN5@P_trace:
  0006d	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv69[ebp]
  00073	99		 cdq
  00074	a3 00 00 00 00	 mov	 DWORD PTR _atl_trace, eax
  00079	89 15 04 00 00
	00		 mov	 DWORD PTR _atl_trace+4, edx

; 2558 :     Pop;

  0007f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00084	83 e8 08	 sub	 eax, 8
  00087	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_trace:

; 2559 : }

  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00095	3b ec		 cmp	 ebp, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
_P_trace ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_walkback
_TEXT	SEGMENT
tv69 = -200						; size = 4
tv74 = -196						; size = 4
_P_walkback PROC					; COMDAT

; 2564 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2565 :     Sl(1);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00023	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	7d 07		 jge	 SHORT $LN1@P_walkback
  00031	e8 00 00 00 00	 call	 _stakunder
  00036	eb 54		 jmp	 SHORT $LN2@P_walkback
$LN1@P_walkback:

; 2566 :     atl_walkback = (S0 == 0) ? Falsity : Truth;

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0003d	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv74[ebp], eax
  00043	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv74[ebp]
  00049	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv74[ebp]
  0004f	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00052	0b 42 fc	 or	 eax, DWORD PTR [edx-4]
  00055	75 0c		 jne	 SHORT $LN4@P_walkback
  00057	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
  00061	eb 0a		 jmp	 SHORT $LN5@P_walkback
$LN4@P_walkback:
  00063	c7 85 38 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv69[ebp], -1
$LN5@P_walkback:
  0006d	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv69[ebp]
  00073	99		 cdq
  00074	a3 00 00 00 00	 mov	 DWORD PTR _atl_walkback, eax
  00079	89 15 04 00 00
	00		 mov	 DWORD PTR _atl_walkback+4, edx

; 2567 :     Pop;

  0007f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00084	83 e8 08	 sub	 eax, 8
  00087	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_walkback:

; 2568 : }

  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00095	3b ec		 cmp	 ebp, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
_P_walkback ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_wordsused
_TEXT	SEGMENT
_dw$ = -8						; size = 4
_P_wordsused PROC					; COMDAT

; 2574 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2575 :     dictword *dw = dict;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  00023	89 45 f8	 mov	 DWORD PTR _dw$[ebp], eax
$LN3@P_wordsuse:

; 2576 : 
; 2577 :     while (dw != NULL) {

  00026	83 7d f8 00	 cmp	 DWORD PTR _dw$[ebp], 0
  0002a	74 39		 je	 SHORT $LN2@P_wordsuse

; 2578 : 	if (*(dw->wname) & WORDUSED) {

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  0002f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00032	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00035	83 e2 02	 and	 edx, 2
  00038	74 21		 je	 SHORT $LN1@P_wordsuse

; 2579 :            V printf("\n%s", dw->wname + 1);

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  0003d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00040	83 c1 01	 add	 ecx, 1
  00043	8b f4		 mov	 esi, esp
  00045	51		 push	 ecx
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_03ILJCGOLJ@?6?$CFs?$AA@
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00051	83 c4 08	 add	 esp, 8
  00054	3b f4		 cmp	 esi, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@P_wordsuse:

; 2580 : 	}
; 2581 : #ifdef Keyhit
; 2582 : 	if (kbquit()) {
; 2583 : 	    break;
; 2584 : 	}
; 2585 : #endif
; 2586 : 	dw = dw->wnext;

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	89 4d f8	 mov	 DWORD PTR _dw$[ebp], ecx

; 2587 :     }

  00063	eb c1		 jmp	 SHORT $LN3@P_wordsuse
$LN2@P_wordsuse:

; 2588 :     V printf("\n");

  00065	8b f4		 mov	 esi, esp
  00067	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00072	83 c4 04	 add	 esp, 4
  00075	3b f4		 cmp	 esi, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2589 : }

  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00085	3b ec		 cmp	 ebp, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
_P_wordsused ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_wordsunused
_TEXT	SEGMENT
_dw$ = -8						; size = 4
_P_wordsunused PROC					; COMDAT

; 2592 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2593 :     dictword *dw = dict;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  00023	89 45 f8	 mov	 DWORD PTR _dw$[ebp], eax
$LN3@P_wordsunu:

; 2594 : 
; 2595 :     while (dw != NULL) {

  00026	83 7d f8 00	 cmp	 DWORD PTR _dw$[ebp], 0
  0002a	74 39		 je	 SHORT $LN2@P_wordsunu

; 2596 : 	if (!(*(dw->wname) & WORDUSED)) {

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  0002f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00032	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00035	83 e2 02	 and	 edx, 2
  00038	75 21		 jne	 SHORT $LN1@P_wordsunu

; 2597 :            V printf("\n%s", dw->wname + 1);

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  0003d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00040	83 c1 01	 add	 ecx, 1
  00043	8b f4		 mov	 esi, esp
  00045	51		 push	 ecx
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_03ILJCGOLJ@?6?$CFs?$AA@
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00051	83 c4 08	 add	 esp, 8
  00054	3b f4		 cmp	 esi, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@P_wordsunu:

; 2598 : 	}
; 2599 : #ifdef Keyhit
; 2600 : 	if (kbquit()) {
; 2601 : 	    break;
; 2602 : 	}
; 2603 : #endif
; 2604 : 	dw = dw->wnext;

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	89 4d f8	 mov	 DWORD PTR _dw$[ebp], ecx

; 2605 :     }

  00063	eb c1		 jmp	 SHORT $LN3@P_wordsunu
$LN2@P_wordsunu:

; 2606 :     V printf("\n");

  00065	8b f4		 mov	 esi, esp
  00067	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00072	83 c4 04	 add	 esp, 4
  00075	3b f4		 cmp	 esi, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2607 : }

  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00085	3b ec		 cmp	 ebp, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
_P_wordsunused ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_brackcompile
_TEXT	SEGMENT
tv66 = -196						; size = 4
_P_brackcompile PROC					; COMDAT

; 2613 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2614 :     Compiling;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv66[ebp], eax
  00029	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv66[ebp]
  0002f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv66[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	75 07		 jne	 SHORT $LN1@P_brackcom
  0003c	e8 00 00 00 00	 call	 _notcomp
  00041	eb 0a		 jmp	 SHORT $LN2@P_brackcom
$LN1@P_brackcom:

; 2615 :     cbrackpend = True;		      /* Set [COMPILE] pending */

  00043	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _cbrackpend, 1
$LN2@P_brackcom:

; 2616 : }

  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_P_brackcompile ENDP
_TEXT	ENDS
_BSS	SEGMENT
	ALIGN	8

_s_lit	DQ	01H DUP (?)
; Function compile flags: /Odtp /RTCsu /ZI
_BSS	ENDS
;	COMDAT _P_literal
_TEXT	SEGMENT
tv75 = -196						; size = 4
_P_literal PROC						; COMDAT

; 2619 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2620 :     Compiling;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv75[ebp], eax
  00029	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv75[ebp]
  0002f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv75[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	75 0a		 jne	 SHORT $LN3@P_literal
  0003c	e8 00 00 00 00	 call	 _notcomp
  00041	e9 86 00 00 00	 jmp	 $LN4@P_literal
$LN3@P_literal:

; 2621 :     Sl(1);

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00051	c1 f8 03	 sar	 eax, 3
  00054	83 f8 01	 cmp	 eax, 1
  00057	7d 07		 jge	 SHORT $LN2@P_literal
  00059	e8 00 00 00 00	 call	 _stakunder
  0005e	eb 6c		 jmp	 SHORT $LN4@P_literal
$LN2@P_literal:

; 2622 :     Ho(2);

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00065	83 c0 10	 add	 eax, 16			; 00000010H
  00068	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  0006e	76 07		 jbe	 SHORT $LN1@P_literal
  00070	e8 00 00 00 00	 call	 _heapover
  00075	eb 55		 jmp	 SHORT $LN4@P_literal
$LN1@P_literal:

; 2623 :     Hstore = s_lit;		      /* Compile load literal word */

  00077	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0007c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_lit
  00082	89 08		 mov	 DWORD PTR [eax], ecx
  00084	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_lit+4
  0008a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0008d	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00092	83 c0 08	 add	 eax, 8
  00095	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2624 :     Hstore = S0;		      /* Compile top of stack in line */

  0009a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0009f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  000a5	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  000a8	89 10		 mov	 DWORD PTR [eax], edx
  000aa	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  000ad	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000b0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  000b6	83 c2 08	 add	 edx, 8
  000b9	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 2625 :     Pop;

  000bf	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000c4	83 e8 08	 sub	 eax, 8
  000c7	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN4@P_literal:

; 2626 : }

  000cc	5f		 pop	 edi
  000cd	5e		 pop	 esi
  000ce	5b		 pop	 ebx
  000cf	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  000d5	3b ec		 cmp	 ebp, esp
  000d7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
_P_literal ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_compile
_TEXT	SEGMENT
tv71 = -196						; size = 4
_P_compile PROC						; COMDAT

; 2629 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2630 :     Compiling;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv71[ebp], eax
  00029	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv71[ebp]
  0002f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv71[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	75 07		 jne	 SHORT $LN2@P_compile
  0003c	e8 00 00 00 00	 call	 _notcomp
  00041	eb 46		 jmp	 SHORT $LN3@P_compile
$LN2@P_compile:

; 2631 :     Ho(1);

  00043	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00048	83 c0 08	 add	 eax, 8
  0004b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00051	76 07		 jbe	 SHORT $LN1@P_compile
  00053	e8 00 00 00 00	 call	 _heapover
  00058	eb 2f		 jmp	 SHORT $LN3@P_compile
$LN1@P_compile:

; 2632 :     Hstore = (stackitem) *ip++;       /* Compile the next datum from the

  0005a	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	99		 cdq
  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  00068	89 01		 mov	 DWORD PTR [ecx], eax
  0006a	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0006d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  00073	83 c2 08	 add	 edx, 8
  00076	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx
  0007c	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  00081	83 c0 04	 add	 eax, 4
  00084	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax
$LN3@P_compile:

; 2633 : 					 instruction stream. */
; 2634 : }

  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00092	3b ec		 cmp	 ebp, esp
  00094	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
_P_compile ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_backmark
_TEXT	SEGMENT
tv70 = -196						; size = 4
_P_backmark PROC					; COMDAT

; 2637 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2638 :     Compiling;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  00029	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv70[ebp]
  0002f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv70[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	75 07		 jne	 SHORT $LN2@P_backmark
  0003c	e8 00 00 00 00	 call	 _notcomp
  00041	eb 37		 jmp	 SHORT $LN3@P_backmark
$LN2@P_backmark:

; 2639 :     So(1);

  00043	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00048	83 c0 08	 add	 eax, 8
  0004b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00051	76 07		 jbe	 SHORT $LN1@P_backmark
  00053	e8 00 00 00 00	 call	 _stakover
  00058	eb 20		 jmp	 SHORT $LN3@P_backmark
$LN1@P_backmark:

; 2640 :     Push = (stackitem) hptr;	      /* Push heap address onto stack */

  0005a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0005f	99		 cdq
  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00066	89 01		 mov	 DWORD PTR [ecx], eax
  00068	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0006b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00071	83 c2 08	 add	 edx, 8
  00074	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN3@P_backmark:

; 2641 : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
_P_backmark ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_backresolve
_TEXT	SEGMENT
tv85 = -212						; size = 4
_offset$ = -12						; size = 8
_P_backresolve PROC					; COMDAT

; 2644 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00012	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2645 :     stackitem offset;
; 2646 : 
; 2647 :     Compiling;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv85[ebp], eax
  00029	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR tv85[ebp]
  0002f	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR tv85[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	75 0a		 jne	 SHORT $LN5@P_backreso
  0003c	e8 00 00 00 00	 call	 _notcomp
  00041	e9 a0 00 00 00	 jmp	 $LN6@P_backreso
$LN5@P_backreso:

; 2648 :     Sl(1);

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0004b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00051	c1 f8 03	 sar	 eax, 3
  00054	83 f8 01	 cmp	 eax, 1
  00057	7d 0a		 jge	 SHORT $LN4@P_backreso
  00059	e8 00 00 00 00	 call	 _stakunder
  0005e	e9 83 00 00 00	 jmp	 $LN6@P_backreso
$LN4@P_backreso:

; 2649 :     Ho(1);

  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00068	83 c0 08	 add	 eax, 8
  0006b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00071	76 07		 jbe	 SHORT $LN3@P_backreso
  00073	e8 00 00 00 00	 call	 _heapover
  00078	eb 6c		 jmp	 SHORT $LN6@P_backreso
$LN3@P_backreso:

; 2650 :     Hpc(S0);

  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0007f	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00082	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  00088	72 10		 jb	 SHORT $LN1@P_backreso
  0008a	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0008f	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00092	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  00098	72 07		 jb	 SHORT $LN2@P_backreso
$LN1@P_backreso:
  0009a	e8 00 00 00 00	 call	 _badpointer
  0009f	eb 45		 jmp	 SHORT $LN6@P_backreso
$LN2@P_backreso:

; 2651 :     offset = -(hptr - (stackitem *) S0);

  000a1	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000a6	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000a9	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000ae	2b c1		 sub	 eax, ecx
  000b0	c1 f8 03	 sar	 eax, 3
  000b3	f7 d8		 neg	 eax
  000b5	99		 cdq
  000b6	89 45 f4	 mov	 DWORD PTR _offset$[ebp], eax
  000b9	89 55 f8	 mov	 DWORD PTR _offset$[ebp+4], edx

; 2652 :     Hstore = offset;

  000bc	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000c1	8b 4d f4	 mov	 ecx, DWORD PTR _offset$[ebp]
  000c4	89 08		 mov	 DWORD PTR [eax], ecx
  000c6	8b 55 f8	 mov	 edx, DWORD PTR _offset$[ebp+4]
  000c9	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000cc	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  000d1	83 c0 08	 add	 eax, 8
  000d4	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2653 :     Pop;

  000d9	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000de	83 e8 08	 sub	 eax, 8
  000e1	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN6@P_backreso:

; 2654 : }

  000e6	5f		 pop	 edi
  000e7	5e		 pop	 esi
  000e8	5b		 pop	 ebx
  000e9	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  000ef	3b ec		 cmp	 ebp, esp
  000f1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c3		 ret	 0
_P_backresolve ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_fwdmark
_TEXT	SEGMENT
tv71 = -196						; size = 4
_P_fwdmark PROC						; COMDAT

; 2657 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2658 :     Compiling;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv71[ebp], eax
  00029	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv71[ebp]
  0002f	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv71[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	75 07		 jne	 SHORT $LN2@P_fwdmark
  0003c	e8 00 00 00 00	 call	 _notcomp
  00041	eb 58		 jmp	 SHORT $LN3@P_fwdmark
$LN2@P_fwdmark:

; 2659 :     Ho(1);

  00043	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00048	83 c0 08	 add	 eax, 8
  0004b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00051	76 07		 jbe	 SHORT $LN1@P_fwdmark
  00053	e8 00 00 00 00	 call	 _heapover
  00058	eb 41		 jmp	 SHORT $LN3@P_fwdmark
$LN1@P_fwdmark:

; 2660 :     Push = (stackitem) hptr;	      /* Push heap address onto stack */

  0005a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0005f	99		 cdq
  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00066	89 01		 mov	 DWORD PTR [ecx], eax
  00068	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0006b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00071	83 c2 08	 add	 edx, 8
  00074	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 2661 :     Hstore = 0;

  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0007f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00085	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0008c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  00092	83 c1 08	 add	 ecx, 8
  00095	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx
$LN3@P_fwdmark:

; 2662 : }

  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  000a4	3b ec		 cmp	 ebp, esp
  000a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
_P_fwdmark ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _P_fwdresolve
_TEXT	SEGMENT
tv83 = -212						; size = 4
_offset$ = -12						; size = 8
_P_fwdresolve PROC					; COMDAT

; 2665 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00012	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2666 :     stackitem offset;
; 2667 : 
; 2668 :     Compiling;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00023	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv83[ebp], eax
  00029	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR tv83[ebp]
  0002f	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR tv83[ebp]
  00035	8b 01		 mov	 eax, DWORD PTR [ecx]
  00037	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0003a	75 07		 jne	 SHORT $LN4@P_fwdresol
  0003c	e8 00 00 00 00	 call	 _notcomp
  00041	eb 7a		 jmp	 SHORT $LN5@P_fwdresol
$LN4@P_fwdresol:

; 2669 :     Sl(1);

  00043	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00048	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0004e	c1 f8 03	 sar	 eax, 3
  00051	83 f8 01	 cmp	 eax, 1
  00054	7d 07		 jge	 SHORT $LN3@P_fwdresol
  00056	e8 00 00 00 00	 call	 _stakunder
  0005b	eb 60		 jmp	 SHORT $LN5@P_fwdresol
$LN3@P_fwdresol:

; 2670 :     Hpc(S0);

  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00062	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00065	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  0006b	72 10		 jb	 SHORT $LN1@P_fwdresol
  0006d	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00072	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00075	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  0007b	72 07		 jb	 SHORT $LN2@P_fwdresol
$LN1@P_fwdresol:
  0007d	e8 00 00 00 00	 call	 _badpointer
  00082	eb 39		 jmp	 SHORT $LN5@P_fwdresol
$LN2@P_fwdresol:

; 2671 :     offset = (hptr - (stackitem *) S0);

  00084	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00089	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0008c	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00091	2b c1		 sub	 eax, ecx
  00093	c1 f8 03	 sar	 eax, 3
  00096	99		 cdq
  00097	89 45 f4	 mov	 DWORD PTR _offset$[ebp], eax
  0009a	89 55 f8	 mov	 DWORD PTR _offset$[ebp+4], edx

; 2672 :     *((stackitem *) S0) = offset;

  0009d	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000a2	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000a5	8b 55 f4	 mov	 edx, DWORD PTR _offset$[ebp]
  000a8	89 11		 mov	 DWORD PTR [ecx], edx
  000aa	8b 45 f8	 mov	 eax, DWORD PTR _offset$[ebp+4]
  000ad	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 2673 :     Pop;

  000b0	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  000b5	83 e8 08	 sub	 eax, 8
  000b8	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN5@P_fwdresol:

; 2674 : }

  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  000c6	3b ec		 cmp	 ebp, esp
  000c8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c3		 ret	 0
_P_fwdresolve ENDP
_TEXT	ENDS
PUBLIC	??_C@_06FAPHFCKA@?5?5?5?$CFs?6?$AA@		; `string'
PUBLIC	??_C@_0L@PCCJFDMH@Walkback?3?6?$AA@		; `string'
;	COMDAT ??_C@_06FAPHFCKA@?5?5?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_06FAPHFCKA@?5?5?5?$CFs?6?$AA@ DB '   %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PCCJFDMH@Walkback?3?6?$AA@
CONST	SEGMENT
??_C@_0L@PCCJFDMH@Walkback?3?6?$AA@ DB 'Walkback:', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _pwalkback
_TEXT	SEGMENT
_wb$84950 = -8						; size = 4
_pwalkback PROC						; COMDAT

; 3023 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3024 :     if (atl_walkback && ((curword != NULL) || (wbptr > wback))) {

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_walkback
  00023	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _atl_walkback+4
  00029	0f 84 a5 00 00
	00		 je	 $LN6@pwalkback
  0002f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _curword, 0
  00036	75 11		 jne	 SHORT $LN4@pwalkback
  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _wbptr
  0003d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _wback
  00043	0f 86 8b 00 00
	00		 jbe	 $LN6@pwalkback
$LN4@pwalkback:

; 3025 :         V printf("Walkback:\n");

  00049	8b f4		 mov	 esi, esp
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0L@PCCJFDMH@Walkback?3?6?$AA@
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00056	83 c4 04	 add	 esp, 4
  00059	3b f4		 cmp	 esi, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3026 : 	if (curword != NULL) {

  00060	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _curword, 0
  00067	74 23		 je	 SHORT $LN2@pwalkback

; 3027 :             V printf("   %s\n", curword->wname + 1);

  00069	a1 00 00 00 00	 mov	 eax, DWORD PTR _curword
  0006e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00071	83 c1 01	 add	 ecx, 1
  00074	8b f4		 mov	 esi, esp
  00076	51		 push	 ecx
  00077	68 00 00 00 00	 push	 OFFSET ??_C@_06FAPHFCKA@?5?5?5?$CFs?6?$AA@
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00082	83 c4 08	 add	 esp, 8
  00085	3b f4		 cmp	 esi, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@pwalkback:

; 3028 : 	}
; 3029 : 	while (wbptr > wback) {

  0008c	a1 00 00 00 00	 mov	 eax, DWORD PTR _wbptr
  00091	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _wback
  00097	76 3b		 jbe	 SHORT $LN6@pwalkback

; 3030 : 	    dictword *wb = *(--wbptr);

  00099	a1 00 00 00 00	 mov	 eax, DWORD PTR _wbptr
  0009e	83 e8 04	 sub	 eax, 4
  000a1	a3 00 00 00 00	 mov	 DWORD PTR _wbptr, eax
  000a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _wbptr
  000ac	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ae	89 55 f8	 mov	 DWORD PTR _wb$84950[ebp], edx

; 3031 :             V printf("   %s\n", wb->wname + 1);

  000b1	8b 45 f8	 mov	 eax, DWORD PTR _wb$84950[ebp]
  000b4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b7	83 c1 01	 add	 ecx, 1
  000ba	8b f4		 mov	 esi, esp
  000bc	51		 push	 ecx
  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_06FAPHFCKA@?5?5?5?$CFs?6?$AA@
  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000c8	83 c4 08	 add	 esp, 8
  000cb	3b f4		 cmp	 esi, esp
  000cd	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3032 : 	}

  000d2	eb b8		 jmp	 SHORT $LN2@pwalkback
$LN6@pwalkback:

; 3033 :     }
; 3034 : }

  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
  000d6	5b		 pop	 ebx
  000d7	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000dd	3b ec		 cmp	 ebp, esp
  000df	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
_pwalkback ENDP
_TEXT	ENDS
PUBLIC	??_C@_05FHDBFBFM@?6?$CFs?4?6?$AA@		; `string'
;	COMDAT ??_C@_05FHDBFBFM@?6?$CFs?4?6?$AA@
CONST	SEGMENT
??_C@_05FHDBFBFM@?6?$CFs?4?6?$AA@ DB 0aH, '%s.', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _trouble
_TEXT	SEGMENT
_kind$ = 8						; size = 4
_trouble PROC						; COMDAT

; 3041 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3042 : #ifdef MEMMESSAGE
; 3043 :     V printf("\n%s.\n", kind);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 08	 mov	 eax, DWORD PTR _kind$[ebp]
  00023	50		 push	 eax
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_05FHDBFBFM@?6?$CFs?4?6?$AA@
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0002f	83 c4 08	 add	 esp, 8
  00032	3b f4		 cmp	 esi, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3044 : #endif
; 3045 : #ifdef WALKBACK
; 3046 :     pwalkback();

  00039	e8 00 00 00 00	 call	 _pwalkback

; 3047 : #endif /* WALKBACK */
; 3048 :     P_abort();			      /* Abort */

  0003e	e8 00 00 00 00	 call	 _P_abort

; 3049 :     atl_comment = state = Falsity;    /* Reset all interpretation state */

  00043	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00048	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0004e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00055	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl_comment, 0
  0005f	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl_comment+4, 0

; 3050 :     forgetpend = defpend = stringlit =
; 3051 : 	tickpend = ctickpend = False;

  00069	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ctickpend, 0
  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR _ctickpend
  00078	a3 00 00 00 00	 mov	 DWORD PTR _tickpend, eax
  0007d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tickpend
  00083	89 0d 00 00 00
	00		 mov	 DWORD PTR _stringlit, ecx
  00089	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stringlit
  0008f	89 15 00 00 00
	00		 mov	 DWORD PTR _defpend, edx
  00095	a1 00 00 00 00	 mov	 eax, DWORD PTR _defpend
  0009a	a3 00 00 00 00	 mov	 DWORD PTR _forgetpend, eax

; 3052 : }

  0009f	5f		 pop	 edi
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
  000a2	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000a8	3b ec		 cmp	 ebp, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
_trouble ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@MGPMFBBC@Stack?5overflow?$AA@		; `string'
;	COMDAT ??_C@_0P@MGPMFBBC@Stack?5overflow?$AA@
CONST	SEGMENT
??_C@_0P@MGPMFBBC@Stack?5overflow?$AA@ DB 'Stack overflow', 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _stakover
_TEXT	SEGMENT
_stakover PROC						; COMDAT

; 3068 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3069 :     trouble("Stack overflow");

  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0P@MGPMFBBC@Stack?5overflow?$AA@
  00023	e8 00 00 00 00	 call	 _trouble
  00028	83 c4 04	 add	 esp, 4

; 3070 :     evalstat = ATL_STACKOVER;

  0002b	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _evalstat, -1

; 3071 : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_stakover ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@IDBDELE@Stack?5underflow?$AA@		; `string'
;	COMDAT ??_C@_0BA@IDBDELE@Stack?5underflow?$AA@
CONST	SEGMENT
??_C@_0BA@IDBDELE@Stack?5underflow?$AA@ DB 'Stack underflow', 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _stakunder
_TEXT	SEGMENT
_stakunder PROC						; COMDAT

; 3076 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3077 :     trouble("Stack underflow");

  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@IDBDELE@Stack?5underflow?$AA@
  00023	e8 00 00 00 00	 call	 _trouble
  00028	83 c4 04	 add	 esp, 4

; 3078 :     evalstat = ATL_STACKUNDER;

  0002b	c7 05 00 00 00
	00 fe ff ff ff	 mov	 DWORD PTR _evalstat, -2	; fffffffeH

; 3079 : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_stakunder ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@LMAJCFEC@Return?5stack?5overflow?$AA@	; `string'
;	COMDAT ??_C@_0BG@LMAJCFEC@Return?5stack?5overflow?$AA@
CONST	SEGMENT
??_C@_0BG@LMAJCFEC@Return?5stack?5overflow?$AA@ DB 'Return stack overflow'
	DB	00H						; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _rstakover
_TEXT	SEGMENT
_rstakover PROC						; COMDAT

; 3084 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3085 :     trouble("Return stack overflow");

  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@LMAJCFEC@Return?5stack?5overflow?$AA@
  00023	e8 00 00 00 00	 call	 _trouble
  00028	83 c4 04	 add	 esp, 4

; 3086 :     evalstat = ATL_RSTACKOVER;

  0002b	c7 05 00 00 00
	00 fd ff ff ff	 mov	 DWORD PTR _evalstat, -3	; fffffffdH

; 3087 : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_rstakover ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@GDCAJADE@Return?5stack?5underflow?$AA@ ; `string'
;	COMDAT ??_C@_0BH@GDCAJADE@Return?5stack?5underflow?$AA@
CONST	SEGMENT
??_C@_0BH@GDCAJADE@Return?5stack?5underflow?$AA@ DB 'Return stack underfl'
	DB	'ow', 00H					; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _rstakunder
_TEXT	SEGMENT
_rstakunder PROC					; COMDAT

; 3092 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3093 :     trouble("Return stack underflow");

  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GDCAJADE@Return?5stack?5underflow?$AA@
  00023	e8 00 00 00 00	 call	 _trouble
  00028	83 c4 04	 add	 esp, 4

; 3094 :     evalstat = ATL_RSTACKUNDER;

  0002b	c7 05 00 00 00
	00 fc ff ff ff	 mov	 DWORD PTR _evalstat, -4	; fffffffcH

; 3095 : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_rstakunder ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@HPAGMHGG@Heap?5overflow?$AA@		; `string'
;	COMDAT ??_C@_0O@HPAGMHGG@Heap?5overflow?$AA@
CONST	SEGMENT
??_C@_0O@HPAGMHGG@Heap?5overflow?$AA@ DB 'Heap overflow', 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _heapover
_TEXT	SEGMENT
_heapover PROC						; COMDAT

; 3103 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3104 :     trouble("Heap overflow");

  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0O@HPAGMHGG@Heap?5overflow?$AA@
  00023	e8 00 00 00 00	 call	 _trouble
  00028	83 c4 04	 add	 esp, 4

; 3105 :     evalstat = ATL_HEAPOVER;

  0002b	c7 05 00 00 00
	00 fb ff ff ff	 mov	 DWORD PTR _evalstat, -5	; fffffffbH

; 3106 : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_heapover ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@PMMKGAPI@Bad?5pointer?$AA@		; `string'
;	COMDAT ??_C@_0M@PMMKGAPI@Bad?5pointer?$AA@
CONST	SEGMENT
??_C@_0M@PMMKGAPI@Bad?5pointer?$AA@ DB 'Bad pointer', 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _badpointer
_TEXT	SEGMENT
_badpointer PROC					; COMDAT

; 3111 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3112 :     trouble("Bad pointer");

  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PMMKGAPI@Bad?5pointer?$AA@
  00023	e8 00 00 00 00	 call	 _trouble
  00028	83 c4 04	 add	 esp, 4

; 3113 :     evalstat = ATL_BADPOINTER;

  0002b	c7 05 00 00 00
	00 fa ff ff ff	 mov	 DWORD PTR _evalstat, -6	; fffffffaH

; 3114 : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_badpointer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@IGAMCALP@Compiler?5word?5outside?5definition@ ; `string'
;	COMDAT ??_C@_0CB@IGAMCALP@Compiler?5word?5outside?5definition@
CONST	SEGMENT
??_C@_0CB@IGAMCALP@Compiler?5word?5outside?5definition@ DB 'Compiler word'
	DB	' outside definition', 00H			; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _notcomp
_TEXT	SEGMENT
_notcomp PROC						; COMDAT

; 3119 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3120 :     trouble("Compiler word outside definition");

  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@IGAMCALP@Compiler?5word?5outside?5definition@
  00023	e8 00 00 00 00	 call	 _trouble
  00028	83 c4 04	 add	 esp, 4

; 3121 :     evalstat = ATL_NOTINDEF;

  0002b	c7 05 00 00 00
	00 f7 ff ff ff	 mov	 DWORD PTR _evalstat, -9	; fffffff7H

; 3122 : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_notcomp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@FGOAMMID@Divide?5by?5zero?$AA@		; `string'
;	COMDAT ??_C@_0P@FGOAMMID@Divide?5by?5zero?$AA@
CONST	SEGMENT
??_C@_0P@FGOAMMID@Divide?5by?5zero?$AA@ DB 'Divide by zero', 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _divzero
_TEXT	SEGMENT
_divzero PROC						; COMDAT

; 3127 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3128 :     trouble("Divide by zero");

  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0P@FGOAMMID@Divide?5by?5zero?$AA@
  00023	e8 00 00 00 00	 call	 _trouble
  00028	83 c4 04	 add	 esp, 4

; 3129 :     evalstat = ATL_DIVZERO;

  0002b	c7 05 00 00 00
	00 f3 ff ff ff	 mov	 DWORD PTR _evalstat, -13 ; fffffff3H

; 3130 : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_divzero ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@FPAAJABI@Break?5signal?$AA@		; `string'
PUBLIC	??_C@_0M@KIMLNNGH@?6Trace?3?5?$CFs?5?$AA@	; `string'
;	COMDAT ??_C@_0N@FPAAJABI@Break?5signal?$AA@
CONST	SEGMENT
??_C@_0N@FPAAJABI@Break?5signal?$AA@ DB 'Break signal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KIMLNNGH@?6Trace?3?5?$CFs?5?$AA@
CONST	SEGMENT
??_C@_0M@KIMLNNGH@?6Trace?3?5?$CFs?5?$AA@ DB 0aH, 'Trace: %s ', 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _exword
_TEXT	SEGMENT
_wp$ = 8						; size = 4
_exword	PROC						; COMDAT

; 3138 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3139 :     curword = wp;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _wp$[ebp]
  00021	a3 00 00 00 00	 mov	 DWORD PTR _curword, eax

; 3140 : #ifdef TRACE
; 3141 :     if (atl_trace) {

  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_trace
  0002b	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _atl_trace+4
  00031	74 23		 je	 SHORT $LN5@exword

; 3142 :         V printf("\nTrace: %s ", curword->wname + 1);

  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR _curword
  00038	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003b	83 c1 01	 add	 ecx, 1
  0003e	8b f4		 mov	 esi, esp
  00040	51		 push	 ecx
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0M@KIMLNNGH@?6Trace?3?5?$CFs?5?$AA@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0004c	83 c4 08	 add	 esp, 8
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@exword:

; 3143 :     }
; 3144 : #endif /* TRACE */
; 3145 :     (*curword->wcode)();	      /* Execute the first word */

  00056	a1 00 00 00 00	 mov	 eax, DWORD PTR _curword
  0005b	8b f4		 mov	 esi, esp
  0005d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00060	ff d1		 call	 ecx
  00062	3b f4		 cmp	 esi, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@exword:

; 3146 :     while (ip != NULL) {

  00069	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ip, 0
  00070	0f 84 86 00 00
	00		 je	 $LN3@exword

; 3147 : #ifdef BREAK
; 3148 : #ifdef Keybreak
; 3149 : 	Keybreak();		      /* Poll for asynchronous interrupt */
; 3150 : #endif
; 3151 : 	if (broken) {		      /* Did we receive a break signal */

  00076	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _broken, 0
  0007d	74 19		 je	 SHORT $LN2@exword

; 3152 :             trouble("Break signal");

  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FPAAJABI@Break?5signal?$AA@
  00084	e8 00 00 00 00	 call	 _trouble
  00089	83 c4 04	 add	 esp, 4

; 3153 : 	    evalstat = ATL_BREAK;

  0008c	c7 05 00 00 00
	00 f4 ff ff ff	 mov	 DWORD PTR _evalstat, -12 ; fffffff4H

; 3154 : 	    break;

  00096	eb 64		 jmp	 SHORT $LN3@exword
$LN2@exword:

; 3155 : 	}
; 3156 : #endif /* BREAK */
; 3157 : 	curword = *ip++;

  00098	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  0009d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009f	89 0d 00 00 00
	00		 mov	 DWORD PTR _curword, ecx
  000a5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ip
  000ab	83 c2 04	 add	 edx, 4
  000ae	89 15 00 00 00
	00		 mov	 DWORD PTR _ip, edx

; 3158 : #ifdef TRACE
; 3159 : 	if (atl_trace) {

  000b4	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_trace
  000b9	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _atl_trace+4
  000bf	74 23		 je	 SHORT $LN1@exword

; 3160 :             V printf("\nTrace: %s ", curword->wname + 1);

  000c1	a1 00 00 00 00	 mov	 eax, DWORD PTR _curword
  000c6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c9	83 c1 01	 add	 ecx, 1
  000cc	8b f4		 mov	 esi, esp
  000ce	51		 push	 ecx
  000cf	68 00 00 00 00	 push	 OFFSET ??_C@_0M@KIMLNNGH@?6Trace?3?5?$CFs?5?$AA@
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000da	83 c4 08	 add	 esp, 8
  000dd	3b f4		 cmp	 esi, esp
  000df	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@exword:

; 3161 : 	}
; 3162 : #endif /* TRACE */
; 3163 : 	(*curword->wcode)();	      /* Execute the next word */

  000e4	a1 00 00 00 00	 mov	 eax, DWORD PTR _curword
  000e9	8b f4		 mov	 esi, esp
  000eb	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000ee	ff d1		 call	 ecx
  000f0	3b f4		 cmp	 esi, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3164 :     }

  000f7	e9 6d ff ff ff	 jmp	 $LN4@exword
$LN3@exword:

; 3165 :     curword = NULL;

  000fc	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _curword, 0

; 3166 : }

  00106	5f		 pop	 edi
  00107	5e		 pop	 esi
  00108	5b		 pop	 ebx
  00109	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0010f	3b ec		 cmp	 ebp, esp
  00111	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c3		 ret	 0
_exword	ENDP
_TEXT	ENDS
PUBLIC	_atl_body
PUBLIC	_atl_vardef
PUBLIC	??_C@_06LFNPDNNG@ABORT?$CC?$AA@			; `string'
PUBLIC	??_C@_08NNENOOIF@?$CI?$CLXLOOP?$CJ?$AA@		; `string'
PUBLIC	??_C@_07OJMAACBK@?$CIXLOOP?$CJ?$AA@		; `string'
PUBLIC	??_C@_06HGJLGIML@?$CIX?$DPDO?$CJ?$AA@		; `string'
PUBLIC	??_C@_05IGFHMHHB@?$CIXDO?$CJ?$AA@		; `string'
PUBLIC	??_C@_06KEGFEFEO@BRANCH?$AA@			; `string'
PUBLIC	??_C@_07MGAEII@?$DPBRANCH?$AA@			; `string'
PUBLIC	??_C@_02GPDAODKN@?4?$CI?$AA@			; `string'
PUBLIC	??_C@_08DJEGOAOP@?$CISTRLIT?$CJ?$AA@		; `string'
PUBLIC	??_C@_06BDCMAFHD@?$CIFLIT?$CJ?$AA@		; `string'
PUBLIC	??_C@_05PBCOGCHP@?$CILIT?$CJ?$AA@		; `string'
PUBLIC	??_C@_04GOLNGIJ@EXIT?$AA@			; `string'
PUBLIC	_atl_init
_BSS	SEGMENT
_rstackbot DD	01H DUP (?)
	ALIGN	8

_s_strlit DQ	01H DUP (?)
_s_flit	DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_06LFNPDNNG@ABORT?$CC?$AA@
CONST	SEGMENT
??_C@_06LFNPDNNG@ABORT?$CC?$AA@ DB 'ABORT"', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NNENOOIF@?$CI?$CLXLOOP?$CJ?$AA@
CONST	SEGMENT
??_C@_08NNENOOIF@?$CI?$CLXLOOP?$CJ?$AA@ DB '(+XLOOP)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07OJMAACBK@?$CIXLOOP?$CJ?$AA@
CONST	SEGMENT
??_C@_07OJMAACBK@?$CIXLOOP?$CJ?$AA@ DB '(XLOOP)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HGJLGIML@?$CIX?$DPDO?$CJ?$AA@
CONST	SEGMENT
??_C@_06HGJLGIML@?$CIX?$DPDO?$CJ?$AA@ DB '(X?DO)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05IGFHMHHB@?$CIXDO?$CJ?$AA@
CONST	SEGMENT
??_C@_05IGFHMHHB@?$CIXDO?$CJ?$AA@ DB '(XDO)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06KEGFEFEO@BRANCH?$AA@
CONST	SEGMENT
??_C@_06KEGFEFEO@BRANCH?$AA@ DB 'BRANCH', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MGAEII@?$DPBRANCH?$AA@
CONST	SEGMENT
??_C@_07MGAEII@?$DPBRANCH?$AA@ DB '?BRANCH', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02GPDAODKN@?4?$CI?$AA@
CONST	SEGMENT
??_C@_02GPDAODKN@?4?$CI?$AA@ DB '.(', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DJEGOAOP@?$CISTRLIT?$CJ?$AA@
CONST	SEGMENT
??_C@_08DJEGOAOP@?$CISTRLIT?$CJ?$AA@ DB '(STRLIT)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06BDCMAFHD@?$CIFLIT?$CJ?$AA@
CONST	SEGMENT
??_C@_06BDCMAFHD@?$CIFLIT?$CJ?$AA@ DB '(FLIT)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05PBCOGCHP@?$CILIT?$CJ?$AA@
CONST	SEGMENT
??_C@_05PBCOGCHP@?$CILIT?$CJ?$AA@ DB '(LIT)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04GOLNGIJ@EXIT?$AA@
CONST	SEGMENT
??_C@_04GOLNGIJ@EXIT?$AA@ DB 'EXIT', 00H		; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _atl_init
_TEXT	SEGMENT
tv506 = -260						; size = 8
_si$85082 = -56						; size = 4
_dw$85075 = -44						; size = 4
_i$85074 = -32						; size = 4
_cp$85048 = -20						; size = 4
_i$85047 = -8						; size = 4
_atl_init PROC						; COMDAT

; 3178 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd fc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-260]
  00012	b9 41 00 00 00	 mov	 ecx, 65			; 00000041H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3179 : 
; 3180 :     /* If any of the following three lines of code produce errors,
; 3181 :        you are probably trying to build on an architecture which
; 3182 :        violates the fundamental reuirement of 64-bit ATLAST that
; 3183 :        stack items, pointers, and real numbers are all 8 byte, 64-bit
; 3184 :        values.  If this is the case and you can't fix the problem by
; 3185 :        changing compiler memory model options, it's best to revert
; 3186 :        to the 32-bit version of ATLAST, which can be built on most
; 3187 :        systems (including 64-bit systems) by compiling and linking
; 3188 :        in 32-bit mode. */
; 3189 :     
; 3190 : /*
; 3191 :     MEMORY_MODEL_ERROR(sizeof(stackitem) != 8);
; 3192 :     MEMORY_MODEL_ERROR(sizeof(stackitem *) != 8);
; 3193 :     MEMORY_MODEL_ERROR(sizeof(atl_real) != 8);
; 3194 : */
; 3195 :     if (dict == NULL) {

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dict, 0
  00025	0f 85 6f 05 00
	00		 jne	 $LN25@atl_init

; 3196 : 	atl_primdef(primt);	      /* Define primitive words */

  0002b	68 00 00 00 00	 push	 OFFSET _primt
  00030	e8 00 00 00 00	 call	 _atl_primdef
  00035	83 c4 04	 add	 esp, 4

; 3197 : 	dictprot = dict;	      /* Set protected mark in dictionary */

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  0003d	a3 00 00 00 00	 mov	 DWORD PTR _dictprot, eax

; 3198 : 
; 3199 : 	/* Look up compiler-referenced words in the new dictionary and
; 3200 : 	   save their compile addresses in static variables. */
; 3201 : 
; 3202 : #define Cconst(cell, name)  cell = (stackitem) lookup(name); if(cell==0)abort()
; 3203 :         Cconst(s_exit, "EXIT");

  00042	68 00 00 00 00	 push	 OFFSET ??_C@_04GOLNGIJ@EXIT?$AA@
  00047	e8 00 00 00 00	 call	 _lookup
  0004c	83 c4 04	 add	 esp, 4
  0004f	99		 cdq
  00050	a3 00 00 00 00	 mov	 DWORD PTR _s_exit, eax
  00055	89 15 04 00 00
	00		 mov	 DWORD PTR _s_exit+4, edx
  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_exit
  00060	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _s_exit+4
  00066	75 0f		 jne	 SHORT $LN23@atl_init
  00068	8b f4		 mov	 esi, esp
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__abort
  00070	3b f4		 cmp	 esi, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN23@atl_init:

; 3204 :         Cconst(s_lit, "(LIT)");

  00077	68 00 00 00 00	 push	 OFFSET ??_C@_05PBCOGCHP@?$CILIT?$CJ?$AA@
  0007c	e8 00 00 00 00	 call	 _lookup
  00081	83 c4 04	 add	 esp, 4
  00084	99		 cdq
  00085	a3 00 00 00 00	 mov	 DWORD PTR _s_lit, eax
  0008a	89 15 04 00 00
	00		 mov	 DWORD PTR _s_lit+4, edx
  00090	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_lit
  00095	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _s_lit+4
  0009b	75 0f		 jne	 SHORT $LN22@atl_init
  0009d	8b f4		 mov	 esi, esp
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__abort
  000a5	3b f4		 cmp	 esi, esp
  000a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN22@atl_init:

; 3205 :         Cconst(s_flit, "(FLIT)");

  000ac	68 00 00 00 00	 push	 OFFSET ??_C@_06BDCMAFHD@?$CIFLIT?$CJ?$AA@
  000b1	e8 00 00 00 00	 call	 _lookup
  000b6	83 c4 04	 add	 esp, 4
  000b9	99		 cdq
  000ba	a3 00 00 00 00	 mov	 DWORD PTR _s_flit, eax
  000bf	89 15 04 00 00
	00		 mov	 DWORD PTR _s_flit+4, edx
  000c5	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_flit
  000ca	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _s_flit+4
  000d0	75 0f		 jne	 SHORT $LN21@atl_init
  000d2	8b f4		 mov	 esi, esp
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__abort
  000da	3b f4		 cmp	 esi, esp
  000dc	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN21@atl_init:

; 3206 :         Cconst(s_strlit, "(STRLIT)");

  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_08DJEGOAOP@?$CISTRLIT?$CJ?$AA@
  000e6	e8 00 00 00 00	 call	 _lookup
  000eb	83 c4 04	 add	 esp, 4
  000ee	99		 cdq
  000ef	a3 00 00 00 00	 mov	 DWORD PTR _s_strlit, eax
  000f4	89 15 04 00 00
	00		 mov	 DWORD PTR _s_strlit+4, edx
  000fa	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_strlit
  000ff	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _s_strlit+4
  00105	75 0f		 jne	 SHORT $LN20@atl_init
  00107	8b f4		 mov	 esi, esp
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__abort
  0010f	3b f4		 cmp	 esi, esp
  00111	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN20@atl_init:

; 3207 :         Cconst(s_dotparen, ".(");

  00116	68 00 00 00 00	 push	 OFFSET ??_C@_02GPDAODKN@?4?$CI?$AA@
  0011b	e8 00 00 00 00	 call	 _lookup
  00120	83 c4 04	 add	 esp, 4
  00123	99		 cdq
  00124	a3 00 00 00 00	 mov	 DWORD PTR _s_dotparen, eax
  00129	89 15 04 00 00
	00		 mov	 DWORD PTR _s_dotparen+4, edx
  0012f	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_dotparen
  00134	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _s_dotparen+4
  0013a	75 0f		 jne	 SHORT $LN19@atl_init
  0013c	8b f4		 mov	 esi, esp
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__abort
  00144	3b f4		 cmp	 esi, esp
  00146	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN19@atl_init:

; 3208 :         Cconst(s_qbranch, "?BRANCH");

  0014b	68 00 00 00 00	 push	 OFFSET ??_C@_07MGAEII@?$DPBRANCH?$AA@
  00150	e8 00 00 00 00	 call	 _lookup
  00155	83 c4 04	 add	 esp, 4
  00158	99		 cdq
  00159	a3 00 00 00 00	 mov	 DWORD PTR _s_qbranch, eax
  0015e	89 15 04 00 00
	00		 mov	 DWORD PTR _s_qbranch+4, edx
  00164	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_qbranch
  00169	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _s_qbranch+4
  0016f	75 0f		 jne	 SHORT $LN18@atl_init
  00171	8b f4		 mov	 esi, esp
  00173	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__abort
  00179	3b f4		 cmp	 esi, esp
  0017b	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN18@atl_init:

; 3209 :         Cconst(s_branch, "BRANCH");

  00180	68 00 00 00 00	 push	 OFFSET ??_C@_06KEGFEFEO@BRANCH?$AA@
  00185	e8 00 00 00 00	 call	 _lookup
  0018a	83 c4 04	 add	 esp, 4
  0018d	99		 cdq
  0018e	a3 00 00 00 00	 mov	 DWORD PTR _s_branch, eax
  00193	89 15 04 00 00
	00		 mov	 DWORD PTR _s_branch+4, edx
  00199	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_branch
  0019e	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _s_branch+4
  001a4	75 0f		 jne	 SHORT $LN17@atl_init
  001a6	8b f4		 mov	 esi, esp
  001a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__abort
  001ae	3b f4		 cmp	 esi, esp
  001b0	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN17@atl_init:

; 3210 :         Cconst(s_xdo, "(XDO)");

  001b5	68 00 00 00 00	 push	 OFFSET ??_C@_05IGFHMHHB@?$CIXDO?$CJ?$AA@
  001ba	e8 00 00 00 00	 call	 _lookup
  001bf	83 c4 04	 add	 esp, 4
  001c2	99		 cdq
  001c3	a3 00 00 00 00	 mov	 DWORD PTR _s_xdo, eax
  001c8	89 15 04 00 00
	00		 mov	 DWORD PTR _s_xdo+4, edx
  001ce	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_xdo
  001d3	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _s_xdo+4
  001d9	75 0f		 jne	 SHORT $LN16@atl_init
  001db	8b f4		 mov	 esi, esp
  001dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__abort
  001e3	3b f4		 cmp	 esi, esp
  001e5	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN16@atl_init:

; 3211 :         Cconst(s_xqdo, "(X?DO)");

  001ea	68 00 00 00 00	 push	 OFFSET ??_C@_06HGJLGIML@?$CIX?$DPDO?$CJ?$AA@
  001ef	e8 00 00 00 00	 call	 _lookup
  001f4	83 c4 04	 add	 esp, 4
  001f7	99		 cdq
  001f8	a3 00 00 00 00	 mov	 DWORD PTR _s_xqdo, eax
  001fd	89 15 04 00 00
	00		 mov	 DWORD PTR _s_xqdo+4, edx
  00203	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_xqdo
  00208	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _s_xqdo+4
  0020e	75 0f		 jne	 SHORT $LN15@atl_init
  00210	8b f4		 mov	 esi, esp
  00212	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__abort
  00218	3b f4		 cmp	 esi, esp
  0021a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN15@atl_init:

; 3212 :         Cconst(s_xloop, "(XLOOP)");

  0021f	68 00 00 00 00	 push	 OFFSET ??_C@_07OJMAACBK@?$CIXLOOP?$CJ?$AA@
  00224	e8 00 00 00 00	 call	 _lookup
  00229	83 c4 04	 add	 esp, 4
  0022c	99		 cdq
  0022d	a3 00 00 00 00	 mov	 DWORD PTR _s_xloop, eax
  00232	89 15 04 00 00
	00		 mov	 DWORD PTR _s_xloop+4, edx
  00238	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_xloop
  0023d	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _s_xloop+4
  00243	75 0f		 jne	 SHORT $LN14@atl_init
  00245	8b f4		 mov	 esi, esp
  00247	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__abort
  0024d	3b f4		 cmp	 esi, esp
  0024f	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN14@atl_init:

; 3213 :         Cconst(s_pxloop, "(+XLOOP)");

  00254	68 00 00 00 00	 push	 OFFSET ??_C@_08NNENOOIF@?$CI?$CLXLOOP?$CJ?$AA@
  00259	e8 00 00 00 00	 call	 _lookup
  0025e	83 c4 04	 add	 esp, 4
  00261	99		 cdq
  00262	a3 00 00 00 00	 mov	 DWORD PTR _s_pxloop, eax
  00267	89 15 04 00 00
	00		 mov	 DWORD PTR _s_pxloop+4, edx
  0026d	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_pxloop
  00272	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _s_pxloop+4
  00278	75 0f		 jne	 SHORT $LN13@atl_init
  0027a	8b f4		 mov	 esi, esp
  0027c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__abort
  00282	3b f4		 cmp	 esi, esp
  00284	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN13@atl_init:

; 3214 :         Cconst(s_abortq, "ABORT\"");

  00289	68 00 00 00 00	 push	 OFFSET ??_C@_06LFNPDNNG@ABORT?$CC?$AA@
  0028e	e8 00 00 00 00	 call	 _lookup
  00293	83 c4 04	 add	 esp, 4
  00296	99		 cdq
  00297	a3 00 00 00 00	 mov	 DWORD PTR _s_abortq, eax
  0029c	89 15 04 00 00
	00		 mov	 DWORD PTR _s_abortq+4, edx
  002a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_abortq
  002a7	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _s_abortq+4
  002ad	75 0f		 jne	 SHORT $LN12@atl_init
  002af	8b f4		 mov	 esi, esp
  002b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__abort
  002b7	3b f4		 cmp	 esi, esp
  002b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN12@atl_init:

; 3215 : #undef Cconst
; 3216 : 
; 3217 : 	if (stack == NULL) {	      /* Allocate stack if needed */

  002be	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _stack, 0
  002c5	75 16		 jne	 SHORT $LN11@atl_init

; 3218 : 	    stack = (stackitem *)
; 3219 : 		alloc(((unsigned int) atl_stklen) * sizeof(stackitem));

  002c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_stklen
  002cc	c1 e0 03	 shl	 eax, 3
  002cf	50		 push	 eax
  002d0	e8 00 00 00 00	 call	 _alloc
  002d5	83 c4 04	 add	 esp, 4
  002d8	a3 00 00 00 00	 mov	 DWORD PTR _stack, eax
$LN11@atl_init:

; 3220 : 	}
; 3221 : 	stk = stackbot = stack;

  002dd	a1 00 00 00 00	 mov	 eax, DWORD PTR _stack
  002e2	a3 00 00 00 00	 mov	 DWORD PTR _stackbot, eax
  002e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stackbot
  002ed	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx

; 3222 : #ifdef MEMSTAT
; 3223 : 	stackmax = stack;
; 3224 : #endif
; 3225 : 	stacktop = stack + atl_stklen;

  002f3	6a 00		 push	 0
  002f5	6a 08		 push	 8
  002f7	a1 04 00 00 00	 mov	 eax, DWORD PTR _atl_stklen+4
  002fc	50		 push	 eax
  002fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl_stklen
  00303	51		 push	 ecx
  00304	e8 00 00 00 00	 call	 __allmul
  00309	03 05 00 00 00
	00		 add	 eax, DWORD PTR _stack
  0030f	a3 00 00 00 00	 mov	 DWORD PTR _stacktop, eax

; 3226 : 	if (rstack == NULL) {	      /* Allocate return stack if needed */

  00314	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _rstack, 0
  0031b	75 16		 jne	 SHORT $LN10@atl_init

; 3227 : 	    rstack = (dictword ***)
; 3228 : 		alloc(((unsigned int) atl_rstklen) *
; 3229 : 		sizeof(dictword **));

  0031d	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_rstklen
  00322	c1 e0 02	 shl	 eax, 2
  00325	50		 push	 eax
  00326	e8 00 00 00 00	 call	 _alloc
  0032b	83 c4 04	 add	 esp, 4
  0032e	a3 00 00 00 00	 mov	 DWORD PTR _rstack, eax
$LN10@atl_init:

; 3230 : 	}
; 3231 : 	rstk = rstackbot = rstack;

  00333	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstack
  00338	a3 00 00 00 00	 mov	 DWORD PTR _rstackbot, eax
  0033d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstackbot
  00343	89 0d 00 00 00
	00		 mov	 DWORD PTR _rstk, ecx

; 3232 : #ifdef MEMSTAT
; 3233 : 	rstackmax = rstack;
; 3234 : #endif
; 3235 : 	rstacktop = rstack + atl_rstklen;

  00349	6a 00		 push	 0
  0034b	6a 04		 push	 4
  0034d	a1 04 00 00 00	 mov	 eax, DWORD PTR _atl_rstklen+4
  00352	50		 push	 eax
  00353	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl_rstklen
  00359	51		 push	 ecx
  0035a	e8 00 00 00 00	 call	 __allmul
  0035f	03 05 00 00 00
	00		 add	 eax, DWORD PTR _rstack
  00365	a3 00 00 00 00	 mov	 DWORD PTR _rstacktop, eax

; 3236 : #ifdef WALKBACK
; 3237 : 	if (wback == NULL) {

  0036a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _wback, 0
  00371	75 16		 jne	 SHORT $LN9@atl_init

; 3238 : 	    wback = (dictword **) alloc(((unsigned int) atl_rstklen) *
; 3239 : 				    sizeof(dictword *));

  00373	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_rstklen
  00378	c1 e0 02	 shl	 eax, 2
  0037b	50		 push	 eax
  0037c	e8 00 00 00 00	 call	 _alloc
  00381	83 c4 04	 add	 esp, 4
  00384	a3 00 00 00 00	 mov	 DWORD PTR _wback, eax
$LN9@atl_init:

; 3240 : 	}
; 3241 : 	wbptr = wback;

  00389	a1 00 00 00 00	 mov	 eax, DWORD PTR _wback
  0038e	a3 00 00 00 00	 mov	 DWORD PTR _wbptr, eax

; 3242 : #endif
; 3243 : 	if (heap == NULL) {

  00393	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _heap, 0
  0039a	0f 85 fb 00 00
	00		 jne	 $LN8@atl_init

; 3244 : 
; 3245 : 	    /* The temporary string buffers are placed at the start of the
; 3246 : 	       heap, which permits us to pointer-check pointers into them
; 3247 : 	       as within the heap extents.  Hence, the size of the buffer
; 3248 : 	       we acquire for the heap is the sum of the heap and temporary
; 3249 : 	       string requests. */
; 3250 : 
; 3251 : 	    int i;
; 3252 : 	    char *cp;
; 3253 : 
; 3254 : 	    /* Force length of temporary strings to even number of
; 3255 : 	       stackitems. */
; 3256 : 	    atl_ltempstr += sizeof(stackitem) -
; 3257 : 		(atl_ltempstr % sizeof(stackitem));

  003a0	6a 00		 push	 0
  003a2	6a 08		 push	 8
  003a4	a1 04 00 00 00	 mov	 eax, DWORD PTR _atl_ltempstr+4
  003a9	50		 push	 eax
  003aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl_ltempstr
  003b0	51		 push	 ecx
  003b1	e8 00 00 00 00	 call	 __allrem
  003b6	b9 08 00 00 00	 mov	 ecx, 8
  003bb	2b c8		 sub	 ecx, eax
  003bd	b8 00 00 00 00	 mov	 eax, 0
  003c2	1b c2		 sbb	 eax, edx
  003c4	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _atl_ltempstr
  003ca	13 05 04 00 00
	00		 adc	 eax, DWORD PTR _atl_ltempstr+4
  003d0	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl_ltempstr, ecx
  003d6	a3 04 00 00 00	 mov	 DWORD PTR _atl_ltempstr+4, eax

; 3258 : 	    cp = alloc((((unsigned int) atl_heaplen) * sizeof(stackitem)) +
; 3259 : 			((unsigned int) (atl_ntempstr * atl_ltempstr)));

  003db	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _atl_heaplen
  003e1	a1 04 00 00 00	 mov	 eax, DWORD PTR _atl_ltempstr+4
  003e6	50		 push	 eax
  003e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl_ltempstr
  003ed	51		 push	 ecx
  003ee	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _atl_ntempstr+4
  003f4	52		 push	 edx
  003f5	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_ntempstr
  003fa	50		 push	 eax
  003fb	e8 00 00 00 00	 call	 __allmul
  00400	8d 0c f0	 lea	 ecx, DWORD PTR [eax+esi*8]
  00403	51		 push	 ecx
  00404	e8 00 00 00 00	 call	 _alloc
  00409	83 c4 04	 add	 esp, 4
  0040c	89 45 ec	 mov	 DWORD PTR _cp$85048[ebp], eax

; 3260 : 	    heapbot = (stackitem *) cp;

  0040f	8b 45 ec	 mov	 eax, DWORD PTR _cp$85048[ebp]
  00412	a3 00 00 00 00	 mov	 DWORD PTR _heapbot, eax

; 3261 : 	    strbuf = (char **) alloc(((unsigned int) atl_ntempstr) *
; 3262 : 				sizeof(char *));

  00417	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_ntempstr
  0041c	c1 e0 02	 shl	 eax, 2
  0041f	50		 push	 eax
  00420	e8 00 00 00 00	 call	 _alloc
  00425	83 c4 04	 add	 esp, 4
  00428	a3 00 00 00 00	 mov	 DWORD PTR _strbuf, eax

; 3263 : 	    for (i = 0; i < atl_ntempstr; i++) {

  0042d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$85047[ebp], 0
  00434	eb 09		 jmp	 SHORT $LN7@atl_init
$LN6@atl_init:
  00436	8b 45 f8	 mov	 eax, DWORD PTR _i$85047[ebp]
  00439	83 c0 01	 add	 eax, 1
  0043c	89 45 f8	 mov	 DWORD PTR _i$85047[ebp], eax
$LN7@atl_init:
  0043f	8b 45 f8	 mov	 eax, DWORD PTR _i$85047[ebp]
  00442	99		 cdq
  00443	89 85 fc fe ff
	ff		 mov	 DWORD PTR tv506[ebp], eax
  00449	89 95 00 ff ff
	ff		 mov	 DWORD PTR tv506[ebp+4], edx
  0044f	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv506[ebp+4]
  00455	3b 05 04 00 00
	00		 cmp	 eax, DWORD PTR _atl_ntempstr+4
  0045b	7f 2c		 jg	 SHORT $LN5@atl_init
  0045d	7c 0e		 jl	 SHORT $LN27@atl_init
  0045f	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR tv506[ebp]
  00465	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl_ntempstr
  0046b	73 1c		 jae	 SHORT $LN5@atl_init
$LN27@atl_init:

; 3264 : 		strbuf[i] = cp;

  0046d	8b 45 f8	 mov	 eax, DWORD PTR _i$85047[ebp]
  00470	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _strbuf
  00476	8b 55 ec	 mov	 edx, DWORD PTR _cp$85048[ebp]
  00479	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 3265 : 		cp += ((unsigned int) atl_ltempstr);

  0047c	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_ltempstr
  00481	03 45 ec	 add	 eax, DWORD PTR _cp$85048[ebp]
  00484	89 45 ec	 mov	 DWORD PTR _cp$85048[ebp], eax

; 3266 : 	    }

  00487	eb ad		 jmp	 SHORT $LN6@atl_init
$LN5@atl_init:

; 3267 : 	    cstrbuf = 0;

  00489	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cstrbuf, 0

; 3268 : 	    heap = (stackitem *) cp;  /* Allocatable heap starts after

  00493	8b 45 ec	 mov	 eax, DWORD PTR _cp$85048[ebp]
  00496	a3 00 00 00 00	 mov	 DWORD PTR _heap, eax
$LN8@atl_init:

; 3269 : 					 the temporary strings */
; 3270 : 	}
; 3271 : 	/* The system state word is kept in the first word of the heap
; 3272 :            so that pointer checking doesn't bounce references to it.
; 3273 : 	   When creating the heap, we preallocate this word and initialise
; 3274 : 	   the state to the interpretive state. */
; 3275 : 	hptr = heap + 1;

  0049b	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  004a0	83 c0 08	 add	 eax, 8
  004a3	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 3276 : 	state = Falsity;

  004a8	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  004ad	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  004b3	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 3277 : #ifdef MEMSTAT
; 3278 : 	heapmax = hptr;
; 3279 : #endif
; 3280 : 	heaptop = heap + atl_heaplen;

  004ba	6a 00		 push	 0
  004bc	6a 08		 push	 8
  004be	a1 04 00 00 00	 mov	 eax, DWORD PTR _atl_heaplen+4
  004c3	50		 push	 eax
  004c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl_heaplen
  004ca	51		 push	 ecx
  004cb	e8 00 00 00 00	 call	 __allmul
  004d0	03 05 00 00 00
	00		 add	 eax, DWORD PTR _heap
  004d6	a3 00 00 00 00	 mov	 DWORD PTR _heaptop, eax

; 3281 : 
; 3282 : 	/* Now that dynamic memory is up and running, allocate constants
; 3283 : 	   and variables built into the system.  */
; 3284 : 
; 3285 : #ifdef FILEIO
; 3286 : 	{   static struct {
; 3287 : 		char *sfn;
; 3288 : 		FILE *sfd;
; 3289 : 	    } stdfiles[] = {
; 3290 :                 {"STDIN", NULL},
; 3291 :                 {"STDOUT", NULL},
; 3292 :                 {"STDERR", NULL}
; 3293 : 	    };
; 3294 : 	    int i;
; 3295 : 	    dictword *dw;
; 3296 : 
; 3297 :     	    /* On some systems stdin, stdout, and stderr aren't
; 3298 : 	       constants which can appear in an initialisation.
; 3299 : 	       So, we initialise them at runtime here. */
; 3300 : 	       
; 3301 :     	    stdfiles[0].sfd = stdin;

  004db	8b f4		 mov	 esi, esp
  004dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  004e3	3b f4		 cmp	 esi, esp
  004e5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004ea	a3 04 00 00 00	 mov	 DWORD PTR ?stdfiles@?8??atl_init@@9@9+4, eax

; 3302 : 	    stdfiles[1].sfd = stdout;

  004ef	8b f4		 mov	 esi, esp
  004f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  004f7	3b f4		 cmp	 esi, esp
  004f9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004fe	83 c0 20	 add	 eax, 32			; 00000020H
  00501	a3 0c 00 00 00	 mov	 DWORD PTR ?stdfiles@?8??atl_init@@9@9+12, eax

; 3303 : 	    stdfiles[2].sfd = stderr;

  00506	8b f4		 mov	 esi, esp
  00508	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0050e	3b f4		 cmp	 esi, esp
  00510	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00515	83 c0 40	 add	 eax, 64			; 00000040H
  00518	a3 14 00 00 00	 mov	 DWORD PTR ?stdfiles@?8??atl_init@@9@9+20, eax

; 3304 : 	    
; 3305 : 	    for (i = 0; i < ELEMENTS(stdfiles); i++) {

  0051d	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$85074[ebp], 0
  00524	eb 09		 jmp	 SHORT $LN4@atl_init
$LN3@atl_init:
  00526	8b 45 e0	 mov	 eax, DWORD PTR _i$85074[ebp]
  00529	83 c0 01	 add	 eax, 1
  0052c	89 45 e0	 mov	 DWORD PTR _i$85074[ebp], eax
$LN4@atl_init:
  0052f	83 7d e0 03	 cmp	 DWORD PTR _i$85074[ebp], 3
  00533	73 5b		 jae	 SHORT $LN2@atl_init

; 3306 : 		if ((dw = atl_vardef(stdfiles[i].sfn,
; 3307 : 			2 * sizeof(stackitem))) != NULL) {

  00535	6a 10		 push	 16			; 00000010H
  00537	8b 45 e0	 mov	 eax, DWORD PTR _i$85074[ebp]
  0053a	8b 0c c5 00 00
	00 00		 mov	 ecx, DWORD PTR ?stdfiles@?8??atl_init@@9@9[eax*8]
  00541	51		 push	 ecx
  00542	e8 00 00 00 00	 call	 _atl_vardef
  00547	83 c4 08	 add	 esp, 8
  0054a	89 45 d4	 mov	 DWORD PTR _dw$85075[ebp], eax
  0054d	83 7d d4 00	 cmp	 DWORD PTR _dw$85075[ebp], 0
  00551	74 3b		 je	 SHORT $LN1@atl_init

; 3308 : 		    stackitem *si = atl_body(dw);

  00553	8b 45 d4	 mov	 eax, DWORD PTR _dw$85075[ebp]
  00556	50		 push	 eax
  00557	e8 00 00 00 00	 call	 _atl_body
  0055c	83 c4 04	 add	 esp, 4
  0055f	89 45 c8	 mov	 DWORD PTR _si$85082[ebp], eax

; 3309 : 		    *si++ = FileSent;

  00562	8b 45 c8	 mov	 eax, DWORD PTR _si$85082[ebp]
  00565	c7 00 9d df 1f
	83		 mov	 DWORD PTR [eax], -2095063139 ; 831fdf9dH
  0056b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00572	8b 4d c8	 mov	 ecx, DWORD PTR _si$85082[ebp]
  00575	83 c1 08	 add	 ecx, 8
  00578	89 4d c8	 mov	 DWORD PTR _si$85082[ebp], ecx

; 3310 : 		    *si = (stackitem) stdfiles[i].sfd;

  0057b	8b 45 e0	 mov	 eax, DWORD PTR _i$85074[ebp]
  0057e	8b 04 c5 04 00
	00 00		 mov	 eax, DWORD PTR ?stdfiles@?8??atl_init@@9@9[eax*8+4]
  00585	99		 cdq
  00586	8b 4d c8	 mov	 ecx, DWORD PTR _si$85082[ebp]
  00589	89 01		 mov	 DWORD PTR [ecx], eax
  0058b	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN1@atl_init:

; 3311 : 		}
; 3312 : 	    }

  0058e	eb 96		 jmp	 SHORT $LN3@atl_init
$LN2@atl_init:

; 3313 : 	}
; 3314 : #endif /* FILEIO */
; 3315 : 	dictprot = dict;	      /* Protect all standard words */

  00590	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  00595	a3 00 00 00 00	 mov	 DWORD PTR _dictprot, eax
$LN25@atl_init:

; 3316 :     }
; 3317 : }

  0059a	5f		 pop	 edi
  0059b	5e		 pop	 esi
  0059c	5b		 pop	 ebx
  0059d	81 c4 04 01 00
	00		 add	 esp, 260		; 00000104H
  005a3	3b ec		 cmp	 ebp, esp
  005a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  005aa	8b e5		 mov	 esp, ebp
  005ac	5d		 pop	 ebp
  005ad	c3		 ret	 0
_atl_init ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _atl_primdef
_TEXT	SEGMENT
_n$ = -44						; size = 4
_i$ = -32						; size = 4
_nw$ = -20						; size = 4
_pf$ = -8						; size = 4
_pt$ = 8						; size = 4
_atl_primdef PROC					; COMDAT

; 2964 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2965 :     struct primfcn *pf = pt;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _pt$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR _pf$[ebp], eax

; 2966 :     dictword *nw;
; 2967 :     int i, n = 0;

  00024	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
$LN6@atl_primde:

; 2968 : #ifdef WORDSUSED
; 2969 : #ifdef READONLYSTRINGS
; 2970 :     unsigned int nltotal;
; 2971 :     char *dynames, *cp;
; 2972 : #endif /* READONLYSTRINGS */
; 2973 : #endif /* WORDSUSED */
; 2974 : 
; 2975 :     /* Count the number of definitions in the table. */
; 2976 : 
; 2977 :     while (pf->pname != NULL) {

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _pf$[ebp]
  0002e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00031	74 14		 je	 SHORT $LN5@atl_primde

; 2978 : 	n++;

  00033	8b 45 d4	 mov	 eax, DWORD PTR _n$[ebp]
  00036	83 c0 01	 add	 eax, 1
  00039	89 45 d4	 mov	 DWORD PTR _n$[ebp], eax

; 2979 : 	pf++;

  0003c	8b 45 f8	 mov	 eax, DWORD PTR _pf$[ebp]
  0003f	83 c0 08	 add	 eax, 8
  00042	89 45 f8	 mov	 DWORD PTR _pf$[ebp], eax

; 2980 :     }

  00045	eb e4		 jmp	 SHORT $LN6@atl_primde
$LN5@atl_primde:

; 2981 : 
; 2982 : #ifdef WORDSUSED
; 2983 : #ifdef READONLYSTRINGS
; 2984 :     nltotal = n;
; 2985 :     for (i = 0; i < n; i++) {
; 2986 : 	nltotal += strlen(pt[i].pname);
; 2987 :     }
; 2988 :     cp = dynames = alloc(nltotal);
; 2989 :     for (i = 0; i < n; i++) {
; 2990 : 	strcpy(cp, pt[i].pname);
; 2991 : 	cp += strlen(cp) + 1;
; 2992 :     }
; 2993 :     cp = dynames;
; 2994 : #endif /* READONLYSTRINGS */
; 2995 : #endif /* WORDSUSED */
; 2996 : 
; 2997 :     nw = (dictword *) alloc((unsigned int) (n * sizeof(dictword)));

  00047	8b 45 d4	 mov	 eax, DWORD PTR _n$[ebp]
  0004a	6b c0 0c	 imul	 eax, 12			; 0000000cH
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 _alloc
  00053	83 c4 04	 add	 esp, 4
  00056	89 45 ec	 mov	 DWORD PTR _nw$[ebp], eax

; 2998 : 
; 2999 :     nw[n - 1].wnext = dict;

  00059	8b 45 d4	 mov	 eax, DWORD PTR _n$[ebp]
  0005c	83 e8 01	 sub	 eax, 1
  0005f	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00062	8b 4d ec	 mov	 ecx, DWORD PTR _nw$[ebp]
  00065	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dict
  0006b	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 3000 :     dict = nw;

  0006e	8b 45 ec	 mov	 eax, DWORD PTR _nw$[ebp]
  00071	a3 00 00 00 00	 mov	 DWORD PTR _dict, eax

; 3001 :     for (i = 0; i < n; i++) {

  00076	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0007d	eb 09		 jmp	 SHORT $LN4@atl_primde
$LN3@atl_primde:
  0007f	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  00082	83 c0 01	 add	 eax, 1
  00085	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax
$LN4@atl_primde:
  00088	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  0008b	3b 45 d4	 cmp	 eax, DWORD PTR _n$[ebp]
  0008e	7d 41		 jge	 SHORT $LN7@atl_primde

; 3002 : 	nw->wname = pt->pname;

  00090	8b 45 ec	 mov	 eax, DWORD PTR _nw$[ebp]
  00093	8b 4d 08	 mov	 ecx, DWORD PTR _pt$[ebp]
  00096	8b 11		 mov	 edx, DWORD PTR [ecx]
  00098	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 3003 : #ifdef WORDSUSED
; 3004 : #ifdef READONLYSTRINGS
; 3005 :     	nw->wname = cp;
; 3006 : 	cp += strlen(cp) + 1;
; 3007 : #endif /* READONLYSTRINGS */
; 3008 : #endif /* WORDSUSED */
; 3009 : 	nw->wcode = pt->pcode;

  0009b	8b 45 ec	 mov	 eax, DWORD PTR _nw$[ebp]
  0009e	8b 4d 08	 mov	 ecx, DWORD PTR _pt$[ebp]
  000a1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a4	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 3010 : 	if (i != (n - 1)) {

  000a7	8b 45 d4	 mov	 eax, DWORD PTR _n$[ebp]
  000aa	83 e8 01	 sub	 eax, 1
  000ad	39 45 e0	 cmp	 DWORD PTR _i$[ebp], eax
  000b0	74 0b		 je	 SHORT $LN1@atl_primde

; 3011 : 	    nw->wnext = nw + 1;

  000b2	8b 45 ec	 mov	 eax, DWORD PTR _nw$[ebp]
  000b5	83 c0 0c	 add	 eax, 12			; 0000000cH
  000b8	8b 4d ec	 mov	 ecx, DWORD PTR _nw$[ebp]
  000bb	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@atl_primde:

; 3012 : 	}
; 3013 : 	nw++;

  000bd	8b 45 ec	 mov	 eax, DWORD PTR _nw$[ebp]
  000c0	83 c0 0c	 add	 eax, 12			; 0000000cH
  000c3	89 45 ec	 mov	 DWORD PTR _nw$[ebp], eax

; 3014 : 	pt++;

  000c6	8b 45 08	 mov	 eax, DWORD PTR _pt$[ebp]
  000c9	83 c0 08	 add	 eax, 8
  000cc	89 45 08	 mov	 DWORD PTR _pt$[ebp], eax

; 3015 :     }

  000cf	eb ae		 jmp	 SHORT $LN3@atl_primde
$LN7@atl_primde:

; 3016 : }

  000d1	5f		 pop	 edi
  000d2	5e		 pop	 esi
  000d3	5b		 pop	 ebx
  000d4	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000da	3b ec		 cmp	 ebp, esp
  000dc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
_atl_primdef ENDP
_TEXT	ENDS
PUBLIC	_atl_lookup
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _atl_lookup
_TEXT	SEGMENT
_name$ = 8						; size = 4
_atl_lookup PROC					; COMDAT

; 3325 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3326 :     V strcpy(tokbuf, name);	      /* Use built-in token buffer... */

  0001e	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  00021	50		 push	 eax
  00022	68 00 00 00 00	 push	 OFFSET _tokbuf
  00027	e8 00 00 00 00	 call	 _strcpy
  0002c	83 c4 08	 add	 esp, 8

; 3327 :     ucase(tokbuf);                    /* so ucase() doesn't wreck arg string */

  0002f	68 00 00 00 00	 push	 OFFSET _tokbuf
  00034	e8 00 00 00 00	 call	 _ucase
  00039	83 c4 04	 add	 esp, 4

; 3328 :     return lookup(tokbuf);	      /* Now use normal lookup() on it */

  0003c	68 00 00 00 00	 push	 OFFSET _tokbuf
  00041	e8 00 00 00 00	 call	 _lookup
  00046	83 c4 04	 add	 esp, 4

; 3329 : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_atl_lookup ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _atl_body
_TEXT	SEGMENT
_dw$ = 8						; size = 4
_atl_body PROC						; COMDAT

; 3336 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3337 :     return ((stackitem *) dw) + Dictwordl;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _dw$[ebp]
  00021	83 c0 10	 add	 eax, 16			; 00000010H

; 3338 : }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_atl_body ENDP
_TEXT	ENDS
PUBLIC	_atl_exec
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _atl_exec
_TEXT	SEGMENT
_restat$ = -20						; size = 4
_sestat$ = -8						; size = 4
_dw$ = 8						; size = 4
_atl_exec PROC						; COMDAT

; 3347 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3348 :     int sestat = evalstat, restat;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  00023	89 45 f8	 mov	 DWORD PTR _sestat$[ebp], eax

; 3349 : 
; 3350 :     evalstat = ATL_SNORM;

  00026	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _evalstat, 0

; 3351 : #ifdef BREAK
; 3352 :     broken = False;		      /* Reset break received */

  00030	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _broken, 0

; 3353 : #endif
; 3354 : #undef Memerrs
; 3355 : #define Memerrs evalstat
; 3356 :     Rso(1);

  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  0003f	83 c0 04	 add	 eax, 4
  00042	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _rstacktop
  00048	76 0f		 jbe	 SHORT $LN3@atl_exec
  0004a	e8 00 00 00 00	 call	 _rstakover
  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  00054	e9 88 00 00 00	 jmp	 $LN4@atl_exec
$LN3@atl_exec:

; 3357 :     Rpush = ip; 		      /* Push instruction pointer */

  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ip
  00064	89 08		 mov	 DWORD PTR [eax], ecx
  00066	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  0006c	83 c2 04	 add	 edx, 4
  0006f	89 15 00 00 00
	00		 mov	 DWORD PTR _rstk, edx

; 3358 :     ip = NULL;			      /* Keep exword from running away */

  00075	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ip, 0

; 3359 :     exword(dw);

  0007f	8b 45 08	 mov	 eax, DWORD PTR _dw$[ebp]
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 _exword
  00088	83 c4 04	 add	 esp, 4

; 3360 :     if (evalstat == ATL_SNORM) {      /* If word ran to completion */

  0008b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _evalstat, 0
  00092	75 3a		 jne	 SHORT $LN2@atl_exec

; 3361 : 	Rsl(1);

  00094	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  00099	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _rstack
  0009f	c1 f8 02	 sar	 eax, 2
  000a2	83 f8 01	 cmp	 eax, 1
  000a5	7d 0c		 jge	 SHORT $LN1@atl_exec
  000a7	e8 00 00 00 00	 call	 _rstakunder
  000ac	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  000b1	eb 2e		 jmp	 SHORT $LN4@atl_exec
$LN1@atl_exec:

; 3362 : 	ip = R0;		      /* Pop the return stack */

  000b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  000b8	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  000bb	89 0d 00 00 00
	00		 mov	 DWORD PTR _ip, ecx

; 3363 : 	Rpop;

  000c1	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  000c6	83 e8 04	 sub	 eax, 4
  000c9	a3 00 00 00 00	 mov	 DWORD PTR _rstk, eax
$LN2@atl_exec:

; 3364 :     }
; 3365 : #undef Memerrs
; 3366 : #define Memerrs
; 3367 :     restat = evalstat;

  000ce	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  000d3	89 45 ec	 mov	 DWORD PTR _restat$[ebp], eax

; 3368 :     evalstat = sestat;

  000d6	8b 45 f8	 mov	 eax, DWORD PTR _sestat$[ebp]
  000d9	a3 00 00 00 00	 mov	 DWORD PTR _evalstat, eax

; 3369 :     return restat;

  000de	8b 45 ec	 mov	 eax, DWORD PTR _restat$[ebp]
$LN4@atl_exec:

; 3370 : }

  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx
  000e4	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000ea	3b ec		 cmp	 ebp, esp
  000ec	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
_atl_exec ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _atl_vardef
_TEXT	SEGMENT
_isize$ = -20						; size = 4
_di$ = -8						; size = 4
_name$ = 8						; size = 4
_size$ = 12						; size = 4
_atl_vardef PROC					; COMDAT

; 3383 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3384 :     dictword *di;
; 3385 :     int isize = (size + (sizeof(stackitem) - 1)) / sizeof(stackitem);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00021	83 c0 07	 add	 eax, 7
  00024	c1 e8 03	 shr	 eax, 3
  00027	89 45 ec	 mov	 DWORD PTR _isize$[ebp], eax

; 3386 : 
; 3387 : #undef Memerrs
; 3388 : #define Memerrs NULL
; 3389 :     evalstat = ATL_SNORM;

  0002a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _evalstat, 0

; 3390 :     Ho(Dictwordl + isize);

  00034	8b 45 ec	 mov	 eax, DWORD PTR _isize$[ebp]
  00037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  0003d	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  00041	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  00047	76 0c		 jbe	 SHORT $LN4@atl_vardef
  00049	e8 00 00 00 00	 call	 _heapover
  0004e	33 c0		 xor	 eax, eax
  00050	e9 a5 00 00 00	 jmp	 $LN5@atl_vardef
$LN4@atl_vardef:

; 3391 : #undef Memerrs
; 3392 : #define Memerrs
; 3393 :     if (evalstat != ATL_SNORM)	      /* Did the heap overflow */

  00055	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _evalstat, 0
  0005c	74 07		 je	 SHORT $LN3@atl_vardef

; 3394 : 	return NULL;		      /* Yes.  Return NULL */

  0005e	33 c0		 xor	 eax, eax
  00060	e9 95 00 00 00	 jmp	 $LN5@atl_vardef
$LN3@atl_vardef:

; 3395 :     createword = (dictword *) hptr;   /* Develop address of word */

  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0006a	a3 00 00 00 00	 mov	 DWORD PTR _createword, eax

; 3396 :     createword->wcode = P_var;	      /* Store default code */

  0006f	a1 00 00 00 00	 mov	 eax, DWORD PTR _createword
  00074	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _P_var

; 3397 :     hptr += Dictwordl;		      /* Allocate heap space for word */

  0007b	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00080	83 c0 10	 add	 eax, 16			; 00000010H
  00083	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax
$LN2@atl_vardef:

; 3398 :     while (isize > 0) {

  00088	83 7d ec 00	 cmp	 DWORD PTR _isize$[ebp], 0
  0008c	7e 2c		 jle	 SHORT $LN1@atl_vardef

; 3399 : 	Hstore = 0;		      /* Allocate heap area and clear it */

  0008e	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00093	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00099	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  000a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  000a6	83 c1 08	 add	 ecx, 8
  000a9	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx

; 3400 : 	isize--;

  000af	8b 45 ec	 mov	 eax, DWORD PTR _isize$[ebp]
  000b2	83 e8 01	 sub	 eax, 1
  000b5	89 45 ec	 mov	 DWORD PTR _isize$[ebp], eax

; 3401 :     }

  000b8	eb ce		 jmp	 SHORT $LN2@atl_vardef
$LN1@atl_vardef:

; 3402 :     V strcpy(tokbuf, name);	      /* Use built-in token buffer... */

  000ba	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  000bd	50		 push	 eax
  000be	68 00 00 00 00	 push	 OFFSET _tokbuf
  000c3	e8 00 00 00 00	 call	 _strcpy
  000c8	83 c4 08	 add	 esp, 8

; 3403 :     ucase(tokbuf);                    /* so ucase() doesn't wreck arg string */

  000cb	68 00 00 00 00	 push	 OFFSET _tokbuf
  000d0	e8 00 00 00 00	 call	 _ucase
  000d5	83 c4 04	 add	 esp, 4

; 3404 :     enter(tokbuf);		      /* Make dictionary entry for it */

  000d8	68 00 00 00 00	 push	 OFFSET _tokbuf
  000dd	e8 00 00 00 00	 call	 _enter
  000e2	83 c4 04	 add	 esp, 4

; 3405 :     di = createword;		      /* Save word address */

  000e5	a1 00 00 00 00	 mov	 eax, DWORD PTR _createword
  000ea	89 45 f8	 mov	 DWORD PTR _di$[ebp], eax

; 3406 :     createword = NULL;		      /* Mark no word underway */

  000ed	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _createword, 0

; 3407 :     return di;			      /* Return new word */

  000f7	8b 45 f8	 mov	 eax, DWORD PTR _di$[ebp]
$LN5@atl_vardef:

; 3408 : }

  000fa	5f		 pop	 edi
  000fb	5e		 pop	 esi
  000fc	5b		 pop	 ebx
  000fd	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00103	3b ec		 cmp	 ebp, esp
  00105	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
_atl_vardef ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _enter
_TEXT	SEGMENT
_tkname$ = 8						; size = 4
_enter	PROC						; COMDAT

; 547  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 548  :     /* Allocate name buffer */
; 549  :     createword->wname = alloc(((unsigned int) strlen(tkname) + 2));

  0001e	8b 45 08	 mov	 eax, DWORD PTR _tkname$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _strlen
  00027	83 c4 04	 add	 esp, 4
  0002a	83 c0 02	 add	 eax, 2
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _alloc
  00033	83 c4 04	 add	 esp, 4
  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _createword
  0003c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 550  :     createword->wname[0] = 0;	      /* Clear flags */

  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR _createword
  00044	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00047	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 551  :     V strcpy(createword->wname + 1, tkname); /* Copy token to name buffer */

  0004a	8b 45 08	 mov	 eax, DWORD PTR _tkname$[ebp]
  0004d	50		 push	 eax
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _createword
  00054	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00057	83 c2 01	 add	 edx, 1
  0005a	52		 push	 edx
  0005b	e8 00 00 00 00	 call	 _strcpy
  00060	83 c4 08	 add	 esp, 8

; 552  :     createword->wnext = dict;	      /* Chain rest of dictionary to word */

  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR _createword
  00068	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dict
  0006e	89 08		 mov	 DWORD PTR [eax], ecx

; 553  :     dict = createword;		      /* Put word at head of dictionary */

  00070	a1 00 00 00 00	 mov	 eax, DWORD PTR _createword
  00075	a3 00 00 00 00	 mov	 DWORD PTR _dict, eax

; 554  : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
_enter	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _atl_mark
_TEXT	SEGMENT
_mp$ = 8						; size = 4
_atl_mark PROC						; COMDAT

; 3414 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3415 :     mp->mstack = stk;		      /* Save stack position */

  0001e	8b 45 08	 mov	 eax, DWORD PTR _mp$[ebp]
  00021	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00027	89 08		 mov	 DWORD PTR [eax], ecx

; 3416 :     mp->mheap = hptr;		      /* Save heap allocation marker */

  00029	8b 45 08	 mov	 eax, DWORD PTR _mp$[ebp]
  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  00032	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 3417 :     mp->mrstack = rstk; 	      /* Set return stack pointer */

  00035	8b 45 08	 mov	 eax, DWORD PTR _mp$[ebp]
  00038	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  0003e	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 3418 :     mp->mdict = dict;		      /* Save last item in dictionary */

  00041	8b 45 08	 mov	 eax, DWORD PTR _mp$[ebp]
  00044	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dict
  0004a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 3419 : }

  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
_atl_mark ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _atl_unwind
_TEXT	SEGMENT
_mp$ = 8						; size = 4
_atl_unwind PROC					; COMDAT

; 3425 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3426 : 
; 3427 :     /* If atl_mark() was called before the system was initialised, and
; 3428 :        we've initialised since, we cannot unwind.  Just ignore the
; 3429 :        unwind request.	The user must manually atl_init before an
; 3430 :        atl_mark() request is made. */
; 3431 : 
; 3432 :     if (mp->mdict == NULL)	      /* Was mark made before atl_init ? */

  0001e	8b 45 08	 mov	 eax, DWORD PTR _mp$[ebp]
  00021	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00025	75 02		 jne	 SHORT $LN3@atl_unwind

; 3433 : 	return; 		      /* Yes.  Cannot unwind past init */

  00027	eb 71		 jmp	 SHORT $LN4@atl_unwind
$LN3@atl_unwind:

; 3434 : 
; 3435 :     stk = mp->mstack;		      /* Roll back stack allocation */

  00029	8b 45 08	 mov	 eax, DWORD PTR _mp$[ebp]
  0002c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002e	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx

; 3436 :     hptr = mp->mheap;		      /* Reset heap state */

  00034	8b 45 08	 mov	 eax, DWORD PTR _mp$[ebp]
  00037	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003a	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx

; 3437 :     rstk = mp->mrstack; 	      /* Reset the return stack */

  00040	8b 45 08	 mov	 eax, DWORD PTR _mp$[ebp]
  00043	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00046	89 0d 00 00 00
	00		 mov	 DWORD PTR _rstk, ecx
$LN2@atl_unwind:

; 3438 : 
; 3439 :     /* To unwind the dictionary, we can't just reset the pointer,
; 3440 :        we must walk back through the chain and release all the name
; 3441 :        buffers attached to the items allocated after the mark was
; 3442 :        made. */
; 3443 : 
; 3444 :     while (dict != NULL && dict != dictprot && dict != mp->mdict) {

  0004c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dict, 0
  00053	74 45		 je	 SHORT $LN4@atl_unwind
  00055	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  0005a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _dictprot
  00060	74 38		 je	 SHORT $LN4@atl_unwind
  00062	8b 45 08	 mov	 eax, DWORD PTR _mp$[ebp]
  00065	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dict
  0006b	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  0006e	74 2a		 je	 SHORT $LN4@atl_unwind

; 3445 : 	free(dict->wname);	      /* Release name string for item */

  00070	8b f4		 mov	 esi, esp
  00072	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  00077	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007a	51		 push	 ecx
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00081	83 c4 04	 add	 esp, 4
  00084	3b f4		 cmp	 esi, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3446 : 	dict = dict->wnext;	      /* Link to previous item */

  0008b	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  00090	8b 08		 mov	 ecx, DWORD PTR [eax]
  00092	89 0d 00 00 00
	00		 mov	 DWORD PTR _dict, ecx

; 3447 :     }

  00098	eb b2		 jmp	 SHORT $LN2@atl_unwind
$LN4@atl_unwind:

; 3448 : }

  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
  0009d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000a3	3b ec		 cmp	 ebp, esp
  000a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
_atl_unwind ENDP
_TEXT	ENDS
PUBLIC	_atl_break
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _atl_break
_TEXT	SEGMENT
_atl_break PROC						; COMDAT

; 3460 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3461 :     broken = True;		      /* Set break request */

  0001e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _broken, 1

; 3462 : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
_atl_break ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@JBHCBGIC@?6Runaway?5?$GA?$CI?8?5comment?4?6?$AA@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0BH@JBHCBGIC@?6Runaway?5?$GA?$CI?8?5comment?4?6?$AA@
CONST	SEGMENT
??_C@_0BH@JBHCBGIC@?6Runaway?5?$GA?$CI?8?5comment?4?6?$AA@ DB 0aH, 'Runaw'
	DB	'ay `('' comment.', 0aH, 00H			; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _atl_load
_TEXT	SEGMENT
_lineno$ = -232						; size = 4
_sinstr$ = -220						; size = 4
_sip$ = -208						; size = 4
_scomm$ = -196						; size = 8
_mk$ = -180						; size = 16
_s$ = -156						; size = 134
_es$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_fp$ = 8						; size = 4
_atl_load PROC						; COMDAT

; 3469 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 01 00
	00		 sub	 esp, 428		; 000001acH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 54 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-428]
  00012	b9 6b 00 00 00	 mov	 ecx, 107		; 0000006bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3470 :     int es = ATL_SNORM;

  00028	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _es$[ebp], 0

; 3471 :     char s[134];
; 3472 :     atl_statemark mk;
; 3473 :     atl_int scomm = atl_comment;      /* Stack comment pending state */

  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_comment
  00034	89 85 3c ff ff
	ff		 mov	 DWORD PTR _scomm$[ebp], eax
  0003a	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _atl_comment+4
  00040	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _scomm$[ebp+4], ecx

; 3474 :     dictword **sip = ip;	      /* Stack instruction pointer */

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  0004b	89 85 30 ff ff
	ff		 mov	 DWORD PTR _sip$[ebp], eax

; 3475 :     char *sinstr = instream;	      /* Stack input stream */

  00051	a1 00 00 00 00	 mov	 eax, DWORD PTR _instream
  00056	89 85 24 ff ff
	ff		 mov	 DWORD PTR _sinstr$[ebp], eax

; 3476 :     int lineno = 0;		      /* Current line number */

  0005c	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _lineno$[ebp], 0

; 3477 : 
; 3478 :     atl_errline = 0;		      /* Reset line number of error */

  00066	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl_errline, 0
  00070	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl_errline+4, 0

; 3479 :     atl_mark(&mk);

  0007a	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _mk$[ebp]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 _atl_mark
  00086	83 c4 04	 add	 esp, 4

; 3480 :     ip = NULL;			      /* Fool atl_eval into interp state */

  00089	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ip, 0
$LN4@atl_load:

; 3481 :     while (atl_fgetsp(s, 132, fp) != NULL) {

  00093	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  00096	50		 push	 eax
  00097	68 84 00 00 00	 push	 132			; 00000084H
  0009c	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 _atl_fgetsp
  000a8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ab	85 c0		 test	 eax, eax
  000ad	74 4c		 je	 SHORT $LN3@atl_load

; 3482 : 	lineno++;

  000af	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _lineno$[ebp]
  000b5	83 c0 01	 add	 eax, 1
  000b8	89 85 18 ff ff
	ff		 mov	 DWORD PTR _lineno$[ebp], eax

; 3483 : 	if ((es = atl_eval(s)) != ATL_SNORM) {

  000be	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 _atl_eval
  000ca	83 c4 04	 add	 esp, 4
  000cd	89 45 f4	 mov	 DWORD PTR _es$[ebp], eax
  000d0	83 7d f4 00	 cmp	 DWORD PTR _es$[ebp], 0
  000d4	74 23		 je	 SHORT $LN2@atl_load

; 3484 : 	    atl_errline = lineno;     /* Save line number of error */

  000d6	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _lineno$[ebp]
  000dc	99		 cdq
  000dd	a3 00 00 00 00	 mov	 DWORD PTR _atl_errline, eax
  000e2	89 15 04 00 00
	00		 mov	 DWORD PTR _atl_errline+4, edx

; 3485 : 	    atl_unwind(&mk);

  000e8	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _mk$[ebp]
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 _atl_unwind
  000f4	83 c4 04	 add	 esp, 4

; 3486 : 	    break;

  000f7	eb 02		 jmp	 SHORT $LN3@atl_load
$LN2@atl_load:

; 3487 : 	}
; 3488 :     }

  000f9	eb 98		 jmp	 SHORT $LN4@atl_load
$LN3@atl_load:

; 3489 :     /* If there were no other errors, check for a runaway comment.  If
; 3490 :        we ended the file in comment-ignore mode, set the runaway comment
; 3491 :        error status and unwind the file.  */
; 3492 :     if ((es == ATL_SNORM) && (atl_comment == Truth)) {

  000fb	83 7d f4 00	 cmp	 DWORD PTR _es$[ebp], 0
  000ff	75 3d		 jne	 SHORT $LN1@atl_load
  00101	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_comment
  00106	23 05 04 00 00
	00		 and	 eax, DWORD PTR _atl_comment+4
  0010c	83 f8 ff	 cmp	 eax, -1
  0010f	75 2d		 jne	 SHORT $LN1@atl_load

; 3493 : #ifdef MEMMESSAGE
; 3494 :         V printf("\nRunaway `(' comment.\n");

  00111	8b f4		 mov	 esi, esp
  00113	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@JBHCBGIC@?6Runaway?5?$GA?$CI?8?5comment?4?6?$AA@
  00118	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0011e	83 c4 04	 add	 esp, 4
  00121	3b f4		 cmp	 esi, esp
  00123	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3495 : #endif
; 3496 : 	es = ATL_RUNCOMM;

  00128	c7 45 f4 f5 ff
	ff ff		 mov	 DWORD PTR _es$[ebp], -11 ; fffffff5H

; 3497 : 	atl_unwind(&mk);

  0012f	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _mk$[ebp]
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 _atl_unwind
  0013b	83 c4 04	 add	 esp, 4
$LN1@atl_load:

; 3498 :     }
; 3499 :     atl_comment = scomm;	      /* Unstack comment pending status */

  0013e	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _scomm$[ebp]
  00144	a3 00 00 00 00	 mov	 DWORD PTR _atl_comment, eax
  00149	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _scomm$[ebp+4]
  0014f	89 0d 04 00 00
	00		 mov	 DWORD PTR _atl_comment+4, ecx

; 3500 :     ip = sip;			      /* Unstack instruction pointer */

  00155	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _sip$[ebp]
  0015b	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax

; 3501 :     instream = sinstr;		      /* Unstack input stream */

  00160	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _sinstr$[ebp]
  00166	a3 00 00 00 00	 mov	 DWORD PTR _instream, eax

; 3502 :     return es;

  0016b	8b 45 f4	 mov	 eax, DWORD PTR _es$[ebp]

; 3503 : }

  0016e	52		 push	 edx
  0016f	8b cd		 mov	 ecx, ebp
  00171	50		 push	 eax
  00172	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@atl_load
  00178	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0017d	58		 pop	 eax
  0017e	5a		 pop	 edx
  0017f	5f		 pop	 edi
  00180	5e		 pop	 esi
  00181	5b		 pop	 ebx
  00182	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00185	33 cd		 xor	 ecx, ebp
  00187	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018c	81 c4 ac 01 00
	00		 add	 esp, 428		; 000001acH
  00192	3b ec		 cmp	 ebp, esp
  00194	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00199	8b e5		 mov	 esp, ebp
  0019b	5d		 pop	 ebp
  0019c	c3		 ret	 0
  0019d	8d 49 00	 npad	 3
$LN10@atl_load:
  001a0	02 00 00 00	 DD	 2
  001a4	00 00 00 00	 DD	 $LN9@atl_load
$LN9@atl_load:
  001a8	64 ff ff ff	 DD	 -156			; ffffff64H
  001ac	86 00 00 00	 DD	 134			; 00000086H
  001b0	00 00 00 00	 DD	 $LN7@atl_load
  001b4	4c ff ff ff	 DD	 -180			; ffffff4cH
  001b8	10 00 00 00	 DD	 16			; 00000010H
  001bc	00 00 00 00	 DD	 $LN8@atl_load
$LN8@atl_load:
  001c0	6d		 DB	 109			; 0000006dH
  001c1	6b		 DB	 107			; 0000006bH
  001c2	00		 DB	 0
$LN7@atl_load:
  001c3	73		 DB	 115			; 00000073H
  001c4	00		 DB	 0
_atl_load ENDP
_TEXT	ENDS
PUBLIC	??_C@_03LMKFJNEF@?$CFli?$AA@			; `string'
PUBLIC	??_C@_03IEGBKDB@?2?5?$CK?$AA@			; `string'
PUBLIC	_atl_prologue
;	COMDAT ??_C@_03LMKFJNEF@?$CFli?$AA@
CONST	SEGMENT
??_C@_03LMKFJNEF@?$CFli?$AA@ DB '%li', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IEGBKDB@?2?5?$CK?$AA@
CONST	SEGMENT
??_C@_03IEGBKDB@?2?5?$CK?$AA@ DB '\ *', 00H		; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _atl_prologue
_TEXT	SEGMENT
_ap$85178 = -32						; size = 4
_vp$85177 = -20						; size = 4
_i$85176 = -8						; size = 4
_sp$ = 8						; size = 4
_atl_prologue PROC					; COMDAT

; 3511 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3512 :     static struct {
; 3513 : 	char *pname;
; 3514 : 	atl_int *pparam;
; 3515 :     } proname[] = {
; 3516 :         {"STACK ", &atl_stklen},
; 3517 :         {"RSTACK ", &atl_rstklen},
; 3518 :         {"HEAP ", &atl_heaplen},
; 3519 :         {"TEMPSTRL ", &atl_ltempstr},
; 3520 :         {"TEMPSTRN ", &atl_ntempstr}
; 3521 :     };
; 3522 : 
; 3523 :     if (strncmp(sp, "\\ *", 3) == 0) {

  0001e	8b f4		 mov	 esi, esp
  00020	6a 03		 push	 3
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_03IEGBKDB@?2?5?$CK?$AA@
  00027	8b 45 08	 mov	 eax, DWORD PTR _sp$[ebp]
  0002a	50		 push	 eax
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncmp
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	3b f4		 cmp	 esi, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	85 c0		 test	 eax, eax
  0003d	0f 85 c6 00 00
	00		 jne	 $LN6@atl_prolog

; 3524 : 	int i;
; 3525 : 	char *vp = sp + 3, *ap;

  00043	8b 45 08	 mov	 eax, DWORD PTR _sp$[ebp]
  00046	83 c0 03	 add	 eax, 3
  00049	89 45 ec	 mov	 DWORD PTR _vp$85177[ebp], eax

; 3526 : 
; 3527 : 	ucase(vp);

  0004c	8b 45 ec	 mov	 eax, DWORD PTR _vp$85177[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _ucase
  00055	83 c4 04	 add	 esp, 4

; 3528 : 	for (i = 0; i < ELEMENTS(proname); i++) {

  00058	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$85176[ebp], 0
  0005f	eb 09		 jmp	 SHORT $LN5@atl_prolog
$LN4@atl_prolog:
  00061	8b 45 f8	 mov	 eax, DWORD PTR _i$85176[ebp]
  00064	83 c0 01	 add	 eax, 1
  00067	89 45 f8	 mov	 DWORD PTR _i$85176[ebp], eax
$LN5@atl_prolog:
  0006a	83 7d f8 05	 cmp	 DWORD PTR _i$85176[ebp], 5
  0006e	0f 83 95 00 00
	00		 jae	 $LN6@atl_prolog

; 3529 : 	    if (strncmp(sp + 3, proname[i].pname,
; 3530 : 		    strlen(proname[i].pname)) == 0) {

  00074	8b 45 f8	 mov	 eax, DWORD PTR _i$85176[ebp]
  00077	8b 0c c5 00 00
	00 00		 mov	 ecx, DWORD PTR ?proname@?1??atl_prologue@@9@9[eax*8]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 _strlen
  00084	83 c4 04	 add	 esp, 4
  00087	8b f4		 mov	 esi, esp
  00089	50		 push	 eax
  0008a	8b 55 f8	 mov	 edx, DWORD PTR _i$85176[ebp]
  0008d	8b 04 d5 00 00
	00 00		 mov	 eax, DWORD PTR ?proname@?1??atl_prologue@@9@9[edx*8]
  00094	50		 push	 eax
  00095	8b 4d 08	 mov	 ecx, DWORD PTR _sp$[ebp]
  00098	83 c1 03	 add	 ecx, 3
  0009b	51		 push	 ecx
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncmp
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a5	3b f4		 cmp	 esi, esp
  000a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ac	85 c0		 test	 eax, eax
  000ae	75 54		 jne	 SHORT $LN2@atl_prolog

; 3531 :                 if ((ap = strchr(sp + 3, ' ')) != NULL) {

  000b0	8b f4		 mov	 esi, esp
  000b2	6a 20		 push	 32			; 00000020H
  000b4	8b 45 08	 mov	 eax, DWORD PTR _sp$[ebp]
  000b7	83 c0 03	 add	 eax, 3
  000ba	50		 push	 eax
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strchr
  000c1	83 c4 08	 add	 esp, 8
  000c4	3b f4		 cmp	 esi, esp
  000c6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cb	89 45 e0	 mov	 DWORD PTR _ap$85178[ebp], eax
  000ce	83 7d e0 00	 cmp	 DWORD PTR _ap$85178[ebp], 0
  000d2	74 30		 je	 SHORT $LN2@atl_prolog

; 3532 :                     V sscanf(ap + 1, "%li", proname[i].pparam);

  000d4	8b f4		 mov	 esi, esp
  000d6	8b 45 f8	 mov	 eax, DWORD PTR _i$85176[ebp]
  000d9	8b 0c c5 04 00
	00 00		 mov	 ecx, DWORD PTR ?proname@?1??atl_prologue@@9@9[eax*8+4]
  000e0	51		 push	 ecx
  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_03LMKFJNEF@?$CFli?$AA@
  000e6	8b 55 e0	 mov	 edx, DWORD PTR _ap$85178[ebp]
  000e9	83 c2 01	 add	 edx, 1
  000ec	52		 push	 edx
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sscanf
  000f3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f6	3b f4		 cmp	 esi, esp
  000f8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3533 : #ifdef PROLOGUEDEBUG
; 3534 : V printf("Prologue set %sto %ld\n", proname[i].pname, *proname[i].pparam);
; 3535 : #endif
; 3536 : 		    return 1;

  000fd	b8 01 00 00 00	 mov	 eax, 1
  00102	eb 07		 jmp	 SHORT $LN7@atl_prolog
$LN2@atl_prolog:

; 3537 : 	       }
; 3538 : 	    }
; 3539 : 	}

  00104	e9 58 ff ff ff	 jmp	 $LN4@atl_prolog
$LN6@atl_prolog:

; 3540 :     }
; 3541 :     return 0;

  00109	33 c0		 xor	 eax, eax
$LN7@atl_prolog:

; 3542 : }

  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx
  0010e	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00114	3b ec		 cmp	 ebp, esp
  00116	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c3		 ret	 0
_atl_prologue ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@GECOCLOJ@?6Unknown?5token?5type?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@NFKPJPPG@?6?$CFs?5isn?8t?5unique?4?$AA@ ; `string'
PUBLIC	??_C@_0BE@LDIAODFB@?6Forget?5protected?4?6?$AA@	; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0BI@GECOCLOJ@?6Unknown?5token?5type?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BI@GECOCLOJ@?6Unknown?5token?5type?5?$CFd?6?$AA@ DB 0aH, 'Unknown '
	DB	'token type %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NFKPJPPG@?6?$CFs?5isn?8t?5unique?4?$AA@
CONST	SEGMENT
??_C@_0BC@NFKPJPPG@?6?$CFs?5isn?8t?5unique?4?$AA@ DB 0aH, '%s isn''t uniq'
	DB	'ue.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LDIAODFB@?6Forget?5protected?4?6?$AA@
CONST	SEGMENT
??_C@_0BE@LDIAODFB@?6Forget?5protected?4?6?$AA@ DB 0aH, 'Forget protected'
	DB	'.', 0aH, 00H				; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _atl_eval
_TEXT	SEGMENT
tv451 = -316						; size = 4
tv433 = -316						; size = 4
tv399 = -316						; size = 4
tv365 = -316						; size = 4
tv302 = -316						; size = 4
tv72 = -316						; size = 4
_l$85306 = -116						; size = 4
_l$85295 = -104						; size = 4
_tru$85283 = -92					; size = 8
_i$85277 = -76						; size = 4
_tru$85267 = -64					; size = 8
_i$85261 = -48						; size = 4
_dw$85206 = -36						; size = 4
_di$85197 = -24						; size = 4
_i$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_sp$ = 8						; size = 4
_atl_eval PROC						; COMDAT

; 3548 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 3c 01 00
	00		 sub	 esp, 316		; 0000013cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd c4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-316]
  00012	b9 4f 00 00 00	 mov	 ecx, 79			; 0000004fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3549 :     int i;
; 3550 : 
; 3551 : #undef Memerrs
; 3552 : #define Memerrs evalstat
; 3553 :     instream = sp;

  00028	8b 45 08	 mov	 eax, DWORD PTR _sp$[ebp]
  0002b	a3 00 00 00 00	 mov	 DWORD PTR _instream, eax

; 3554 :     evalstat = ATL_SNORM;	      /* Set normal evaluation status */

  00030	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _evalstat, 0

; 3555 : #ifdef BREAK
; 3556 :     broken = False;		      /* Reset asynchronous break */

  0003a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _broken, 0

; 3557 : #endif
; 3558 : 
; 3559 : /* If automatic prologue processing is configured and we haven't yet
; 3560 :    initialised, check if this is a prologue statement.	If so, execute
; 3561 :    it.	Otherwise automatically initialise with the memory specifications
; 3562 :    currently operative. */
; 3563 : 
; 3564 : #ifdef PROLOGUE
; 3565 :     if (dict == NULL) {

  00044	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dict, 0
  0004b	75 1f		 jne	 SHORT $LN64@atl_eval

; 3566 : 	if (atl_prologue(sp))

  0004d	8b 45 08	 mov	 eax, DWORD PTR _sp$[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 _atl_prologue
  00056	83 c4 04	 add	 esp, 4
  00059	85 c0		 test	 eax, eax
  0005b	74 0a		 je	 SHORT $LN63@atl_eval

; 3567 : 	   return evalstat;

  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  00062	e9 e4 07 00 00	 jmp	 $LN65@atl_eval
$LN63@atl_eval:

; 3568 : 	atl_init();

  00067	e8 00 00 00 00	 call	 _atl_init
$LN64@atl_eval:

; 3569 :     }
; 3570 : #endif /* PROLOGUE */
; 3571 : 
; 3572 :     while ((evalstat == ATL_SNORM) && (i = token(&instream)) != TokNull) {

  0006c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _evalstat, 0
  00073	0f 85 cd 07 00
	00		 jne	 $LN61@atl_eval
  00079	68 00 00 00 00	 push	 OFFSET _instream
  0007e	e8 00 00 00 00	 call	 _token
  00083	83 c4 04	 add	 esp, 4
  00086	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
  00089	83 7d f4 00	 cmp	 DWORD PTR _i$[ebp], 0
  0008d	0f 84 b3 07 00
	00		 je	 $LN61@atl_eval

; 3573 : 	dictword *di;
; 3574 : 
; 3575 : 	switch (i) {

  00093	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00096	89 85 c4 fe ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
  0009c	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR tv72[ebp]
  000a2	83 e9 01	 sub	 ecx, 1
  000a5	89 8d c4 fe ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  000ab	83 bd c4 fe ff
	ff 03		 cmp	 DWORD PTR tv72[ebp], 3
  000b2	0f 87 6e 07 00
	00		 ja	 $LN1@atl_eval
  000b8	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR tv72[ebp]
  000be	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN71@atl_eval[edx*4]
$LN58@atl_eval:

; 3576 : 	    case TokWord:
; 3577 : 		if (forgetpend) {

  000c5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _forgetpend, 0
  000cc	0f 84 2a 01 00
	00		 je	 $LN57@atl_eval

; 3578 : 		    forgetpend = False;

  000d2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _forgetpend, 0

; 3579 : 		    ucase(tokbuf);

  000dc	68 00 00 00 00	 push	 OFFSET _tokbuf
  000e1	e8 00 00 00 00	 call	 _ucase
  000e6	83 c4 04	 add	 esp, 4

; 3580 : 		    if ((di = lookup(tokbuf)) != NULL) {

  000e9	68 00 00 00 00	 push	 OFFSET _tokbuf
  000ee	e8 00 00 00 00	 call	 _lookup
  000f3	83 c4 04	 add	 esp, 4
  000f6	89 45 e8	 mov	 DWORD PTR _di$85197[ebp], eax
  000f9	83 7d e8 00	 cmp	 DWORD PTR _di$85197[ebp], 0
  000fd	0f 84 ce 00 00
	00		 je	 $LN56@atl_eval

; 3581 : 			dictword *dw = dict;

  00103	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  00108	89 45 dc	 mov	 DWORD PTR _dw$85206[ebp], eax
$LN55@atl_eval:

; 3582 : 
; 3583 : 			/* Pass 1.  Rip through the dictionary to make sure
; 3584 : 				    this word is not past the marker that
; 3585 : 				    guards against forgetting too much. */
; 3586 : 
; 3587 : 			while (dw != NULL) {

  0010b	83 7d dc 00	 cmp	 DWORD PTR _dw$85206[ebp], 0
  0010f	74 5a		 je	 SHORT $LN54@atl_eval

; 3588 : 			    if (dw == dictprot) {

  00111	8b 45 dc	 mov	 eax, DWORD PTR _dw$85206[ebp]
  00114	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _dictprot
  0011a	75 28		 jne	 SHORT $LN53@atl_eval

; 3589 : #ifdef MEMMESSAGE
; 3590 :                                 V printf("\nForget protected.\n");

  0011c	8b f4		 mov	 esi, esp
  0011e	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@LDIAODFB@?6Forget?5protected?4?6?$AA@
  00123	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00129	83 c4 04	 add	 esp, 4
  0012c	3b f4		 cmp	 esi, esp
  0012e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3591 : #endif
; 3592 : 				evalstat = ATL_FORGETPROT;

  00133	c7 05 00 00 00
	00 f8 ff ff ff	 mov	 DWORD PTR _evalstat, -8	; fffffff8H

; 3593 : 				di = NULL;

  0013d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _di$85197[ebp], 0
$LN53@atl_eval:

; 3594 : 			    }
; 3595 : 			    if (strcmp(dw->wname + 1, tokbuf) == 0)

  00144	68 00 00 00 00	 push	 OFFSET _tokbuf
  00149	8b 45 dc	 mov	 eax, DWORD PTR _dw$85206[ebp]
  0014c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0014f	83 c1 01	 add	 ecx, 1
  00152	51		 push	 ecx
  00153	e8 00 00 00 00	 call	 _strcmp
  00158	83 c4 08	 add	 esp, 8
  0015b	85 c0		 test	 eax, eax
  0015d	75 02		 jne	 SHORT $LN52@atl_eval

; 3596 : 				break;

  0015f	eb 0a		 jmp	 SHORT $LN54@atl_eval
$LN52@atl_eval:

; 3597 : 			    dw = dw->wnext;

  00161	8b 45 dc	 mov	 eax, DWORD PTR _dw$85206[ebp]
  00164	8b 08		 mov	 ecx, DWORD PTR [eax]
  00166	89 4d dc	 mov	 DWORD PTR _dw$85206[ebp], ecx

; 3598 : 			}

  00169	eb a0		 jmp	 SHORT $LN55@atl_eval
$LN54@atl_eval:

; 3599 : 
; 3600 : 			/* Pass 2.  Walk back through the dictionary
; 3601 : 				    items until we encounter the target
; 3602 :                                     of the FORGET.  Release each item's
; 3603 : 				    name buffer and dechain it from the
; 3604 : 				    dictionary list. */
; 3605 : 
; 3606 : 			if (di != NULL) {

  0016b	83 7d e8 00	 cmp	 DWORD PTR _di$85197[ebp], 0
  0016f	74 5e		 je	 SHORT $LN46@atl_eval
$LN50@atl_eval:

; 3607 : 			    do {
; 3608 : 				dw = dict;

  00171	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  00176	89 45 dc	 mov	 DWORD PTR _dw$85206[ebp], eax

; 3609 : 				if (dw->wname != NULL)

  00179	8b 45 dc	 mov	 eax, DWORD PTR _dw$85206[ebp]
  0017c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00180	74 19		 je	 SHORT $LN47@atl_eval

; 3610 : 				    free(dw->wname);

  00182	8b f4		 mov	 esi, esp
  00184	8b 45 dc	 mov	 eax, DWORD PTR _dw$85206[ebp]
  00187	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0018a	51		 push	 ecx
  0018b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00191	83 c4 04	 add	 esp, 4
  00194	3b f4		 cmp	 esi, esp
  00196	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN47@atl_eval:

; 3611 : 				dict = dw->wnext;

  0019b	8b 45 dc	 mov	 eax, DWORD PTR _dw$85206[ebp]
  0019e	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a0	89 0d 00 00 00
	00		 mov	 DWORD PTR _dict, ecx

; 3612 : 			    } while (dw != di);

  001a6	8b 45 dc	 mov	 eax, DWORD PTR _dw$85206[ebp]
  001a9	3b 45 e8	 cmp	 eax, DWORD PTR _di$85197[ebp]
  001ac	75 c3		 jne	 SHORT $LN50@atl_eval

; 3613 : 			    /* Finally, back the heap allocation pointer
; 3614 : 			       up to the start of the last item forgotten. */
; 3615 : 			    hptr = (stackitem *) di;

  001ae	8b 45 e8	 mov	 eax, DWORD PTR _di$85197[ebp]
  001b1	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 3616 : 			    /* Uhhhh, just one more thing.  If this word
; 3617 :                                was defined with DOES>, there's a link to
; 3618 : 			       the method address hidden before its
; 3619 :                                wnext field.  See if it's a DOES> by testing
; 3620 : 			       the wcode field for P_dodoes and, if so,
; 3621 : 			       back up the heap one more item. */
; 3622 : 			    if (di->wcode == (codeptr) P_dodoes) {

  001b6	8b 45 e8	 mov	 eax, DWORD PTR _di$85197[ebp]
  001b9	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_dodoes
  001c0	75 0d		 jne	 SHORT $LN46@atl_eval

; 3623 : #ifdef FORGETDEBUG
; 3624 : V printf(" Forgetting DOES> word. ");
; 3625 : #endif
; 3626 : 				hptr--;

  001c2	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  001c7	83 e8 08	 sub	 eax, 8
  001ca	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax
$LN46@atl_eval:

; 3627 : 			    }
; 3628 : 			}
; 3629 : 		    } else {

  001cf	eb 26		 jmp	 SHORT $LN45@atl_eval
$LN56@atl_eval:

; 3630 : #ifdef MEMMESSAGE
; 3631 :                         V printf(" '%s' undefined ", tokbuf);

  001d1	8b f4		 mov	 esi, esp
  001d3	68 00 00 00 00	 push	 OFFSET _tokbuf
  001d8	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@OHOHCFGF@?5?8?$CFs?8?5undefined?5?$AA@
  001dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  001e3	83 c4 08	 add	 esp, 8
  001e6	3b f4		 cmp	 esi, esp
  001e8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3632 : #endif
; 3633 : 			evalstat = ATL_UNDEFINED;

  001ed	c7 05 00 00 00
	00 f9 ff ff ff	 mov	 DWORD PTR _evalstat, -7	; fffffff9H
$LN45@atl_eval:

; 3634 : 		    }

  001f7	e9 54 02 00 00	 jmp	 $LN28@atl_eval
$LN57@atl_eval:

; 3635 : 		} else if (tickpend) {

  001fc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _tickpend, 0
  00203	0f 84 97 00 00
	00		 je	 $LN43@atl_eval

; 3636 : 		    tickpend = False;

  00209	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _tickpend, 0

; 3637 : 		    ucase(tokbuf);

  00213	68 00 00 00 00	 push	 OFFSET _tokbuf
  00218	e8 00 00 00 00	 call	 _ucase
  0021d	83 c4 04	 add	 esp, 4

; 3638 : 		    if ((di = lookup(tokbuf)) != NULL) {

  00220	68 00 00 00 00	 push	 OFFSET _tokbuf
  00225	e8 00 00 00 00	 call	 _lookup
  0022a	83 c4 04	 add	 esp, 4
  0022d	89 45 e8	 mov	 DWORD PTR _di$85197[ebp], eax
  00230	83 7d e8 00	 cmp	 DWORD PTR _di$85197[ebp], 0
  00234	74 3f		 je	 SHORT $LN42@atl_eval

; 3639 : 			So(1);

  00236	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0023b	83 c0 08	 add	 eax, 8
  0023e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  00244	76 0f		 jbe	 SHORT $LN41@atl_eval
  00246	e8 00 00 00 00	 call	 _stakover
  0024b	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  00250	e9 f6 05 00 00	 jmp	 $LN65@atl_eval
$LN41@atl_eval:

; 3640 : 			Push = (stackitem) di; /* Push word compile address */

  00255	8b 45 e8	 mov	 eax, DWORD PTR _di$85197[ebp]
  00258	99		 cdq
  00259	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0025f	89 01		 mov	 DWORD PTR [ecx], eax
  00261	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00264	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0026a	83 c2 08	 add	 edx, 8
  0026d	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 3641 : 		    } else {

  00273	eb 26		 jmp	 SHORT $LN40@atl_eval
$LN42@atl_eval:

; 3642 : #ifdef MEMMESSAGE
; 3643 :                         V printf(" '%s' undefined ", tokbuf);

  00275	8b f4		 mov	 esi, esp
  00277	68 00 00 00 00	 push	 OFFSET _tokbuf
  0027c	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@OHOHCFGF@?5?8?$CFs?8?5undefined?5?$AA@
  00281	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00287	83 c4 08	 add	 esp, 8
  0028a	3b f4		 cmp	 esi, esp
  0028c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3644 : #endif
; 3645 : 			evalstat = ATL_UNDEFINED;

  00291	c7 05 00 00 00
	00 f9 ff ff ff	 mov	 DWORD PTR _evalstat, -7	; fffffff9H
$LN40@atl_eval:

; 3646 : 		    }

  0029b	e9 b0 01 00 00	 jmp	 $LN28@atl_eval
$LN43@atl_eval:

; 3647 : 		} else if (defpend) {

  002a0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _defpend, 0
  002a7	74 63		 je	 SHORT $LN38@atl_eval

; 3648 : 		    /* If a definition is pending, define the token and
; 3649 : 		       leave the address of the new word item created for
; 3650 : 		       it on the return stack. */
; 3651 : 		    defpend = False;

  002a9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _defpend, 0

; 3652 : 		    ucase(tokbuf);

  002b3	68 00 00 00 00	 push	 OFFSET _tokbuf
  002b8	e8 00 00 00 00	 call	 _ucase
  002bd	83 c4 04	 add	 esp, 4

; 3653 : 		    if (atl_redef && (lookup(tokbuf) != NULL))

  002c0	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_redef
  002c5	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _atl_redef+4
  002cb	74 2d		 je	 SHORT $LN37@atl_eval
  002cd	68 00 00 00 00	 push	 OFFSET _tokbuf
  002d2	e8 00 00 00 00	 call	 _lookup
  002d7	83 c4 04	 add	 esp, 4
  002da	85 c0		 test	 eax, eax
  002dc	74 1c		 je	 SHORT $LN37@atl_eval

; 3654 :                         V printf("\n%s isn't unique.", tokbuf);

  002de	8b f4		 mov	 esi, esp
  002e0	68 00 00 00 00	 push	 OFFSET _tokbuf
  002e5	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@NFKPJPPG@?6?$CFs?5isn?8t?5unique?4?$AA@
  002ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  002f0	83 c4 08	 add	 esp, 8
  002f3	3b f4		 cmp	 esi, esp
  002f5	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN37@atl_eval:

; 3655 : 		    enter(tokbuf);

  002fa	68 00 00 00 00	 push	 OFFSET _tokbuf
  002ff	e8 00 00 00 00	 call	 _enter
  00304	83 c4 04	 add	 esp, 4

; 3656 : 		} else {

  00307	e9 44 01 00 00	 jmp	 $LN28@atl_eval
$LN38@atl_eval:

; 3657 : 		    di = lookup(tokbuf);

  0030c	68 00 00 00 00	 push	 OFFSET _tokbuf
  00311	e8 00 00 00 00	 call	 _lookup
  00316	83 c4 04	 add	 esp, 4
  00319	89 45 e8	 mov	 DWORD PTR _di$85197[ebp], eax

; 3658 : 		    if (di != NULL) {

  0031c	83 7d e8 00	 cmp	 DWORD PTR _di$85197[ebp], 0
  00320	0f 84 f2 00 00
	00		 je	 $LN35@atl_eval

; 3659 :                         /* Test the state.  If we're interpreting, execute
; 3660 :                            the word in all cases.  If we're compiling,
; 3661 : 			   compile the word unless it is a compiler word
; 3662 : 			   flagged for immediate execution by the
; 3663 : 			   presence of a space as the first character of
; 3664 : 			   its name in the dictionary entry. */
; 3665 : 			if (state &&
; 3666 : 			    (cbrackpend || ctickpend ||
; 3667 : 			     !(di->wname[0] & IMMEDIATE))) {

  00326	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  0032b	89 85 c4 fe ff
	ff		 mov	 DWORD PTR tv302[ebp], eax
  00331	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR tv302[ebp]
  00337	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR tv302[ebp]
  0033d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0033f	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  00342	0f 84 c2 00 00
	00		 je	 $LN34@atl_eval
  00348	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cbrackpend, 0
  0034f	75 1b		 jne	 SHORT $LN33@atl_eval
  00351	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ctickpend, 0
  00358	75 12		 jne	 SHORT $LN33@atl_eval
  0035a	8b 45 e8	 mov	 eax, DWORD PTR _di$85197[ebp]
  0035d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00360	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00363	83 e2 01	 and	 edx, 1
  00366	0f 85 9e 00 00
	00		 jne	 $LN34@atl_eval
$LN33@atl_eval:

; 3668 : 			    if (ctickpend) {

  0036c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ctickpend, 0
  00373	74 4c		 je	 SHORT $LN32@atl_eval

; 3669 : 				/* If a compile-time tick preceded this
; 3670 : 				   word, compile a (lit) word to cause its
; 3671 : 				   address to be pushed at execution time. */
; 3672 : 				Ho(1);

  00375	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0037a	83 c0 08	 add	 eax, 8
  0037d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00383	76 0f		 jbe	 SHORT $LN31@atl_eval
  00385	e8 00 00 00 00	 call	 _heapover
  0038a	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  0038f	e9 b7 04 00 00	 jmp	 $LN65@atl_eval
$LN31@atl_eval:

; 3673 : 				Hstore = s_lit;

  00394	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00399	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_lit
  0039f	89 08		 mov	 DWORD PTR [eax], ecx
  003a1	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_lit+4
  003a7	89 50 04	 mov	 DWORD PTR [eax+4], edx
  003aa	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  003af	83 c0 08	 add	 eax, 8
  003b2	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 3674 : 				ctickpend = False;

  003b7	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ctickpend, 0
$LN32@atl_eval:

; 3675 : 			    }
; 3676 : 			    cbrackpend = False;

  003c1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cbrackpend, 0

; 3677 : 			    Ho(1);	  /* Reserve stack space */

  003cb	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  003d0	83 c0 08	 add	 eax, 8
  003d3	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  003d9	76 0f		 jbe	 SHORT $LN30@atl_eval
  003db	e8 00 00 00 00	 call	 _heapover
  003e0	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  003e5	e9 61 04 00 00	 jmp	 $LN65@atl_eval
$LN30@atl_eval:

; 3678 : 			    Hstore = (stackitem) di;/* Compile word address */

  003ea	8b 45 e8	 mov	 eax, DWORD PTR _di$85197[ebp]
  003ed	99		 cdq
  003ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  003f4	89 01		 mov	 DWORD PTR [ecx], eax
  003f6	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  003f9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  003ff	83 c2 08	 add	 edx, 8
  00402	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 3679 : 			} else {

  00408	eb 0c		 jmp	 SHORT $LN29@atl_eval
$LN34@atl_eval:

; 3680 : 			    exword(di);   /* Execute word */

  0040a	8b 45 e8	 mov	 eax, DWORD PTR _di$85197[ebp]
  0040d	50		 push	 eax
  0040e	e8 00 00 00 00	 call	 _exword
  00413	83 c4 04	 add	 esp, 4
$LN29@atl_eval:

; 3681 : 			}
; 3682 : 		    } else {

  00416	eb 38		 jmp	 SHORT $LN28@atl_eval
$LN35@atl_eval:

; 3683 : #ifdef MEMMESSAGE
; 3684 :                         V printf(" '%s' undefined ", tokbuf);

  00418	8b f4		 mov	 esi, esp
  0041a	68 00 00 00 00	 push	 OFFSET _tokbuf
  0041f	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@OHOHCFGF@?5?8?$CFs?8?5undefined?5?$AA@
  00424	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0042a	83 c4 08	 add	 esp, 8
  0042d	3b f4		 cmp	 esi, esp
  0042f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3685 : #endif
; 3686 : 			evalstat = ATL_UNDEFINED;

  00434	c7 05 00 00 00
	00 f9 ff ff ff	 mov	 DWORD PTR _evalstat, -7	; fffffff9H

; 3687 : 			state = Falsity;

  0043e	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00443	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00449	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN28@atl_eval:

; 3688 : 		    }
; 3689 : 		}
; 3690 : 		break;

  00450	e9 ec 03 00 00	 jmp	 $LN59@atl_eval
$LN27@atl_eval:

; 3691 : 
; 3692 : 	    case TokInt:
; 3693 : 		if (state) {

  00455	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  0045a	89 85 c4 fe ff
	ff		 mov	 DWORD PTR tv365[ebp], eax
  00460	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR tv365[ebp]
  00466	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR tv365[ebp]
  0046c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0046e	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  00471	74 64		 je	 SHORT $LN26@atl_eval

; 3694 : 		    Ho(2);

  00473	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00478	83 c0 10	 add	 eax, 16			; 00000010H
  0047b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  00481	76 0f		 jbe	 SHORT $LN25@atl_eval
  00483	e8 00 00 00 00	 call	 _heapover
  00488	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  0048d	e9 b9 03 00 00	 jmp	 $LN65@atl_eval
$LN25@atl_eval:

; 3695 : 		    Hstore = s_lit;   /* Push (lit) */

  00492	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00497	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_lit
  0049d	89 08		 mov	 DWORD PTR [eax], ecx
  0049f	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_lit+4
  004a5	89 50 04	 mov	 DWORD PTR [eax+4], edx
  004a8	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  004ad	83 c0 08	 add	 eax, 8
  004b0	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 3696 : 		    Hstore = tokint;  /* Compile actual literal */

  004b5	a1 00 00 00 00	 mov	 eax, DWORD PTR _tokint
  004ba	99		 cdq
  004bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  004c1	89 01		 mov	 DWORD PTR [ecx], eax
  004c3	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  004c6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  004cc	83 c2 08	 add	 edx, 8
  004cf	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 3697 : 		} else {

  004d5	eb 3f		 jmp	 SHORT $LN24@atl_eval
$LN26@atl_eval:

; 3698 : 		    So(1);

  004d7	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  004dc	83 c0 08	 add	 eax, 8
  004df	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  004e5	76 0f		 jbe	 SHORT $LN23@atl_eval
  004e7	e8 00 00 00 00	 call	 _stakover
  004ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  004f1	e9 55 03 00 00	 jmp	 $LN65@atl_eval
$LN23@atl_eval:

; 3699 : 		    Push = tokint;

  004f6	a1 00 00 00 00	 mov	 eax, DWORD PTR _tokint
  004fb	99		 cdq
  004fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00502	89 01		 mov	 DWORD PTR [ecx], eax
  00504	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00507	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0050d	83 c2 08	 add	 edx, 8
  00510	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN24@atl_eval:

; 3700 : 		}
; 3701 : 		break;

  00516	e9 26 03 00 00	 jmp	 $LN59@atl_eval
$LN22@atl_eval:

; 3702 : 
; 3703 : #ifdef REAL
; 3704 : 	    case TokReal:
; 3705 : 		if (state) {

  0051b	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  00520	89 85 c4 fe ff
	ff		 mov	 DWORD PTR tv399[ebp], eax
  00526	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR tv399[ebp]
  0052c	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR tv399[ebp]
  00532	8b 01		 mov	 eax, DWORD PTR [ecx]
  00534	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  00537	0f 84 8b 00 00
	00		 je	 $LN21@atl_eval

; 3706 : 		    int i;
; 3707 :     	    	    union {
; 3708 : 		    	atl_real r;
; 3709 : 			stackitem s[Realsize];
; 3710 : 		    } tru;
; 3711 : 
; 3712 : 		    Ho(Realsize + 1);

  0053d	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00542	83 c0 10	 add	 eax, 16			; 00000010H
  00545	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  0054b	76 0f		 jbe	 SHORT $LN20@atl_eval
  0054d	e8 00 00 00 00	 call	 _heapover
  00552	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  00557	e9 ef 02 00 00	 jmp	 $LN65@atl_eval
$LN20@atl_eval:

; 3713 : 		    Hstore = s_flit;  /* Push (flit) */

  0055c	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00561	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_flit
  00567	89 08		 mov	 DWORD PTR [eax], ecx
  00569	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_flit+4
  0056f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00572	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00577	83 c0 08	 add	 eax, 8
  0057a	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 3714 :     	    	    tru.r = tokreal;

  0057f	dd 05 00 00 00
	00		 fld	 QWORD PTR _tokreal
  00585	dd 5d c0	 fstp	 QWORD PTR _tru$85267[ebp]

; 3715 : 		    for (i = 0; i < Realsize; i++) {

  00588	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _i$85261[ebp], 0
  0058f	eb 09		 jmp	 SHORT $LN19@atl_eval
$LN18@atl_eval:
  00591	8b 45 d0	 mov	 eax, DWORD PTR _i$85261[ebp]
  00594	83 c0 01	 add	 eax, 1
  00597	89 45 d0	 mov	 DWORD PTR _i$85261[ebp], eax
$LN19@atl_eval:
  0059a	83 7d d0 01	 cmp	 DWORD PTR _i$85261[ebp], 1
  0059e	73 26		 jae	 SHORT $LN17@atl_eval

; 3716 : 			Hstore = tru.s[i];

  005a0	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  005a5	8b 4d d0	 mov	 ecx, DWORD PTR _i$85261[ebp]
  005a8	8b 54 cd c0	 mov	 edx, DWORD PTR _tru$85267[ebp+ecx*8]
  005ac	89 10		 mov	 DWORD PTR [eax], edx
  005ae	8b 4c cd c4	 mov	 ecx, DWORD PTR _tru$85267[ebp+ecx*8+4]
  005b2	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  005b5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  005bb	83 c2 08	 add	 edx, 8
  005be	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 3717 : 		    }

  005c4	eb cb		 jmp	 SHORT $LN18@atl_eval
$LN17@atl_eval:

; 3718 : 		} else {

  005c6	eb 66		 jmp	 SHORT $LN12@atl_eval
$LN21@atl_eval:

; 3719 : 		    int i;
; 3720 :     	    	    union {
; 3721 : 		    	atl_real r;
; 3722 : 			stackitem s[Realsize];
; 3723 : 		    } tru;
; 3724 : 
; 3725 : 		    So(Realsize);

  005c8	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  005cd	83 c0 08	 add	 eax, 8
  005d0	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  005d6	76 0f		 jbe	 SHORT $LN15@atl_eval
  005d8	e8 00 00 00 00	 call	 _stakover
  005dd	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  005e2	e9 64 02 00 00	 jmp	 $LN65@atl_eval
$LN15@atl_eval:

; 3726 :     	    	    tru.r = tokreal;

  005e7	dd 05 00 00 00
	00		 fld	 QWORD PTR _tokreal
  005ed	dd 5d a4	 fstp	 QWORD PTR _tru$85283[ebp]

; 3727 : 		    for (i = 0; i < Realsize; i++) {

  005f0	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _i$85277[ebp], 0
  005f7	eb 09		 jmp	 SHORT $LN14@atl_eval
$LN13@atl_eval:
  005f9	8b 45 b4	 mov	 eax, DWORD PTR _i$85277[ebp]
  005fc	83 c0 01	 add	 eax, 1
  005ff	89 45 b4	 mov	 DWORD PTR _i$85277[ebp], eax
$LN14@atl_eval:
  00602	83 7d b4 01	 cmp	 DWORD PTR _i$85277[ebp], 1
  00606	73 26		 jae	 SHORT $LN12@atl_eval

; 3728 : 			Push = tru.s[i];

  00608	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0060d	8b 4d b4	 mov	 ecx, DWORD PTR _i$85277[ebp]
  00610	8b 54 cd a4	 mov	 edx, DWORD PTR _tru$85283[ebp+ecx*8]
  00614	89 10		 mov	 DWORD PTR [eax], edx
  00616	8b 4c cd a8	 mov	 ecx, DWORD PTR _tru$85283[ebp+ecx*8+4]
  0061a	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0061d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00623	83 c2 08	 add	 edx, 8
  00626	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 3729 : 		    }

  0062c	eb cb		 jmp	 SHORT $LN13@atl_eval
$LN12@atl_eval:

; 3730 : 		}
; 3731 : 		break;

  0062e	e9 0e 02 00 00	 jmp	 $LN59@atl_eval
$LN11@atl_eval:

; 3732 : #endif /* REAL */
; 3733 : 
; 3734 : #ifdef STRING
; 3735 : 	    case TokString:
; 3736 : 		if (stringlit) {

  00633	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _stringlit, 0
  0063a	0f 84 b6 00 00
	00		 je	 $LN10@atl_eval

; 3737 : 		    stringlit = False;

  00640	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _stringlit, 0

; 3738 : 		    if (state) {

  0064a	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  0064f	89 85 c4 fe ff
	ff		 mov	 DWORD PTR tv433[ebp], eax
  00655	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR tv433[ebp]
  0065b	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR tv433[ebp]
  00661	8b 01		 mov	 eax, DWORD PTR [ecx]
  00663	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  00666	74 6d		 je	 SHORT $LN9@atl_eval

; 3739 : 			int l = (strlen(tokbuf) + 1 + sizeof(stackitem)) /
; 3740 : 				    sizeof(stackitem);

  00668	68 00 00 00 00	 push	 OFFSET _tokbuf
  0066d	e8 00 00 00 00	 call	 _strlen
  00672	83 c4 04	 add	 esp, 4
  00675	83 c0 09	 add	 eax, 9
  00678	c1 e8 03	 shr	 eax, 3
  0067b	89 45 98	 mov	 DWORD PTR _l$85295[ebp], eax

; 3741 : 			Ho(l);

  0067e	8b 45 98	 mov	 eax, DWORD PTR _l$85295[ebp]
  00681	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  00687	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  0068a	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  00690	76 0f		 jbe	 SHORT $LN8@atl_eval
  00692	e8 00 00 00 00	 call	 _heapover
  00697	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  0069c	e9 aa 01 00 00	 jmp	 $LN65@atl_eval
$LN8@atl_eval:

; 3742 : 			*((char *) hptr) = l;  /* Store in-line skip length */

  006a1	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  006a6	8a 4d 98	 mov	 cl, BYTE PTR _l$85295[ebp]
  006a9	88 08		 mov	 BYTE PTR [eax], cl

; 3743 : 			V strcpy(((char *) hptr) + 1, tokbuf);

  006ab	68 00 00 00 00	 push	 OFFSET _tokbuf
  006b0	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  006b5	83 c0 01	 add	 eax, 1
  006b8	50		 push	 eax
  006b9	e8 00 00 00 00	 call	 _strcpy
  006be	83 c4 08	 add	 esp, 8

; 3744 : 			hptr += l;

  006c1	8b 45 98	 mov	 eax, DWORD PTR _l$85295[ebp]
  006c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  006ca	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  006cd	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 3745 : 		    } else {

  006d3	eb 1c		 jmp	 SHORT $LN7@atl_eval
$LN9@atl_eval:

; 3746 :                         V printf("%s", tokbuf);

  006d5	8b f4		 mov	 esi, esp
  006d7	68 00 00 00 00	 push	 OFFSET _tokbuf
  006dc	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  006e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  006e7	83 c4 08	 add	 esp, 8
  006ea	3b f4		 cmp	 esi, esp
  006ec	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@atl_eval:

; 3747 : 		    }
; 3748 : 		} else {

  006f1	e9 2e 01 00 00	 jmp	 $LN3@atl_eval
$LN10@atl_eval:

; 3749 : 		    if (state) {

  006f6	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  006fb	89 85 c4 fe ff
	ff		 mov	 DWORD PTR tv451[ebp], eax
  00701	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR tv451[ebp]
  00707	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR tv451[ebp]
  0070d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0070f	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  00712	0f 84 91 00 00
	00		 je	 $LN5@atl_eval

; 3750 : 			int l = (strlen(tokbuf) + 1 + sizeof(stackitem)) /
; 3751 : 				    sizeof(stackitem);

  00718	68 00 00 00 00	 push	 OFFSET _tokbuf
  0071d	e8 00 00 00 00	 call	 _strlen
  00722	83 c4 04	 add	 esp, 4
  00725	83 c0 09	 add	 eax, 9
  00728	c1 e8 03	 shr	 eax, 3
  0072b	89 45 8c	 mov	 DWORD PTR _l$85306[ebp], eax

; 3752 : 			Ho(l + 1);

  0072e	8b 45 8c	 mov	 eax, DWORD PTR _l$85306[ebp]
  00731	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  00737	8d 54 c1 08	 lea	 edx, DWORD PTR [ecx+eax*8+8]
  0073b	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  00741	76 0f		 jbe	 SHORT $LN4@atl_eval
  00743	e8 00 00 00 00	 call	 _heapover
  00748	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  0074d	e9 f9 00 00 00	 jmp	 $LN65@atl_eval
$LN4@atl_eval:

; 3753 : 			/* Compile string literal instruction, followed by
; 3754 : 			   in-line skip length and the string literal */
; 3755 : 			Hstore = s_strlit;

  00752	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00757	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_strlit
  0075d	89 08		 mov	 DWORD PTR [eax], ecx
  0075f	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_strlit+4
  00765	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00768	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0076d	83 c0 08	 add	 eax, 8
  00770	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 3756 : 			*((char *) hptr) = l;  /* Store in-line skip length */

  00775	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0077a	8a 4d 8c	 mov	 cl, BYTE PTR _l$85306[ebp]
  0077d	88 08		 mov	 BYTE PTR [eax], cl

; 3757 : 			V strcpy(((char *) hptr) + 1, tokbuf);

  0077f	68 00 00 00 00	 push	 OFFSET _tokbuf
  00784	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  00789	83 c0 01	 add	 eax, 1
  0078c	50		 push	 eax
  0078d	e8 00 00 00 00	 call	 _strcpy
  00792	83 c4 08	 add	 esp, 8

; 3758 : 			hptr += l;

  00795	8b 45 8c	 mov	 eax, DWORD PTR _l$85306[ebp]
  00798	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  0079e	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  007a1	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 3759 : 		    } else {

  007a7	eb 7b		 jmp	 SHORT $LN3@atl_eval
$LN5@atl_eval:

; 3760 : 			So(1);

  007a9	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  007ae	83 c0 08	 add	 eax, 8
  007b1	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  007b7	76 0f		 jbe	 SHORT $LN2@atl_eval
  007b9	e8 00 00 00 00	 call	 _stakover
  007be	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  007c3	e9 83 00 00 00	 jmp	 $LN65@atl_eval
$LN2@atl_eval:

; 3761 : 			V strcpy(strbuf[cstrbuf], tokbuf);

  007c8	68 00 00 00 00	 push	 OFFSET _tokbuf
  007cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _cstrbuf
  007d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _strbuf
  007d8	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  007db	52		 push	 edx
  007dc	e8 00 00 00 00	 call	 _strcpy
  007e1	83 c4 08	 add	 esp, 8

; 3762 : 			Push = (stackitem) strbuf[cstrbuf];

  007e4	a1 00 00 00 00	 mov	 eax, DWORD PTR _cstrbuf
  007e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _strbuf
  007ef	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  007f2	99		 cdq
  007f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  007f9	89 01		 mov	 DWORD PTR [ecx], eax
  007fb	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  007fe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00804	83 c2 08	 add	 edx, 8
  00807	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 3763 : 			cstrbuf = (cstrbuf + 1) % ((int) atl_ntempstr);

  0080d	a1 00 00 00 00	 mov	 eax, DWORD PTR _cstrbuf
  00812	83 c0 01	 add	 eax, 1
  00815	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl_ntempstr
  0081b	99		 cdq
  0081c	f7 f9		 idiv	 ecx
  0081e	89 15 00 00 00
	00		 mov	 DWORD PTR _cstrbuf, edx
$LN3@atl_eval:

; 3764 : 		    }
; 3765 : 		}
; 3766 : 		break;

  00824	eb 1b		 jmp	 SHORT $LN59@atl_eval
$LN1@atl_eval:

; 3767 : #endif /* STRING */
; 3768 : 	    default:
; 3769 :                 V printf("\nUnknown token type %d\n", i);

  00826	8b f4		 mov	 esi, esp
  00828	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0082b	50		 push	 eax
  0082c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@GECOCLOJ@?6Unknown?5token?5type?5?$CFd?6?$AA@
  00831	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00837	83 c4 08	 add	 esp, 8
  0083a	3b f4		 cmp	 esi, esp
  0083c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN59@atl_eval:

; 3770 : 		break;
; 3771 : 	}
; 3772 :     }

  00841	e9 26 f8 ff ff	 jmp	 $LN64@atl_eval
$LN61@atl_eval:

; 3773 :     return evalstat;

  00846	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
$LN65@atl_eval:

; 3774 : }

  0084b	52		 push	 edx
  0084c	8b cd		 mov	 ecx, ebp
  0084e	50		 push	 eax
  0084f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN70@atl_eval
  00855	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0085a	58		 pop	 eax
  0085b	5a		 pop	 edx
  0085c	5f		 pop	 edi
  0085d	5e		 pop	 esi
  0085e	5b		 pop	 ebx
  0085f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00862	33 cd		 xor	 ecx, ebp
  00864	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00869	81 c4 3c 01 00
	00		 add	 esp, 316		; 0000013cH
  0086f	3b ec		 cmp	 ebp, esp
  00871	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00876	8b e5		 mov	 esp, ebp
  00878	5d		 pop	 ebp
  00879	c3		 ret	 0
  0087a	8b ff		 npad	 2
$LN70@atl_eval:
  0087c	02 00 00 00	 DD	 2
  00880	00 00 00 00	 DD	 $LN69@atl_eval
$LN69@atl_eval:
  00884	c0 ff ff ff	 DD	 -64			; ffffffc0H
  00888	08 00 00 00	 DD	 8
  0088c	00 00 00 00	 DD	 $LN67@atl_eval
  00890	a4 ff ff ff	 DD	 -92			; ffffffa4H
  00894	08 00 00 00	 DD	 8
  00898	00 00 00 00	 DD	 $LN68@atl_eval
$LN68@atl_eval:
  0089c	74		 DB	 116			; 00000074H
  0089d	72		 DB	 114			; 00000072H
  0089e	75		 DB	 117			; 00000075H
  0089f	00		 DB	 0
$LN67@atl_eval:
  008a0	74		 DB	 116			; 00000074H
  008a1	72		 DB	 114			; 00000072H
  008a2	75		 DB	 117			; 00000075H
  008a3	00		 DB	 0
$LN71@atl_eval:
  008a4	00 00 00 00	 DD	 $LN58@atl_eval
  008a8	00 00 00 00	 DD	 $LN27@atl_eval
  008ac	00 00 00 00	 DD	 $LN22@atl_eval
  008b0	00 00 00 00	 DD	 $LN11@atl_eval
_atl_eval ENDP
_TEXT	ENDS
END
