; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\A15\facultate\forth\atlast-2.0\atlast.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_opterr
PUBLIC	_optind
PUBLIC	_optopt
PUBLIC	_atl_stklen
PUBLIC	_atl_rstklen
PUBLIC	_atl_heaplen
PUBLIC	_atl_ltempstr
PUBLIC	_atl_ntempstr
PUBLIC	_atl_trace
PUBLIC	_atl_walkback
PUBLIC	_atl_comment
PUBLIC	_atl_redef
PUBLIC	_atl_errline
_BSS	SEGMENT
$SG82875 DB	01H DUP (?)
	ALIGN	4

$SG82874 DB	01H DUP (?)
	ALIGN	4

$SG82871 DB	01H DUP (?)
	ALIGN	4

$SG82870 DB	01H DUP (?)
	ALIGN	4

$SG82868 DB	01H DUP (?)
	ALIGN	4

$SG82866 DB	01H DUP (?)
	ALIGN	4

$SG82864 DB	01H DUP (?)
	ALIGN	4

$SG82862 DB	01H DUP (?)
	ALIGN	4

$SG81829 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	___mingw_optreset:DWORD
COMM	_optarg:DWORD
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

$SG82015 DB	01H DUP (?)
	ALIGN	4

$SG82022 DB	01H DUP (?)
	ALIGN	4

$SG82031 DB	01H DUP (?)
	ALIGN	4

$SG82041 DB	01H DUP (?)
	ALIGN	4

$SG82060 DB	01H DUP (?)
	ALIGN	4

$SG82065 DB	01H DUP (?)
	ALIGN	4

$SG82074 DB	01H DUP (?)
	ALIGN	4

$SG82079 DB	01H DUP (?)
	ALIGN	8

_atl_trace DQ	01H DUP (?)
_atl_comment DQ	01H DUP (?)
_atl_errline DQ	01H DUP (?)
_stack	DD	01H DUP (?)
_rstack	DD	01H DUP (?)
_heap	DD	01H DUP (?)
_dict	DD	01H DUP (?)
_dictprot DD	01H DUP (?)
_strbuf	DD	01H DUP (?)
_cstrbuf DD	01H DUP (?)
_wback	DD	01H DUP (?)
_instream DD	01H DUP (?)
_ip	DD	01H DUP (?)
_curword DD	01H DUP (?)
_evalstat DD	01H DUP (?)
_defpend DD	01H DUP (?)
_forgetpend DD	01H DUP (?)
_tickpend DD	01H DUP (?)
_ctickpend DD	01H DUP (?)
_cbrackpend DD	01H DUP (?)
_createword DD	01H DUP (?)
_stringlit DD	01H DUP (?)
_broken	DD	01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
_recargchar DB	'option requires an argument -- %c', 00H
	ORG $+2
_recargstring DB 'option requires an argument -- %s', 00H
	ORG $+2
_ambig	DB	'ambiguous option -- %.*s', 00H
	ORG $+3
_noarg	DB	'option doesn''t take an argument -- %.*s', 00H
_illoptchar DB	'unknown option -- %c', 00H
	ORG $+3
_illoptstring DB 'unknown option -- %s', 00H
CONST	ENDS
_DATA	SEGMENT
_opterr	DD	01H
_optind	DD	01H
_optopt	DD	03fH
_place	DD	FLAT:$SG81829
_nonopt_start DD 0ffffffffH
_nonopt_end DD	0ffffffffH
$SG81845 DB	'%s: ', 00H
	ORG $+3
$SG81850 DB	0aH, 00H
	ORG $+2
?posixly_correct@?1??getopt_internal@@9@9 DD 0ffffffffH	; `getopt_internal'::`2'::posixly_correct
$SG82002 DB	'POSIXLY_CORRECT', 00H
_atl_stklen DQ	0000000000000064H
_atl_rstklen DQ	0000000000000064H
_atl_heaplen DQ	00000000000007d0H
_atl_ltempstr DQ 0000000000000100H
_atl_ntempstr DQ 0000000000000004H
_atl_walkback DQ ffffffffffffffffH
_atl_redef DQ	ffffffffffffffffH
$SG82863 DB	'r', 00H
	ORG $+2
$SG82865 DB	'r+', 00H
	ORG $+1
$SG82867 DB	'r', 00H
	ORG $+2
$SG82869 DB	'r+', 00H
	ORG $+1
$SG82872 DB	'w', 00H
	ORG $+2
$SG82873 DB	'w+', 00H
	ORG $+1
$SG82876 DB	'w', 00H
	ORG $+2
$SG82877 DB	'w+', 00H
	ORG $+1
_fopenmodes DD	FLAT:$SG82862
	DD	FLAT:$SG82863
	DD	FLAT:$SG82864
	DD	FLAT:$SG82865
	DD	FLAT:$SG82866
	DD	FLAT:$SG82867
	DD	FLAT:$SG82868
	DD	FLAT:$SG82869
	DD	FLAT:$SG82870
	DD	FLAT:$SG82871
	DD	FLAT:$SG82872
	DD	FLAT:$SG82873
	DD	FLAT:$SG82874
	DD	FLAT:$SG82875
	DD	FLAT:$SG82876
	DD	FLAT:$SG82877
_base	DD	0aH
$SG82923 DB	0aH, 0aH, 'Out of memory!  %u bytes requested.', 0aH, 00H
	ORG $+1
$SG82985 DB	0aH, 'Runaway string: %s', 0aH, 00H
	ORG $+3
$SG82988 DB	'\', 00H
	ORG $+2
$SG82993 DB	'(', 00H
	ORG $+2
$SG83005 DB	'%lf%c', 00H
	ORG $+2
$SG83274 DB	'Subscript out of range', 00H
	ORG $+1
$SG83292 DB	'Bad array element size', 00H
	ORG $+1
$SG83294 DB	'Bad array subscript count', 00H
	ORG $+2
$SG83300 DB	'Bad array dimension', 00H
$SG83318 DB	'"%s" ', 00H
	ORG $+2
$SG83497 DB	'%g ', 00H
$SG83653 DB	'%g ', 00H
$SG83763 DB	'%lX', 00H
$SG83764 DB	'%ld ', 00H
	ORG $+3
$SG83774 DB	'%lX', 00H
$SG83775 DB	'%ld ', 00H
	ORG $+3
$SG83779 DB	0aH, 00H
	ORG $+2
$SG83784 DB	'Stack: ', 00H
$SG83787 DB	'Empty.', 00H
	ORG $+1
$SG83793 DB	'%lX', 00H
$SG83794 DB	'%ld ', 00H
	ORG $+3
$SG83807 DB	'%s', 00H
	ORG $+1
$SG83818 DB	'%s', 00H
	ORG $+1
$SG83828 DB	0aH, '%s', 00H
$SG83831 DB	0aH, 00H
	ORG $+2
$SG83855 DB	0aH, 'Not a file', 0aH, 00H
	ORG $+3
$SG83876 DB	0aH, 'Not a file', 0aH, 00H
	ORG $+3
$SG83882 DB	0aH, 'File not open', 0aH, 00H
$SG83911 DB	0aH, 'Not a file', 0aH, 00H
	ORG $+3
$SG83917 DB	0aH, 'File not open', 0aH, 00H
$SG83938 DB	0aH, 'Not a file', 0aH, 00H
	ORG $+3
$SG83944 DB	0aH, 'File not open', 0aH, 00H
$SG83966 DB	0aH, 'Not a file', 0aH, 00H
	ORG $+3
$SG83972 DB	0aH, 'File not open', 0aH, 00H
$SG83991 DB	0aH, 'Not a file', 0aH, 00H
	ORG $+3
$SG83997 DB	0aH, 'File not open', 0aH, 00H
$SG84012 DB	0aH, 'Not a file', 0aH, 00H
	ORG $+3
$SG84018 DB	0aH, 'File not open', 0aH, 00H
$SG84031 DB	0aH, 'Not a file', 0aH, 00H
	ORG $+3
$SG84037 DB	0aH, 'File not open', 0aH, 00H
$SG84051 DB	0aH, 'Not a file', 0aH, 00H
	ORG $+3
$SG84057 DB	0aH, 'File not open', 0aH, 00H
$SG84071 DB	0aH, 'Not a file', 0aH, 00H
	ORG $+3
$SG84077 DB	0aH, 'File not open', 0aH, 00H
$SG84095 DB	0aH, 'Not a file', 0aH, 00H
	ORG $+3
$SG84101 DB	0aH, 'File not open', 0aH, 00H
$SG84247 DB	'%ld ', 00H
	ORG $+3
$SG84486 DB	'%s', 00H
	ORG $+1
$SG84540 DB	' ''%s'' undefined ', 00H
	ORG $+3
$SG84543 DB	0aH, 'Word not specified when expected.', 0aH, 00H
$SG84549 DB	0aH, 'Word requested by ` not on same input line.', 0aH, 00H
	ORG $+2
$SG84595 DB	0aH, '>LINK Foulup--wnext is not at zero!', 0aH, 00H
	ORG $+2
$SG84614 DB	0aH, 'LINK> Foulup--wnext is not at zero!', 0aH, 00H
	ORG $+2
$SG84686 DB	0aH, '%s', 00H
$SG84688 DB	0aH, 00H
	ORG $+2
$SG84698 DB	0aH, '%s', 00H
$SG84700 DB	0aH, 00H
	ORG $+2
$SG84747 DB	'0+', 00H
	ORG $+1
$SG84748 DB	'0-', 00H
	ORG $+1
$SG84749 DB	'0*', 00H
	ORG $+1
$SG84750 DB	'0/', 00H
	ORG $+1
$SG84751 DB	'0MOD', 00H
	ORG $+3
$SG84752 DB	'0/MOD', 00H
	ORG $+2
$SG84753 DB	'0MIN', 00H
	ORG $+3
$SG84754 DB	'0MAX', 00H
	ORG $+3
$SG84755 DB	'0NEGATE', 00H
$SG84756 DB	'0ABS', 00H
	ORG $+3
$SG84757 DB	'0=', 00H
	ORG $+1
$SG84758 DB	'0<>', 00H
$SG84759 DB	'0>', 00H
	ORG $+1
$SG84760 DB	'0<', 00H
	ORG $+1
$SG84761 DB	'0>=', 00H
$SG84762 DB	'0<=', 00H
$SG84763 DB	'0AND', 00H
	ORG $+3
$SG84764 DB	'0OR', 00H
$SG84765 DB	'0XOR', 00H
	ORG $+3
$SG84766 DB	'0NOT', 00H
	ORG $+3
$SG84767 DB	'0SHIFT', 00H
	ORG $+1
$SG84768 DB	'0DEPTH', 00H
	ORG $+1
$SG84769 DB	'0CLEAR', 00H
	ORG $+1
$SG84770 DB	'0DUP', 00H
	ORG $+3
$SG84771 DB	'0DROP', 00H
	ORG $+2
$SG84772 DB	'0SWAP', 00H
	ORG $+2
$SG84773 DB	'0OVER', 00H
	ORG $+2
$SG84774 DB	'0PICK', 00H
	ORG $+2
$SG84775 DB	'0ROT', 00H
	ORG $+3
$SG84776 DB	'0-ROT', 00H
	ORG $+2
$SG84777 DB	'0ROLL', 00H
	ORG $+2
$SG84778 DB	'0>R', 00H
$SG84779 DB	'0R>', 00H
$SG84780 DB	'0R@', 00H
$SG84781 DB	'01+', 00H
$SG84782 DB	'02+', 00H
$SG84783 DB	'01-', 00H
$SG84784 DB	'02-', 00H
$SG84785 DB	'02*', 00H
$SG84786 DB	'02/', 00H
$SG84787 DB	'00=', 00H
$SG84788 DB	'00<>', 00H
	ORG $+3
$SG84789 DB	'00>', 00H
$SG84790 DB	'00<', 00H
$SG84791 DB	'02DUP', 00H
	ORG $+2
$SG84792 DB	'02DROP', 00H
	ORG $+1
$SG84793 DB	'02SWAP', 00H
	ORG $+1
$SG84794 DB	'02OVER', 00H
	ORG $+1
$SG84795 DB	'02ROT', 00H
	ORG $+2
$SG84796 DB	'02VARIABLE', 00H
	ORG $+1
$SG84797 DB	'02CONSTANT', 00H
	ORG $+1
$SG84798 DB	'02!', 00H
$SG84799 DB	'02@', 00H
$SG84800 DB	'0VARIABLE', 00H
	ORG $+2
$SG84801 DB	'0CONSTANT', 00H
	ORG $+2
$SG84802 DB	'0!', 00H
	ORG $+1
$SG84803 DB	'0@', 00H
	ORG $+1
$SG84804 DB	'0+!', 00H
$SG84805 DB	'0ALLOT', 00H
	ORG $+1
$SG84806 DB	'0,', 00H
	ORG $+1
$SG84807 DB	'0C!', 00H
$SG84808 DB	'0C@', 00H
$SG84809 DB	'0C,', 00H
$SG84810 DB	'0C=', 00H
$SG84811 DB	'0HERE', 00H
	ORG $+2
$SG84812 DB	'0ARRAY', 00H
	ORG $+1
$SG84813 DB	'0(STRLIT)', 00H
	ORG $+2
$SG84814 DB	'0STRING', 00H
$SG84815 DB	'0STRCPY', 00H
$SG84816 DB	'0S!', 00H
$SG84817 DB	'0STRCAT', 00H
$SG84818 DB	'0S+', 00H
$SG84819 DB	'0STRLEN', 00H
$SG84820 DB	'0STRCMP', 00H
$SG84821 DB	'0STRCHAR', 00H
	ORG $+3
$SG84822 DB	'0SUBSTR', 00H
$SG84823 DB	'0COMPARE', 00H
	ORG $+3
$SG84824 DB	'0STRFORM', 00H
	ORG $+3
$SG84825 DB	'0FSTRFORM', 00H
	ORG $+2
$SG84826 DB	'0STRINT', 00H
$SG84827 DB	'0STRREAL', 00H
	ORG $+3
$SG84828 DB	'0(FLIT)', 00H
$SG84829 DB	'0F+', 00H
$SG84830 DB	'0F-', 00H
$SG84831 DB	'0F*', 00H
$SG84832 DB	'0F/', 00H
$SG84833 DB	'0FMIN', 00H
	ORG $+2
$SG84834 DB	'0FMAX', 00H
	ORG $+2
$SG84835 DB	'0FNEGATE', 00H
	ORG $+3
$SG84836 DB	'0FABS', 00H
	ORG $+2
$SG84837 DB	'0F=', 00H
$SG84838 DB	'0F<>', 00H
	ORG $+3
$SG84839 DB	'0F>', 00H
$SG84840 DB	'0F<', 00H
$SG84841 DB	'0F>=', 00H
	ORG $+3
$SG84842 DB	'0F<=', 00H
	ORG $+3
$SG84843 DB	'0F.', 00H
$SG84844 DB	'0FLOAT', 00H
	ORG $+1
$SG84845 DB	'0FIX', 00H
	ORG $+3
$SG84846 DB	'0ACOS', 00H
	ORG $+2
$SG84847 DB	'0ASIN', 00H
	ORG $+2
$SG84848 DB	'0ATAN', 00H
	ORG $+2
$SG84849 DB	'0ATAN2', 00H
	ORG $+1
$SG84850 DB	'0COS', 00H
	ORG $+3
$SG84851 DB	'0EXP', 00H
	ORG $+3
$SG84852 DB	'0LOG', 00H
	ORG $+3
$SG84853 DB	'0POW', 00H
	ORG $+3
$SG84854 DB	'0SIN', 00H
	ORG $+3
$SG84855 DB	'0SQRT', 00H
	ORG $+2
$SG84856 DB	'0TAN', 00H
	ORG $+3
$SG84857 DB	'0(NEST)', 00H
$SG84858 DB	'0EXIT', 00H
	ORG $+2
$SG84859 DB	'0(LIT)', 00H
	ORG $+1
$SG84860 DB	'0BRANCH', 00H
$SG84861 DB	'0?BRANCH', 00H
	ORG $+3
$SG84862 DB	'1IF', 00H
$SG84863 DB	'1ELSE', 00H
	ORG $+2
$SG84864 DB	'1THEN', 00H
	ORG $+2
$SG84865 DB	'0?DUP', 00H
	ORG $+2
$SG84866 DB	'1BEGIN', 00H
	ORG $+1
$SG84867 DB	'1UNTIL', 00H
	ORG $+1
$SG84868 DB	'1AGAIN', 00H
	ORG $+1
$SG84869 DB	'1WHILE', 00H
	ORG $+1
$SG84870 DB	'1REPEAT', 00H
$SG84871 DB	'1DO', 00H
$SG84872 DB	'1?DO', 00H
	ORG $+3
$SG84873 DB	'1LOOP', 00H
	ORG $+2
$SG84874 DB	'1+LOOP', 00H
	ORG $+1
$SG84875 DB	'0(XDO)', 00H
	ORG $+1
$SG84876 DB	'0(X?DO)', 00H
$SG84877 DB	'0(XLOOP)', 00H
	ORG $+3
$SG84878 DB	'0(+XLOOP)', 00H
	ORG $+2
$SG84879 DB	'0LEAVE', 00H
	ORG $+1
$SG84880 DB	'0I', 00H
	ORG $+1
$SG84881 DB	'0J', 00H
	ORG $+1
$SG84882 DB	'0QUIT', 00H
	ORG $+2
$SG84883 DB	'0ABORT', 00H
	ORG $+1
$SG84884 DB	'1ABORT"', 00H
$SG84885 DB	'0SYSTEM', 00H
$SG84886 DB	'0TRACE', 00H
	ORG $+1
$SG84887 DB	'0WALKBACK', 00H
	ORG $+2
$SG84888 DB	'0WORDSUSED', 00H
	ORG $+1
$SG84889 DB	'0WORDSUNUSED', 00H
	ORG $+3
$SG84890 DB	'0:', 00H
	ORG $+1
$SG84891 DB	'1;', 00H
	ORG $+1
$SG84892 DB	'0IMMEDIATE', 00H
	ORG $+1
$SG84893 DB	'1[', 00H
	ORG $+1
$SG84894 DB	'0]', 00H
	ORG $+1
$SG84895 DB	'0CREATE', 00H
$SG84896 DB	'0FORGET', 00H
$SG84897 DB	'0DOES>', 00H
	ORG $+1
$SG84898 DB	'0''', 00H
	ORG $+1
$SG84899 DB	'1['']', 00H
	ORG $+3
$SG84900 DB	'0EXECUTE', 00H
	ORG $+3
$SG84901 DB	'0>BODY', 00H
	ORG $+1
$SG84902 DB	'0STATE', 00H
	ORG $+1
$SG84903 DB	'0FIND', 00H
	ORG $+2
$SG84904 DB	'0>NAME', 00H
	ORG $+1
$SG84905 DB	'0>LINK', 00H
	ORG $+1
$SG84906 DB	'0BODY>', 00H
	ORG $+1
$SG84907 DB	'0NAME>', 00H
	ORG $+1
$SG84908 DB	'0LINK>', 00H
	ORG $+1
$SG84909 DB	'0N>LINK', 00H
$SG84910 DB	'0L>NAME', 00H
$SG84911 DB	'0NAME>S!', 00H
	ORG $+3
$SG84912 DB	'0S>NAME!', 00H
	ORG $+3
$SG84913 DB	'1[COMPILE]', 00H
	ORG $+1
$SG84914 DB	'1LITERAL', 00H
	ORG $+3
$SG84915 DB	'0COMPILE', 00H
	ORG $+3
$SG84916 DB	'0<MARK', 00H
	ORG $+1
$SG84917 DB	'0<RESOLVE', 00H
	ORG $+2
$SG84918 DB	'0>MARK', 00H
	ORG $+1
$SG84919 DB	'0>RESOLVE', 00H
	ORG $+2
$SG84920 DB	'0.', 00H
	ORG $+1
$SG84921 DB	'0?', 00H
	ORG $+1
$SG84922 DB	'0CR', 00H
$SG84923 DB	'0.S', 00H
$SG84924 DB	'1."', 00H
$SG84925 DB	'1.(', 00H
$SG84926 DB	'0TYPE', 00H
	ORG $+2
$SG84927 DB	'0WORDS', 00H
	ORG $+1
$SG84928 DB	'0FILE', 00H
	ORG $+2
$SG84929 DB	'0FOPEN', 00H
	ORG $+1
$SG84930 DB	'0FCLOSE', 00H
$SG84931 DB	'0FDELETE', 00H
	ORG $+3
$SG84932 DB	'0FGETS', 00H
	ORG $+1
$SG84933 DB	'0FPUTS', 00H
	ORG $+1
$SG84934 DB	'0FREAD', 00H
	ORG $+1
$SG84935 DB	'0FWRITE', 00H
$SG84936 DB	'0FGETC', 00H
	ORG $+1
$SG84937 DB	'0FPUTC', 00H
	ORG $+1
$SG84938 DB	'0FTELL', 00H
	ORG $+1
$SG84939 DB	'0FSEEK', 00H
	ORG $+1
$SG84940 DB	'0FLOAD', 00H
	ORG $+1
$SG84941 DB	'0EVALUATE', 00H
	ORG $+2
$SG84967 DB	'Walkback:', 0aH, 00H
	ORG $+1
_primt	DD	FLAT:$SG84747
	DD	FLAT:_P_plus
	DD	FLAT:$SG84748
	DD	FLAT:_P_minus
	DD	FLAT:$SG84749
	DD	FLAT:_P_times
	DD	FLAT:$SG84750
	DD	FLAT:_P_div
	DD	FLAT:$SG84751
	DD	FLAT:_P_mod
	DD	FLAT:$SG84752
	DD	FLAT:_P_divmod
	DD	FLAT:$SG84753
	DD	FLAT:_P_min
	DD	FLAT:$SG84754
	DD	FLAT:_P_max
	DD	FLAT:$SG84755
	DD	FLAT:_P_neg
	DD	FLAT:$SG84756
	DD	FLAT:_P_abs
	DD	FLAT:$SG84757
	DD	FLAT:_P_equal
	DD	FLAT:$SG84758
	DD	FLAT:_P_unequal
	DD	FLAT:$SG84759
	DD	FLAT:_P_gtr
	DD	FLAT:$SG84760
	DD	FLAT:_P_lss
	DD	FLAT:$SG84761
	DD	FLAT:_P_geq
	DD	FLAT:$SG84762
	DD	FLAT:_P_leq
	DD	FLAT:$SG84763
	DD	FLAT:_P_and
	DD	FLAT:$SG84764
	DD	FLAT:_P_or
	DD	FLAT:$SG84765
	DD	FLAT:_P_xor
	DD	FLAT:$SG84766
	DD	FLAT:_P_not
	DD	FLAT:$SG84767
	DD	FLAT:_P_shift
	DD	FLAT:$SG84768
	DD	FLAT:_P_depth
	DD	FLAT:$SG84769
	DD	FLAT:_P_clear
	DD	FLAT:$SG84770
	DD	FLAT:_P_dup
	DD	FLAT:$SG84771
	DD	FLAT:_P_drop
	DD	FLAT:$SG84772
	DD	FLAT:_P_swap
	DD	FLAT:$SG84773
	DD	FLAT:_P_over
	DD	FLAT:$SG84774
	DD	FLAT:_P_pick
	DD	FLAT:$SG84775
	DD	FLAT:_P_rot
	DD	FLAT:$SG84776
	DD	FLAT:_P_minusrot
	DD	FLAT:$SG84777
	DD	FLAT:_P_roll
	DD	FLAT:$SG84778
	DD	FLAT:_P_tor
	DD	FLAT:$SG84779
	DD	FLAT:_P_rfrom
	DD	FLAT:$SG84780
	DD	FLAT:_P_rfetch
	DD	FLAT:$SG84781
	DD	FLAT:_P_1plus
	DD	FLAT:$SG84782
	DD	FLAT:_P_2plus
	DD	FLAT:$SG84783
	DD	FLAT:_P_1minus
	DD	FLAT:$SG84784
	DD	FLAT:_P_2minus
	DD	FLAT:$SG84785
	DD	FLAT:_P_2times
	DD	FLAT:$SG84786
	DD	FLAT:_P_2div
	DD	FLAT:$SG84787
	DD	FLAT:_P_0equal
	DD	FLAT:$SG84788
	DD	FLAT:_P_0notequal
	DD	FLAT:$SG84789
	DD	FLAT:_P_0gtr
	DD	FLAT:$SG84790
	DD	FLAT:_P_0lss
	DD	FLAT:$SG84791
	DD	FLAT:_P_2dup
	DD	FLAT:$SG84792
	DD	FLAT:_P_2drop
	DD	FLAT:$SG84793
	DD	FLAT:_P_2swap
	DD	FLAT:$SG84794
	DD	FLAT:_P_2over
	DD	FLAT:$SG84795
	DD	FLAT:_P_2rot
	DD	FLAT:$SG84796
	DD	FLAT:_P_2variable
	DD	FLAT:$SG84797
	DD	FLAT:_P_2constant
	DD	FLAT:$SG84798
	DD	FLAT:_P_2bang
	DD	FLAT:$SG84799
	DD	FLAT:_P_2at
	DD	FLAT:$SG84800
	DD	FLAT:_P_variable
	DD	FLAT:$SG84801
	DD	FLAT:_P_constant
	DD	FLAT:$SG84802
	DD	FLAT:_P_bang
	DD	FLAT:$SG84803
	DD	FLAT:_P_at
	DD	FLAT:$SG84804
	DD	FLAT:_P_plusbang
	DD	FLAT:$SG84805
	DD	FLAT:_P_allot
	DD	FLAT:$SG84806
	DD	FLAT:_P_comma
	DD	FLAT:$SG84807
	DD	FLAT:_P_cbang
	DD	FLAT:$SG84808
	DD	FLAT:_P_cat
	DD	FLAT:$SG84809
	DD	FLAT:_P_ccomma
	DD	FLAT:$SG84810
	DD	FLAT:_P_cequal
	DD	FLAT:$SG84811
	DD	FLAT:_P_here
	DD	FLAT:$SG84812
	DD	FLAT:_P_array
	DD	FLAT:$SG84813
	DD	FLAT:_P_strlit
	DD	FLAT:$SG84814
	DD	FLAT:_P_string
	DD	FLAT:$SG84815
	DD	FLAT:_P_strcpy
	DD	FLAT:$SG84816
	DD	FLAT:_P_strcpy
	DD	FLAT:$SG84817
	DD	FLAT:_P_strcat
	DD	FLAT:$SG84818
	DD	FLAT:_P_strcat
	DD	FLAT:$SG84819
	DD	FLAT:_P_strlen
	DD	FLAT:$SG84820
	DD	FLAT:_P_strcmp
	DD	FLAT:$SG84821
	DD	FLAT:_P_strchar
	DD	FLAT:$SG84822
	DD	FLAT:_P_substr
	DD	FLAT:$SG84823
	DD	FLAT:_P_strcmp
	DD	FLAT:$SG84824
	DD	FLAT:_P_strform
	DD	FLAT:$SG84825
	DD	FLAT:_P_fstrform
	DD	FLAT:$SG84826
	DD	FLAT:_P_strint
	DD	FLAT:$SG84827
	DD	FLAT:_P_strreal
	DD	FLAT:$SG84828
	DD	FLAT:_P_flit
	DD	FLAT:$SG84829
	DD	FLAT:_P_fplus
	DD	FLAT:$SG84830
	DD	FLAT:_P_fminus
	DD	FLAT:$SG84831
	DD	FLAT:_P_ftimes
	DD	FLAT:$SG84832
	DD	FLAT:_P_fdiv
	DD	FLAT:$SG84833
	DD	FLAT:_P_fmin
	DD	FLAT:$SG84834
	DD	FLAT:_P_fmax
	DD	FLAT:$SG84835
	DD	FLAT:_P_fneg
	DD	FLAT:$SG84836
	DD	FLAT:_P_fabs
	DD	FLAT:$SG84837
	DD	FLAT:_P_fequal
	DD	FLAT:$SG84838
	DD	FLAT:_P_funequal
	DD	FLAT:$SG84839
	DD	FLAT:_P_fgtr
	DD	FLAT:$SG84840
	DD	FLAT:_P_flss
	DD	FLAT:$SG84841
	DD	FLAT:_P_fgeq
	DD	FLAT:$SG84842
	DD	FLAT:_P_fleq
	DD	FLAT:$SG84843
	DD	FLAT:_P_fdot
	DD	FLAT:$SG84844
	DD	FLAT:_P_float
	DD	FLAT:$SG84845
	DD	FLAT:_P_fix
	DD	FLAT:$SG84846
	DD	FLAT:_P_acos
	DD	FLAT:$SG84847
	DD	FLAT:_P_asin
	DD	FLAT:$SG84848
	DD	FLAT:_P_atan
	DD	FLAT:$SG84849
	DD	FLAT:_P_atan2
	DD	FLAT:$SG84850
	DD	FLAT:_P_cos
	DD	FLAT:$SG84851
	DD	FLAT:_P_exp
	DD	FLAT:$SG84852
	DD	FLAT:_P_log
	DD	FLAT:$SG84853
	DD	FLAT:_P_pow
	DD	FLAT:$SG84854
	DD	FLAT:_P_sin
	DD	FLAT:$SG84855
	DD	FLAT:_P_sqrt
	DD	FLAT:$SG84856
	DD	FLAT:_P_tan
	DD	FLAT:$SG84857
	DD	FLAT:_P_nest
	DD	FLAT:$SG84858
	DD	FLAT:_P_exit
	DD	FLAT:$SG84859
	DD	FLAT:_P_dolit
	DD	FLAT:$SG84860
	DD	FLAT:_P_branch
	DD	FLAT:$SG84861
	DD	FLAT:_P_qbranch
	DD	FLAT:$SG84862
	DD	FLAT:_P_if
	DD	FLAT:$SG84863
	DD	FLAT:_P_else
	DD	FLAT:$SG84864
	DD	FLAT:_P_then
	DD	FLAT:$SG84865
	DD	FLAT:_P_qdup
	DD	FLAT:$SG84866
	DD	FLAT:_P_begin
	DD	FLAT:$SG84867
	DD	FLAT:_P_until
	DD	FLAT:$SG84868
	DD	FLAT:_P_again
	DD	FLAT:$SG84869
	DD	FLAT:_P_while
	DD	FLAT:$SG84870
	DD	FLAT:_P_repeat
	DD	FLAT:$SG84871
	DD	FLAT:_P_do
	DD	FLAT:$SG84872
	DD	FLAT:_P_qdo
	DD	FLAT:$SG84873
	DD	FLAT:_P_loop
	DD	FLAT:$SG84874
	DD	FLAT:_P_ploop
	DD	FLAT:$SG84875
	DD	FLAT:_P_xdo
	DD	FLAT:$SG84876
	DD	FLAT:_P_xqdo
	DD	FLAT:$SG84877
	DD	FLAT:_P_xloop
	DD	FLAT:$SG84878
	DD	FLAT:_P_xploop
	DD	FLAT:$SG84879
	DD	FLAT:_P_leave
	DD	FLAT:$SG84880
	DD	FLAT:_P_i
	DD	FLAT:$SG84881
	DD	FLAT:_P_j
	DD	FLAT:$SG84882
	DD	FLAT:_P_quit
	DD	FLAT:$SG84883
	DD	FLAT:_P_abort
	DD	FLAT:$SG84884
	DD	FLAT:_P_abortq
	DD	FLAT:$SG84885
	DD	FLAT:_P_system
	DD	FLAT:$SG84886
	DD	FLAT:_P_trace
	DD	FLAT:$SG84887
	DD	FLAT:_P_walkback
	DD	FLAT:$SG84888
	DD	FLAT:_P_wordsused
	DD	FLAT:$SG84889
	DD	FLAT:_P_wordsunused
	DD	FLAT:$SG84890
	DD	FLAT:_P_colon
	DD	FLAT:$SG84891
	DD	FLAT:_P_semicolon
	DD	FLAT:$SG84892
	DD	FLAT:_P_immediate
	DD	FLAT:$SG84893
	DD	FLAT:_P_lbrack
	DD	FLAT:$SG84894
	DD	FLAT:_P_rbrack
	DD	FLAT:$SG84895
	DD	FLAT:_P_create
	DD	FLAT:$SG84896
	DD	FLAT:_P_forget
	DD	FLAT:$SG84897
	DD	FLAT:_P_does
	DD	FLAT:$SG84898
	DD	FLAT:_P_tick
	DD	FLAT:$SG84899
	DD	FLAT:_P_bracktick
	DD	FLAT:$SG84900
	DD	FLAT:_P_execute
	DD	FLAT:$SG84901
	DD	FLAT:_P_body
	DD	FLAT:$SG84902
	DD	FLAT:_P_state
	DD	FLAT:$SG84903
	DD	FLAT:_P_find
	DD	FLAT:$SG84904
	DD	FLAT:_P_toname
	DD	FLAT:$SG84905
	DD	FLAT:_P_tolink
	DD	FLAT:$SG84906
	DD	FLAT:_P_frombody
	DD	FLAT:$SG84907
	DD	FLAT:_P_fromname
	DD	FLAT:$SG84908
	DD	FLAT:_P_fromlink
	DD	FLAT:$SG84909
	DD	FLAT:_P_nametolink
	DD	FLAT:$SG84910
	DD	FLAT:_P_linktoname
	DD	FLAT:$SG84911
	DD	FLAT:_P_fetchname
	DD	FLAT:$SG84912
	DD	FLAT:_P_storename
	DD	FLAT:$SG84913
	DD	FLAT:_P_brackcompile
	DD	FLAT:$SG84914
	DD	FLAT:_P_literal
	DD	FLAT:$SG84915
	DD	FLAT:_P_compile
	DD	FLAT:$SG84916
	DD	FLAT:_P_backmark
	DD	FLAT:$SG84917
	DD	FLAT:_P_backresolve
	DD	FLAT:$SG84918
	DD	FLAT:_P_fwdmark
	DD	FLAT:$SG84919
	DD	FLAT:_P_fwdresolve
	DD	FLAT:$SG84920
	DD	FLAT:_P_dot
	DD	FLAT:$SG84921
	DD	FLAT:_P_question
	DD	FLAT:$SG84922
	DD	FLAT:_P_cr
	DD	FLAT:$SG84923
	DD	FLAT:_P_dots
	DD	FLAT:$SG84924
	DD	FLAT:_P_dotquote
	DD	FLAT:$SG84925
	DD	FLAT:_P_dotparen
	DD	FLAT:$SG84926
	DD	FLAT:_P_type
	DD	FLAT:$SG84927
	DD	FLAT:_P_words
	DD	FLAT:$SG84928
	DD	FLAT:_P_file
	DD	FLAT:$SG84929
	DD	FLAT:_P_fopen
	DD	FLAT:$SG84930
	DD	FLAT:_P_fclose
	DD	FLAT:$SG84931
	DD	FLAT:_P_fdelete
	DD	FLAT:$SG84932
	DD	FLAT:_P_fgetline
	DD	FLAT:$SG84933
	DD	FLAT:_P_fputline
	DD	FLAT:$SG84934
	DD	FLAT:_P_fread
	DD	FLAT:$SG84935
	DD	FLAT:_P_fwrite
	DD	FLAT:$SG84936
	DD	FLAT:_P_fgetc
	DD	FLAT:$SG84937
	DD	FLAT:_P_fputc
	DD	FLAT:$SG84938
	DD	FLAT:_P_ftell
	DD	FLAT:$SG84939
	DD	FLAT:_P_fseek
	DD	FLAT:$SG84940
	DD	FLAT:_P_fload
	DD	FLAT:$SG84941
	DD	FLAT:_P_evaluate
	DD	00H
	DD	00H
$SG84971 DB	'   %s', 0aH, 00H
	ORG $+1
$SG84977 DB	'   %s', 0aH, 00H
	ORG $+1
$SG84982 DB	0aH, '%s.', 0aH, 00H
	ORG $+2
$SG84987 DB	'Stack overflow', 00H
	ORG $+1
$SG84989 DB	'Stack underflow', 00H
$SG84991 DB	'Return stack overflow', 00H
	ORG $+2
$SG84993 DB	'Return stack underflow', 00H
	ORG $+1
$SG84995 DB	'Heap overflow', 00H
	ORG $+2
$SG84997 DB	'Bad pointer', 00H
$SG84999 DB	'Compiler word outside definition', 00H
	ORG $+3
$SG85001 DB	'Divide by zero', 00H
	ORG $+1
$SG85007 DB	0aH, 'Trace: %s ', 00H
$SG85013 DB	'Break signal', 00H
	ORG $+3
$SG85016 DB	0aH, 'Trace: %s ', 00H
$SG85022 DB	'EXIT', 00H
	ORG $+3
$SG85025 DB	'(LIT)', 00H
	ORG $+2
$SG85028 DB	'(FLIT)', 00H
	ORG $+1
$SG85031 DB	'(STRLIT)', 00H
	ORG $+3
$SG85034 DB	'.(', 00H
	ORG $+1
$SG85037 DB	'?BRANCH', 00H
$SG85040 DB	'BRANCH', 00H
	ORG $+1
$SG85043 DB	'(XDO)', 00H
	ORG $+2
$SG85046 DB	'(X?DO)', 00H
	ORG $+1
$SG85049 DB	'(XLOOP)', 00H
$SG85052 DB	'(+XLOOP)', 00H
	ORG $+3
$SG85055 DB	'ABORT"', 00H
	ORG $+1
$SG85095 DB	'STDIN', 00H
	ORG $+2
$SG85097 DB	'STDOUT', 00H
	ORG $+1
$SG85099 DB	'STDERR', 00H
	ORG $+1
?stdfiles@?8??atl_init@@9@9 DD FLAT:$SG85095		; `atl_init'::`9'::stdfiles
	DD	00H
	DD	FLAT:$SG85097
	DD	00H
	DD	FLAT:$SG85099
	DD	00H
$SG85186 DB	0aH, 'Runaway `('' comment.', 0aH, 00H
	ORG $+1
$SG85196 DB	'STACK ', 00H
	ORG $+1
$SG85197 DB	'RSTACK ', 00H
$SG85198 DB	'HEAP ', 00H
	ORG $+2
$SG85199 DB	'TEMPSTRL ', 00H
	ORG $+2
$SG85200 DB	'TEMPSTRN ', 00H
	ORG $+2
?proname@?1??atl_prologue@@9@9 DD FLAT:$SG85196		; `atl_prologue'::`2'::proname
	DD	FLAT:_atl_stklen
	DD	FLAT:$SG85197
	DD	FLAT:_atl_rstklen
	DD	FLAT:$SG85198
	DD	FLAT:_atl_heaplen
	DD	FLAT:$SG85199
	DD	FLAT:_atl_ltempstr
	DD	FLAT:$SG85200
	DD	FLAT:_atl_ntempstr
$SG85202 DB	'\ *', 00H
$SG85213 DB	'%li', 00H
$SG85240 DB	0aH, 'Forget protected.', 0aH, 00H
$SG85255 DB	' ''%s'' undefined ', 00H
	ORG $+3
$SG85264 DB	' ''%s'' undefined ', 00H
	ORG $+3
$SG85270 DB	0aH, '%s isn''t unique.', 00H
	ORG $+2
$SG85283 DB	' ''%s'' undefined ', 00H
	ORG $+3
$SG85334 DB	'%s', 00H
	ORG $+1
$SG85351 DB	0aH, 'Unknown token type %d', 0aH, 00H
_DATA	ENDS
PUBLIC	_getopt
; Function compile flags: /Odtp
; File c:\a15\facultate\forth\atlast-2.0\getopt.h
_TEXT	SEGMENT
_nargc$ = 8						; size = 4
_nargv$ = 12						; size = 4
_options$ = 16						; size = 4
_getopt	PROC

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 223  : 
; 224  : 	/*
; 225  : 	 * We don't pass FLAG_PERMUTE to getopt_internal() since
; 226  : 	 * the BSD getopt(3) (unlike GNU) has never done this.
; 227  : 	 *
; 228  : 	 * Furthermore, since many privileged programs call getopt()
; 229  : 	 * before dropping privileges it makes sense to keep things
; 230  : 	 * as simple (and bug-free) as possible.
; 231  : 	 */
; 232  : 	return (getopt_internal(nargc, nargv, options, NULL, NULL, 0));

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	6a 00		 push	 0
  00009	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR _nargv$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR _nargc$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _getopt_internal
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 233  : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
_getopt	ENDP
_TEXT	ENDS
EXTRN	_strchr:PROC
EXTRN	_getenv:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_short_too$ = -12					; size = 4
_oli$ = -8						; size = 4
_optchar$ = -4						; size = 4
_nargc$ = 8						; size = 4
_nargv$ = 12						; size = 4
_options$ = 16						; size = 4
_long_options$ = 20					; size = 4
_idx$ = 24						; size = 4
_flags$ = 28						; size = 4
_getopt_internal PROC

; 420  : {

  00020	55		 push	 ebp
  00021	8b ec		 mov	 ebp, esp
  00023	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 421  : 	char *oli;				/* option letter list index */
; 422  : 	int optchar, short_too;
; 423  : 	static int posixly_correct = -1;
; 424  : 
; 425  : 	if (options == NULL)

  00026	83 7d 10 00	 cmp	 DWORD PTR _options$[ebp], 0
  0002a	75 08		 jne	 SHORT $LN54@getopt_int

; 426  : 		return (-1);

  0002c	83 c8 ff	 or	 eax, -1
  0002f	e9 aa 06 00 00	 jmp	 $LN55@getopt_int
$LN54@getopt_int:

; 427  : 
; 428  : 	/*
; 429  : 	 * XXX Some GNU programs (like cvs) set optind to 0 instead of
; 430  : 	 * XXX using optreset.  Work around this braindamage.
; 431  : 	 */
; 432  : 	if (optind == 0)

  00034	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _optind, 0
  0003b	75 14		 jne	 SHORT $LN53@getopt_int

; 433  : 		optind = optreset = 1;

  0003d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ___mingw_optreset, 1
  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR ___mingw_optreset
  0004c	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax
$LN53@getopt_int:

; 434  : 
; 435  : 	/*
; 436  : 	 * Disable GNU extensions if POSIXLY_CORRECT is set or options
; 437  : 	 * string begins with a '+'.
; 438  : 	 *
; 439  : 	 * CV, 2009-12-14: Check POSIXLY_CORRECT anew if optind == 0 or
; 440  : 	 *                 optreset != 0 for GNU compatibility.
; 441  : 	 */
; 442  : 	if (posixly_correct == -1 || optreset != 0)

  00051	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?posixly_correct@?1??getopt_internal@@9@9, -1
  00058	74 09		 je	 SHORT $LN51@getopt_int
  0005a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ___mingw_optreset, 0
  00061	74 18		 je	 SHORT $LN52@getopt_int
$LN51@getopt_int:

; 443  : 		posixly_correct = (getenv("POSIXLY_CORRECT") != NULL);

  00063	68 00 00 00 00	 push	 OFFSET $SG82002
  00068	e8 00 00 00 00	 call	 _getenv
  0006d	83 c4 04	 add	 esp, 4
  00070	f7 d8		 neg	 eax
  00072	1b c0		 sbb	 eax, eax
  00074	f7 d8		 neg	 eax
  00076	a3 00 00 00 00	 mov	 DWORD PTR ?posixly_correct@?1??getopt_internal@@9@9, eax
$LN52@getopt_int:

; 444  : 	if (*options == '-')

  0007b	8b 4d 10	 mov	 ecx, DWORD PTR _options$[ebp]
  0007e	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00081	83 fa 2d	 cmp	 edx, 45			; 0000002dH
  00084	75 0b		 jne	 SHORT $LN50@getopt_int

; 445  : 		flags |= FLAG_ALLARGS;

  00086	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  00089	83 c8 02	 or	 eax, 2
  0008c	89 45 1c	 mov	 DWORD PTR _flags$[ebp], eax
  0008f	eb 1d		 jmp	 SHORT $LN49@getopt_int
$LN50@getopt_int:

; 446  : 	else if (posixly_correct || *options == '+')

  00091	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?posixly_correct@?1??getopt_internal@@9@9, 0
  00098	75 0b		 jne	 SHORT $LN47@getopt_int
  0009a	8b 4d 10	 mov	 ecx, DWORD PTR _options$[ebp]
  0009d	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000a0	83 fa 2b	 cmp	 edx, 43			; 0000002bH
  000a3	75 09		 jne	 SHORT $LN49@getopt_int
$LN47@getopt_int:

; 447  : 		flags &= ~FLAG_PERMUTE;

  000a5	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  000a8	83 e0 fe	 and	 eax, -2			; fffffffeH
  000ab	89 45 1c	 mov	 DWORD PTR _flags$[ebp], eax
$LN49@getopt_int:

; 448  : 	if (*options == '+' || *options == '-')

  000ae	8b 4d 10	 mov	 ecx, DWORD PTR _options$[ebp]
  000b1	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000b4	83 fa 2b	 cmp	 edx, 43			; 0000002bH
  000b7	74 0b		 je	 SHORT $LN45@getopt_int
  000b9	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  000bc	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000bf	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  000c2	75 09		 jne	 SHORT $LN46@getopt_int
$LN45@getopt_int:

; 449  : 		options++;

  000c4	8b 55 10	 mov	 edx, DWORD PTR _options$[ebp]
  000c7	83 c2 01	 add	 edx, 1
  000ca	89 55 10	 mov	 DWORD PTR _options$[ebp], edx
$LN46@getopt_int:

; 450  : 
; 451  : 	optarg = NULL;

  000cd	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _optarg, 0

; 452  : 	if (optreset)

  000d7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ___mingw_optreset, 0
  000de	74 14		 je	 SHORT $start$82011

; 453  : 		nonopt_start = nonopt_end = -1;

  000e0	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _nonopt_end, -1
  000ea	a1 00 00 00 00	 mov	 eax, DWORD PTR _nonopt_end
  000ef	a3 00 00 00 00	 mov	 DWORD PTR _nonopt_start, eax
$start$82011:

; 454  : start:
; 455  : 	if (optreset || !*place) {		/* update scanning pointer */

  000f4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ___mingw_optreset, 0
  000fb	75 11		 jne	 SHORT $LN42@getopt_int
  000fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _place
  00103	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00106	85 d2		 test	 edx, edx
  00108	0f 85 73 02 00
	00		 jne	 $LN43@getopt_int
$LN42@getopt_int:

; 456  : 		optreset = 0;

  0010e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ___mingw_optreset, 0

; 457  : 		if (optind >= nargc) {          /* end of argument vector */

  00118	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  0011d	3b 45 08	 cmp	 eax, DWORD PTR _nargc$[ebp]
  00120	0f 8c 80 00 00
	00		 jl	 $LN41@getopt_int

; 458  : 			place = EMSG;

  00126	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET $SG82015

; 459  : 			if (nonopt_end != -1) {

  00130	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _nonopt_end, -1
  00137	74 3a		 je	 SHORT $LN40@getopt_int

; 460  : 				/* do permutation, if we have to */
; 461  : 				permute_args(nonopt_start, nonopt_end,
; 462  : 				    optind, nargv);

  00139	8b 4d 0c	 mov	 ecx, DWORD PTR _nargv$[ebp]
  0013c	51		 push	 ecx
  0013d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optind
  00143	52		 push	 edx
  00144	a1 00 00 00 00	 mov	 eax, DWORD PTR _nonopt_end
  00149	50		 push	 eax
  0014a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nonopt_start
  00150	51		 push	 ecx
  00151	e8 00 00 00 00	 call	 _permute_args
  00156	83 c4 10	 add	 esp, 16			; 00000010H

; 463  : 				optind -= nonopt_end - nonopt_start;

  00159	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _nonopt_end
  0015f	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _nonopt_start
  00165	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  0016a	2b c2		 sub	 eax, edx
  0016c	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax
  00171	eb 15		 jmp	 SHORT $LN39@getopt_int
$LN40@getopt_int:

; 464  : 			}
; 465  : 			else if (nonopt_start != -1) {

  00173	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _nonopt_start, -1
  0017a	74 0c		 je	 SHORT $LN39@getopt_int

; 466  : 				/*
; 467  : 				 * If we skipped non-options, set optind
; 468  : 				 * to the first of them.
; 469  : 				 */
; 470  : 				optind = nonopt_start;

  0017c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nonopt_start
  00182	89 0d 00 00 00
	00		 mov	 DWORD PTR _optind, ecx
$LN39@getopt_int:

; 471  : 			}
; 472  : 			nonopt_start = nonopt_end = -1;

  00188	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _nonopt_end, -1
  00192	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _nonopt_end
  00198	89 15 00 00 00
	00		 mov	 DWORD PTR _nonopt_start, edx

; 473  : 			return (-1);

  0019e	83 c8 ff	 or	 eax, -1
  001a1	e9 38 05 00 00	 jmp	 $LN55@getopt_int
$LN41@getopt_int:

; 474  : 		}
; 475  : 		if (*(place = nargv[optind]) != '-' ||
; 476  : 		    (place[1] == '\0' && strchr(options, '-') == NULL)) {

  001a6	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  001ab	8b 4d 0c	 mov	 ecx, DWORD PTR _nargv$[ebp]
  001ae	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  001b1	89 15 00 00 00
	00		 mov	 DWORD PTR _place, edx
  001b7	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  001bc	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001bf	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  001c2	75 28		 jne	 SHORT $LN36@getopt_int
  001c4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _place
  001ca	0f be 42 01	 movsx	 eax, BYTE PTR [edx+1]
  001ce	85 c0		 test	 eax, eax
  001d0	0f 85 d6 00 00
	00		 jne	 $LN37@getopt_int
  001d6	6a 2d		 push	 45			; 0000002dH
  001d8	8b 4d 10	 mov	 ecx, DWORD PTR _options$[ebp]
  001db	51		 push	 ecx
  001dc	e8 00 00 00 00	 call	 _strchr
  001e1	83 c4 08	 add	 esp, 8
  001e4	85 c0		 test	 eax, eax
  001e6	0f 85 c0 00 00
	00		 jne	 $LN37@getopt_int
$LN36@getopt_int:

; 477  : 			place = EMSG;		/* found non-option */

  001ec	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET $SG82022

; 478  : 			if (flags & FLAG_ALLARGS) {

  001f6	8b 55 1c	 mov	 edx, DWORD PTR _flags$[ebp]
  001f9	83 e2 02	 and	 edx, 2
  001fc	74 28		 je	 SHORT $LN35@getopt_int

; 479  : 				/*
; 480  : 				 * GNU extension:
; 481  : 				 * return non-option as argument to option 1
; 482  : 				 */
; 483  : 				optarg = nargv[optind++];

  001fe	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  00203	8b 4d 0c	 mov	 ecx, DWORD PTR _nargv$[ebp]
  00206	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00209	89 15 00 00 00
	00		 mov	 DWORD PTR _optarg, edx
  0020f	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  00214	83 c0 01	 add	 eax, 1
  00217	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax

; 484  : 				return (INORDER);

  0021c	b8 01 00 00 00	 mov	 eax, 1
  00221	e9 b8 04 00 00	 jmp	 $LN55@getopt_int
$LN35@getopt_int:

; 485  : 			}
; 486  : 			if (!(flags & FLAG_PERMUTE)) {

  00226	8b 4d 1c	 mov	 ecx, DWORD PTR _flags$[ebp]
  00229	83 e1 01	 and	 ecx, 1
  0022c	75 08		 jne	 SHORT $LN34@getopt_int

; 487  : 				/*
; 488  : 				 * If no permutation wanted, stop parsing
; 489  : 				 * at first non-option.
; 490  : 				 */
; 491  : 				return (-1);

  0022e	83 c8 ff	 or	 eax, -1
  00231	e9 a8 04 00 00	 jmp	 $LN55@getopt_int
$LN34@getopt_int:

; 492  : 			}
; 493  : 			/* do permutation */
; 494  : 			if (nonopt_start == -1)

  00236	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _nonopt_start, -1
  0023d	75 0e		 jne	 SHORT $LN33@getopt_int

; 495  : 				nonopt_start = optind;

  0023f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optind
  00245	89 15 00 00 00
	00		 mov	 DWORD PTR _nonopt_start, edx
  0024b	eb 4d		 jmp	 SHORT $LN32@getopt_int
$LN33@getopt_int:

; 496  : 			else if (nonopt_end != -1) {

  0024d	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _nonopt_end, -1
  00254	74 44		 je	 SHORT $LN32@getopt_int

; 497  : 				permute_args(nonopt_start, nonopt_end,
; 498  : 				    optind, nargv);

  00256	8b 45 0c	 mov	 eax, DWORD PTR _nargv$[ebp]
  00259	50		 push	 eax
  0025a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  00260	51		 push	 ecx
  00261	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _nonopt_end
  00267	52		 push	 edx
  00268	a1 00 00 00 00	 mov	 eax, DWORD PTR _nonopt_start
  0026d	50		 push	 eax
  0026e	e8 00 00 00 00	 call	 _permute_args
  00273	83 c4 10	 add	 esp, 16			; 00000010H

; 499  : 				nonopt_start = optind -
; 500  : 				    (nonopt_end - nonopt_start);

  00276	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nonopt_end
  0027c	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _nonopt_start
  00282	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optind
  00288	2b d1		 sub	 edx, ecx
  0028a	89 15 00 00 00
	00		 mov	 DWORD PTR _nonopt_start, edx

; 501  : 				nonopt_end = -1;

  00290	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _nonopt_end, -1
$LN32@getopt_int:

; 502  : 			}
; 503  : 			optind++;

  0029a	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  0029f	83 c0 01	 add	 eax, 1
  002a2	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax

; 504  : 			/* process next argument */
; 505  : 			goto start;

  002a7	e9 48 fe ff ff	 jmp	 $start$82011
$LN37@getopt_int:

; 506  : 		}
; 507  : 		if (nonopt_start != -1 && nonopt_end == -1)

  002ac	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _nonopt_start, -1
  002b3	74 15		 je	 SHORT $LN30@getopt_int
  002b5	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _nonopt_end, -1
  002bc	75 0c		 jne	 SHORT $LN30@getopt_int

; 508  : 			nonopt_end = optind;

  002be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  002c4	89 0d 00 00 00
	00		 mov	 DWORD PTR _nonopt_end, ecx
$LN30@getopt_int:

; 509  : 
; 510  : 		/*
; 511  : 		 * If we have "-" do nothing, if "--" we are done.
; 512  : 		 */
; 513  : 		if (place[1] != '\0' && *++place == '-' && place[1] == '\0') {

  002ca	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _place
  002d0	0f be 42 01	 movsx	 eax, BYTE PTR [edx+1]
  002d4	85 c0		 test	 eax, eax
  002d6	0f 84 a5 00 00
	00		 je	 $LN43@getopt_int
  002dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _place
  002e2	83 c1 01	 add	 ecx, 1
  002e5	89 0d 00 00 00
	00		 mov	 DWORD PTR _place, ecx
  002eb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _place
  002f1	0f be 02	 movsx	 eax, BYTE PTR [edx]
  002f4	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  002f7	0f 85 84 00 00
	00		 jne	 $LN43@getopt_int
  002fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _place
  00303	0f be 51 01	 movsx	 edx, BYTE PTR [ecx+1]
  00307	85 d2		 test	 edx, edx
  00309	75 76		 jne	 SHORT $LN43@getopt_int

; 514  : 			optind++;

  0030b	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  00310	83 c0 01	 add	 eax, 1
  00313	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax

; 515  : 			place = EMSG;

  00318	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET $SG82031

; 516  : 			/*
; 517  : 			 * We found an option (--), so if we skipped
; 518  : 			 * non-options, we have to permute.
; 519  : 			 */
; 520  : 			if (nonopt_end != -1) {

  00322	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _nonopt_end, -1
  00329	74 38		 je	 SHORT $LN28@getopt_int

; 521  : 				permute_args(nonopt_start, nonopt_end,
; 522  : 				    optind, nargv);

  0032b	8b 4d 0c	 mov	 ecx, DWORD PTR _nargv$[ebp]
  0032e	51		 push	 ecx
  0032f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optind
  00335	52		 push	 edx
  00336	a1 00 00 00 00	 mov	 eax, DWORD PTR _nonopt_end
  0033b	50		 push	 eax
  0033c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nonopt_start
  00342	51		 push	 ecx
  00343	e8 00 00 00 00	 call	 _permute_args
  00348	83 c4 10	 add	 esp, 16			; 00000010H

; 523  : 				optind -= nonopt_end - nonopt_start;

  0034b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _nonopt_end
  00351	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _nonopt_start
  00357	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  0035c	2b c2		 sub	 eax, edx
  0035e	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax
$LN28@getopt_int:

; 524  : 			}
; 525  : 			nonopt_start = nonopt_end = -1;

  00363	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _nonopt_end, -1
  0036d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nonopt_end
  00373	89 0d 00 00 00
	00		 mov	 DWORD PTR _nonopt_start, ecx

; 526  : 			return (-1);

  00379	83 c8 ff	 or	 eax, -1
  0037c	e9 5d 03 00 00	 jmp	 $LN55@getopt_int
$LN43@getopt_int:

; 527  : 		}
; 528  : 	}
; 529  : 
; 530  : 	/*
; 531  : 	 * Check long options if:
; 532  : 	 *  1) we were passed some
; 533  : 	 *  2) the arg is not just "-"
; 534  : 	 *  3) either the arg starts with -- we are getopt_long_only()
; 535  : 	 */
; 536  : 	if (long_options != NULL && place != nargv[optind] &&
; 537  : 	    (*place == '-' || (flags & FLAG_LONGONLY))) {

  00381	83 7d 14 00	 cmp	 DWORD PTR _long_options$[ebp], 0
  00385	0f 84 be 00 00
	00		 je	 $LN27@getopt_int
  0038b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optind
  00391	8b 45 0c	 mov	 eax, DWORD PTR _nargv$[ebp]
  00394	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _place
  0039a	3b 0c 90	 cmp	 ecx, DWORD PTR [eax+edx*4]
  0039d	0f 84 a6 00 00
	00		 je	 $LN27@getopt_int
  003a3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _place
  003a9	0f be 02	 movsx	 eax, BYTE PTR [edx]
  003ac	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  003af	74 0c		 je	 SHORT $LN26@getopt_int
  003b1	8b 4d 1c	 mov	 ecx, DWORD PTR _flags$[ebp]
  003b4	83 e1 04	 and	 ecx, 4
  003b7	0f 84 8c 00 00
	00		 je	 $LN27@getopt_int
$LN26@getopt_int:

; 538  : 		short_too = 0;

  003bd	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _short_too$[ebp], 0

; 539  : 		if (*place == '-')

  003c4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _place
  003ca	0f be 02	 movsx	 eax, BYTE PTR [edx]
  003cd	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  003d0	75 11		 jne	 SHORT $LN25@getopt_int

; 540  : 			place++;		/* --foo long option */

  003d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _place
  003d8	83 c1 01	 add	 ecx, 1
  003db	89 0d 00 00 00
	00		 mov	 DWORD PTR _place, ecx
  003e1	eb 2f		 jmp	 SHORT $LN24@getopt_int
$LN25@getopt_int:

; 541  : 		else if (*place != ':' && strchr(options, *place) != NULL)

  003e3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _place
  003e9	0f be 02	 movsx	 eax, BYTE PTR [edx]
  003ec	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  003ef	74 21		 je	 SHORT $LN24@getopt_int
  003f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _place
  003f7	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  003fa	52		 push	 edx
  003fb	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  003fe	50		 push	 eax
  003ff	e8 00 00 00 00	 call	 _strchr
  00404	83 c4 08	 add	 esp, 8
  00407	85 c0		 test	 eax, eax
  00409	74 07		 je	 SHORT $LN24@getopt_int

; 542  : 			short_too = 1;		/* could be short option too */

  0040b	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _short_too$[ebp], 1
$LN24@getopt_int:

; 543  : 
; 544  : 		optchar = parse_long_options(nargv, options, long_options,
; 545  : 		    idx, short_too);

  00412	8b 4d f4	 mov	 ecx, DWORD PTR _short_too$[ebp]
  00415	51		 push	 ecx
  00416	8b 55 18	 mov	 edx, DWORD PTR _idx$[ebp]
  00419	52		 push	 edx
  0041a	8b 45 14	 mov	 eax, DWORD PTR _long_options$[ebp]
  0041d	50		 push	 eax
  0041e	8b 4d 10	 mov	 ecx, DWORD PTR _options$[ebp]
  00421	51		 push	 ecx
  00422	8b 55 0c	 mov	 edx, DWORD PTR _nargv$[ebp]
  00425	52		 push	 edx
  00426	e8 00 00 00 00	 call	 _parse_long_options
  0042b	83 c4 14	 add	 esp, 20			; 00000014H
  0042e	89 45 fc	 mov	 DWORD PTR _optchar$[ebp], eax

; 546  : 		if (optchar != -1) {

  00431	83 7d fc ff	 cmp	 DWORD PTR _optchar$[ebp], -1
  00435	74 12		 je	 SHORT $LN27@getopt_int

; 547  : 			place = EMSG;

  00437	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET $SG82041

; 548  : 			return (optchar);

  00441	8b 45 fc	 mov	 eax, DWORD PTR _optchar$[ebp]
  00444	e9 95 02 00 00	 jmp	 $LN55@getopt_int
$LN27@getopt_int:

; 549  : 		}
; 550  : 	}
; 551  : 
; 552  : 	if ((optchar = (int)*place++) == (int)':' ||
; 553  : 	    (optchar == (int)'-' && *place != '\0') ||
; 554  : 	    (oli = (char*)strchr(options, optchar)) == NULL) {

  00449	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  0044e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00451	89 4d fc	 mov	 DWORD PTR _optchar$[ebp], ecx
  00454	8b 55 fc	 mov	 edx, DWORD PTR _optchar$[ebp]
  00457	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  0045c	83 c0 01	 add	 eax, 1
  0045f	a3 00 00 00 00	 mov	 DWORD PTR _place, eax
  00464	83 fa 3a	 cmp	 edx, 58			; 0000003aH
  00467	74 2c		 je	 SHORT $LN20@getopt_int
  00469	83 7d fc 2d	 cmp	 DWORD PTR _optchar$[ebp], 45 ; 0000002dH
  0046d	75 0d		 jne	 SHORT $LN19@getopt_int
  0046f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _place
  00475	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00478	85 d2		 test	 edx, edx
  0047a	75 19		 jne	 SHORT $LN20@getopt_int
$LN19@getopt_int:
  0047c	8b 45 fc	 mov	 eax, DWORD PTR _optchar$[ebp]
  0047f	50		 push	 eax
  00480	8b 4d 10	 mov	 ecx, DWORD PTR _options$[ebp]
  00483	51		 push	 ecx
  00484	e8 00 00 00 00	 call	 _strchr
  00489	83 c4 08	 add	 esp, 8
  0048c	89 45 f8	 mov	 DWORD PTR _oli$[ebp], eax
  0048f	83 7d f8 00	 cmp	 DWORD PTR _oli$[ebp], 0
  00493	75 6d		 jne	 SHORT $LN21@getopt_int
$LN20@getopt_int:

; 555  : 		/*
; 556  : 		 * If the user specified "-" and  '-' isn't listed in
; 557  : 		 * options, return -1 (non-option) as per POSIX.
; 558  : 		 * Otherwise, it is an unknown option character (or ':').
; 559  : 		 */
; 560  : 		if (optchar == (int)'-' && *place == '\0')

  00495	83 7d fc 2d	 cmp	 DWORD PTR _optchar$[ebp], 45 ; 0000002dH
  00499	75 15		 jne	 SHORT $LN18@getopt_int
  0049b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _place
  004a1	0f be 02	 movsx	 eax, BYTE PTR [edx]
  004a4	85 c0		 test	 eax, eax
  004a6	75 08		 jne	 SHORT $LN18@getopt_int

; 561  : 			return (-1);

  004a8	83 c8 ff	 or	 eax, -1
  004ab	e9 2e 02 00 00	 jmp	 $LN55@getopt_int
$LN18@getopt_int:

; 562  : 		if (!*place)

  004b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _place
  004b6	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  004b9	85 d2		 test	 edx, edx
  004bb	75 0d		 jne	 SHORT $LN17@getopt_int

; 563  : 			++optind;

  004bd	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  004c2	83 c0 01	 add	 eax, 1
  004c5	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax
$LN17@getopt_int:

; 564  : 		if (PRINT_ERROR)

  004ca	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _opterr, 0
  004d1	74 1c		 je	 SHORT $LN16@getopt_int
  004d3	8b 4d 10	 mov	 ecx, DWORD PTR _options$[ebp]
  004d6	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  004d9	83 fa 3a	 cmp	 edx, 58			; 0000003aH
  004dc	74 11		 je	 SHORT $LN16@getopt_int

; 565  : 			warnx(illoptchar, optchar);

  004de	8b 45 fc	 mov	 eax, DWORD PTR _optchar$[ebp]
  004e1	50		 push	 eax
  004e2	68 00 00 00 00	 push	 OFFSET _illoptchar
  004e7	e8 00 00 00 00	 call	 _warnx
  004ec	83 c4 08	 add	 esp, 8
$LN16@getopt_int:

; 566  : 		optopt = optchar;

  004ef	8b 4d fc	 mov	 ecx, DWORD PTR _optchar$[ebp]
  004f2	89 0d 00 00 00
	00		 mov	 DWORD PTR _optopt, ecx

; 567  : 		return (BADCH);

  004f8	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  004fd	e9 dc 01 00 00	 jmp	 $LN55@getopt_int
$LN21@getopt_int:

; 568  : 	}
; 569  : 	if (long_options != NULL && optchar == 'W' && oli[1] == ';') {

  00502	83 7d 14 00	 cmp	 DWORD PTR _long_options$[ebp], 0
  00506	0f 84 d3 00 00
	00		 je	 $LN15@getopt_int
  0050c	83 7d fc 57	 cmp	 DWORD PTR _optchar$[ebp], 87 ; 00000057H
  00510	0f 85 c9 00 00
	00		 jne	 $LN15@getopt_int
  00516	8b 55 f8	 mov	 edx, DWORD PTR _oli$[ebp]
  00519	0f be 42 01	 movsx	 eax, BYTE PTR [edx+1]
  0051d	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  00520	0f 85 b9 00 00
	00		 jne	 $LN15@getopt_int

; 570  : 		/* -W long-option */
; 571  : 		if (*place)			/* no space */

  00526	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _place
  0052c	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0052f	85 d2		 test	 edx, edx
  00531	74 02		 je	 SHORT $LN14@getopt_int
  00533	eb 7b		 jmp	 SHORT $LN13@getopt_int
$LN14@getopt_int:

; 572  : 			/* NOTHING */;
; 573  : 		else if (++optind >= nargc) {	/* no arg */

  00535	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  0053a	83 c0 01	 add	 eax, 1
  0053d	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax
  00542	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  00548	3b 4d 08	 cmp	 ecx, DWORD PTR _nargc$[ebp]
  0054b	7c 52		 jl	 SHORT $LN12@getopt_int

; 574  : 			place = EMSG;

  0054d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET $SG82060

; 575  : 			if (PRINT_ERROR)

  00557	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _opterr, 0
  0055e	74 1c		 je	 SHORT $LN11@getopt_int
  00560	8b 55 10	 mov	 edx, DWORD PTR _options$[ebp]
  00563	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00566	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00569	74 11		 je	 SHORT $LN11@getopt_int

; 576  : 				warnx(recargchar, optchar);

  0056b	8b 4d fc	 mov	 ecx, DWORD PTR _optchar$[ebp]
  0056e	51		 push	 ecx
  0056f	68 00 00 00 00	 push	 OFFSET _recargchar
  00574	e8 00 00 00 00	 call	 _warnx
  00579	83 c4 08	 add	 esp, 8
$LN11@getopt_int:

; 577  : 			optopt = optchar;

  0057c	8b 55 fc	 mov	 edx, DWORD PTR _optchar$[ebp]
  0057f	89 15 00 00 00
	00		 mov	 DWORD PTR _optopt, edx

; 578  : 			return (BADARG);

  00585	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  00588	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0058b	83 e8 3a	 sub	 eax, 58			; 0000003aH
  0058e	f7 d8		 neg	 eax
  00590	1b c0		 sbb	 eax, eax
  00592	83 e0 05	 and	 eax, 5
  00595	83 c0 3a	 add	 eax, 58			; 0000003aH
  00598	e9 41 01 00 00	 jmp	 $LN55@getopt_int

; 579  : 		} else				/* white space */

  0059d	eb 11		 jmp	 SHORT $LN13@getopt_int
$LN12@getopt_int:

; 580  : 			place = nargv[optind];

  0059f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  005a5	8b 55 0c	 mov	 edx, DWORD PTR _nargv$[ebp]
  005a8	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  005ab	a3 00 00 00 00	 mov	 DWORD PTR _place, eax
$LN13@getopt_int:

; 581  : 		optchar = parse_long_options(nargv, options, long_options,
; 582  : 		    idx, 0);

  005b0	6a 00		 push	 0
  005b2	8b 4d 18	 mov	 ecx, DWORD PTR _idx$[ebp]
  005b5	51		 push	 ecx
  005b6	8b 55 14	 mov	 edx, DWORD PTR _long_options$[ebp]
  005b9	52		 push	 edx
  005ba	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  005bd	50		 push	 eax
  005be	8b 4d 0c	 mov	 ecx, DWORD PTR _nargv$[ebp]
  005c1	51		 push	 ecx
  005c2	e8 00 00 00 00	 call	 _parse_long_options
  005c7	83 c4 14	 add	 esp, 20			; 00000014H
  005ca	89 45 fc	 mov	 DWORD PTR _optchar$[ebp], eax

; 583  : 		place = EMSG;

  005cd	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET $SG82065

; 584  : 		return (optchar);

  005d7	8b 45 fc	 mov	 eax, DWORD PTR _optchar$[ebp]
  005da	e9 ff 00 00 00	 jmp	 $LN55@getopt_int
$LN15@getopt_int:

; 585  : 	}
; 586  : 	if (*++oli != ':') {			/* doesn't take argument */

  005df	8b 55 f8	 mov	 edx, DWORD PTR _oli$[ebp]
  005e2	83 c2 01	 add	 edx, 1
  005e5	89 55 f8	 mov	 DWORD PTR _oli$[ebp], edx
  005e8	8b 45 f8	 mov	 eax, DWORD PTR _oli$[ebp]
  005eb	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  005ee	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  005f1	74 21		 je	 SHORT $LN9@getopt_int

; 587  : 		if (!*place)

  005f3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _place
  005f9	0f be 02	 movsx	 eax, BYTE PTR [edx]
  005fc	85 c0		 test	 eax, eax
  005fe	75 0f		 jne	 SHORT $LN8@getopt_int

; 588  : 			++optind;

  00600	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  00606	83 c1 01	 add	 ecx, 1
  00609	89 0d 00 00 00
	00		 mov	 DWORD PTR _optind, ecx
$LN8@getopt_int:

; 589  : 	} else {				/* takes (optional) argument */

  0060f	e9 c7 00 00 00	 jmp	 $LN7@getopt_int
$LN9@getopt_int:

; 590  : 		optarg = NULL;

  00614	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _optarg, 0

; 591  : 		if (*place)			/* no white space */

  0061e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _place
  00624	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00627	85 c0		 test	 eax, eax
  00629	74 11		 je	 SHORT $LN6@getopt_int

; 592  : 			optarg = place;

  0062b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _place
  00631	89 0d 00 00 00
	00		 mov	 DWORD PTR _optarg, ecx
  00637	e9 86 00 00 00	 jmp	 $LN5@getopt_int
$LN6@getopt_int:

; 593  : 		else if (oli[1] != ':') {	/* arg not optional */

  0063c	8b 55 f8	 mov	 edx, DWORD PTR _oli$[ebp]
  0063f	0f be 42 01	 movsx	 eax, BYTE PTR [edx+1]
  00643	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00646	74 7a		 je	 SHORT $LN5@getopt_int

; 594  : 			if (++optind >= nargc) {	/* no arg */

  00648	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  0064e	83 c1 01	 add	 ecx, 1
  00651	89 0d 00 00 00
	00		 mov	 DWORD PTR _optind, ecx
  00657	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optind
  0065d	3b 55 08	 cmp	 edx, DWORD PTR _nargc$[ebp]
  00660	7c 4e		 jl	 SHORT $LN3@getopt_int

; 595  : 				place = EMSG;

  00662	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET $SG82074

; 596  : 				if (PRINT_ERROR)

  0066c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _opterr, 0
  00673	74 1c		 je	 SHORT $LN2@getopt_int
  00675	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  00678	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0067b	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  0067e	74 11		 je	 SHORT $LN2@getopt_int

; 597  : 					warnx(recargchar, optchar);

  00680	8b 55 fc	 mov	 edx, DWORD PTR _optchar$[ebp]
  00683	52		 push	 edx
  00684	68 00 00 00 00	 push	 OFFSET _recargchar
  00689	e8 00 00 00 00	 call	 _warnx
  0068e	83 c4 08	 add	 esp, 8
$LN2@getopt_int:

; 598  : 				optopt = optchar;

  00691	8b 45 fc	 mov	 eax, DWORD PTR _optchar$[ebp]
  00694	a3 00 00 00 00	 mov	 DWORD PTR _optopt, eax

; 599  : 				return (BADARG);

  00699	8b 4d 10	 mov	 ecx, DWORD PTR _options$[ebp]
  0069c	0f be 01	 movsx	 eax, BYTE PTR [ecx]
  0069f	83 e8 3a	 sub	 eax, 58			; 0000003aH
  006a2	f7 d8		 neg	 eax
  006a4	1b c0		 sbb	 eax, eax
  006a6	83 e0 05	 and	 eax, 5
  006a9	83 c0 3a	 add	 eax, 58			; 0000003aH
  006ac	eb 30		 jmp	 SHORT $LN55@getopt_int

; 600  : 			} else

  006ae	eb 12		 jmp	 SHORT $LN5@getopt_int
$LN3@getopt_int:

; 601  : 				optarg = nargv[optind];

  006b0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optind
  006b6	8b 45 0c	 mov	 eax, DWORD PTR _nargv$[ebp]
  006b9	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  006bc	89 0d 00 00 00
	00		 mov	 DWORD PTR _optarg, ecx
$LN5@getopt_int:

; 602  : 		}
; 603  : 		place = EMSG;

  006c2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET $SG82079

; 604  : 		++optind;

  006cc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optind
  006d2	83 c2 01	 add	 edx, 1
  006d5	89 15 00 00 00
	00		 mov	 DWORD PTR _optind, edx
$LN7@getopt_int:

; 605  : 	}
; 606  : 	/* dump back option letter */
; 607  : 	return (optchar);

  006db	8b 45 fc	 mov	 eax, DWORD PTR _optchar$[ebp]
$LN55@getopt_int:

; 608  : }

  006de	8b e5		 mov	 esp, ebp
  006e0	5d		 pop	 ebp
  006e1	c3		 ret	 0
_getopt_internal ENDP
; Function compile flags: /Odtp
_ap$ = -4						; size = 4
_fmt$ = 8						; size = 4
_warnx	PROC

; 151  : {

  006f0	55		 push	 ebp
  006f1	8b ec		 mov	 ebp, esp
  006f3	51		 push	 ecx

; 152  :   va_list ap;
; 153  :   va_start(ap,fmt);

  006f4	8d 45 0c	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  006f7	89 45 fc	 mov	 DWORD PTR _ap$[ebp], eax

; 154  :   _vwarnx(fmt,ap);

  006fa	8b 4d fc	 mov	 ecx, DWORD PTR _ap$[ebp]
  006fd	51		 push	 ecx
  006fe	8b 55 08	 mov	 edx, DWORD PTR _fmt$[ebp]
  00701	52		 push	 edx
  00702	e8 00 00 00 00	 call	 __vwarnx
  00707	83 c4 08	 add	 esp, 8

; 155  :   va_end(ap);

  0070a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ap$[ebp], 0

; 156  : }

  00711	8b e5		 mov	 esp, ebp
  00713	5d		 pop	 ebp
  00714	c3		 ret	 0
_warnx	ENDP
_TEXT	ENDS
EXTRN	_vfprintf:PROC
EXTRN	_fprintf:PROC
EXTRN	___iob_func:PROC
EXTRN	___argv:DWORD
; Function compile flags: /Odtp
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
_ap$ = 12						; size = 4
__vwarnx PROC

; 142  : {

  00720	55		 push	 ebp
  00721	8b ec		 mov	 ebp, esp

; 143  :   (void)fprintf(stderr,"%s: ",__progname);

  00723	a1 00 00 00 00	 mov	 eax, DWORD PTR ___argv
  00728	8b 08		 mov	 ecx, DWORD PTR [eax]
  0072a	51		 push	 ecx
  0072b	68 00 00 00 00	 push	 OFFSET $SG81845
  00730	e8 00 00 00 00	 call	 ___iob_func
  00735	83 c0 40	 add	 eax, 64			; 00000040H
  00738	50		 push	 eax
  00739	e8 00 00 00 00	 call	 _fprintf
  0073e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 144  :   if (fmt != NULL)

  00741	83 7d 08 00	 cmp	 DWORD PTR _fmt$[ebp], 0
  00745	74 19		 je	 SHORT $LN1@vwarnx

; 145  :     (void)vfprintf(stderr,fmt,ap);

  00747	8b 55 0c	 mov	 edx, DWORD PTR _ap$[ebp]
  0074a	52		 push	 edx
  0074b	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
  0074e	50		 push	 eax
  0074f	e8 00 00 00 00	 call	 ___iob_func
  00754	83 c0 40	 add	 eax, 64			; 00000040H
  00757	50		 push	 eax
  00758	e8 00 00 00 00	 call	 _vfprintf
  0075d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@vwarnx:

; 146  :   (void)fprintf(stderr,"\n");

  00760	68 00 00 00 00	 push	 OFFSET $SG81850
  00765	e8 00 00 00 00	 call	 ___iob_func
  0076a	83 c0 40	 add	 eax, 64			; 00000040H
  0076d	50		 push	 eax
  0076e	e8 00 00 00 00	 call	 _fprintf
  00773	83 c4 08	 add	 esp, 8

; 147  : }

  00776	5d		 pop	 ebp
  00777	c3		 ret	 0
__vwarnx ENDP
; Function compile flags: /Odtp
_j$ = -36						; size = 4
_pos$ = -32						; size = 4
_swap$ = -28						; size = 4
_cyclelen$ = -24					; size = 4
_ncycle$ = -20						; size = 4
_nopts$ = -16						; size = 4
_cstart$ = -12						; size = 4
_i$ = -8						; size = 4
_nnonopts$ = -4						; size = 4
_panonopt_start$ = 8					; size = 4
_panonopt_end$ = 12					; size = 4
_opt_end$ = 16						; size = 4
_nargv$ = 20						; size = 4
_permute_args PROC

; 184  : {

  00780	55		 push	 ebp
  00781	8b ec		 mov	 ebp, esp
  00783	83 ec 24	 sub	 esp, 36			; 00000024H
  00786	56		 push	 esi

; 185  : 	int cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
; 186  : 	char *swap;
; 187  : 
; 188  : 	/*
; 189  : 	 * compute lengths of blocks and number and size of cycles
; 190  : 	 */
; 191  : 	nnonopts = panonopt_end - panonopt_start;

  00787	8b 45 0c	 mov	 eax, DWORD PTR _panonopt_end$[ebp]
  0078a	2b 45 08	 sub	 eax, DWORD PTR _panonopt_start$[ebp]
  0078d	89 45 fc	 mov	 DWORD PTR _nnonopts$[ebp], eax

; 192  : 	nopts = opt_end - panonopt_end;

  00790	8b 4d 10	 mov	 ecx, DWORD PTR _opt_end$[ebp]
  00793	2b 4d 0c	 sub	 ecx, DWORD PTR _panonopt_end$[ebp]
  00796	89 4d f0	 mov	 DWORD PTR _nopts$[ebp], ecx

; 193  : 	ncycle = gcd(nnonopts, nopts);

  00799	8b 55 f0	 mov	 edx, DWORD PTR _nopts$[ebp]
  0079c	52		 push	 edx
  0079d	8b 45 fc	 mov	 eax, DWORD PTR _nnonopts$[ebp]
  007a0	50		 push	 eax
  007a1	e8 00 00 00 00	 call	 _gcd
  007a6	83 c4 08	 add	 esp, 8
  007a9	89 45 ec	 mov	 DWORD PTR _ncycle$[ebp], eax

; 194  : 	cyclelen = (opt_end - panonopt_start) / ncycle;

  007ac	8b 45 10	 mov	 eax, DWORD PTR _opt_end$[ebp]
  007af	2b 45 08	 sub	 eax, DWORD PTR _panonopt_start$[ebp]
  007b2	99		 cdq
  007b3	f7 7d ec	 idiv	 DWORD PTR _ncycle$[ebp]
  007b6	89 45 e8	 mov	 DWORD PTR _cyclelen$[ebp], eax

; 195  : 
; 196  : 	for (i = 0; i < ncycle; i++) {

  007b9	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  007c0	eb 09		 jmp	 SHORT $LN8@permute_ar
$LN7@permute_ar:
  007c2	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  007c5	83 c1 01	 add	 ecx, 1
  007c8	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$LN8@permute_ar:
  007cb	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  007ce	3b 55 ec	 cmp	 edx, DWORD PTR _ncycle$[ebp]
  007d1	7d 76		 jge	 SHORT $LN9@permute_ar

; 197  : 		cstart = panonopt_end+i;

  007d3	8b 45 0c	 mov	 eax, DWORD PTR _panonopt_end$[ebp]
  007d6	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  007d9	89 45 f4	 mov	 DWORD PTR _cstart$[ebp], eax

; 198  : 		pos = cstart;

  007dc	8b 4d f4	 mov	 ecx, DWORD PTR _cstart$[ebp]
  007df	89 4d e0	 mov	 DWORD PTR _pos$[ebp], ecx

; 199  : 		for (j = 0; j < cyclelen; j++) {

  007e2	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  007e9	eb 09		 jmp	 SHORT $LN5@permute_ar
$LN4@permute_ar:
  007eb	8b 55 dc	 mov	 edx, DWORD PTR _j$[ebp]
  007ee	83 c2 01	 add	 edx, 1
  007f1	89 55 dc	 mov	 DWORD PTR _j$[ebp], edx
$LN5@permute_ar:
  007f4	8b 45 dc	 mov	 eax, DWORD PTR _j$[ebp]
  007f7	3b 45 e8	 cmp	 eax, DWORD PTR _cyclelen$[ebp]
  007fa	7d 48		 jge	 SHORT $LN3@permute_ar

; 200  : 			if (pos >= panonopt_end)

  007fc	8b 4d e0	 mov	 ecx, DWORD PTR _pos$[ebp]
  007ff	3b 4d 0c	 cmp	 ecx, DWORD PTR _panonopt_end$[ebp]
  00802	7c 0b		 jl	 SHORT $LN2@permute_ar

; 201  : 				pos -= nnonopts;

  00804	8b 55 e0	 mov	 edx, DWORD PTR _pos$[ebp]
  00807	2b 55 fc	 sub	 edx, DWORD PTR _nnonopts$[ebp]
  0080a	89 55 e0	 mov	 DWORD PTR _pos$[ebp], edx

; 202  : 			else

  0080d	eb 09		 jmp	 SHORT $LN1@permute_ar
$LN2@permute_ar:

; 203  : 				pos += nopts;

  0080f	8b 45 e0	 mov	 eax, DWORD PTR _pos$[ebp]
  00812	03 45 f0	 add	 eax, DWORD PTR _nopts$[ebp]
  00815	89 45 e0	 mov	 DWORD PTR _pos$[ebp], eax
$LN1@permute_ar:

; 204  : 			swap = nargv[pos];

  00818	8b 4d e0	 mov	 ecx, DWORD PTR _pos$[ebp]
  0081b	8b 55 14	 mov	 edx, DWORD PTR _nargv$[ebp]
  0081e	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00821	89 45 e4	 mov	 DWORD PTR _swap$[ebp], eax

; 205  : 			/* LINTED const cast */
; 206  : 			((char **) nargv)[pos] = nargv[cstart];

  00824	8b 4d e0	 mov	 ecx, DWORD PTR _pos$[ebp]
  00827	8b 55 14	 mov	 edx, DWORD PTR _nargv$[ebp]
  0082a	8b 45 f4	 mov	 eax, DWORD PTR _cstart$[ebp]
  0082d	8b 75 14	 mov	 esi, DWORD PTR _nargv$[ebp]
  00830	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
  00833	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 207  : 			/* LINTED const cast */
; 208  : 			((char **)nargv)[cstart] = swap;

  00836	8b 4d f4	 mov	 ecx, DWORD PTR _cstart$[ebp]
  00839	8b 55 14	 mov	 edx, DWORD PTR _nargv$[ebp]
  0083c	8b 45 e4	 mov	 eax, DWORD PTR _swap$[ebp]
  0083f	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 209  : 		}

  00842	eb a7		 jmp	 SHORT $LN4@permute_ar
$LN3@permute_ar:

; 210  : 	}

  00844	e9 79 ff ff ff	 jmp	 $LN7@permute_ar
$LN9@permute_ar:

; 211  : }

  00849	5e		 pop	 esi
  0084a	8b e5		 mov	 esp, ebp
  0084c	5d		 pop	 ebp
  0084d	c3		 ret	 0
_permute_args ENDP
; Function compile flags: /Odtp
_c$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_gcd	PROC

; 163  : {

  00850	55		 push	 ebp
  00851	8b ec		 mov	 ebp, esp
  00853	51		 push	 ecx

; 164  : 	int c;
; 165  : 
; 166  : 	c = a % b;

  00854	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00857	99		 cdq
  00858	f7 7d 0c	 idiv	 DWORD PTR _b$[ebp]
  0085b	89 55 fc	 mov	 DWORD PTR _c$[ebp], edx
$LN2@gcd:

; 167  : 	while (c != 0) {

  0085e	83 7d fc 00	 cmp	 DWORD PTR _c$[ebp], 0
  00862	74 18		 je	 SHORT $LN1@gcd

; 168  : 		a = b;

  00864	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  00867	89 45 08	 mov	 DWORD PTR _a$[ebp], eax

; 169  : 		b = c;

  0086a	8b 4d fc	 mov	 ecx, DWORD PTR _c$[ebp]
  0086d	89 4d 0c	 mov	 DWORD PTR _b$[ebp], ecx

; 170  : 		c = a % b;

  00870	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00873	99		 cdq
  00874	f7 7d 0c	 idiv	 DWORD PTR _b$[ebp]
  00877	89 55 fc	 mov	 DWORD PTR _c$[ebp], edx

; 171  : 	}

  0087a	eb e2		 jmp	 SHORT $LN2@gcd
$LN1@gcd:

; 172  : 
; 173  : 	return (b);

  0087c	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]

; 174  : }

  0087f	8b e5		 mov	 esp, ebp
  00881	5d		 pop	 ebp
  00882	c3		 ret	 0
_gcd	ENDP
_TEXT	ENDS
EXTRN	_strncmp:PROC
EXTRN	_strlen:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_has_equal$ = -24					; size = 4
_match$ = -20						; size = 4
_ambiguous$ = -16					; size = 4
_i$ = -12						; size = 4
_current_argv_len$ = -8					; size = 4
_current_argv$ = -4					; size = 4
_nargv$ = 8						; size = 4
_options$ = 12						; size = 4
_long_options$ = 16					; size = 4
_idx$ = 20						; size = 4
_short_too$ = 24					; size = 4
_parse_long_options PROC

; 292  : {

  00890	55		 push	 ebp
  00891	8b ec		 mov	 ebp, esp
  00893	83 ec 18	 sub	 esp, 24			; 00000018H
  00896	56		 push	 esi

; 293  : 	char *current_argv, *has_equal;
; 294  : 	size_t current_argv_len;
; 295  : 	int i, ambiguous, match;
; 296  : 
; 297  : #define IDENTICAL_INTERPRETATION(_x, _y)                                \
; 298  : 	(long_options[(_x)].has_arg == long_options[(_y)].has_arg &&    \
; 299  : 	 long_options[(_x)].flag == long_options[(_y)].flag &&          \
; 300  : 	 long_options[(_x)].val == long_options[(_y)].val)
; 301  : 
; 302  : 	current_argv = place;

  00897	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  0089c	89 45 fc	 mov	 DWORD PTR _current_argv$[ebp], eax

; 303  : 	match = -1;

  0089f	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _match$[ebp], -1

; 304  : 	ambiguous = 0;

  008a6	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _ambiguous$[ebp], 0

; 305  : 
; 306  : 	optind++;

  008ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  008b3	83 c1 01	 add	 ecx, 1
  008b6	89 0d 00 00 00
	00		 mov	 DWORD PTR _optind, ecx

; 307  : 
; 308  : 	if ((has_equal = strchr(current_argv, '=')) != NULL) {

  008bc	6a 3d		 push	 61			; 0000003dH
  008be	8b 55 fc	 mov	 edx, DWORD PTR _current_argv$[ebp]
  008c1	52		 push	 edx
  008c2	e8 00 00 00 00	 call	 _strchr
  008c7	83 c4 08	 add	 esp, 8
  008ca	89 45 e8	 mov	 DWORD PTR _has_equal$[ebp], eax
  008cd	83 7d e8 00	 cmp	 DWORD PTR _has_equal$[ebp], 0
  008d1	74 14		 je	 SHORT $LN34@parse_long

; 309  : 		/* argument found (--option=arg) */
; 310  : 		current_argv_len = has_equal - current_argv;

  008d3	8b 45 e8	 mov	 eax, DWORD PTR _has_equal$[ebp]
  008d6	2b 45 fc	 sub	 eax, DWORD PTR _current_argv$[ebp]
  008d9	89 45 f8	 mov	 DWORD PTR _current_argv_len$[ebp], eax

; 311  : 		has_equal++;

  008dc	8b 4d e8	 mov	 ecx, DWORD PTR _has_equal$[ebp]
  008df	83 c1 01	 add	 ecx, 1
  008e2	89 4d e8	 mov	 DWORD PTR _has_equal$[ebp], ecx

; 312  : 	} else

  008e5	eb 0f		 jmp	 SHORT $LN33@parse_long
$LN34@parse_long:

; 313  : 		current_argv_len = strlen(current_argv);

  008e7	8b 55 fc	 mov	 edx, DWORD PTR _current_argv$[ebp]
  008ea	52		 push	 edx
  008eb	e8 00 00 00 00	 call	 _strlen
  008f0	83 c4 04	 add	 esp, 4
  008f3	89 45 f8	 mov	 DWORD PTR _current_argv_len$[ebp], eax
$LN33@parse_long:

; 314  : 
; 315  : 	for (i = 0; long_options[i].name; i++) {

  008f6	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  008fd	eb 09		 jmp	 SHORT $LN32@parse_long
$LN31@parse_long:
  008ff	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00902	83 c0 01	 add	 eax, 1
  00905	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN32@parse_long:
  00908	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0090b	c1 e1 04	 shl	 ecx, 4
  0090e	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  00911	83 3c 0a 00	 cmp	 DWORD PTR [edx+ecx], 0
  00915	0f 84 c8 00 00
	00		 je	 $LN30@parse_long

; 316  : 		/* find matching long option */
; 317  : 		if (strncmp(current_argv, long_options[i].name,
; 318  : 		    current_argv_len))

  0091b	8b 45 f8	 mov	 eax, DWORD PTR _current_argv_len$[ebp]
  0091e	50		 push	 eax
  0091f	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00922	c1 e1 04	 shl	 ecx, 4
  00925	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  00928	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0092b	50		 push	 eax
  0092c	8b 4d fc	 mov	 ecx, DWORD PTR _current_argv$[ebp]
  0092f	51		 push	 ecx
  00930	e8 00 00 00 00	 call	 _strncmp
  00935	83 c4 0c	 add	 esp, 12			; 0000000cH
  00938	85 c0		 test	 eax, eax
  0093a	74 02		 je	 SHORT $LN29@parse_long

; 319  : 			continue;

  0093c	eb c1		 jmp	 SHORT $LN31@parse_long
$LN29@parse_long:

; 320  : 
; 321  : 		if (strlen(long_options[i].name) == current_argv_len) {

  0093e	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00941	c1 e2 04	 shl	 edx, 4
  00944	8b 45 10	 mov	 eax, DWORD PTR _long_options$[ebp]
  00947	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  0094a	51		 push	 ecx
  0094b	e8 00 00 00 00	 call	 _strlen
  00950	83 c4 04	 add	 esp, 4
  00953	3b 45 f8	 cmp	 eax, DWORD PTR _current_argv_len$[ebp]
  00956	75 0f		 jne	 SHORT $LN28@parse_long

; 322  : 			/* exact match */
; 323  : 			match = i;

  00958	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  0095b	89 55 ec	 mov	 DWORD PTR _match$[ebp], edx

; 324  : 			ambiguous = 0;

  0095e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _ambiguous$[ebp], 0

; 325  : 			break;

  00965	eb 7c		 jmp	 SHORT $LN30@parse_long
$LN28@parse_long:

; 326  : 		}
; 327  : 		/*
; 328  : 		 * If this is a known short option, don't allow
; 329  : 		 * a partial match of a single character.
; 330  : 		 */
; 331  : 		if (short_too && current_argv_len == 1)

  00967	83 7d 18 00	 cmp	 DWORD PTR _short_too$[ebp], 0
  0096b	74 08		 je	 SHORT $LN27@parse_long
  0096d	83 7d f8 01	 cmp	 DWORD PTR _current_argv_len$[ebp], 1
  00971	75 02		 jne	 SHORT $LN27@parse_long

; 332  : 			continue;

  00973	eb 8a		 jmp	 SHORT $LN31@parse_long
$LN27@parse_long:

; 333  : 
; 334  : 		if (match == -1)	/* partial match */

  00975	83 7d ec ff	 cmp	 DWORD PTR _match$[ebp], -1
  00979	75 08		 jne	 SHORT $LN26@parse_long

; 335  : 			match = i;

  0097b	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0097e	89 45 ec	 mov	 DWORD PTR _match$[ebp], eax
  00981	eb 5b		 jmp	 SHORT $LN25@parse_long
$LN26@parse_long:

; 336  : 		else if (!IDENTICAL_INTERPRETATION(i, match))

  00983	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00986	c1 e1 04	 shl	 ecx, 4
  00989	8b 55 ec	 mov	 edx, DWORD PTR _match$[ebp]
  0098c	c1 e2 04	 shl	 edx, 4
  0098f	8b 45 10	 mov	 eax, DWORD PTR _long_options$[ebp]
  00992	8b 75 10	 mov	 esi, DWORD PTR _long_options$[ebp]
  00995	8b 4c 08 04	 mov	 ecx, DWORD PTR [eax+ecx+4]
  00999	3b 4c 16 04	 cmp	 ecx, DWORD PTR [esi+edx+4]
  0099d	75 38		 jne	 SHORT $LN23@parse_long
  0099f	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  009a2	c1 e2 04	 shl	 edx, 4
  009a5	8b 45 ec	 mov	 eax, DWORD PTR _match$[ebp]
  009a8	c1 e0 04	 shl	 eax, 4
  009ab	8b 4d 10	 mov	 ecx, DWORD PTR _long_options$[ebp]
  009ae	8b 75 10	 mov	 esi, DWORD PTR _long_options$[ebp]
  009b1	8b 54 11 08	 mov	 edx, DWORD PTR [ecx+edx+8]
  009b5	3b 54 06 08	 cmp	 edx, DWORD PTR [esi+eax+8]
  009b9	75 1c		 jne	 SHORT $LN23@parse_long
  009bb	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  009be	c1 e0 04	 shl	 eax, 4
  009c1	8b 4d ec	 mov	 ecx, DWORD PTR _match$[ebp]
  009c4	c1 e1 04	 shl	 ecx, 4
  009c7	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  009ca	8b 75 10	 mov	 esi, DWORD PTR _long_options$[ebp]
  009cd	8b 44 02 0c	 mov	 eax, DWORD PTR [edx+eax+12]
  009d1	3b 44 0e 0c	 cmp	 eax, DWORD PTR [esi+ecx+12]
  009d5	74 07		 je	 SHORT $LN25@parse_long
$LN23@parse_long:

; 337  : 			ambiguous = 1;

  009d7	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _ambiguous$[ebp], 1
$LN25@parse_long:

; 338  : 	}

  009de	e9 1c ff ff ff	 jmp	 $LN31@parse_long
$LN30@parse_long:

; 339  : 	if (ambiguous) {

  009e3	83 7d f0 00	 cmp	 DWORD PTR _ambiguous$[ebp], 0
  009e7	74 3d		 je	 SHORT $LN22@parse_long

; 340  : 		/* ambiguous abbreviation */
; 341  : 		if (PRINT_ERROR)

  009e9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _opterr, 0
  009f0	74 20		 je	 SHORT $LN21@parse_long
  009f2	8b 4d 0c	 mov	 ecx, DWORD PTR _options$[ebp]
  009f5	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  009f8	83 fa 3a	 cmp	 edx, 58			; 0000003aH
  009fb	74 15		 je	 SHORT $LN21@parse_long

; 342  : 			warnx(ambig, (int)current_argv_len,
; 343  : 			     current_argv);

  009fd	8b 45 fc	 mov	 eax, DWORD PTR _current_argv$[ebp]
  00a00	50		 push	 eax
  00a01	8b 4d f8	 mov	 ecx, DWORD PTR _current_argv_len$[ebp]
  00a04	51		 push	 ecx
  00a05	68 00 00 00 00	 push	 OFFSET _ambig
  00a0a	e8 00 00 00 00	 call	 _warnx
  00a0f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN21@parse_long:

; 344  : 		optopt = 0;

  00a12	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _optopt, 0

; 345  : 		return (BADCH);

  00a1c	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  00a21	e9 27 02 00 00	 jmp	 $LN35@parse_long
$LN22@parse_long:

; 346  : 	}
; 347  : 	if (match != -1) {		/* option found */

  00a26	83 7d ec ff	 cmp	 DWORD PTR _match$[ebp], -1
  00a2a	0f 84 7d 01 00
	00		 je	 $LN20@parse_long

; 348  : 		if (long_options[match].has_arg == no_argument
; 349  : 		    && has_equal) {

  00a30	8b 55 ec	 mov	 edx, DWORD PTR _match$[ebp]
  00a33	c1 e2 04	 shl	 edx, 4
  00a36	8b 45 10	 mov	 eax, DWORD PTR _long_options$[ebp]
  00a39	83 7c 10 04 00	 cmp	 DWORD PTR [eax+edx+4], 0
  00a3e	75 75		 jne	 SHORT $LN19@parse_long
  00a40	83 7d e8 00	 cmp	 DWORD PTR _has_equal$[ebp], 0
  00a44	74 6f		 je	 SHORT $LN19@parse_long

; 350  : 			if (PRINT_ERROR)

  00a46	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _opterr, 0
  00a4d	74 20		 je	 SHORT $LN18@parse_long
  00a4f	8b 4d 0c	 mov	 ecx, DWORD PTR _options$[ebp]
  00a52	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00a55	83 fa 3a	 cmp	 edx, 58			; 0000003aH
  00a58	74 15		 je	 SHORT $LN18@parse_long

; 351  : 				warnx(noarg, (int)current_argv_len,
; 352  : 				     current_argv);

  00a5a	8b 45 fc	 mov	 eax, DWORD PTR _current_argv$[ebp]
  00a5d	50		 push	 eax
  00a5e	8b 4d f8	 mov	 ecx, DWORD PTR _current_argv_len$[ebp]
  00a61	51		 push	 ecx
  00a62	68 00 00 00 00	 push	 OFFSET _noarg
  00a67	e8 00 00 00 00	 call	 _warnx
  00a6c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@parse_long:

; 353  : 			/*
; 354  : 			 * XXX: GNU sets optopt to val regardless of flag
; 355  : 			 */
; 356  : 			if (long_options[match].flag == NULL)

  00a6f	8b 55 ec	 mov	 edx, DWORD PTR _match$[ebp]
  00a72	c1 e2 04	 shl	 edx, 4
  00a75	8b 45 10	 mov	 eax, DWORD PTR _long_options$[ebp]
  00a78	83 7c 10 08 00	 cmp	 DWORD PTR [eax+edx+8], 0
  00a7d	75 14		 jne	 SHORT $LN17@parse_long

; 357  : 				optopt = long_options[match].val;

  00a7f	8b 4d ec	 mov	 ecx, DWORD PTR _match$[ebp]
  00a82	c1 e1 04	 shl	 ecx, 4
  00a85	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  00a88	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  00a8c	a3 00 00 00 00	 mov	 DWORD PTR _optopt, eax

; 358  : 			else

  00a91	eb 0a		 jmp	 SHORT $LN16@parse_long
$LN17@parse_long:

; 359  : 				optopt = 0;

  00a93	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _optopt, 0
$LN16@parse_long:

; 360  : 			return (BADARG);

  00a9d	8b 4d 0c	 mov	 ecx, DWORD PTR _options$[ebp]
  00aa0	0f be 01	 movsx	 eax, BYTE PTR [ecx]
  00aa3	83 e8 3a	 sub	 eax, 58			; 0000003aH
  00aa6	f7 d8		 neg	 eax
  00aa8	1b c0		 sbb	 eax, eax
  00aaa	83 e0 05	 and	 eax, 5
  00aad	83 c0 3a	 add	 eax, 58			; 0000003aH
  00ab0	e9 98 01 00 00	 jmp	 $LN35@parse_long
$LN19@parse_long:

; 361  : 		}
; 362  : 		if (long_options[match].has_arg == required_argument ||
; 363  : 		    long_options[match].has_arg == optional_argument) {

  00ab5	8b 55 ec	 mov	 edx, DWORD PTR _match$[ebp]
  00ab8	c1 e2 04	 shl	 edx, 4
  00abb	8b 45 10	 mov	 eax, DWORD PTR _long_options$[ebp]
  00abe	83 7c 10 04 01	 cmp	 DWORD PTR [eax+edx+4], 1
  00ac3	74 10		 je	 SHORT $LN14@parse_long
  00ac5	8b 4d ec	 mov	 ecx, DWORD PTR _match$[ebp]
  00ac8	c1 e1 04	 shl	 ecx, 4
  00acb	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  00ace	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  00ad3	75 3e		 jne	 SHORT $LN15@parse_long
$LN14@parse_long:

; 364  : 			if (has_equal)

  00ad5	83 7d e8 00	 cmp	 DWORD PTR _has_equal$[ebp], 0
  00ad9	74 0a		 je	 SHORT $LN13@parse_long

; 365  : 				optarg = has_equal;

  00adb	8b 45 e8	 mov	 eax, DWORD PTR _has_equal$[ebp]
  00ade	a3 00 00 00 00	 mov	 DWORD PTR _optarg, eax

; 366  : 			else if (long_options[match].has_arg ==

  00ae3	eb 2e		 jmp	 SHORT $LN15@parse_long
$LN13@parse_long:

; 367  : 			    required_argument) {

  00ae5	8b 4d ec	 mov	 ecx, DWORD PTR _match$[ebp]
  00ae8	c1 e1 04	 shl	 ecx, 4
  00aeb	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  00aee	83 7c 0a 04 01	 cmp	 DWORD PTR [edx+ecx+4], 1
  00af3	75 1e		 jne	 SHORT $LN15@parse_long

; 368  : 				/*
; 369  : 				 * optional argument doesn't use next nargv
; 370  : 				 */
; 371  : 				optarg = nargv[optind++];

  00af5	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  00afa	8b 4d 08	 mov	 ecx, DWORD PTR _nargv$[ebp]
  00afd	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00b00	89 15 00 00 00
	00		 mov	 DWORD PTR _optarg, edx
  00b06	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  00b0b	83 c0 01	 add	 eax, 1
  00b0e	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax
$LN15@parse_long:

; 372  : 			}
; 373  : 		}
; 374  : 		if ((long_options[match].has_arg == required_argument)
; 375  : 		    && (optarg == NULL)) {

  00b13	8b 4d ec	 mov	 ecx, DWORD PTR _match$[ebp]
  00b16	c1 e1 04	 shl	 ecx, 4
  00b19	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  00b1c	83 7c 0a 04 01	 cmp	 DWORD PTR [edx+ecx+4], 1
  00b21	0f 85 84 00 00
	00		 jne	 $LN10@parse_long
  00b27	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _optarg, 0
  00b2e	75 7b		 jne	 SHORT $LN10@parse_long

; 376  : 			/*
; 377  : 			 * Missing argument; leading ':' indicates no error
; 378  : 			 * should be generated.
; 379  : 			 */
; 380  : 			if (PRINT_ERROR)

  00b30	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _opterr, 0
  00b37	74 1c		 je	 SHORT $LN9@parse_long
  00b39	8b 45 0c	 mov	 eax, DWORD PTR _options$[ebp]
  00b3c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00b3f	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  00b42	74 11		 je	 SHORT $LN9@parse_long

; 381  : 				warnx(recargstring,
; 382  : 				    current_argv);

  00b44	8b 55 fc	 mov	 edx, DWORD PTR _current_argv$[ebp]
  00b47	52		 push	 edx
  00b48	68 00 00 00 00	 push	 OFFSET _recargstring
  00b4d	e8 00 00 00 00	 call	 _warnx
  00b52	83 c4 08	 add	 esp, 8
$LN9@parse_long:

; 383  : 			/*
; 384  : 			 * XXX: GNU sets optopt to val regardless of flag
; 385  : 			 */
; 386  : 			if (long_options[match].flag == NULL)

  00b55	8b 45 ec	 mov	 eax, DWORD PTR _match$[ebp]
  00b58	c1 e0 04	 shl	 eax, 4
  00b5b	8b 4d 10	 mov	 ecx, DWORD PTR _long_options$[ebp]
  00b5e	83 7c 01 08 00	 cmp	 DWORD PTR [ecx+eax+8], 0
  00b63	75 15		 jne	 SHORT $LN8@parse_long

; 387  : 				optopt = long_options[match].val;

  00b65	8b 55 ec	 mov	 edx, DWORD PTR _match$[ebp]
  00b68	c1 e2 04	 shl	 edx, 4
  00b6b	8b 45 10	 mov	 eax, DWORD PTR _long_options$[ebp]
  00b6e	8b 4c 10 0c	 mov	 ecx, DWORD PTR [eax+edx+12]
  00b72	89 0d 00 00 00
	00		 mov	 DWORD PTR _optopt, ecx

; 388  : 			else

  00b78	eb 0a		 jmp	 SHORT $LN7@parse_long
$LN8@parse_long:

; 389  : 				optopt = 0;

  00b7a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _optopt, 0
$LN7@parse_long:

; 390  : 			--optind;

  00b84	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optind
  00b8a	83 ea 01	 sub	 edx, 1
  00b8d	89 15 00 00 00
	00		 mov	 DWORD PTR _optind, edx

; 391  : 			return (BADARG);

  00b93	8b 45 0c	 mov	 eax, DWORD PTR _options$[ebp]
  00b96	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00b99	83 e8 3a	 sub	 eax, 58			; 0000003aH
  00b9c	f7 d8		 neg	 eax
  00b9e	1b c0		 sbb	 eax, eax
  00ba0	83 e0 05	 and	 eax, 5
  00ba3	83 c0 3a	 add	 eax, 58			; 0000003aH
  00ba6	e9 a2 00 00 00	 jmp	 $LN35@parse_long
$LN10@parse_long:

; 392  : 		}
; 393  : 	} else {			/* unknown option */

  00bab	eb 53		 jmp	 SHORT $LN6@parse_long
$LN20@parse_long:

; 394  : 		if (short_too) {

  00bad	83 7d 18 00	 cmp	 DWORD PTR _short_too$[ebp], 0
  00bb1	74 17		 je	 SHORT $LN5@parse_long

; 395  : 			--optind;

  00bb3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  00bb9	83 e9 01	 sub	 ecx, 1
  00bbc	89 0d 00 00 00
	00		 mov	 DWORD PTR _optind, ecx

; 396  : 			return (-1);

  00bc2	83 c8 ff	 or	 eax, -1
  00bc5	e9 83 00 00 00	 jmp	 $LN35@parse_long
$LN5@parse_long:

; 397  : 		}
; 398  : 		if (PRINT_ERROR)

  00bca	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _opterr, 0
  00bd1	74 1c		 je	 SHORT $LN4@parse_long
  00bd3	8b 55 0c	 mov	 edx, DWORD PTR _options$[ebp]
  00bd6	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00bd9	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00bdc	74 11		 je	 SHORT $LN4@parse_long

; 399  : 			warnx(illoptstring, current_argv);

  00bde	8b 4d fc	 mov	 ecx, DWORD PTR _current_argv$[ebp]
  00be1	51		 push	 ecx
  00be2	68 00 00 00 00	 push	 OFFSET _illoptstring
  00be7	e8 00 00 00 00	 call	 _warnx
  00bec	83 c4 08	 add	 esp, 8
$LN4@parse_long:

; 400  : 		optopt = 0;

  00bef	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _optopt, 0

; 401  : 		return (BADCH);

  00bf9	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  00bfe	eb 4d		 jmp	 SHORT $LN35@parse_long
$LN6@parse_long:

; 402  : 	}
; 403  : 	if (idx)

  00c00	83 7d 14 00	 cmp	 DWORD PTR _idx$[ebp], 0
  00c04	74 08		 je	 SHORT $LN3@parse_long

; 404  : 		*idx = match;

  00c06	8b 55 14	 mov	 edx, DWORD PTR _idx$[ebp]
  00c09	8b 45 ec	 mov	 eax, DWORD PTR _match$[ebp]
  00c0c	89 02		 mov	 DWORD PTR [edx], eax
$LN3@parse_long:

; 405  : 	if (long_options[match].flag) {

  00c0e	8b 4d ec	 mov	 ecx, DWORD PTR _match$[ebp]
  00c11	c1 e1 04	 shl	 ecx, 4
  00c14	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  00c17	83 7c 0a 08 00	 cmp	 DWORD PTR [edx+ecx+8], 0
  00c1c	74 22		 je	 SHORT $LN2@parse_long

; 406  : 		*long_options[match].flag = long_options[match].val;

  00c1e	8b 45 ec	 mov	 eax, DWORD PTR _match$[ebp]
  00c21	c1 e0 04	 shl	 eax, 4
  00c24	8b 4d ec	 mov	 ecx, DWORD PTR _match$[ebp]
  00c27	c1 e1 04	 shl	 ecx, 4
  00c2a	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  00c2d	8b 4c 0a 08	 mov	 ecx, DWORD PTR [edx+ecx+8]
  00c31	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  00c34	8b 44 02 0c	 mov	 eax, DWORD PTR [edx+eax+12]
  00c38	89 01		 mov	 DWORD PTR [ecx], eax

; 407  : 		return (0);

  00c3a	33 c0		 xor	 eax, eax
  00c3c	eb 0f		 jmp	 SHORT $LN35@parse_long

; 408  : 	} else

  00c3e	eb 0d		 jmp	 SHORT $LN35@parse_long
$LN2@parse_long:

; 409  : 		return (long_options[match].val);

  00c40	8b 4d ec	 mov	 ecx, DWORD PTR _match$[ebp]
  00c43	c1 e1 04	 shl	 ecx, 4
  00c46	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  00c49	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
$LN35@parse_long:

; 410  : #undef IDENTICAL_INTERPRETATION
; 411  : }

  00c4d	5e		 pop	 esi
  00c4e	8b e5		 mov	 esp, ebp
  00c50	5d		 pop	 ebp
  00c51	c3		 ret	 0
_parse_long_options ENDP
_TEXT	ENDS
PUBLIC	_getopt_long
; Function compile flags: /Odtp
_TEXT	SEGMENT
_nargc$ = 8						; size = 4
_nargv$ = 12						; size = 4
_options$ = 16						; size = 4
_long_options$ = 20					; size = 4
_idx$ = 24						; size = 4
_getopt_long PROC

; 617  : {

  00c60	55		 push	 ebp
  00c61	8b ec		 mov	 ebp, esp

; 618  : 
; 619  : 	return (getopt_internal(nargc, nargv, options, long_options, idx,
; 620  : 	    FLAG_PERMUTE));

  00c63	6a 01		 push	 1
  00c65	8b 45 18	 mov	 eax, DWORD PTR _idx$[ebp]
  00c68	50		 push	 eax
  00c69	8b 4d 14	 mov	 ecx, DWORD PTR _long_options$[ebp]
  00c6c	51		 push	 ecx
  00c6d	8b 55 10	 mov	 edx, DWORD PTR _options$[ebp]
  00c70	52		 push	 edx
  00c71	8b 45 0c	 mov	 eax, DWORD PTR _nargv$[ebp]
  00c74	50		 push	 eax
  00c75	8b 4d 08	 mov	 ecx, DWORD PTR _nargc$[ebp]
  00c78	51		 push	 ecx
  00c79	e8 00 00 00 00	 call	 _getopt_internal
  00c7e	83 c4 18	 add	 esp, 24			; 00000018H

; 621  : }

  00c81	5d		 pop	 ebp
  00c82	c3		 ret	 0
_getopt_long ENDP
_TEXT	ENDS
PUBLIC	_getopt_long_only
; Function compile flags: /Odtp
_TEXT	SEGMENT
_nargc$ = 8						; size = 4
_nargv$ = 12						; size = 4
_options$ = 16						; size = 4
_long_options$ = 20					; size = 4
_idx$ = 24						; size = 4
_getopt_long_only PROC

; 630  : {

  00c90	55		 push	 ebp
  00c91	8b ec		 mov	 ebp, esp

; 631  : 
; 632  : 	return (getopt_internal(nargc, nargv, options, long_options, idx,
; 633  : 	    FLAG_PERMUTE|FLAG_LONGONLY));

  00c93	6a 05		 push	 5
  00c95	8b 45 18	 mov	 eax, DWORD PTR _idx$[ebp]
  00c98	50		 push	 eax
  00c99	8b 4d 14	 mov	 ecx, DWORD PTR _long_options$[ebp]
  00c9c	51		 push	 ecx
  00c9d	8b 55 10	 mov	 edx, DWORD PTR _options$[ebp]
  00ca0	52		 push	 edx
  00ca1	8b 45 0c	 mov	 eax, DWORD PTR _nargv$[ebp]
  00ca4	50		 push	 eax
  00ca5	8b 4d 08	 mov	 ecx, DWORD PTR _nargc$[ebp]
  00ca8	51		 push	 ecx
  00ca9	e8 00 00 00 00	 call	 _getopt_internal
  00cae	83 c4 18	 add	 esp, 24			; 00000018H

; 634  : }

  00cb1	5d		 pop	 ebp
  00cb2	c3		 ret	 0
_getopt_long_only ENDP
_TEXT	ENDS
_BSS	SEGMENT
_stk	DD	01H DUP (?)
; Function compile flags: /Odtp
; File c:\a15\facultate\forth\atlast-2.0\atlast.c
_BSS	ENDS
_TEXT	SEGMENT
_P_plus	PROC

; 587  : {

  00cc0	55		 push	 ebp
  00cc1	8b ec		 mov	 ebp, esp

; 588  :     Sl(2);

  00cc3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00cc8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00cce	c1 f8 03	 sar	 eax, 3
  00cd1	83 f8 02	 cmp	 eax, 2
  00cd4	7d 07		 jge	 SHORT $LN1@P_plus
  00cd6	e8 00 00 00 00	 call	 _stakunder
  00cdb	eb 31		 jmp	 SHORT $LN2@P_plus
$LN1@P_plus:

; 589  : /* printf("PLUS %lx + %lx = %lx\n", S1, S0, (S1 + S0)); */
; 590  :     S1 += S0;

  00cdd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00ce3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00ce9	8b 41 f0	 mov	 eax, DWORD PTR [ecx-16]
  00cec	03 42 f8	 add	 eax, DWORD PTR [edx-8]
  00cef	8b 49 f4	 mov	 ecx, DWORD PTR [ecx-12]
  00cf2	13 4a fc	 adc	 ecx, DWORD PTR [edx-4]
  00cf5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00cfb	89 42 f0	 mov	 DWORD PTR [edx-16], eax
  00cfe	89 4a f4	 mov	 DWORD PTR [edx-12], ecx

; 591  :     Pop;

  00d01	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00d06	83 e8 08	 sub	 eax, 8
  00d09	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_plus:

; 592  : }

  00d0e	5d		 pop	 ebp
  00d0f	c3		 ret	 0
_P_plus	ENDP
; Function compile flags: /Odtp
_P_minus PROC

; 595  : {

  00d10	55		 push	 ebp
  00d11	8b ec		 mov	 ebp, esp

; 596  :     Sl(2);

  00d13	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00d18	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00d1e	c1 f8 03	 sar	 eax, 3
  00d21	83 f8 02	 cmp	 eax, 2
  00d24	7d 07		 jge	 SHORT $LN1@P_minus
  00d26	e8 00 00 00 00	 call	 _stakunder
  00d2b	eb 31		 jmp	 SHORT $LN2@P_minus
$LN1@P_minus:

; 597  :     S1 -= S0;

  00d2d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00d33	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00d39	8b 41 f0	 mov	 eax, DWORD PTR [ecx-16]
  00d3c	2b 42 f8	 sub	 eax, DWORD PTR [edx-8]
  00d3f	8b 49 f4	 mov	 ecx, DWORD PTR [ecx-12]
  00d42	1b 4a fc	 sbb	 ecx, DWORD PTR [edx-4]
  00d45	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00d4b	89 42 f0	 mov	 DWORD PTR [edx-16], eax
  00d4e	89 4a f4	 mov	 DWORD PTR [edx-12], ecx

; 598  :     Pop;

  00d51	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00d56	83 e8 08	 sub	 eax, 8
  00d59	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_minus:

; 599  : }

  00d5e	5d		 pop	 ebp
  00d5f	c3		 ret	 0
_P_minus ENDP
_TEXT	ENDS
EXTRN	__allmul:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_times PROC

; 602  : {

  00d60	55		 push	 ebp
  00d61	8b ec		 mov	 ebp, esp

; 603  :     Sl(2);

  00d63	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00d68	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00d6e	c1 f8 03	 sar	 eax, 3
  00d71	83 f8 02	 cmp	 eax, 2
  00d74	7d 07		 jge	 SHORT $LN1@P_times
  00d76	e8 00 00 00 00	 call	 _stakunder
  00d7b	eb 3c		 jmp	 SHORT $LN2@P_times
$LN1@P_times:

; 604  :     S1 *= S0;

  00d7d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00d83	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00d89	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  00d8c	50		 push	 eax
  00d8d	8b 52 f8	 mov	 edx, DWORD PTR [edx-8]
  00d90	52		 push	 edx
  00d91	8b 41 f4	 mov	 eax, DWORD PTR [ecx-12]
  00d94	50		 push	 eax
  00d95	8b 49 f0	 mov	 ecx, DWORD PTR [ecx-16]
  00d98	51		 push	 ecx
  00d99	e8 00 00 00 00	 call	 __allmul
  00d9e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00da4	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  00da7	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 605  :     Pop;

  00daa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00db0	83 ea 08	 sub	 edx, 8
  00db3	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN2@P_times:

; 606  : }

  00db9	5d		 pop	 ebp
  00dba	c3		 ret	 0
_P_times ENDP
_TEXT	ENDS
EXTRN	__alldiv:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv76 = -4						; size = 4
_P_div	PROC

; 609  : {

  00dc0	55		 push	 ebp
  00dc1	8b ec		 mov	 ebp, esp
  00dc3	51		 push	 ecx

; 610  :     Sl(2);

  00dc4	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00dc9	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00dcf	c1 f8 03	 sar	 eax, 3
  00dd2	83 f8 02	 cmp	 eax, 2
  00dd5	7d 07		 jge	 SHORT $LN2@P_div
  00dd7	e8 00 00 00 00	 call	 _stakunder
  00ddc	eb 59		 jmp	 SHORT $LN3@P_div
$LN2@P_div:

; 611  : #ifndef NOMEMCHECK
; 612  :     if (S0 == 0) {

  00dde	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00de4	89 4d fc	 mov	 DWORD PTR tv76[ebp], ecx
  00de7	8b 55 fc	 mov	 edx, DWORD PTR tv76[ebp]
  00dea	8b 45 fc	 mov	 eax, DWORD PTR tv76[ebp]
  00ded	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00df0	0b 48 fc	 or	 ecx, DWORD PTR [eax-4]
  00df3	75 07		 jne	 SHORT $LN1@P_div

; 613  : 	divzero();

  00df5	e8 00 00 00 00	 call	 _divzero

; 614  : 	return;

  00dfa	eb 3b		 jmp	 SHORT $LN3@P_div
$LN1@P_div:

; 615  :     }
; 616  : #endif /* NOMEMCHECK */
; 617  :     S1 /= S0;

  00dfc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00e02	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00e07	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00e0a	51		 push	 ecx
  00e0b	8b 40 f8	 mov	 eax, DWORD PTR [eax-8]
  00e0e	50		 push	 eax
  00e0f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00e12	51		 push	 ecx
  00e13	8b 52 f0	 mov	 edx, DWORD PTR [edx-16]
  00e16	52		 push	 edx
  00e17	e8 00 00 00 00	 call	 __alldiv
  00e1c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00e22	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  00e25	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 618  :     Pop;

  00e28	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00e2e	83 ea 08	 sub	 edx, 8
  00e31	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN3@P_div:

; 619  : }

  00e37	8b e5		 mov	 esp, ebp
  00e39	5d		 pop	 ebp
  00e3a	c3		 ret	 0
_P_div	ENDP
_TEXT	ENDS
EXTRN	__allrem:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv76 = -4						; size = 4
_P_mod	PROC

; 622  : {

  00e40	55		 push	 ebp
  00e41	8b ec		 mov	 ebp, esp
  00e43	51		 push	 ecx

; 623  :     Sl(2);

  00e44	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00e49	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00e4f	c1 f8 03	 sar	 eax, 3
  00e52	83 f8 02	 cmp	 eax, 2
  00e55	7d 07		 jge	 SHORT $LN2@P_mod
  00e57	e8 00 00 00 00	 call	 _stakunder
  00e5c	eb 59		 jmp	 SHORT $LN3@P_mod
$LN2@P_mod:

; 624  : #ifndef NOMEMCHECK
; 625  :     if (S0 == 0) {

  00e5e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00e64	89 4d fc	 mov	 DWORD PTR tv76[ebp], ecx
  00e67	8b 55 fc	 mov	 edx, DWORD PTR tv76[ebp]
  00e6a	8b 45 fc	 mov	 eax, DWORD PTR tv76[ebp]
  00e6d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00e70	0b 48 fc	 or	 ecx, DWORD PTR [eax-4]
  00e73	75 07		 jne	 SHORT $LN1@P_mod

; 626  : 	divzero();

  00e75	e8 00 00 00 00	 call	 _divzero

; 627  : 	return;

  00e7a	eb 3b		 jmp	 SHORT $LN3@P_mod
$LN1@P_mod:

; 628  :     }
; 629  : #endif /* NOMEMCHECK */
; 630  :     S1 %= S0;

  00e7c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00e82	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00e87	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00e8a	51		 push	 ecx
  00e8b	8b 40 f8	 mov	 eax, DWORD PTR [eax-8]
  00e8e	50		 push	 eax
  00e8f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00e92	51		 push	 ecx
  00e93	8b 52 f0	 mov	 edx, DWORD PTR [edx-16]
  00e96	52		 push	 edx
  00e97	e8 00 00 00 00	 call	 __allrem
  00e9c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00ea2	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  00ea5	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 631  :     Pop;

  00ea8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00eae	83 ea 08	 sub	 edx, 8
  00eb1	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN3@P_mod:

; 632  : }

  00eb7	8b e5		 mov	 esp, ebp
  00eb9	5d		 pop	 ebp
  00eba	c3		 ret	 0
_P_mod	ENDP
; Function compile flags: /Odtp
tv79 = -12						; size = 4
_quot$ = -8						; size = 8
_P_divmod PROC

; 635  : {

  00ec0	55		 push	 ebp
  00ec1	8b ec		 mov	 ebp, esp
  00ec3	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 636  :     stackitem quot;
; 637  : 
; 638  :     Sl(2);

  00ec6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00ecb	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00ed1	c1 f8 03	 sar	 eax, 3
  00ed4	83 f8 02	 cmp	 eax, 2
  00ed7	7d 0a		 jge	 SHORT $LN2@P_divmod
  00ed9	e8 00 00 00 00	 call	 _stakunder
  00ede	e9 82 00 00 00	 jmp	 $LN3@P_divmod
$LN2@P_divmod:

; 639  : #ifndef NOMEMCHECK
; 640  :     if (S0 == 0) {

  00ee3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00ee9	89 4d f4	 mov	 DWORD PTR tv79[ebp], ecx
  00eec	8b 55 f4	 mov	 edx, DWORD PTR tv79[ebp]
  00eef	8b 45 f4	 mov	 eax, DWORD PTR tv79[ebp]
  00ef2	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00ef5	0b 48 fc	 or	 ecx, DWORD PTR [eax-4]
  00ef8	75 07		 jne	 SHORT $LN1@P_divmod

; 641  : 	divzero();

  00efa	e8 00 00 00 00	 call	 _divzero

; 642  : 	return;

  00eff	eb 64		 jmp	 SHORT $LN3@P_divmod
$LN1@P_divmod:

; 643  :     }
; 644  : #endif /* NOMEMCHECK */
; 645  :     quot = S1 / S0;

  00f01	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00f07	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00f0c	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00f0f	51		 push	 ecx
  00f10	8b 40 f8	 mov	 eax, DWORD PTR [eax-8]
  00f13	50		 push	 eax
  00f14	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00f17	51		 push	 ecx
  00f18	8b 52 f0	 mov	 edx, DWORD PTR [edx-16]
  00f1b	52		 push	 edx
  00f1c	e8 00 00 00 00	 call	 __alldiv
  00f21	89 45 f8	 mov	 DWORD PTR _quot$[ebp], eax
  00f24	89 55 fc	 mov	 DWORD PTR _quot$[ebp+4], edx

; 646  :     S1 %= S0;

  00f27	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00f2c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00f32	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  00f35	52		 push	 edx
  00f36	8b 49 f8	 mov	 ecx, DWORD PTR [ecx-8]
  00f39	51		 push	 ecx
  00f3a	8b 50 f4	 mov	 edx, DWORD PTR [eax-12]
  00f3d	52		 push	 edx
  00f3e	8b 40 f0	 mov	 eax, DWORD PTR [eax-16]
  00f41	50		 push	 eax
  00f42	e8 00 00 00 00	 call	 __allrem
  00f47	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00f4d	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  00f50	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 647  :     S0 = quot;

  00f53	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00f59	8b 45 f8	 mov	 eax, DWORD PTR _quot$[ebp]
  00f5c	89 42 f8	 mov	 DWORD PTR [edx-8], eax
  00f5f	8b 4d fc	 mov	 ecx, DWORD PTR _quot$[ebp+4]
  00f62	89 4a fc	 mov	 DWORD PTR [edx-4], ecx
$LN3@P_divmod:

; 648  : }

  00f65	8b e5		 mov	 esp, ebp
  00f67	5d		 pop	 ebp
  00f68	c3		 ret	 0
_P_divmod ENDP
; Function compile flags: /Odtp
tv73 = -16						; size = 8
tv79 = -8						; size = 4
tv78 = -4						; size = 4
_P_min	PROC

; 651  : {

  00f70	55		 push	 ebp
  00f71	8b ec		 mov	 ebp, esp
  00f73	83 ec 10	 sub	 esp, 16			; 00000010H

; 652  :     Sl(2);

  00f76	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00f7b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  00f81	c1 f8 03	 sar	 eax, 3
  00f84	83 f8 02	 cmp	 eax, 2
  00f87	7d 07		 jge	 SHORT $LN1@P_min
  00f89	e8 00 00 00 00	 call	 _stakunder
  00f8e	eb 72		 jmp	 SHORT $LN2@P_min
$LN1@P_min:

; 653  :     S1 = min(S1, S0);

  00f90	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  00f96	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  00f9c	89 4d fc	 mov	 DWORD PTR tv78[ebp], ecx
  00f9f	89 55 f8	 mov	 DWORD PTR tv79[ebp], edx
  00fa2	8b 45 fc	 mov	 eax, DWORD PTR tv78[ebp]
  00fa5	8b 4d f8	 mov	 ecx, DWORD PTR tv79[ebp]
  00fa8	8b 50 f4	 mov	 edx, DWORD PTR [eax-12]
  00fab	3b 51 fc	 cmp	 edx, DWORD PTR [ecx-4]
  00fae	7f 23		 jg	 SHORT $LN4@P_min
  00fb0	7c 0e		 jl	 SHORT $LN6@P_min
  00fb2	8b 45 fc	 mov	 eax, DWORD PTR tv78[ebp]
  00fb5	8b 4d f8	 mov	 ecx, DWORD PTR tv79[ebp]
  00fb8	8b 50 f0	 mov	 edx, DWORD PTR [eax-16]
  00fbb	3b 51 f8	 cmp	 edx, DWORD PTR [ecx-8]
  00fbe	77 13		 ja	 SHORT $LN4@P_min
$LN6@P_min:
  00fc0	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00fc5	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00fc8	89 4d f0	 mov	 DWORD PTR tv73[ebp], ecx
  00fcb	8b 50 f4	 mov	 edx, DWORD PTR [eax-12]
  00fce	89 55 f4	 mov	 DWORD PTR tv73[ebp+4], edx
  00fd1	eb 11		 jmp	 SHORT $LN5@P_min
$LN4@P_min:
  00fd3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00fd8	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00fdb	89 4d f0	 mov	 DWORD PTR tv73[ebp], ecx
  00fde	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00fe1	89 55 f4	 mov	 DWORD PTR tv73[ebp+4], edx
$LN5@P_min:
  00fe4	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00fe9	8b 4d f0	 mov	 ecx, DWORD PTR tv73[ebp]
  00fec	89 48 f0	 mov	 DWORD PTR [eax-16], ecx
  00fef	8b 55 f4	 mov	 edx, DWORD PTR tv73[ebp+4]
  00ff2	89 50 f4	 mov	 DWORD PTR [eax-12], edx

; 654  :     Pop;

  00ff5	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  00ffa	83 e8 08	 sub	 eax, 8
  00ffd	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_min:

; 655  : }

  01002	8b e5		 mov	 esp, ebp
  01004	5d		 pop	 ebp
  01005	c3		 ret	 0
_P_min	ENDP
; Function compile flags: /Odtp
tv73 = -16						; size = 8
tv79 = -8						; size = 4
tv78 = -4						; size = 4
_P_max	PROC

; 658  : {

  01010	55		 push	 ebp
  01011	8b ec		 mov	 ebp, esp
  01013	83 ec 10	 sub	 esp, 16			; 00000010H

; 659  :     Sl(2);

  01016	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0101b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  01021	c1 f8 03	 sar	 eax, 3
  01024	83 f8 02	 cmp	 eax, 2
  01027	7d 07		 jge	 SHORT $LN1@P_max
  01029	e8 00 00 00 00	 call	 _stakunder
  0102e	eb 72		 jmp	 SHORT $LN2@P_max
$LN1@P_max:

; 660  :     S1 = max(S1, S0);

  01030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01036	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0103c	89 4d fc	 mov	 DWORD PTR tv78[ebp], ecx
  0103f	89 55 f8	 mov	 DWORD PTR tv79[ebp], edx
  01042	8b 45 fc	 mov	 eax, DWORD PTR tv78[ebp]
  01045	8b 4d f8	 mov	 ecx, DWORD PTR tv79[ebp]
  01048	8b 50 f4	 mov	 edx, DWORD PTR [eax-12]
  0104b	3b 51 fc	 cmp	 edx, DWORD PTR [ecx-4]
  0104e	7c 23		 jl	 SHORT $LN4@P_max
  01050	7f 0e		 jg	 SHORT $LN6@P_max
  01052	8b 45 fc	 mov	 eax, DWORD PTR tv78[ebp]
  01055	8b 4d f8	 mov	 ecx, DWORD PTR tv79[ebp]
  01058	8b 50 f0	 mov	 edx, DWORD PTR [eax-16]
  0105b	3b 51 f8	 cmp	 edx, DWORD PTR [ecx-8]
  0105e	76 13		 jbe	 SHORT $LN4@P_max
$LN6@P_max:
  01060	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01065	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  01068	89 4d f0	 mov	 DWORD PTR tv73[ebp], ecx
  0106b	8b 50 f4	 mov	 edx, DWORD PTR [eax-12]
  0106e	89 55 f4	 mov	 DWORD PTR tv73[ebp+4], edx
  01071	eb 11		 jmp	 SHORT $LN5@P_max
$LN4@P_max:
  01073	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01078	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0107b	89 4d f0	 mov	 DWORD PTR tv73[ebp], ecx
  0107e	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  01081	89 55 f4	 mov	 DWORD PTR tv73[ebp+4], edx
$LN5@P_max:
  01084	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01089	8b 4d f0	 mov	 ecx, DWORD PTR tv73[ebp]
  0108c	89 48 f0	 mov	 DWORD PTR [eax-16], ecx
  0108f	8b 55 f4	 mov	 edx, DWORD PTR tv73[ebp+4]
  01092	89 50 f4	 mov	 DWORD PTR [eax-12], edx

; 661  :     Pop;

  01095	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0109a	83 e8 08	 sub	 eax, 8
  0109d	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_max:

; 662  : }

  010a2	8b e5		 mov	 esp, ebp
  010a4	5d		 pop	 ebp
  010a5	c3		 ret	 0
_P_max	ENDP
; Function compile flags: /Odtp
_P_neg	PROC

; 665  : {

  010b0	55		 push	 ebp
  010b1	8b ec		 mov	 ebp, esp

; 666  :     Sl(1);

  010b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  010b8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  010be	c1 f8 03	 sar	 eax, 3
  010c1	83 f8 01	 cmp	 eax, 1
  010c4	7d 07		 jge	 SHORT $LN1@P_neg
  010c6	e8 00 00 00 00	 call	 _stakunder
  010cb	eb 1f		 jmp	 SHORT $LN2@P_neg
$LN1@P_neg:

; 667  :     S0 = - S0;

  010cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  010d3	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  010d6	f7 da		 neg	 edx
  010d8	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  010db	83 d0 00	 adc	 eax, 0
  010de	f7 d8		 neg	 eax
  010e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  010e6	89 51 f8	 mov	 DWORD PTR [ecx-8], edx
  010e9	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN2@P_neg:

; 668  : }

  010ec	5d		 pop	 ebp
  010ed	c3		 ret	 0
_P_neg	ENDP
; Function compile flags: /Odtp
tv73 = -12						; size = 8
tv76 = -4						; size = 4
_P_abs	PROC

; 671  : {

  010f0	55		 push	 ebp
  010f1	8b ec		 mov	 ebp, esp
  010f3	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 672  :     Sl(1);

  010f6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  010fb	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  01101	c1 f8 03	 sar	 eax, 3
  01104	83 f8 01	 cmp	 eax, 1
  01107	7d 07		 jge	 SHORT $LN1@P_abs
  01109	e8 00 00 00 00	 call	 _stakunder
  0110e	eb 5c		 jmp	 SHORT $LN2@P_abs
$LN1@P_abs:

; 673  :     S0 = abs(S0);

  01110	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01116	89 4d fc	 mov	 DWORD PTR tv76[ebp], ecx
  01119	8b 55 fc	 mov	 edx, DWORD PTR tv76[ebp]
  0111c	83 7a fc 00	 cmp	 DWORD PTR [edx-4], 0
  01120	7f 26		 jg	 SHORT $LN4@P_abs
  01122	7c 09		 jl	 SHORT $LN6@P_abs
  01124	8b 45 fc	 mov	 eax, DWORD PTR tv76[ebp]
  01127	83 78 f8 00	 cmp	 DWORD PTR [eax-8], 0
  0112b	73 1b		 jae	 SHORT $LN4@P_abs
$LN6@P_abs:
  0112d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01133	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  01136	f7 da		 neg	 edx
  01138	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0113b	83 d0 00	 adc	 eax, 0
  0113e	f7 d8		 neg	 eax
  01140	89 55 f4	 mov	 DWORD PTR tv73[ebp], edx
  01143	89 45 f8	 mov	 DWORD PTR tv73[ebp+4], eax
  01146	eb 12		 jmp	 SHORT $LN5@P_abs
$LN4@P_abs:
  01148	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0114e	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  01151	89 55 f4	 mov	 DWORD PTR tv73[ebp], edx
  01154	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  01157	89 45 f8	 mov	 DWORD PTR tv73[ebp+4], eax
$LN5@P_abs:
  0115a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01160	8b 55 f4	 mov	 edx, DWORD PTR tv73[ebp]
  01163	89 51 f8	 mov	 DWORD PTR [ecx-8], edx
  01166	8b 45 f8	 mov	 eax, DWORD PTR tv73[ebp+4]
  01169	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN2@P_abs:

; 674  : }

  0116c	8b e5		 mov	 esp, ebp
  0116e	5d		 pop	 ebp
  0116f	c3		 ret	 0
_P_abs	ENDP
; Function compile flags: /Odtp
tv71 = -12						; size = 4
tv78 = -8						; size = 4
tv77 = -4						; size = 4
_P_equal PROC

; 677  : {

  01170	55		 push	 ebp
  01171	8b ec		 mov	 ebp, esp
  01173	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 678  :     Sl(2);

  01176	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0117b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  01181	c1 f8 03	 sar	 eax, 3
  01184	83 f8 02	 cmp	 eax, 2
  01187	7d 07		 jge	 SHORT $LN1@P_equal
  01189	e8 00 00 00 00	 call	 _stakunder
  0118e	eb 5d		 jmp	 SHORT $LN2@P_equal
$LN1@P_equal:

; 679  :     S1 = (S1 == S0) ? Truth : Falsity;

  01190	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01196	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0119c	89 4d fc	 mov	 DWORD PTR tv77[ebp], ecx
  0119f	89 55 f8	 mov	 DWORD PTR tv78[ebp], edx
  011a2	8b 45 fc	 mov	 eax, DWORD PTR tv77[ebp]
  011a5	8b 4d f8	 mov	 ecx, DWORD PTR tv78[ebp]
  011a8	8b 50 f0	 mov	 edx, DWORD PTR [eax-16]
  011ab	3b 51 f8	 cmp	 edx, DWORD PTR [ecx-8]
  011ae	75 17		 jne	 SHORT $LN4@P_equal
  011b0	8b 45 fc	 mov	 eax, DWORD PTR tv77[ebp]
  011b3	8b 4d f8	 mov	 ecx, DWORD PTR tv78[ebp]
  011b6	8b 50 f4	 mov	 edx, DWORD PTR [eax-12]
  011b9	3b 51 fc	 cmp	 edx, DWORD PTR [ecx-4]
  011bc	75 09		 jne	 SHORT $LN4@P_equal
  011be	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR tv71[ebp], -1
  011c5	eb 07		 jmp	 SHORT $LN5@P_equal
$LN4@P_equal:
  011c7	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN5@P_equal:
  011ce	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  011d1	99		 cdq
  011d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  011d8	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  011db	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 680  :     Pop;

  011de	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  011e4	83 ea 08	 sub	 edx, 8
  011e7	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN2@P_equal:

; 681  : }

  011ed	8b e5		 mov	 esp, ebp
  011ef	5d		 pop	 ebp
  011f0	c3		 ret	 0
_P_equal ENDP
; Function compile flags: /Odtp
tv71 = -12						; size = 4
tv78 = -8						; size = 4
tv77 = -4						; size = 4
_P_unequal PROC

; 684  : {

  01200	55		 push	 ebp
  01201	8b ec		 mov	 ebp, esp
  01203	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 685  :     Sl(2);

  01206	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0120b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  01211	c1 f8 03	 sar	 eax, 3
  01214	83 f8 02	 cmp	 eax, 2
  01217	7d 07		 jge	 SHORT $LN1@P_unequal
  01219	e8 00 00 00 00	 call	 _stakunder
  0121e	eb 5d		 jmp	 SHORT $LN2@P_unequal
$LN1@P_unequal:

; 686  :     S1 = (S1 != S0) ? Truth : Falsity;

  01220	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01226	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0122c	89 4d fc	 mov	 DWORD PTR tv77[ebp], ecx
  0122f	89 55 f8	 mov	 DWORD PTR tv78[ebp], edx
  01232	8b 45 fc	 mov	 eax, DWORD PTR tv77[ebp]
  01235	8b 4d f8	 mov	 ecx, DWORD PTR tv78[ebp]
  01238	8b 50 f0	 mov	 edx, DWORD PTR [eax-16]
  0123b	3b 51 f8	 cmp	 edx, DWORD PTR [ecx-8]
  0123e	75 0e		 jne	 SHORT $LN6@P_unequal
  01240	8b 45 fc	 mov	 eax, DWORD PTR tv77[ebp]
  01243	8b 4d f8	 mov	 ecx, DWORD PTR tv78[ebp]
  01246	8b 50 f4	 mov	 edx, DWORD PTR [eax-12]
  01249	3b 51 fc	 cmp	 edx, DWORD PTR [ecx-4]
  0124c	74 09		 je	 SHORT $LN4@P_unequal
$LN6@P_unequal:
  0124e	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR tv71[ebp], -1
  01255	eb 07		 jmp	 SHORT $LN5@P_unequal
$LN4@P_unequal:
  01257	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN5@P_unequal:
  0125e	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  01261	99		 cdq
  01262	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01268	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  0126b	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 687  :     Pop;

  0126e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  01274	83 ea 08	 sub	 edx, 8
  01277	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN2@P_unequal:

; 688  : }

  0127d	8b e5		 mov	 esp, ebp
  0127f	5d		 pop	 ebp
  01280	c3		 ret	 0
_P_unequal ENDP
; Function compile flags: /Odtp
tv71 = -12						; size = 4
tv78 = -8						; size = 4
tv77 = -4						; size = 4
_P_gtr	PROC

; 691  : {

  01290	55		 push	 ebp
  01291	8b ec		 mov	 ebp, esp
  01293	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 692  :     Sl(2);

  01296	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0129b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  012a1	c1 f8 03	 sar	 eax, 3
  012a4	83 f8 02	 cmp	 eax, 2
  012a7	7d 07		 jge	 SHORT $LN1@P_gtr
  012a9	e8 00 00 00 00	 call	 _stakunder
  012ae	eb 5f		 jmp	 SHORT $LN2@P_gtr
$LN1@P_gtr:

; 693  :     S1 = (S1 > S0) ? Truth : Falsity;

  012b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  012b6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  012bc	89 4d fc	 mov	 DWORD PTR tv77[ebp], ecx
  012bf	89 55 f8	 mov	 DWORD PTR tv78[ebp], edx
  012c2	8b 45 fc	 mov	 eax, DWORD PTR tv77[ebp]
  012c5	8b 4d f8	 mov	 ecx, DWORD PTR tv78[ebp]
  012c8	8b 50 f4	 mov	 edx, DWORD PTR [eax-12]
  012cb	3b 51 fc	 cmp	 edx, DWORD PTR [ecx-4]
  012ce	7c 19		 jl	 SHORT $LN4@P_gtr
  012d0	7f 0e		 jg	 SHORT $LN6@P_gtr
  012d2	8b 45 fc	 mov	 eax, DWORD PTR tv77[ebp]
  012d5	8b 4d f8	 mov	 ecx, DWORD PTR tv78[ebp]
  012d8	8b 50 f0	 mov	 edx, DWORD PTR [eax-16]
  012db	3b 51 f8	 cmp	 edx, DWORD PTR [ecx-8]
  012de	76 09		 jbe	 SHORT $LN4@P_gtr
$LN6@P_gtr:
  012e0	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR tv71[ebp], -1
  012e7	eb 07		 jmp	 SHORT $LN5@P_gtr
$LN4@P_gtr:
  012e9	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN5@P_gtr:
  012f0	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  012f3	99		 cdq
  012f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  012fa	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  012fd	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 694  :     Pop;

  01300	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  01306	83 ea 08	 sub	 edx, 8
  01309	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN2@P_gtr:

; 695  : }

  0130f	8b e5		 mov	 esp, ebp
  01311	5d		 pop	 ebp
  01312	c3		 ret	 0
_P_gtr	ENDP
; Function compile flags: /Odtp
tv71 = -12						; size = 4
tv78 = -8						; size = 4
tv77 = -4						; size = 4
_P_lss	PROC

; 698  : {

  01320	55		 push	 ebp
  01321	8b ec		 mov	 ebp, esp
  01323	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 699  :     Sl(2);

  01326	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0132b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  01331	c1 f8 03	 sar	 eax, 3
  01334	83 f8 02	 cmp	 eax, 2
  01337	7d 07		 jge	 SHORT $LN1@P_lss
  01339	e8 00 00 00 00	 call	 _stakunder
  0133e	eb 5f		 jmp	 SHORT $LN2@P_lss
$LN1@P_lss:

; 700  :     S1 = (S1 < S0) ? Truth : Falsity;

  01340	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01346	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0134c	89 4d fc	 mov	 DWORD PTR tv77[ebp], ecx
  0134f	89 55 f8	 mov	 DWORD PTR tv78[ebp], edx
  01352	8b 45 fc	 mov	 eax, DWORD PTR tv77[ebp]
  01355	8b 4d f8	 mov	 ecx, DWORD PTR tv78[ebp]
  01358	8b 50 f4	 mov	 edx, DWORD PTR [eax-12]
  0135b	3b 51 fc	 cmp	 edx, DWORD PTR [ecx-4]
  0135e	7f 19		 jg	 SHORT $LN4@P_lss
  01360	7c 0e		 jl	 SHORT $LN6@P_lss
  01362	8b 45 fc	 mov	 eax, DWORD PTR tv77[ebp]
  01365	8b 4d f8	 mov	 ecx, DWORD PTR tv78[ebp]
  01368	8b 50 f0	 mov	 edx, DWORD PTR [eax-16]
  0136b	3b 51 f8	 cmp	 edx, DWORD PTR [ecx-8]
  0136e	73 09		 jae	 SHORT $LN4@P_lss
$LN6@P_lss:
  01370	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR tv71[ebp], -1
  01377	eb 07		 jmp	 SHORT $LN5@P_lss
$LN4@P_lss:
  01379	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN5@P_lss:
  01380	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  01383	99		 cdq
  01384	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0138a	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  0138d	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 701  :     Pop;

  01390	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  01396	83 ea 08	 sub	 edx, 8
  01399	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN2@P_lss:

; 702  : }

  0139f	8b e5		 mov	 esp, ebp
  013a1	5d		 pop	 ebp
  013a2	c3		 ret	 0
_P_lss	ENDP
; Function compile flags: /Odtp
tv71 = -12						; size = 4
tv78 = -8						; size = 4
tv77 = -4						; size = 4
_P_geq	PROC

; 705  : {

  013b0	55		 push	 ebp
  013b1	8b ec		 mov	 ebp, esp
  013b3	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 706  :     Sl(2);

  013b6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  013bb	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  013c1	c1 f8 03	 sar	 eax, 3
  013c4	83 f8 02	 cmp	 eax, 2
  013c7	7d 07		 jge	 SHORT $LN1@P_geq
  013c9	e8 00 00 00 00	 call	 _stakunder
  013ce	eb 5f		 jmp	 SHORT $LN2@P_geq
$LN1@P_geq:

; 707  :     S1 = (S1 >= S0) ? Truth : Falsity;

  013d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  013d6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  013dc	89 4d fc	 mov	 DWORD PTR tv77[ebp], ecx
  013df	89 55 f8	 mov	 DWORD PTR tv78[ebp], edx
  013e2	8b 45 fc	 mov	 eax, DWORD PTR tv77[ebp]
  013e5	8b 4d f8	 mov	 ecx, DWORD PTR tv78[ebp]
  013e8	8b 50 f4	 mov	 edx, DWORD PTR [eax-12]
  013eb	3b 51 fc	 cmp	 edx, DWORD PTR [ecx-4]
  013ee	7c 19		 jl	 SHORT $LN4@P_geq
  013f0	7f 0e		 jg	 SHORT $LN6@P_geq
  013f2	8b 45 fc	 mov	 eax, DWORD PTR tv77[ebp]
  013f5	8b 4d f8	 mov	 ecx, DWORD PTR tv78[ebp]
  013f8	8b 50 f0	 mov	 edx, DWORD PTR [eax-16]
  013fb	3b 51 f8	 cmp	 edx, DWORD PTR [ecx-8]
  013fe	72 09		 jb	 SHORT $LN4@P_geq
$LN6@P_geq:
  01400	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR tv71[ebp], -1
  01407	eb 07		 jmp	 SHORT $LN5@P_geq
$LN4@P_geq:
  01409	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN5@P_geq:
  01410	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  01413	99		 cdq
  01414	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0141a	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  0141d	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 708  :     Pop;

  01420	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  01426	83 ea 08	 sub	 edx, 8
  01429	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN2@P_geq:

; 709  : }

  0142f	8b e5		 mov	 esp, ebp
  01431	5d		 pop	 ebp
  01432	c3		 ret	 0
_P_geq	ENDP
; Function compile flags: /Odtp
tv71 = -12						; size = 4
tv78 = -8						; size = 4
tv77 = -4						; size = 4
_P_leq	PROC

; 712  : {

  01440	55		 push	 ebp
  01441	8b ec		 mov	 ebp, esp
  01443	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 713  :     Sl(2);

  01446	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0144b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  01451	c1 f8 03	 sar	 eax, 3
  01454	83 f8 02	 cmp	 eax, 2
  01457	7d 07		 jge	 SHORT $LN1@P_leq
  01459	e8 00 00 00 00	 call	 _stakunder
  0145e	eb 5f		 jmp	 SHORT $LN2@P_leq
$LN1@P_leq:

; 714  :     S1 = (S1 <= S0) ? Truth : Falsity;

  01460	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01466	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0146c	89 4d fc	 mov	 DWORD PTR tv77[ebp], ecx
  0146f	89 55 f8	 mov	 DWORD PTR tv78[ebp], edx
  01472	8b 45 fc	 mov	 eax, DWORD PTR tv77[ebp]
  01475	8b 4d f8	 mov	 ecx, DWORD PTR tv78[ebp]
  01478	8b 50 f4	 mov	 edx, DWORD PTR [eax-12]
  0147b	3b 51 fc	 cmp	 edx, DWORD PTR [ecx-4]
  0147e	7f 19		 jg	 SHORT $LN4@P_leq
  01480	7c 0e		 jl	 SHORT $LN6@P_leq
  01482	8b 45 fc	 mov	 eax, DWORD PTR tv77[ebp]
  01485	8b 4d f8	 mov	 ecx, DWORD PTR tv78[ebp]
  01488	8b 50 f0	 mov	 edx, DWORD PTR [eax-16]
  0148b	3b 51 f8	 cmp	 edx, DWORD PTR [ecx-8]
  0148e	77 09		 ja	 SHORT $LN4@P_leq
$LN6@P_leq:
  01490	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR tv71[ebp], -1
  01497	eb 07		 jmp	 SHORT $LN5@P_leq
$LN4@P_leq:
  01499	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN5@P_leq:
  014a0	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  014a3	99		 cdq
  014a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  014aa	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  014ad	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 715  :     Pop;

  014b0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  014b6	83 ea 08	 sub	 edx, 8
  014b9	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN2@P_leq:

; 716  : }

  014bf	8b e5		 mov	 esp, ebp
  014c1	5d		 pop	 ebp
  014c2	c3		 ret	 0
_P_leq	ENDP
; Function compile flags: /Odtp
_P_and	PROC

; 719  : {

  014d0	55		 push	 ebp
  014d1	8b ec		 mov	 ebp, esp

; 720  :     Sl(2);

  014d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  014d8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  014de	c1 f8 03	 sar	 eax, 3
  014e1	83 f8 02	 cmp	 eax, 2
  014e4	7d 07		 jge	 SHORT $LN1@P_and
  014e6	e8 00 00 00 00	 call	 _stakunder
  014eb	eb 31		 jmp	 SHORT $LN2@P_and
$LN1@P_and:

; 721  : /* printf("AND %lx & %lx = %lx\n", S1, S0, (S1 & S0)); */
; 722  :     S1 &= S0;

  014ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  014f3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  014f9	8b 41 f0	 mov	 eax, DWORD PTR [ecx-16]
  014fc	23 42 f8	 and	 eax, DWORD PTR [edx-8]
  014ff	8b 49 f4	 mov	 ecx, DWORD PTR [ecx-12]
  01502	23 4a fc	 and	 ecx, DWORD PTR [edx-4]
  01505	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0150b	89 42 f0	 mov	 DWORD PTR [edx-16], eax
  0150e	89 4a f4	 mov	 DWORD PTR [edx-12], ecx

; 723  :     Pop;

  01511	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01516	83 e8 08	 sub	 eax, 8
  01519	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_and:

; 724  : }

  0151e	5d		 pop	 ebp
  0151f	c3		 ret	 0
_P_and	ENDP
; Function compile flags: /Odtp
_P_or	PROC

; 727  : {

  01520	55		 push	 ebp
  01521	8b ec		 mov	 ebp, esp

; 728  :     Sl(2);

  01523	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01528	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0152e	c1 f8 03	 sar	 eax, 3
  01531	83 f8 02	 cmp	 eax, 2
  01534	7d 07		 jge	 SHORT $LN1@P_or
  01536	e8 00 00 00 00	 call	 _stakunder
  0153b	eb 31		 jmp	 SHORT $LN2@P_or
$LN1@P_or:

; 729  :     S1 |= S0;

  0153d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01543	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  01549	8b 41 f0	 mov	 eax, DWORD PTR [ecx-16]
  0154c	0b 42 f8	 or	 eax, DWORD PTR [edx-8]
  0154f	8b 49 f4	 mov	 ecx, DWORD PTR [ecx-12]
  01552	0b 4a fc	 or	 ecx, DWORD PTR [edx-4]
  01555	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0155b	89 42 f0	 mov	 DWORD PTR [edx-16], eax
  0155e	89 4a f4	 mov	 DWORD PTR [edx-12], ecx

; 730  :     Pop;

  01561	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01566	83 e8 08	 sub	 eax, 8
  01569	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_or:

; 731  : }

  0156e	5d		 pop	 ebp
  0156f	c3		 ret	 0
_P_or	ENDP
; Function compile flags: /Odtp
_P_xor	PROC

; 734  : {

  01570	55		 push	 ebp
  01571	8b ec		 mov	 ebp, esp

; 735  :     Sl(2);

  01573	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01578	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0157e	c1 f8 03	 sar	 eax, 3
  01581	83 f8 02	 cmp	 eax, 2
  01584	7d 07		 jge	 SHORT $LN1@P_xor
  01586	e8 00 00 00 00	 call	 _stakunder
  0158b	eb 31		 jmp	 SHORT $LN2@P_xor
$LN1@P_xor:

; 736  :     S1 ^= S0;

  0158d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01593	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  01599	8b 41 f0	 mov	 eax, DWORD PTR [ecx-16]
  0159c	33 42 f8	 xor	 eax, DWORD PTR [edx-8]
  0159f	8b 49 f4	 mov	 ecx, DWORD PTR [ecx-12]
  015a2	33 4a fc	 xor	 ecx, DWORD PTR [edx-4]
  015a5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  015ab	89 42 f0	 mov	 DWORD PTR [edx-16], eax
  015ae	89 4a f4	 mov	 DWORD PTR [edx-12], ecx

; 737  :     Pop;

  015b1	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  015b6	83 e8 08	 sub	 eax, 8
  015b9	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_xor:

; 738  : }

  015be	5d		 pop	 ebp
  015bf	c3		 ret	 0
_P_xor	ENDP
; Function compile flags: /Odtp
_P_not	PROC

; 741  : {

  015c0	55		 push	 ebp
  015c1	8b ec		 mov	 ebp, esp

; 742  :     Sl(1);

  015c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  015c8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  015ce	c1 f8 03	 sar	 eax, 3
  015d1	83 f8 01	 cmp	 eax, 1
  015d4	7d 07		 jge	 SHORT $LN1@P_not
  015d6	e8 00 00 00 00	 call	 _stakunder
  015db	eb 1c		 jmp	 SHORT $LN2@P_not
$LN1@P_not:

; 743  :     S0 = ~S0;

  015dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  015e3	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  015e6	f7 d2		 not	 edx
  015e8	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  015eb	f7 d0		 not	 eax
  015ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  015f3	89 51 f8	 mov	 DWORD PTR [ecx-8], edx
  015f6	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN2@P_not:

; 744  : }

  015f9	5d		 pop	 ebp
  015fa	c3		 ret	 0
_P_not	ENDP
; Function compile flags: /Odtp
tv81 = -8						; size = 4
tv86 = -4						; size = 4
_P_shift PROC

; 747  : {

  01600	55		 push	 ebp
  01601	8b ec		 mov	 ebp, esp
  01603	83 ec 08	 sub	 esp, 8

; 748  :     Sl(1);

  01606	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0160b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  01611	c1 f8 03	 sar	 eax, 3
  01614	83 f8 01	 cmp	 eax, 1
  01617	7d 07		 jge	 SHORT $LN1@P_shift
  01619	e8 00 00 00 00	 call	 _stakunder
  0161e	eb 74		 jmp	 SHORT $LN2@P_shift
$LN1@P_shift:

; 749  :     S1 = (S0 < 0) ? (((unsigned long) S1) >> (-S0)) :
; 750  : 		    (((unsigned long) S1) <<   S0);

  01620	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01626	89 4d fc	 mov	 DWORD PTR tv86[ebp], ecx
  01629	8b 55 fc	 mov	 edx, DWORD PTR tv86[ebp]
  0162c	83 7a fc 00	 cmp	 DWORD PTR [edx-4], 0
  01630	7f 2d		 jg	 SHORT $LN4@P_shift
  01632	7c 09		 jl	 SHORT $LN6@P_shift
  01634	8b 45 fc	 mov	 eax, DWORD PTR tv86[ebp]
  01637	83 78 f8 00	 cmp	 DWORD PTR [eax-8], 0
  0163b	73 22		 jae	 SHORT $LN4@P_shift
$LN6@P_shift:
  0163d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01643	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  01646	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0164b	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0164e	f7 d9		 neg	 ecx
  01650	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  01653	83 d0 00	 adc	 eax, 0
  01656	f7 d8		 neg	 eax
  01658	d3 ea		 shr	 edx, cl
  0165a	89 55 f8	 mov	 DWORD PTR tv81[ebp], edx
  0165d	eb 16		 jmp	 SHORT $LN5@P_shift
$LN4@P_shift:
  0165f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01665	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  01668	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0166d	8a 48 f8	 mov	 cl, BYTE PTR [eax-8]
  01670	d3 e2		 shl	 edx, cl
  01672	89 55 f8	 mov	 DWORD PTR tv81[ebp], edx
$LN5@P_shift:
  01675	8b 4d f8	 mov	 ecx, DWORD PTR tv81[ebp]
  01678	33 d2		 xor	 edx, edx
  0167a	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0167f	89 48 f0	 mov	 DWORD PTR [eax-16], ecx
  01682	89 50 f4	 mov	 DWORD PTR [eax-12], edx

; 751  :     Pop;

  01685	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0168b	83 e9 08	 sub	 ecx, 8
  0168e	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN2@P_shift:

; 752  : }

  01694	8b e5		 mov	 esp, ebp
  01696	5d		 pop	 ebp
  01697	c3		 ret	 0
_P_shift ENDP
; Function compile flags: /Odtp
_P_1plus PROC

; 757  : {

  016a0	55		 push	 ebp
  016a1	8b ec		 mov	 ebp, esp

; 758  :     Sl(1);

  016a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  016a8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  016ae	c1 f8 03	 sar	 eax, 3
  016b1	83 f8 01	 cmp	 eax, 1
  016b4	7d 07		 jge	 SHORT $LN1@P_1plus
  016b6	e8 00 00 00 00	 call	 _stakunder
  016bb	eb 1e		 jmp	 SHORT $LN2@P_1plus
$LN1@P_1plus:

; 759  :     S0++;

  016bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  016c3	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  016c6	83 c2 01	 add	 edx, 1
  016c9	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  016cc	83 d0 00	 adc	 eax, 0
  016cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  016d5	89 51 f8	 mov	 DWORD PTR [ecx-8], edx
  016d8	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN2@P_1plus:

; 760  : }

  016db	5d		 pop	 ebp
  016dc	c3		 ret	 0
_P_1plus ENDP
; Function compile flags: /Odtp
_P_2plus PROC

; 763  : {

  016e0	55		 push	 ebp
  016e1	8b ec		 mov	 ebp, esp

; 764  :     Sl(1);

  016e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  016e8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  016ee	c1 f8 03	 sar	 eax, 3
  016f1	83 f8 01	 cmp	 eax, 1
  016f4	7d 07		 jge	 SHORT $LN1@P_2plus
  016f6	e8 00 00 00 00	 call	 _stakunder
  016fb	eb 1e		 jmp	 SHORT $LN2@P_2plus
$LN1@P_2plus:

; 765  :     S0 += 2;

  016fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01703	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  01706	83 c2 02	 add	 edx, 2
  01709	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0170c	83 d0 00	 adc	 eax, 0
  0170f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01715	89 51 f8	 mov	 DWORD PTR [ecx-8], edx
  01718	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN2@P_2plus:

; 766  : }

  0171b	5d		 pop	 ebp
  0171c	c3		 ret	 0
_P_2plus ENDP
; Function compile flags: /Odtp
_P_1minus PROC

; 769  : {

  01720	55		 push	 ebp
  01721	8b ec		 mov	 ebp, esp

; 770  :     Sl(1);

  01723	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01728	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0172e	c1 f8 03	 sar	 eax, 3
  01731	83 f8 01	 cmp	 eax, 1
  01734	7d 07		 jge	 SHORT $LN1@P_1minus
  01736	e8 00 00 00 00	 call	 _stakunder
  0173b	eb 1e		 jmp	 SHORT $LN2@P_1minus
$LN1@P_1minus:

; 771  :     S0--;

  0173d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01743	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  01746	83 ea 01	 sub	 edx, 1
  01749	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0174c	83 d8 00	 sbb	 eax, 0
  0174f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01755	89 51 f8	 mov	 DWORD PTR [ecx-8], edx
  01758	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN2@P_1minus:

; 772  : }

  0175b	5d		 pop	 ebp
  0175c	c3		 ret	 0
_P_1minus ENDP
; Function compile flags: /Odtp
_P_2minus PROC

; 775  : {

  01760	55		 push	 ebp
  01761	8b ec		 mov	 ebp, esp

; 776  :     Sl(1);

  01763	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01768	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0176e	c1 f8 03	 sar	 eax, 3
  01771	83 f8 01	 cmp	 eax, 1
  01774	7d 07		 jge	 SHORT $LN1@P_2minus
  01776	e8 00 00 00 00	 call	 _stakunder
  0177b	eb 1e		 jmp	 SHORT $LN2@P_2minus
$LN1@P_2minus:

; 777  :     S0 -= 2;

  0177d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01783	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  01786	83 ea 02	 sub	 edx, 2
  01789	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0178c	83 d8 00	 sbb	 eax, 0
  0178f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01795	89 51 f8	 mov	 DWORD PTR [ecx-8], edx
  01798	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN2@P_2minus:

; 778  : }

  0179b	5d		 pop	 ebp
  0179c	c3		 ret	 0
_P_2minus ENDP
; Function compile flags: /Odtp
_P_2times PROC

; 781  : {

  017a0	55		 push	 ebp
  017a1	8b ec		 mov	 ebp, esp

; 782  :     Sl(1);

  017a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  017a8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  017ae	c1 f8 03	 sar	 eax, 3
  017b1	83 f8 01	 cmp	 eax, 1
  017b4	7d 07		 jge	 SHORT $LN1@P_2times
  017b6	e8 00 00 00 00	 call	 _stakunder
  017bb	eb 23		 jmp	 SHORT $LN2@P_2times
$LN1@P_2times:

; 783  :     S0 *= 2;

  017bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  017c3	6a 00		 push	 0
  017c5	6a 02		 push	 2
  017c7	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  017ca	52		 push	 edx
  017cb	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  017ce	50		 push	 eax
  017cf	e8 00 00 00 00	 call	 __allmul
  017d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  017da	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  017dd	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN2@P_2times:

; 784  : }

  017e0	5d		 pop	 ebp
  017e1	c3		 ret	 0
_P_2times ENDP
; Function compile flags: /Odtp
_P_2div PROC

; 787  : {

  017f0	55		 push	 ebp
  017f1	8b ec		 mov	 ebp, esp

; 788  :     Sl(1);

  017f3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  017f8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  017fe	c1 f8 03	 sar	 eax, 3
  01801	83 f8 01	 cmp	 eax, 1
  01804	7d 07		 jge	 SHORT $LN1@P_2div
  01806	e8 00 00 00 00	 call	 _stakunder
  0180b	eb 23		 jmp	 SHORT $LN2@P_2div
$LN1@P_2div:

; 789  :     S0 /= 2;

  0180d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01813	6a 00		 push	 0
  01815	6a 02		 push	 2
  01817	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  0181a	52		 push	 edx
  0181b	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  0181e	50		 push	 eax
  0181f	e8 00 00 00 00	 call	 __alldiv
  01824	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0182a	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  0182d	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN2@P_2div:

; 790  : }

  01830	5d		 pop	 ebp
  01831	c3		 ret	 0
_P_2div	ENDP
; Function compile flags: /Odtp
tv70 = -8						; size = 4
tv74 = -4						; size = 4
_P_0equal PROC

; 797  : {

  01840	55		 push	 ebp
  01841	8b ec		 mov	 ebp, esp
  01843	83 ec 08	 sub	 esp, 8

; 798  :     Sl(1);

  01846	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0184b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  01851	c1 f8 03	 sar	 eax, 3
  01854	83 f8 01	 cmp	 eax, 1
  01857	7d 07		 jge	 SHORT $LN1@P_0equal
  01859	e8 00 00 00 00	 call	 _stakunder
  0185e	eb 37		 jmp	 SHORT $LN2@P_0equal
$LN1@P_0equal:

; 799  :     S0 = (S0 == 0) ? Truth : Falsity;

  01860	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01866	89 4d fc	 mov	 DWORD PTR tv74[ebp], ecx
  01869	8b 55 fc	 mov	 edx, DWORD PTR tv74[ebp]
  0186c	8b 45 fc	 mov	 eax, DWORD PTR tv74[ebp]
  0186f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  01872	0b 48 fc	 or	 ecx, DWORD PTR [eax-4]
  01875	75 09		 jne	 SHORT $LN4@P_0equal
  01877	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
  0187e	eb 07		 jmp	 SHORT $LN5@P_0equal
$LN4@P_0equal:
  01880	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_0equal:
  01887	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]
  0188a	99		 cdq
  0188b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01891	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  01894	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN2@P_0equal:

; 800  : }

  01897	8b e5		 mov	 esp, ebp
  01899	5d		 pop	 ebp
  0189a	c3		 ret	 0
_P_0equal ENDP
; Function compile flags: /Odtp
tv70 = -8						; size = 4
tv74 = -4						; size = 4
_P_0notequal PROC

; 803  : {

  018a0	55		 push	 ebp
  018a1	8b ec		 mov	 ebp, esp
  018a3	83 ec 08	 sub	 esp, 8

; 804  :     Sl(1);

  018a6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  018ab	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  018b1	c1 f8 03	 sar	 eax, 3
  018b4	83 f8 01	 cmp	 eax, 1
  018b7	7d 07		 jge	 SHORT $LN1@P_0notequa
  018b9	e8 00 00 00 00	 call	 _stakunder
  018be	eb 37		 jmp	 SHORT $LN2@P_0notequa
$LN1@P_0notequa:

; 805  :     S0 = (S0 != 0) ? Truth : Falsity;

  018c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  018c6	89 4d fc	 mov	 DWORD PTR tv74[ebp], ecx
  018c9	8b 55 fc	 mov	 edx, DWORD PTR tv74[ebp]
  018cc	8b 45 fc	 mov	 eax, DWORD PTR tv74[ebp]
  018cf	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  018d2	0b 48 fc	 or	 ecx, DWORD PTR [eax-4]
  018d5	74 09		 je	 SHORT $LN4@P_0notequa
  018d7	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
  018de	eb 07		 jmp	 SHORT $LN5@P_0notequa
$LN4@P_0notequa:
  018e0	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_0notequa:
  018e7	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]
  018ea	99		 cdq
  018eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  018f1	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  018f4	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN2@P_0notequa:

; 806  : }

  018f7	8b e5		 mov	 esp, ebp
  018f9	5d		 pop	 ebp
  018fa	c3		 ret	 0
_P_0notequal ENDP
; Function compile flags: /Odtp
tv70 = -8						; size = 4
tv74 = -4						; size = 4
_P_0gtr	PROC

; 809  : {

  01900	55		 push	 ebp
  01901	8b ec		 mov	 ebp, esp
  01903	83 ec 08	 sub	 esp, 8

; 810  :     Sl(1);

  01906	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0190b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  01911	c1 f8 03	 sar	 eax, 3
  01914	83 f8 01	 cmp	 eax, 1
  01917	7d 07		 jge	 SHORT $LN1@P_0gtr
  01919	e8 00 00 00 00	 call	 _stakunder
  0191e	eb 3d		 jmp	 SHORT $LN2@P_0gtr
$LN1@P_0gtr:

; 811  :     S0 = (S0 > 0) ? Truth : Falsity;

  01920	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01926	89 4d fc	 mov	 DWORD PTR tv74[ebp], ecx
  01929	8b 55 fc	 mov	 edx, DWORD PTR tv74[ebp]
  0192c	83 7a fc 00	 cmp	 DWORD PTR [edx-4], 0
  01930	7c 14		 jl	 SHORT $LN4@P_0gtr
  01932	7f 09		 jg	 SHORT $LN6@P_0gtr
  01934	8b 45 fc	 mov	 eax, DWORD PTR tv74[ebp]
  01937	83 78 f8 00	 cmp	 DWORD PTR [eax-8], 0
  0193b	76 09		 jbe	 SHORT $LN4@P_0gtr
$LN6@P_0gtr:
  0193d	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
  01944	eb 07		 jmp	 SHORT $LN5@P_0gtr
$LN4@P_0gtr:
  01946	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_0gtr:
  0194d	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]
  01950	99		 cdq
  01951	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01957	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  0195a	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN2@P_0gtr:

; 812  : }

  0195d	8b e5		 mov	 esp, ebp
  0195f	5d		 pop	 ebp
  01960	c3		 ret	 0
_P_0gtr	ENDP
; Function compile flags: /Odtp
tv70 = -8						; size = 4
tv74 = -4						; size = 4
_P_0lss	PROC

; 815  : {

  01970	55		 push	 ebp
  01971	8b ec		 mov	 ebp, esp
  01973	83 ec 08	 sub	 esp, 8

; 816  :     Sl(1);

  01976	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0197b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  01981	c1 f8 03	 sar	 eax, 3
  01984	83 f8 01	 cmp	 eax, 1
  01987	7d 07		 jge	 SHORT $LN1@P_0lss
  01989	e8 00 00 00 00	 call	 _stakunder
  0198e	eb 3d		 jmp	 SHORT $LN2@P_0lss
$LN1@P_0lss:

; 817  :     S0 = (S0 < 0) ? Truth : Falsity;

  01990	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01996	89 4d fc	 mov	 DWORD PTR tv74[ebp], ecx
  01999	8b 55 fc	 mov	 edx, DWORD PTR tv74[ebp]
  0199c	83 7a fc 00	 cmp	 DWORD PTR [edx-4], 0
  019a0	7f 14		 jg	 SHORT $LN4@P_0lss
  019a2	7c 09		 jl	 SHORT $LN6@P_0lss
  019a4	8b 45 fc	 mov	 eax, DWORD PTR tv74[ebp]
  019a7	83 78 f8 00	 cmp	 DWORD PTR [eax-8], 0
  019ab	73 09		 jae	 SHORT $LN4@P_0lss
$LN6@P_0lss:
  019ad	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
  019b4	eb 07		 jmp	 SHORT $LN5@P_0lss
$LN4@P_0lss:
  019b6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_0lss:
  019bd	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]
  019c0	99		 cdq
  019c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  019c7	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  019ca	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN2@P_0lss:

; 818  : }

  019cd	8b e5		 mov	 esp, ebp
  019cf	5d		 pop	 ebp
  019d0	c3		 ret	 0
_P_0lss	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_hptr	DD	01H DUP (?)
_stacktop DD	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
_P_here	PROC

; 825  : {

  019e0	55		 push	 ebp
  019e1	8b ec		 mov	 ebp, esp

; 826  :     So(1);

  019e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  019e8	83 c0 08	 add	 eax, 8
  019eb	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  019f1	76 07		 jbe	 SHORT $LN1@P_here
  019f3	e8 00 00 00 00	 call	 _stakover
  019f8	eb 20		 jmp	 SHORT $LN2@P_here
$LN1@P_here:

; 827  :     Push = (stackitem) hptr;

  019fa	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  019ff	99		 cdq
  01a00	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01a06	89 01		 mov	 DWORD PTR [ecx], eax
  01a08	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  01a0b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  01a11	83 c2 08	 add	 edx, 8
  01a14	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN2@P_here:

; 828  : }

  01a1a	5d		 pop	 ebp
  01a1b	c3		 ret	 0
_P_here	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_heaptop DD	01H DUP (?)
_heapbot DD	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
_P_bang	PROC

; 831  : {

  01a20	55		 push	 ebp
  01a21	8b ec		 mov	 ebp, esp

; 832  :     Sl(2);

  01a23	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01a28	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  01a2e	c1 f8 03	 sar	 eax, 3
  01a31	83 f8 02	 cmp	 eax, 2
  01a34	7d 07		 jge	 SHORT $LN3@P_bang
  01a36	e8 00 00 00 00	 call	 _stakunder
  01a3b	eb 51		 jmp	 SHORT $LN4@P_bang
$LN3@P_bang:

; 833  :     Hpc(S0);

  01a3d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01a43	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  01a46	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  01a4c	72 10		 jb	 SHORT $LN1@P_bang
  01a4e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01a53	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  01a56	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  01a5c	72 07		 jb	 SHORT $LN2@P_bang
$LN1@P_bang:
  01a5e	e8 00 00 00 00	 call	 _badpointer
  01a63	eb 29		 jmp	 SHORT $LN4@P_bang
$LN2@P_bang:

; 834  :     *((stackitem *) S0) = S1;

  01a65	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  01a6b	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  01a6e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01a74	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  01a77	89 10		 mov	 DWORD PTR [eax], edx
  01a79	8b 49 f4	 mov	 ecx, DWORD PTR [ecx-12]
  01a7c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 835  :     Pop2;

  01a7f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  01a85	83 ea 10	 sub	 edx, 16			; 00000010H
  01a88	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN4@P_bang:

; 836  : }

  01a8e	5d		 pop	 ebp
  01a8f	c3		 ret	 0
_P_bang	ENDP
; Function compile flags: /Odtp
_P_at	PROC

; 839  : {

  01a90	55		 push	 ebp
  01a91	8b ec		 mov	 ebp, esp

; 840  :     Sl(1);

  01a93	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01a98	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  01a9e	c1 f8 03	 sar	 eax, 3
  01aa1	83 f8 01	 cmp	 eax, 1
  01aa4	7d 07		 jge	 SHORT $LN3@P_at
  01aa6	e8 00 00 00 00	 call	 _stakunder
  01aab	eb 42		 jmp	 SHORT $LN4@P_at
$LN3@P_at:

; 841  :     Hpc(S0);

  01aad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01ab3	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  01ab6	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  01abc	72 10		 jb	 SHORT $LN1@P_at
  01abe	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01ac3	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  01ac6	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  01acc	72 07		 jb	 SHORT $LN2@P_at
$LN1@P_at:
  01ace	e8 00 00 00 00	 call	 _badpointer
  01ad3	eb 1a		 jmp	 SHORT $LN4@P_at
$LN2@P_at:

; 842  :     S0 = *((stackitem *) S0);

  01ad5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  01adb	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  01ade	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01ae4	8b 10		 mov	 edx, DWORD PTR [eax]
  01ae6	89 51 f8	 mov	 DWORD PTR [ecx-8], edx
  01ae9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  01aec	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN4@P_at:

; 843  : }

  01aef	5d		 pop	 ebp
  01af0	c3		 ret	 0
_P_at	ENDP
; Function compile flags: /Odtp
_P_plusbang PROC

; 846  : {

  01b00	55		 push	 ebp
  01b01	8b ec		 mov	 ebp, esp

; 847  :     Sl(2);

  01b03	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01b08	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  01b0e	c1 f8 03	 sar	 eax, 3
  01b11	83 f8 02	 cmp	 eax, 2
  01b14	7d 07		 jge	 SHORT $LN3@P_plusbang
  01b16	e8 00 00 00 00	 call	 _stakunder
  01b1b	eb 5f		 jmp	 SHORT $LN4@P_plusbang
$LN3@P_plusbang:

; 848  :     Hpc(S0);

  01b1d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01b23	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  01b26	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  01b2c	72 10		 jb	 SHORT $LN1@P_plusbang
  01b2e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01b33	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  01b36	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  01b3c	72 07		 jb	 SHORT $LN2@P_plusbang
$LN1@P_plusbang:
  01b3e	e8 00 00 00 00	 call	 _badpointer
  01b43	eb 37		 jmp	 SHORT $LN4@P_plusbang
$LN2@P_plusbang:

; 849  :     *((stackitem *) S0) += S1;

  01b45	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  01b4b	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  01b4e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01b54	8b 10		 mov	 edx, DWORD PTR [eax]
  01b56	03 51 f0	 add	 edx, DWORD PTR [ecx-16]
  01b59	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  01b5c	13 41 f4	 adc	 eax, DWORD PTR [ecx-12]
  01b5f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01b65	8b 49 f8	 mov	 ecx, DWORD PTR [ecx-8]
  01b68	89 11		 mov	 DWORD PTR [ecx], edx
  01b6a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 850  :     Pop2;

  01b6d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  01b73	83 ea 10	 sub	 edx, 16			; 00000010H
  01b76	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN4@P_plusbang:

; 851  : }

  01b7c	5d		 pop	 ebp
  01b7d	c3		 ret	 0
_P_plusbang ENDP
; Function compile flags: /Odtp
_n$ = -8						; size = 8
_P_allot PROC

; 854  : {

  01b80	55		 push	 ebp
  01b81	8b ec		 mov	 ebp, esp
  01b83	83 ec 08	 sub	 esp, 8

; 855  :     stackitem n;
; 856  : 
; 857  :     Sl(1);

  01b86	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01b8b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  01b91	c1 f8 03	 sar	 eax, 3
  01b94	83 f8 01	 cmp	 eax, 1
  01b97	7d 07		 jge	 SHORT $LN2@P_allot
  01b99	e8 00 00 00 00	 call	 _stakunder
  01b9e	eb 74		 jmp	 SHORT $LN3@P_allot
$LN2@P_allot:

; 858  :     n = (S0 + (sizeof(stackitem) - 1)) / sizeof(stackitem);

  01ba0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01ba6	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  01ba9	83 c2 07	 add	 edx, 7
  01bac	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  01baf	83 d0 00	 adc	 eax, 0
  01bb2	6a 00		 push	 0
  01bb4	6a 08		 push	 8
  01bb6	50		 push	 eax
  01bb7	52		 push	 edx
  01bb8	e8 00 00 00 00	 call	 __alldiv
  01bbd	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
  01bc0	89 55 fc	 mov	 DWORD PTR _n$[ebp+4], edx

; 859  :     Pop;

  01bc3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01bc9	83 e9 08	 sub	 ecx, 8
  01bcc	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx

; 860  :     Ho(n);

  01bd2	6a 00		 push	 0
  01bd4	6a 08		 push	 8
  01bd6	8b 55 fc	 mov	 edx, DWORD PTR _n$[ebp+4]
  01bd9	52		 push	 edx
  01bda	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  01bdd	50		 push	 eax
  01bde	e8 00 00 00 00	 call	 __allmul
  01be3	03 05 00 00 00
	00		 add	 eax, DWORD PTR _hptr
  01be9	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  01bef	76 07		 jbe	 SHORT $LN1@P_allot
  01bf1	e8 00 00 00 00	 call	 _heapover
  01bf6	eb 1c		 jmp	 SHORT $LN3@P_allot
$LN1@P_allot:

; 861  :     hptr += n;

  01bf8	6a 00		 push	 0
  01bfa	6a 08		 push	 8
  01bfc	8b 4d fc	 mov	 ecx, DWORD PTR _n$[ebp+4]
  01bff	51		 push	 ecx
  01c00	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  01c03	52		 push	 edx
  01c04	e8 00 00 00 00	 call	 __allmul
  01c09	03 05 00 00 00
	00		 add	 eax, DWORD PTR _hptr
  01c0f	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax
$LN3@P_allot:

; 862  : }

  01c14	8b e5		 mov	 esp, ebp
  01c16	5d		 pop	 ebp
  01c17	c3		 ret	 0
_P_allot ENDP
; Function compile flags: /Odtp
_P_comma PROC

; 865  : {

  01c20	55		 push	 ebp
  01c21	8b ec		 mov	 ebp, esp

; 866  :     Sl(1);

  01c23	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01c28	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  01c2e	c1 f8 03	 sar	 eax, 3
  01c31	83 f8 01	 cmp	 eax, 1
  01c34	7d 07		 jge	 SHORT $LN2@P_comma
  01c36	e8 00 00 00 00	 call	 _stakunder
  01c3b	eb 4c		 jmp	 SHORT $LN3@P_comma
$LN2@P_comma:

; 867  :     Ho(1);

  01c3d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  01c43	83 c1 08	 add	 ecx, 8
  01c46	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  01c4c	76 07		 jbe	 SHORT $LN1@P_comma
  01c4e	e8 00 00 00 00	 call	 _heapover
  01c53	eb 34		 jmp	 SHORT $LN3@P_comma
$LN1@P_comma:

; 868  :     Hstore = S0;

  01c55	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  01c5b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01c60	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  01c63	89 0a		 mov	 DWORD PTR [edx], ecx
  01c65	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  01c68	89 42 04	 mov	 DWORD PTR [edx+4], eax
  01c6b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  01c71	83 c1 08	 add	 ecx, 8
  01c74	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx

; 869  :     Pop;

  01c7a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  01c80	83 ea 08	 sub	 edx, 8
  01c83	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN3@P_comma:

; 870  : }

  01c89	5d		 pop	 ebp
  01c8a	c3		 ret	 0
_P_comma ENDP
; Function compile flags: /Odtp
_P_cbang PROC

; 873  : {

  01c90	55		 push	 ebp
  01c91	8b ec		 mov	 ebp, esp

; 874  :     Sl(2);

  01c93	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01c98	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  01c9e	c1 f8 03	 sar	 eax, 3
  01ca1	83 f8 02	 cmp	 eax, 2
  01ca4	7d 07		 jge	 SHORT $LN3@P_cbang
  01ca6	e8 00 00 00 00	 call	 _stakunder
  01cab	eb 49		 jmp	 SHORT $LN4@P_cbang
$LN3@P_cbang:

; 875  :     Hpc(S0);

  01cad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01cb3	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  01cb6	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  01cbc	72 10		 jb	 SHORT $LN1@P_cbang
  01cbe	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01cc3	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  01cc6	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  01ccc	72 07		 jb	 SHORT $LN2@P_cbang
$LN1@P_cbang:
  01cce	e8 00 00 00 00	 call	 _badpointer
  01cd3	eb 21		 jmp	 SHORT $LN4@P_cbang
$LN2@P_cbang:

; 876  :     *((unsigned char *) S0) = S1;

  01cd5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  01cdb	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  01cde	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01ce4	8a 51 f0	 mov	 dl, BYTE PTR [ecx-16]
  01ce7	88 10		 mov	 BYTE PTR [eax], dl

; 877  :     Pop2;

  01ce9	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01cee	83 e8 10	 sub	 eax, 16			; 00000010H
  01cf1	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN4@P_cbang:

; 878  : }

  01cf6	5d		 pop	 ebp
  01cf7	c3		 ret	 0
_P_cbang ENDP
; Function compile flags: /Odtp
_P_cat	PROC

; 881  : {

  01d00	55		 push	 ebp
  01d01	8b ec		 mov	 ebp, esp

; 882  :     Sl(1);

  01d03	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01d08	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  01d0e	c1 f8 03	 sar	 eax, 3
  01d11	83 f8 01	 cmp	 eax, 1
  01d14	7d 07		 jge	 SHORT $LN3@P_cat
  01d16	e8 00 00 00 00	 call	 _stakunder
  01d1b	eb 41		 jmp	 SHORT $LN4@P_cat
$LN3@P_cat:

; 883  :     Hpc(S0);

  01d1d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01d23	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  01d26	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  01d2c	72 10		 jb	 SHORT $LN1@P_cat
  01d2e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01d33	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  01d36	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  01d3c	72 07		 jb	 SHORT $LN2@P_cat
$LN1@P_cat:
  01d3e	e8 00 00 00 00	 call	 _badpointer
  01d43	eb 19		 jmp	 SHORT $LN4@P_cat
$LN2@P_cat:

; 884  :     S0 = *((unsigned char *) S0);

  01d45	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  01d4b	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  01d4e	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  01d51	99		 cdq
  01d52	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01d58	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  01d5b	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN4@P_cat:

; 885  : }

  01d5e	5d		 pop	 ebp
  01d5f	c3		 ret	 0
_P_cat	ENDP
; Function compile flags: /Odtp
_chp$ = -4						; size = 4
_P_ccomma PROC

; 888  : {

  01d60	55		 push	 ebp
  01d61	8b ec		 mov	 ebp, esp
  01d63	51		 push	 ecx

; 889  :     unsigned char *chp;
; 890  : 
; 891  :     Sl(1);

  01d64	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01d69	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  01d6f	c1 f8 03	 sar	 eax, 3
  01d72	83 f8 01	 cmp	 eax, 1
  01d75	7d 07		 jge	 SHORT $LN2@P_ccomma
  01d77	e8 00 00 00 00	 call	 _stakunder
  01d7c	eb 4f		 jmp	 SHORT $LN3@P_ccomma
$LN2@P_ccomma:

; 892  :     Ho(1);

  01d7e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  01d84	83 c1 08	 add	 ecx, 8
  01d87	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  01d8d	76 07		 jbe	 SHORT $LN1@P_ccomma
  01d8f	e8 00 00 00 00	 call	 _heapover
  01d94	eb 37		 jmp	 SHORT $LN3@P_ccomma
$LN1@P_ccomma:

; 893  :     chp = ((unsigned char *) hptr);

  01d96	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  01d9c	89 55 fc	 mov	 DWORD PTR _chp$[ebp], edx

; 894  :     *chp++ = S0;

  01d9f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01da4	8a 48 f8	 mov	 cl, BYTE PTR [eax-8]
  01da7	8b 55 fc	 mov	 edx, DWORD PTR _chp$[ebp]
  01daa	88 0a		 mov	 BYTE PTR [edx], cl
  01dac	8b 45 fc	 mov	 eax, DWORD PTR _chp$[ebp]
  01daf	83 c0 01	 add	 eax, 1
  01db2	89 45 fc	 mov	 DWORD PTR _chp$[ebp], eax

; 895  :     hptr = (stackitem *) chp;

  01db5	8b 4d fc	 mov	 ecx, DWORD PTR _chp$[ebp]
  01db8	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx

; 896  :     Pop;

  01dbe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  01dc4	83 ea 08	 sub	 edx, 8
  01dc7	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN3@P_ccomma:

; 897  : }

  01dcd	8b e5		 mov	 esp, ebp
  01dcf	5d		 pop	 ebp
  01dd0	c3		 ret	 0
_P_ccomma ENDP
; Function compile flags: /Odtp
_chp$83212 = -12					; size = 4
_n$ = -8						; size = 8
_P_cequal PROC

; 900  : {				      /* a series of bytes. */

  01de0	55		 push	 ebp
  01de1	8b ec		 mov	 ebp, esp
  01de3	83 ec 0c	 sub	 esp, 12			; 0000000cH
  01de6	56		 push	 esi

; 901  :     stackitem n = (((stackitem) hptr) - ((stackitem) heap)) %
; 902  : 			(sizeof(stackitem));

  01de7	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  01dec	99		 cdq
  01ded	8b c8		 mov	 ecx, eax
  01def	8b f2		 mov	 esi, edx
  01df1	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  01df6	99		 cdq
  01df7	2b c8		 sub	 ecx, eax
  01df9	1b f2		 sbb	 esi, edx
  01dfb	6a 00		 push	 0
  01dfd	6a 08		 push	 8
  01dff	56		 push	 esi
  01e00	51		 push	 ecx
  01e01	e8 00 00 00 00	 call	 __allrem
  01e06	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
  01e09	89 55 fc	 mov	 DWORD PTR _n$[ebp+4], edx

; 903  : 
; 904  :     if (n != 0) {

  01e0c	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  01e0f	0b 55 fc	 or	 edx, DWORD PTR _n$[ebp+4]
  01e12	74 26		 je	 SHORT $LN2@P_cequal

; 905  : 	char *chp = ((char *) hptr);

  01e14	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  01e19	89 45 f4	 mov	 DWORD PTR _chp$83212[ebp], eax

; 906  : 
; 907  : 	chp += sizeof(stackitem) - n;

  01e1c	b9 08 00 00 00	 mov	 ecx, 8
  01e21	2b 4d f8	 sub	 ecx, DWORD PTR _n$[ebp]
  01e24	ba 00 00 00 00	 mov	 edx, 0
  01e29	1b 55 fc	 sbb	 edx, DWORD PTR _n$[ebp+4]
  01e2c	03 4d f4	 add	 ecx, DWORD PTR _chp$83212[ebp]
  01e2f	89 4d f4	 mov	 DWORD PTR _chp$83212[ebp], ecx

; 908  : 	hptr = ((stackitem *) chp);

  01e32	8b 45 f4	 mov	 eax, DWORD PTR _chp$83212[ebp]
  01e35	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax
$LN2@P_cequal:

; 909  :     }
; 910  : }

  01e3a	5e		 pop	 esi
  01e3b	8b e5		 mov	 esp, ebp
  01e3d	5d		 pop	 ebp
  01e3e	c3		 ret	 0
_P_cequal ENDP
; Function compile flags: /Odtp
_P_create PROC

; 921  : {

  01e40	55		 push	 ebp
  01e41	8b ec		 mov	 ebp, esp

; 922  :     defpend = True;		      /* Set definition pending */

  01e43	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _defpend, 1

; 923  :     Ho(Dictwordl);

  01e4d	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  01e52	83 c0 10	 add	 eax, 16			; 00000010H
  01e55	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  01e5b	76 07		 jbe	 SHORT $LN1@P_create
  01e5d	e8 00 00 00 00	 call	 _heapover
  01e62	eb 34		 jmp	 SHORT $LN2@P_create
$LN1@P_create:

; 924  :     createword = (dictword *) hptr;   /* Develop address of word */

  01e64	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  01e6a	89 0d 00 00 00
	00		 mov	 DWORD PTR _createword, ecx

; 925  :     createword->wname = NULL;	      /* Clear pointer to name string */

  01e70	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _createword
  01e76	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 926  :     createword->wcode = P_var;	      /* Store default code */

  01e7d	a1 00 00 00 00	 mov	 eax, DWORD PTR _createword
  01e82	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _P_var

; 927  :     hptr += Dictwordl;		      /* Allocate heap space for word */

  01e89	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  01e8f	83 c1 10	 add	 ecx, 16			; 00000010H
  01e92	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx
$LN2@P_create:

; 928  : }

  01e98	5d		 pop	 ebp
  01e99	c3		 ret	 0
_P_create ENDP
; Function compile flags: /Odtp
_P_var	PROC

; 915  : {

  01ea0	55		 push	 ebp
  01ea1	8b ec		 mov	 ebp, esp

; 916  :     So(1);

  01ea3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01ea8	83 c0 08	 add	 eax, 8
  01eab	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  01eb1	76 07		 jbe	 SHORT $LN1@P_var
  01eb3	e8 00 00 00 00	 call	 _stakover
  01eb8	eb 23		 jmp	 SHORT $LN2@P_var
$LN1@P_var:

; 917  :     Push = (stackitem) (((stackitem *) curword) + Dictwordl);

  01eba	a1 00 00 00 00	 mov	 eax, DWORD PTR _curword
  01ebf	83 c0 10	 add	 eax, 16			; 00000010H
  01ec2	99		 cdq
  01ec3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01ec9	89 01		 mov	 DWORD PTR [ecx], eax
  01ecb	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  01ece	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  01ed4	83 c2 08	 add	 edx, 8
  01ed7	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN2@P_var:

; 918  : }

  01edd	5d		 pop	 ebp
  01ede	c3		 ret	 0
_P_var	ENDP
; Function compile flags: /Odtp
_P_forget PROC

; 931  : {

  01ee0	55		 push	 ebp
  01ee1	8b ec		 mov	 ebp, esp

; 932  :     forgetpend = True;		      /* Mark forget pending */

  01ee3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _forgetpend, 1

; 933  : }

  01eed	5d		 pop	 ebp
  01eee	c3		 ret	 0
_P_forget ENDP
; Function compile flags: /Odtp
_P_variable PROC

; 936  : {

  01ef0	55		 push	 ebp
  01ef1	8b ec		 mov	 ebp, esp

; 937  :     P_create(); 		      /* Create dictionary item */

  01ef3	e8 00 00 00 00	 call	 _P_create

; 938  :     Ho(1);

  01ef8	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  01efd	83 c0 08	 add	 eax, 8
  01f00	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  01f06	76 07		 jbe	 SHORT $LN1@P_variable
  01f08	e8 00 00 00 00	 call	 _heapover
  01f0d	eb 22		 jmp	 SHORT $LN2@P_variable
$LN1@P_variable:

; 939  :     Hstore = 0; 		      /* Initial value = 0 */

  01f0f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  01f15	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  01f1b	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  01f22	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  01f28	83 c2 08	 add	 edx, 8
  01f2b	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx
$LN2@P_variable:

; 940  : }

  01f31	5d		 pop	 ebp
  01f32	c3		 ret	 0
_P_variable ENDP
; Function compile flags: /Odtp
_P_constant PROC

; 949  : {

  01f40	55		 push	 ebp
  01f41	8b ec		 mov	 ebp, esp

; 950  :     Sl(1);

  01f43	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01f48	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  01f4e	c1 f8 03	 sar	 eax, 3
  01f51	83 f8 01	 cmp	 eax, 1
  01f54	7d 07		 jge	 SHORT $LN2@P_constant
  01f56	e8 00 00 00 00	 call	 _stakunder
  01f5b	eb 5c		 jmp	 SHORT $LN3@P_constant
$LN2@P_constant:

; 951  :     P_create(); 		      /* Create dictionary item */

  01f5d	e8 00 00 00 00	 call	 _P_create

; 952  :     createword->wcode = P_con;	      /* Set code to constant push */

  01f62	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _createword
  01f68	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], OFFSET _P_con

; 953  :     Ho(1);

  01f6f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  01f75	83 c2 08	 add	 edx, 8
  01f78	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  01f7e	76 07		 jbe	 SHORT $LN1@P_constant
  01f80	e8 00 00 00 00	 call	 _heapover
  01f85	eb 32		 jmp	 SHORT $LN3@P_constant
$LN1@P_constant:

; 954  :     Hstore = S0;		      /* Store constant value in body */

  01f87	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  01f8c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01f92	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  01f95	89 10		 mov	 DWORD PTR [eax], edx
  01f97	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  01f9a	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  01f9d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  01fa3	83 c2 08	 add	 edx, 8
  01fa6	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 955  :     Pop;

  01fac	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01fb1	83 e8 08	 sub	 eax, 8
  01fb4	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN3@P_constant:

; 956  : }

  01fb9	5d		 pop	 ebp
  01fba	c3		 ret	 0
_P_constant ENDP
; Function compile flags: /Odtp
_P_con	PROC

; 943  : {

  01fc0	55		 push	 ebp
  01fc1	8b ec		 mov	 ebp, esp

; 944  :     So(1);

  01fc3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01fc8	83 c0 08	 add	 eax, 8
  01fcb	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  01fd1	76 07		 jbe	 SHORT $LN1@P_con
  01fd3	e8 00 00 00 00	 call	 _stakover
  01fd8	eb 24		 jmp	 SHORT $LN2@P_con
$LN1@P_con:

; 945  :     Push = *(((stackitem *) curword) + Dictwordl);

  01fda	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  01fe0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _curword
  01fe6	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  01fe9	89 01		 mov	 DWORD PTR [ecx], eax
  01feb	8b 52 14	 mov	 edx, DWORD PTR [edx+20]
  01fee	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  01ff1	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  01ff6	83 c0 08	 add	 eax, 8
  01ff9	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_con:

; 946  : }

  01ffe	5d		 pop	 ebp
  01fff	c3		 ret	 0
_P_con	ENDP
; Function compile flags: /Odtp
tv166 = -28						; size = 4
tv153 = -24						; size = 4
tv147 = -20						; size = 4
_isp$ = -16						; size = 4
_asize$ = -12						; size = 4
_nsubs$ = -8						; size = 4
_i$ = -4						; size = 4
_P_array PROC

; 996  : {				      /* sub1 sub2 ... subn n esize -- array */

  02000	55		 push	 ebp
  02001	8b ec		 mov	 ebp, esp
  02003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  02006	56		 push	 esi

; 997  :     int i, nsubs, asize = 1;

  02007	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _asize$[ebp], 1

; 998  :     stackitem *isp;
; 999  : 
; 1000 :     Sl(2);

  0200e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02013	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  02019	c1 f8 03	 sar	 eax, 3
  0201c	83 f8 02	 cmp	 eax, 2
  0201f	7d 0a		 jge	 SHORT $LN14@P_array
  02021	e8 00 00 00 00	 call	 _stakunder
  02026	e9 1c 02 00 00	 jmp	 $LN15@P_array
$LN14@P_array:

; 1001 : #ifndef NOMEMCHECK
; 1002 :     if (S0 <= 0)

  0202b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02031	89 4d ec	 mov	 DWORD PTR tv147[ebp], ecx
  02034	8b 55 ec	 mov	 edx, DWORD PTR tv147[ebp]
  02037	83 7a fc 00	 cmp	 DWORD PTR [edx-4], 0
  0203b	7f 18		 jg	 SHORT $LN13@P_array
  0203d	7c 09		 jl	 SHORT $LN17@P_array
  0203f	8b 45 ec	 mov	 eax, DWORD PTR tv147[ebp]
  02042	83 78 f8 00	 cmp	 DWORD PTR [eax-8], 0
  02046	77 0d		 ja	 SHORT $LN13@P_array
$LN17@P_array:

; 1003 :         trouble("Bad array element size");

  02048	68 00 00 00 00	 push	 OFFSET $SG83292
  0204d	e8 00 00 00 00	 call	 _trouble
  02052	83 c4 04	 add	 esp, 4
$LN13@P_array:

; 1004 :     if (S1 <= 0)

  02055	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0205b	89 4d e8	 mov	 DWORD PTR tv153[ebp], ecx
  0205e	8b 55 e8	 mov	 edx, DWORD PTR tv153[ebp]
  02061	83 7a f4 00	 cmp	 DWORD PTR [edx-12], 0
  02065	7f 18		 jg	 SHORT $LN12@P_array
  02067	7c 09		 jl	 SHORT $LN18@P_array
  02069	8b 45 e8	 mov	 eax, DWORD PTR tv153[ebp]
  0206c	83 78 f0 00	 cmp	 DWORD PTR [eax-16], 0
  02070	77 0d		 ja	 SHORT $LN12@P_array
$LN18@P_array:

; 1005 :         trouble("Bad array subscript count");

  02072	68 00 00 00 00	 push	 OFFSET $SG83294
  02077	e8 00 00 00 00	 call	 _trouble
  0207c	83 c4 04	 add	 esp, 4
$LN12@P_array:

; 1006 : #endif /* NOMEMCHECK */
; 1007 : 
; 1008 :     nsubs = S1; 		      /* Number of subscripts */

  0207f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02085	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  02088	89 55 f8	 mov	 DWORD PTR _nsubs$[ebp], edx

; 1009 :     Sl(nsubs + 2);		      /* Verify that dimensions are present */

  0208b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02090	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  02096	c1 f8 03	 sar	 eax, 3
  02099	8b 4d f8	 mov	 ecx, DWORD PTR _nsubs$[ebp]
  0209c	83 c1 02	 add	 ecx, 2
  0209f	3b c1		 cmp	 eax, ecx
  020a1	7d 0a		 jge	 SHORT $LN11@P_array
  020a3	e8 00 00 00 00	 call	 _stakunder
  020a8	e9 9a 01 00 00	 jmp	 $LN15@P_array
$LN11@P_array:

; 1010 : 
; 1011 :     /* Calculate size of array as the product of the subscripts */
; 1012 : 
; 1013 :     asize = S0; 		      /* Fundamental element size */

  020ad	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  020b3	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  020b6	89 45 f4	 mov	 DWORD PTR _asize$[ebp], eax

; 1014 :     isp = &S2;

  020b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  020bf	83 e9 18	 sub	 ecx, 24			; 00000018H
  020c2	89 4d f0	 mov	 DWORD PTR _isp$[ebp], ecx

; 1015 :     for (i = 0; i < nsubs; i++) {

  020c5	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  020cc	eb 09		 jmp	 SHORT $LN10@P_array
$LN9@P_array:
  020ce	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  020d1	83 c2 01	 add	 edx, 1
  020d4	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN10@P_array:
  020d7	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  020da	3b 45 f8	 cmp	 eax, DWORD PTR _nsubs$[ebp]
  020dd	7d 49		 jge	 SHORT $LN8@P_array

; 1016 : #ifndef NOMEMCHECK
; 1017 : 	if (*isp <= 0)

  020df	8b 4d f0	 mov	 ecx, DWORD PTR _isp$[ebp]
  020e2	89 4d e4	 mov	 DWORD PTR tv166[ebp], ecx
  020e5	8b 55 e4	 mov	 edx, DWORD PTR tv166[ebp]
  020e8	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  020ec	7f 17		 jg	 SHORT $LN7@P_array
  020ee	7c 08		 jl	 SHORT $LN19@P_array
  020f0	8b 45 e4	 mov	 eax, DWORD PTR tv166[ebp]
  020f3	83 38 00	 cmp	 DWORD PTR [eax], 0
  020f6	77 0d		 ja	 SHORT $LN7@P_array
$LN19@P_array:

; 1018 :             trouble("Bad array dimension");

  020f8	68 00 00 00 00	 push	 OFFSET $SG83300
  020fd	e8 00 00 00 00	 call	 _trouble
  02102	83 c4 04	 add	 esp, 4
$LN7@P_array:

; 1019 : #endif /* NOMEMCHECK */
; 1020 : 	asize *= *isp--;

  02105	8b 45 f4	 mov	 eax, DWORD PTR _asize$[ebp]
  02108	99		 cdq
  02109	8b 4d f0	 mov	 ecx, DWORD PTR _isp$[ebp]
  0210c	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0210f	56		 push	 esi
  02110	8b 09		 mov	 ecx, DWORD PTR [ecx]
  02112	51		 push	 ecx
  02113	52		 push	 edx
  02114	50		 push	 eax
  02115	e8 00 00 00 00	 call	 __allmul
  0211a	89 45 f4	 mov	 DWORD PTR _asize$[ebp], eax
  0211d	8b 55 f0	 mov	 edx, DWORD PTR _isp$[ebp]
  02120	83 ea 08	 sub	 edx, 8
  02123	89 55 f0	 mov	 DWORD PTR _isp$[ebp], edx

; 1021 :     }

  02126	eb a6		 jmp	 SHORT $LN9@P_array
$LN8@P_array:

; 1022 : 
; 1023 :     asize = (asize + (sizeof(stackitem) - 1)) / sizeof(stackitem);

  02128	8b 45 f4	 mov	 eax, DWORD PTR _asize$[ebp]
  0212b	83 c0 07	 add	 eax, 7
  0212e	c1 e8 03	 shr	 eax, 3
  02131	89 45 f4	 mov	 DWORD PTR _asize$[ebp], eax

; 1024 :     Ho(asize + nsubs + 2);	      /* Reserve space for array and header */

  02134	8b 4d f4	 mov	 ecx, DWORD PTR _asize$[ebp]
  02137	03 4d f8	 add	 ecx, DWORD PTR _nsubs$[ebp]
  0213a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  02140	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  02144	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  0214a	76 0a		 jbe	 SHORT $LN6@P_array
  0214c	e8 00 00 00 00	 call	 _heapover
  02151	e9 f1 00 00 00	 jmp	 $LN15@P_array
$LN6@P_array:

; 1025 :     P_create(); 		      /* Create variable */

  02156	e8 00 00 00 00	 call	 _P_create

; 1026 :     createword->wcode = P_arraysub;   /* Set method to subscript calculate */

  0215b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _createword
  02161	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], OFFSET _P_arraysub

; 1027 :     Hstore = nsubs;		      /* Header <- Number of subscripts */

  02168	8b 45 f8	 mov	 eax, DWORD PTR _nsubs$[ebp]
  0216b	99		 cdq
  0216c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  02172	89 01		 mov	 DWORD PTR [ecx], eax
  02174	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  02177	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  0217d	83 c2 08	 add	 edx, 8
  02180	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 1028 :     Hstore = S0;		      /* Header <- Fundamental element size */

  02186	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0218b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02191	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  02194	89 10		 mov	 DWORD PTR [eax], edx
  02196	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  02199	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0219c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  021a2	83 c2 08	 add	 edx, 8
  021a5	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 1029 :     isp = &S2;

  021ab	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  021b0	83 e8 18	 sub	 eax, 24			; 00000018H
  021b3	89 45 f0	 mov	 DWORD PTR _isp$[ebp], eax

; 1030 :     for (i = 0; i < nsubs; i++) {     /* Header <- Store subscripts */

  021b6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  021bd	eb 09		 jmp	 SHORT $LN5@P_array
$LN4@P_array:
  021bf	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  021c2	83 c1 01	 add	 ecx, 1
  021c5	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN5@P_array:
  021c8	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  021cb	3b 55 f8	 cmp	 edx, DWORD PTR _nsubs$[ebp]
  021ce	7d 2c		 jge	 SHORT $LN2@P_array

; 1031 : 	Hstore = *isp--;

  021d0	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  021d5	8b 4d f0	 mov	 ecx, DWORD PTR _isp$[ebp]
  021d8	8b 11		 mov	 edx, DWORD PTR [ecx]
  021da	89 10		 mov	 DWORD PTR [eax], edx
  021dc	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  021df	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  021e2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  021e8	83 c2 08	 add	 edx, 8
  021eb	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx
  021f1	8b 45 f0	 mov	 eax, DWORD PTR _isp$[ebp]
  021f4	83 e8 08	 sub	 eax, 8
  021f7	89 45 f0	 mov	 DWORD PTR _isp$[ebp], eax

; 1032 :     }

  021fa	eb c3		 jmp	 SHORT $LN4@P_array
$LN2@P_array:

; 1033 :     while (asize-- > 0) 	      /* Clear the array to zero */

  021fc	8b 4d f4	 mov	 ecx, DWORD PTR _asize$[ebp]
  021ff	8b 55 f4	 mov	 edx, DWORD PTR _asize$[ebp]
  02202	83 ea 01	 sub	 edx, 1
  02205	89 55 f4	 mov	 DWORD PTR _asize$[ebp], edx
  02208	85 c9		 test	 ecx, ecx
  0220a	7e 23		 jle	 SHORT $LN1@P_array

; 1034 : 	Hstore = 0;

  0220c	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  02211	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  02217	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0221e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  02224	83 c1 08	 add	 ecx, 8
  02227	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx
  0222d	eb cd		 jmp	 SHORT $LN2@P_array
$LN1@P_array:

; 1035 :     Npop(nsubs + 2);

  0222f	8b 55 f8	 mov	 edx, DWORD PTR _nsubs$[ebp]
  02232	8d 04 d5 10 00
	00 00		 lea	 eax, DWORD PTR [edx*8+16]
  02239	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0223f	2b c8		 sub	 ecx, eax
  02241	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN15@P_array:

; 1036 : }

  02247	5e		 pop	 esi
  02248	8b e5		 mov	 esp, ebp
  0224a	5d		 pop	 ebp
  0224b	c3		 ret	 0
_P_array ENDP
; Function compile flags: /Odtp
tv157 = -40						; size = 4
tv156 = -36						; size = 4
_subn$83271 = -32					; size = 8
_array$ = -24						; size = 4
_isp$ = -20						; size = 4
_offset$ = -16						; size = 4
_nsubs$ = -12						; size = 4
_i$ = -8						; size = 4
_esize$ = -4						; size = 4
_P_arraysub PROC

; 962  : {				      /* sub1 sub2 ... subn -- addr */

  02250	55		 push	 ebp
  02251	8b ec		 mov	 ebp, esp
  02253	83 ec 28	 sub	 esp, 40			; 00000028H
  02256	56		 push	 esi

; 963  :     int i, offset, esize, nsubs;
; 964  :     stackitem *array;
; 965  :     stackitem *isp;
; 966  : 
; 967  :     Sl(1);

  02257	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0225c	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  02262	c1 f8 03	 sar	 eax, 3
  02265	83 f8 01	 cmp	 eax, 1
  02268	7d 0a		 jge	 SHORT $LN11@P_arraysub
  0226a	e8 00 00 00 00	 call	 _stakunder
  0226f	e9 6f 01 00 00	 jmp	 $LN12@P_arraysub
$LN11@P_arraysub:

; 968  :     array = (((stackitem *) curword) + Dictwordl);

  02274	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _curword
  0227a	83 c1 10	 add	 ecx, 16			; 00000010H
  0227d	89 4d e8	 mov	 DWORD PTR _array$[ebp], ecx

; 969  :     Hpc(array);

  02280	8b 55 e8	 mov	 edx, DWORD PTR _array$[ebp]
  02283	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  02289	72 0b		 jb	 SHORT $LN9@P_arraysub
  0228b	8b 45 e8	 mov	 eax, DWORD PTR _array$[ebp]
  0228e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  02294	72 0a		 jb	 SHORT $LN10@P_arraysub
$LN9@P_arraysub:
  02296	e8 00 00 00 00	 call	 _badpointer
  0229b	e9 43 01 00 00	 jmp	 $LN12@P_arraysub
$LN10@P_arraysub:

; 970  :     nsubs = *array++;		      /* Load number of subscripts */

  022a0	8b 4d e8	 mov	 ecx, DWORD PTR _array$[ebp]
  022a3	8b 11		 mov	 edx, DWORD PTR [ecx]
  022a5	89 55 f4	 mov	 DWORD PTR _nsubs$[ebp], edx
  022a8	8b 45 e8	 mov	 eax, DWORD PTR _array$[ebp]
  022ab	83 c0 08	 add	 eax, 8
  022ae	89 45 e8	 mov	 DWORD PTR _array$[ebp], eax

; 971  :     esize = *array++;		      /* Load element size */

  022b1	8b 4d e8	 mov	 ecx, DWORD PTR _array$[ebp]
  022b4	8b 11		 mov	 edx, DWORD PTR [ecx]
  022b6	89 55 fc	 mov	 DWORD PTR _esize$[ebp], edx
  022b9	8b 45 e8	 mov	 eax, DWORD PTR _array$[ebp]
  022bc	83 c0 08	 add	 eax, 8
  022bf	89 45 e8	 mov	 DWORD PTR _array$[ebp], eax

; 972  : #ifndef NOMEMCHECK
; 973  :     isp = &S0;

  022c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  022c8	83 e9 08	 sub	 ecx, 8
  022cb	89 4d ec	 mov	 DWORD PTR _isp$[ebp], ecx

; 974  :     for (i = 0; i < nsubs; i++) {

  022ce	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  022d5	eb 09		 jmp	 SHORT $LN8@P_arraysub
$LN7@P_arraysub:
  022d7	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  022da	83 c2 01	 add	 edx, 1
  022dd	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN8@P_arraysub:
  022e0	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  022e3	3b 45 f4	 cmp	 eax, DWORD PTR _nsubs$[ebp]
  022e6	7d 5f		 jge	 SHORT $LN6@P_arraysub

; 975  : 	stackitem subn = *isp--;

  022e8	8b 4d ec	 mov	 ecx, DWORD PTR _isp$[ebp]
  022eb	8b 11		 mov	 edx, DWORD PTR [ecx]
  022ed	89 55 e0	 mov	 DWORD PTR _subn$83271[ebp], edx
  022f0	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  022f3	89 45 e4	 mov	 DWORD PTR _subn$83271[ebp+4], eax
  022f6	8b 4d ec	 mov	 ecx, DWORD PTR _isp$[ebp]
  022f9	83 e9 08	 sub	 ecx, 8
  022fc	89 4d ec	 mov	 DWORD PTR _isp$[ebp], ecx

; 976  : 
; 977  : 	if (subn < 0 || subn >= array[i])

  022ff	83 7d e4 00	 cmp	 DWORD PTR _subn$83271[ebp+4], 0
  02303	7c 33		 jl	 SHORT $LN4@P_arraysub
  02305	7f 06		 jg	 SHORT $LN14@P_arraysub
  02307	83 7d e0 00	 cmp	 DWORD PTR _subn$83271[ebp], 0
  0230b	72 2b		 jb	 SHORT $LN4@P_arraysub
$LN14@P_arraysub:
  0230d	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  02310	8b 45 e8	 mov	 eax, DWORD PTR _array$[ebp]
  02313	89 45 dc	 mov	 DWORD PTR tv156[ebp], eax
  02316	89 55 d8	 mov	 DWORD PTR tv157[ebp], edx
  02319	8b 4d d8	 mov	 ecx, DWORD PTR tv157[ebp]
  0231c	8b 55 dc	 mov	 edx, DWORD PTR tv156[ebp]
  0231f	8b 45 e4	 mov	 eax, DWORD PTR _subn$83271[ebp+4]
  02322	3b 44 ca 04	 cmp	 eax, DWORD PTR [edx+ecx*8+4]
  02326	7c 1d		 jl	 SHORT $LN5@P_arraysub
  02328	7f 0e		 jg	 SHORT $LN4@P_arraysub
  0232a	8b 4d d8	 mov	 ecx, DWORD PTR tv157[ebp]
  0232d	8b 55 dc	 mov	 edx, DWORD PTR tv156[ebp]
  02330	8b 45 e0	 mov	 eax, DWORD PTR _subn$83271[ebp]
  02333	3b 04 ca	 cmp	 eax, DWORD PTR [edx+ecx*8]
  02336	72 0d		 jb	 SHORT $LN5@P_arraysub
$LN4@P_arraysub:

; 978  :             trouble("Subscript out of range");

  02338	68 00 00 00 00	 push	 OFFSET $SG83274
  0233d	e8 00 00 00 00	 call	 _trouble
  02342	83 c4 04	 add	 esp, 4
$LN5@P_arraysub:

; 979  :     }

  02345	eb 90		 jmp	 SHORT $LN7@P_arraysub
$LN6@P_arraysub:

; 980  : #endif /* NOMEMCHECK */
; 981  :     isp = &S0;

  02347	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0234d	83 e9 08	 sub	 ecx, 8
  02350	89 4d ec	 mov	 DWORD PTR _isp$[ebp], ecx

; 982  :     offset = *isp;		      /* Load initial offset */

  02353	8b 55 ec	 mov	 edx, DWORD PTR _isp$[ebp]
  02356	8b 02		 mov	 eax, DWORD PTR [edx]
  02358	89 45 f0	 mov	 DWORD PTR _offset$[ebp], eax

; 983  :     for (i = 1; i < nsubs; i++)

  0235b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  02362	eb 09		 jmp	 SHORT $LN3@P_arraysub
$LN2@P_arraysub:
  02364	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  02367	83 c1 01	 add	 ecx, 1
  0236a	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$LN3@P_arraysub:
  0236d	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  02370	3b 55 f4	 cmp	 edx, DWORD PTR _nsubs$[ebp]
  02373	7d 34		 jge	 SHORT $LN1@P_arraysub

; 984  : 	offset = (offset * (*(++array))) + *(--isp);

  02375	8b 45 e8	 mov	 eax, DWORD PTR _array$[ebp]
  02378	83 c0 08	 add	 eax, 8
  0237b	89 45 e8	 mov	 DWORD PTR _array$[ebp], eax
  0237e	8b 4d ec	 mov	 ecx, DWORD PTR _isp$[ebp]
  02381	83 e9 08	 sub	 ecx, 8
  02384	89 4d ec	 mov	 DWORD PTR _isp$[ebp], ecx
  02387	8b 45 f0	 mov	 eax, DWORD PTR _offset$[ebp]
  0238a	99		 cdq
  0238b	8b 4d e8	 mov	 ecx, DWORD PTR _array$[ebp]
  0238e	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  02391	56		 push	 esi
  02392	8b 09		 mov	 ecx, DWORD PTR [ecx]
  02394	51		 push	 ecx
  02395	52		 push	 edx
  02396	50		 push	 eax
  02397	e8 00 00 00 00	 call	 __allmul
  0239c	8b 4d ec	 mov	 ecx, DWORD PTR _isp$[ebp]
  0239f	03 01		 add	 eax, DWORD PTR [ecx]
  023a1	13 51 04	 adc	 edx, DWORD PTR [ecx+4]
  023a4	89 45 f0	 mov	 DWORD PTR _offset$[ebp], eax
  023a7	eb bb		 jmp	 SHORT $LN2@P_arraysub
$LN1@P_arraysub:

; 985  :     Npop(nsubs - 1);

  023a9	8b 55 f4	 mov	 edx, DWORD PTR _nsubs$[ebp]
  023ac	8d 04 d5 f8 ff
	ff ff		 lea	 eax, DWORD PTR [edx*8-8]
  023b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  023b9	2b c8		 sub	 ecx, eax
  023bb	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx

; 986  :     /* Calculate subscripted address.  We start at the current word,
; 987  :        advance to the body, skip two more words for the subscript count
; 988  :        and the fundamental element size, then skip the subscript bounds
; 989  :        words (as many as there are subscripts).  Then, finally, we
; 990  :        can add the calculated offset into the array. */
; 991  :     S0 = (stackitem) (((char *) (((stackitem *) curword) +
; 992  : 	    Dictwordl + 2 + nsubs)) + (esize * offset));

  023c1	8b 55 f4	 mov	 edx, DWORD PTR _nsubs$[ebp]
  023c4	a1 00 00 00 00	 mov	 eax, DWORD PTR _curword
  023c9	8d 44 d0 20	 lea	 eax, DWORD PTR [eax+edx*8+32]
  023cd	8b 4d fc	 mov	 ecx, DWORD PTR _esize$[ebp]
  023d0	0f af 4d f0	 imul	 ecx, DWORD PTR _offset$[ebp]
  023d4	03 c1		 add	 eax, ecx
  023d6	99		 cdq
  023d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  023dd	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  023e0	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN12@P_arraysub:

; 993  : }

  023e3	5e		 pop	 esi
  023e4	8b e5		 mov	 esp, ebp
  023e6	5d		 pop	 ebp
  023e7	c3		 ret	 0
_P_arraysub ENDP
_TEXT	ENDS
EXTRN	_printf:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_strlit PROC

; 1044 : {

  023f0	55		 push	 ebp
  023f1	8b ec		 mov	 ebp, esp

; 1045 :     So(1);

  023f3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  023f8	83 c0 08	 add	 eax, 8
  023fb	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  02401	76 07		 jbe	 SHORT $LN2@P_strlit
  02403	e8 00 00 00 00	 call	 _stakover
  02408	eb 5f		 jmp	 SHORT $LN3@P_strlit
$LN2@P_strlit:

; 1046 :     Push = (stackitem) (((char *) ip) + 1);

  0240a	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  0240f	83 c0 01	 add	 eax, 1
  02412	99		 cdq
  02413	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02419	89 01		 mov	 DWORD PTR [ecx], eax
  0241b	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0241e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02424	83 c2 08	 add	 edx, 8
  02427	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 1047 : #ifdef TRACE
; 1048 :     if (atl_trace) {

  0242d	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_trace
  02432	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _atl_trace+4
  02438	74 17		 je	 SHORT $LN1@P_strlit

; 1049 :         V printf("\"%s\" ", (((char *) ip) + 1));

  0243a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ip
  02440	83 c1 01	 add	 ecx, 1
  02443	51		 push	 ecx
  02444	68 00 00 00 00	 push	 OFFSET $SG83318
  02449	e8 00 00 00 00	 call	 _printf
  0244e	83 c4 08	 add	 esp, 8
$LN1@P_strlit:

; 1050 :     }
; 1051 : #endif /* TRACE */
; 1052 :     Skipstring; 		      /* Advance IP past it */

  02451	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ip
  02457	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0245a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ip
  02460	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  02463	89 15 00 00 00
	00		 mov	 DWORD PTR _ip, edx
$LN3@P_strlit:

; 1053 : }

  02469	5d		 pop	 ebp
  0246a	c3		 ret	 0
_P_strlit ENDP
; Function compile flags: /Odtp
_P_string PROC

; 1056 : {

  02470	55		 push	 ebp
  02471	8b ec		 mov	 ebp, esp

; 1057 :     Sl(1);

  02473	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02478	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0247e	c1 f8 03	 sar	 eax, 3
  02481	83 f8 01	 cmp	 eax, 1
  02484	7d 0a		 jge	 SHORT $LN2@P_string
  02486	e8 00 00 00 00	 call	 _stakunder
  0248b	e9 84 00 00 00	 jmp	 $LN3@P_string
$LN2@P_string:

; 1058 :     Ho((S0 + 1 + sizeof(stackitem)) / sizeof(stackitem));

  02490	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02496	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  02499	83 c2 09	 add	 edx, 9
  0249c	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0249f	83 d0 00	 adc	 eax, 0
  024a2	6a 00		 push	 0
  024a4	6a 08		 push	 8
  024a6	50		 push	 eax
  024a7	52		 push	 edx
  024a8	e8 00 00 00 00	 call	 __alldiv
  024ad	6a 00		 push	 0
  024af	6a 08		 push	 8
  024b1	52		 push	 edx
  024b2	50		 push	 eax
  024b3	e8 00 00 00 00	 call	 __allmul
  024b8	03 05 00 00 00
	00		 add	 eax, DWORD PTR _hptr
  024be	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  024c4	76 07		 jbe	 SHORT $LN1@P_string
  024c6	e8 00 00 00 00	 call	 _heapover
  024cb	eb 47		 jmp	 SHORT $LN3@P_string
$LN1@P_string:

; 1059 :     P_create(); 		      /* Create variable */

  024cd	e8 00 00 00 00	 call	 _P_create

; 1060 :     /* Allocate storage for string */
; 1061 :     hptr += (S0 + 1 + sizeof(stackitem)) / sizeof(stackitem);

  024d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  024d8	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  024db	83 c2 09	 add	 edx, 9
  024de	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  024e1	83 d0 00	 adc	 eax, 0
  024e4	6a 00		 push	 0
  024e6	6a 08		 push	 8
  024e8	50		 push	 eax
  024e9	52		 push	 edx
  024ea	e8 00 00 00 00	 call	 __alldiv
  024ef	6a 00		 push	 0
  024f1	6a 08		 push	 8
  024f3	52		 push	 edx
  024f4	50		 push	 eax
  024f5	e8 00 00 00 00	 call	 __allmul
  024fa	03 05 00 00 00
	00		 add	 eax, DWORD PTR _hptr
  02500	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 1062 :     Pop;

  02505	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0250b	83 e9 08	 sub	 ecx, 8
  0250e	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN3@P_string:

; 1063 : }

  02514	5d		 pop	 ebp
  02515	c3		 ret	 0
_P_string ENDP
_TEXT	ENDS
EXTRN	_strcpy:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_strcpy PROC

; 1066 : {

  02520	55		 push	 ebp
  02521	8b ec		 mov	 ebp, esp

; 1067 :     Sl(2);

  02523	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02528	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0252e	c1 f8 03	 sar	 eax, 3
  02531	83 f8 02	 cmp	 eax, 2
  02534	7d 07		 jge	 SHORT $LN5@P_strcpy
  02536	e8 00 00 00 00	 call	 _stakunder
  0253b	eb 7b		 jmp	 SHORT $LN6@P_strcpy
$LN5@P_strcpy:

; 1068 :     Hpc(S0);

  0253d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02543	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  02546	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  0254c	72 10		 jb	 SHORT $LN3@P_strcpy
  0254e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02553	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  02556	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  0255c	72 07		 jb	 SHORT $LN4@P_strcpy
$LN3@P_strcpy:
  0255e	e8 00 00 00 00	 call	 _badpointer
  02563	eb 53		 jmp	 SHORT $LN6@P_strcpy
$LN4@P_strcpy:

; 1069 :     Hpc(S1);

  02565	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0256b	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  0256e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  02574	72 11		 jb	 SHORT $LN1@P_strcpy
  02576	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0257c	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  0257f	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  02585	72 07		 jb	 SHORT $LN2@P_strcpy
$LN1@P_strcpy:
  02587	e8 00 00 00 00	 call	 _badpointer
  0258c	eb 2a		 jmp	 SHORT $LN6@P_strcpy
$LN2@P_strcpy:

; 1070 :     V strcpy((char *) S0, (char *) S1);

  0258e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02593	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  02596	51		 push	 ecx
  02597	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0259d	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  025a0	50		 push	 eax
  025a1	e8 00 00 00 00	 call	 _strcpy
  025a6	83 c4 08	 add	 esp, 8

; 1071 :     Pop2;

  025a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  025af	83 e9 10	 sub	 ecx, 16			; 00000010H
  025b2	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN6@P_strcpy:

; 1072 : }

  025b8	5d		 pop	 ebp
  025b9	c3		 ret	 0
_P_strcpy ENDP
_TEXT	ENDS
EXTRN	_strcat:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_strcat PROC

; 1075 : {

  025c0	55		 push	 ebp
  025c1	8b ec		 mov	 ebp, esp

; 1076 :     Sl(2);

  025c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  025c8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  025ce	c1 f8 03	 sar	 eax, 3
  025d1	83 f8 02	 cmp	 eax, 2
  025d4	7d 07		 jge	 SHORT $LN5@P_strcat
  025d6	e8 00 00 00 00	 call	 _stakunder
  025db	eb 7b		 jmp	 SHORT $LN6@P_strcat
$LN5@P_strcat:

; 1077 :     Hpc(S0);

  025dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  025e3	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  025e6	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  025ec	72 10		 jb	 SHORT $LN3@P_strcat
  025ee	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  025f3	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  025f6	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  025fc	72 07		 jb	 SHORT $LN4@P_strcat
$LN3@P_strcat:
  025fe	e8 00 00 00 00	 call	 _badpointer
  02603	eb 53		 jmp	 SHORT $LN6@P_strcat
$LN4@P_strcat:

; 1078 :     Hpc(S1);

  02605	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0260b	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  0260e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  02614	72 11		 jb	 SHORT $LN1@P_strcat
  02616	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0261c	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  0261f	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  02625	72 07		 jb	 SHORT $LN2@P_strcat
$LN1@P_strcat:
  02627	e8 00 00 00 00	 call	 _badpointer
  0262c	eb 2a		 jmp	 SHORT $LN6@P_strcat
$LN2@P_strcat:

; 1079 :     V strcat((char *) S0, (char *) S1);

  0262e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02633	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  02636	51		 push	 ecx
  02637	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0263d	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  02640	50		 push	 eax
  02641	e8 00 00 00 00	 call	 _strcat
  02646	83 c4 08	 add	 esp, 8

; 1080 :     Pop2;

  02649	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0264f	83 e9 10	 sub	 ecx, 16			; 00000010H
  02652	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN6@P_strcat:

; 1081 : }

  02658	5d		 pop	 ebp
  02659	c3		 ret	 0
_P_strcat ENDP
; Function compile flags: /Odtp
_P_strlen PROC

; 1084 : {

  02660	55		 push	 ebp
  02661	8b ec		 mov	 ebp, esp

; 1085 :     Sl(1);

  02663	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02668	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0266e	c1 f8 03	 sar	 eax, 3
  02671	83 f8 01	 cmp	 eax, 1
  02674	7d 07		 jge	 SHORT $LN3@P_strlen
  02676	e8 00 00 00 00	 call	 _stakunder
  0267b	eb 48		 jmp	 SHORT $LN4@P_strlen
$LN3@P_strlen:

; 1086 :     Hpc(S0);

  0267d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02683	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  02686	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  0268c	72 10		 jb	 SHORT $LN1@P_strlen
  0268e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02693	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  02696	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  0269c	72 07		 jb	 SHORT $LN2@P_strlen
$LN1@P_strlen:
  0269e	e8 00 00 00 00	 call	 _badpointer
  026a3	eb 20		 jmp	 SHORT $LN4@P_strlen
$LN2@P_strlen:

; 1087 :     S0 = strlen((char *) S0);

  026a5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  026ab	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  026ae	50		 push	 eax
  026af	e8 00 00 00 00	 call	 _strlen
  026b4	83 c4 04	 add	 esp, 4
  026b7	33 c9		 xor	 ecx, ecx
  026b9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  026bf	89 42 f8	 mov	 DWORD PTR [edx-8], eax
  026c2	89 4a fc	 mov	 DWORD PTR [edx-4], ecx
$LN4@P_strlen:

; 1088 : }

  026c5	5d		 pop	 ebp
  026c6	c3		 ret	 0
_P_strlen ENDP
_TEXT	ENDS
EXTRN	_strcmp:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv90 = -8						; size = 4
_i$ = -4						; size = 4
_P_strcmp PROC

; 1091 : {

  026d0	55		 push	 ebp
  026d1	8b ec		 mov	 ebp, esp
  026d3	83 ec 08	 sub	 esp, 8

; 1092 :     int i;
; 1093 : 
; 1094 :     Sl(2);

  026d6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  026db	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  026e1	c1 f8 03	 sar	 eax, 3
  026e4	83 f8 02	 cmp	 eax, 2
  026e7	7d 0a		 jge	 SHORT $LN5@P_strcmp
  026e9	e8 00 00 00 00	 call	 _stakunder
  026ee	e9 b0 00 00 00	 jmp	 $LN6@P_strcmp
$LN5@P_strcmp:

; 1095 :     Hpc(S0);

  026f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  026f9	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  026fc	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  02702	72 10		 jb	 SHORT $LN3@P_strcmp
  02704	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02709	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0270c	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  02712	72 0a		 jb	 SHORT $LN4@P_strcmp
$LN3@P_strcmp:
  02714	e8 00 00 00 00	 call	 _badpointer
  02719	e9 85 00 00 00	 jmp	 $LN6@P_strcmp
$LN4@P_strcmp:

; 1096 :     Hpc(S1);

  0271e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02724	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  02727	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  0272d	72 11		 jb	 SHORT $LN1@P_strcmp
  0272f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02735	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  02738	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  0273e	72 07		 jb	 SHORT $LN2@P_strcmp
$LN1@P_strcmp:
  02740	e8 00 00 00 00	 call	 _badpointer
  02745	eb 5c		 jmp	 SHORT $LN6@P_strcmp
$LN2@P_strcmp:

; 1097 :     i = strcmp((char *) S1, (char *) S0);

  02747	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0274c	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0274f	51		 push	 ecx
  02750	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02756	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  02759	50		 push	 eax
  0275a	e8 00 00 00 00	 call	 _strcmp
  0275f	83 c4 08	 add	 esp, 8
  02762	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 1098 :     S1 = (i == 0) ? 0L : ((i > 0) ? 1L : -1L);

  02765	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  02769	75 09		 jne	 SHORT $LN8@P_strcmp
  0276b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv90[ebp], 0
  02772	eb 10		 jmp	 SHORT $LN9@P_strcmp
$LN8@P_strcmp:
  02774	33 c9		 xor	 ecx, ecx
  02776	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  0277a	0f 9f c1	 setg	 cl
  0277d	8d 4c 09 ff	 lea	 ecx, DWORD PTR [ecx+ecx-1]
  02781	89 4d f8	 mov	 DWORD PTR tv90[ebp], ecx
$LN9@P_strcmp:
  02784	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  02787	99		 cdq
  02788	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0278e	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  02791	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 1099 :     Pop;

  02794	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0279a	83 ea 08	 sub	 edx, 8
  0279d	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN6@P_strcmp:

; 1100 : }

  027a3	8b e5		 mov	 esp, ebp
  027a5	5d		 pop	 ebp
  027a6	c3		 ret	 0
_P_strcmp ENDP
; Function compile flags: /Odtp
_P_strchar PROC

; 1103 : {

  027b0	55		 push	 ebp
  027b1	8b ec		 mov	 ebp, esp

; 1104 :     Sl(2);

  027b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  027b8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  027be	c1 f8 03	 sar	 eax, 3
  027c1	83 f8 02	 cmp	 eax, 2
  027c4	7d 0a		 jge	 SHORT $LN5@P_strchar
  027c6	e8 00 00 00 00	 call	 _stakunder
  027cb	e9 8a 00 00 00	 jmp	 $LN6@P_strchar
$LN5@P_strchar:

; 1105 :     Hpc(S0);

  027d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  027d6	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  027d9	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  027df	72 10		 jb	 SHORT $LN3@P_strchar
  027e1	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  027e6	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  027e9	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  027ef	72 07		 jb	 SHORT $LN4@P_strchar
$LN3@P_strchar:
  027f1	e8 00 00 00 00	 call	 _badpointer
  027f6	eb 62		 jmp	 SHORT $LN6@P_strchar
$LN4@P_strchar:

; 1106 :     Hpc(S1);

  027f8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  027fe	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  02801	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  02807	72 11		 jb	 SHORT $LN1@P_strchar
  02809	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0280f	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  02812	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  02818	72 07		 jb	 SHORT $LN2@P_strchar
$LN1@P_strchar:
  0281a	e8 00 00 00 00	 call	 _badpointer
  0281f	eb 39		 jmp	 SHORT $LN6@P_strchar
$LN2@P_strchar:

; 1107 :     S1 = (stackitem) strchr((char *) S1, *((char *) S0));

  02821	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02826	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  02829	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0282c	52		 push	 edx
  0282d	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02832	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  02835	51		 push	 ecx
  02836	e8 00 00 00 00	 call	 _strchr
  0283b	83 c4 08	 add	 esp, 8
  0283e	99		 cdq
  0283f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02845	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  02848	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 1108 :     Pop;

  0284b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02851	83 ea 08	 sub	 edx, 8
  02854	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN6@P_strchar:

; 1109 : }

  0285a	5d		 pop	 ebp
  0285b	c3		 ret	 0
_P_strchar ENDP
; Function compile flags: /Odtp
_sl$ = -24						; size = 4
_ss$ = -20						; size = 4
_se$ = -16						; size = 4
_ds$ = -12						; size = 4
_sn$ = -8						; size = 4
_sp$ = -4						; size = 4
_P_substr PROC

; 1112 : {				      /* source start length/-1 dest -- */

  02860	55		 push	 ebp
  02861	8b ec		 mov	 ebp, esp
  02863	83 ec 18	 sub	 esp, 24			; 00000018H

; 1113 :     long sl, sn;
; 1114 :     char *ss, *sp, *se, *ds;
; 1115 : 
; 1116 :     Sl(4);

  02866	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0286b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  02871	c1 f8 03	 sar	 eax, 3
  02874	83 f8 04	 cmp	 eax, 4
  02877	7d 0a		 jge	 SHORT $LN8@P_substr
  02879	e8 00 00 00 00	 call	 _stakunder
  0287e	e9 09 01 00 00	 jmp	 $LN9@P_substr
$LN8@P_substr:

; 1117 :     Hpc(S0);

  02883	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02889	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  0288c	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  02892	72 10		 jb	 SHORT $LN6@P_substr
  02894	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02899	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0289c	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  028a2	72 0a		 jb	 SHORT $LN7@P_substr
$LN6@P_substr:
  028a4	e8 00 00 00 00	 call	 _badpointer
  028a9	e9 de 00 00 00	 jmp	 $LN9@P_substr
$LN7@P_substr:

; 1118 :     Hpc(S3);

  028ae	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  028b4	8b 42 e0	 mov	 eax, DWORD PTR [edx-32]
  028b7	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  028bd	72 11		 jb	 SHORT $LN4@P_substr
  028bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  028c5	8b 51 e0	 mov	 edx, DWORD PTR [ecx-32]
  028c8	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  028ce	72 0a		 jb	 SHORT $LN5@P_substr
$LN4@P_substr:
  028d0	e8 00 00 00 00	 call	 _badpointer
  028d5	e9 b2 00 00 00	 jmp	 $LN9@P_substr
$LN5@P_substr:

; 1119 :     sl = strlen(ss = ((char *) S3));

  028da	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  028df	8b 48 e0	 mov	 ecx, DWORD PTR [eax-32]
  028e2	89 4d ec	 mov	 DWORD PTR _ss$[ebp], ecx
  028e5	8b 55 ec	 mov	 edx, DWORD PTR _ss$[ebp]
  028e8	52		 push	 edx
  028e9	e8 00 00 00 00	 call	 _strlen
  028ee	83 c4 04	 add	 esp, 4
  028f1	89 45 e8	 mov	 DWORD PTR _sl$[ebp], eax

; 1120 :     se = ss + sl;

  028f4	8b 45 ec	 mov	 eax, DWORD PTR _ss$[ebp]
  028f7	03 45 e8	 add	 eax, DWORD PTR _sl$[ebp]
  028fa	89 45 f0	 mov	 DWORD PTR _se$[ebp], eax

; 1121 :     sp = ((char *) S3) + S2;

  028fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02903	8b 51 e0	 mov	 edx, DWORD PTR [ecx-32]
  02906	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0290b	8b 48 e8	 mov	 ecx, DWORD PTR [eax-24]
  0290e	03 d1		 add	 edx, ecx
  02910	89 55 fc	 mov	 DWORD PTR _sp$[ebp], edx

; 1122 :     if ((sn = S1) < 0)

  02913	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02919	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  0291c	89 45 f8	 mov	 DWORD PTR _sn$[ebp], eax
  0291f	83 7d f8 00	 cmp	 DWORD PTR _sn$[ebp], 0
  02923	7d 07		 jge	 SHORT $LN3@P_substr

; 1123 : 	sn = 999999L;

  02925	c7 45 f8 3f 42
	0f 00		 mov	 DWORD PTR _sn$[ebp], 999999 ; 000f423fH
$LN3@P_substr:

; 1124 :     ds = (char *) S0;

  0292c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02932	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  02935	89 55 f4	 mov	 DWORD PTR _ds$[ebp], edx
$LN2@P_substr:

; 1125 :     while (sn-- && (sp < se))

  02938	8b 45 f8	 mov	 eax, DWORD PTR _sn$[ebp]
  0293b	8b 4d f8	 mov	 ecx, DWORD PTR _sn$[ebp]
  0293e	83 e9 01	 sub	 ecx, 1
  02941	89 4d f8	 mov	 DWORD PTR _sn$[ebp], ecx
  02944	85 c0		 test	 eax, eax
  02946	74 26		 je	 SHORT $LN1@P_substr
  02948	8b 55 fc	 mov	 edx, DWORD PTR _sp$[ebp]
  0294b	3b 55 f0	 cmp	 edx, DWORD PTR _se$[ebp]
  0294e	73 1e		 jae	 SHORT $LN1@P_substr

; 1126 : 	*ds++ = *sp++;

  02950	8b 45 f4	 mov	 eax, DWORD PTR _ds$[ebp]
  02953	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  02956	8a 11		 mov	 dl, BYTE PTR [ecx]
  02958	88 10		 mov	 BYTE PTR [eax], dl
  0295a	8b 45 f4	 mov	 eax, DWORD PTR _ds$[ebp]
  0295d	83 c0 01	 add	 eax, 1
  02960	89 45 f4	 mov	 DWORD PTR _ds$[ebp], eax
  02963	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  02966	83 c1 01	 add	 ecx, 1
  02969	89 4d fc	 mov	 DWORD PTR _sp$[ebp], ecx
  0296c	eb ca		 jmp	 SHORT $LN2@P_substr
$LN1@P_substr:

; 1127 :     *ds++ = EOS;

  0296e	8b 55 f4	 mov	 edx, DWORD PTR _ds$[ebp]
  02971	c6 02 00	 mov	 BYTE PTR [edx], 0
  02974	8b 45 f4	 mov	 eax, DWORD PTR _ds$[ebp]
  02977	83 c0 01	 add	 eax, 1
  0297a	89 45 f4	 mov	 DWORD PTR _ds$[ebp], eax

; 1128 :     Npop(4);

  0297d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02983	83 e9 20	 sub	 ecx, 32			; 00000020H
  02986	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN9@P_substr:

; 1129 : }

  0298c	8b e5		 mov	 esp, ebp
  0298e	5d		 pop	 ebp
  0298f	c3		 ret	 0
_P_substr ENDP
_TEXT	ENDS
EXTRN	_sprintf:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_strform PROC

; 1132 : {                                     /* value "%ld" str -- */

  02990	55		 push	 ebp
  02991	8b ec		 mov	 ebp, esp

; 1133 :     Sl(2);

  02993	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02998	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0299e	c1 f8 03	 sar	 eax, 3
  029a1	83 f8 02	 cmp	 eax, 2
  029a4	7d 0a		 jge	 SHORT $LN5@P_strform
  029a6	e8 00 00 00 00	 call	 _stakunder
  029ab	e9 88 00 00 00	 jmp	 $LN6@P_strform
$LN5@P_strform:

; 1134 :     Hpc(S0);

  029b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  029b6	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  029b9	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  029bf	72 10		 jb	 SHORT $LN3@P_strform
  029c1	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  029c6	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  029c9	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  029cf	72 07		 jb	 SHORT $LN4@P_strform
$LN3@P_strform:
  029d1	e8 00 00 00 00	 call	 _badpointer
  029d6	eb 60		 jmp	 SHORT $LN6@P_strform
$LN4@P_strform:

; 1135 :     Hpc(S1);

  029d8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  029de	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  029e1	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  029e7	72 11		 jb	 SHORT $LN1@P_strform
  029e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  029ef	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  029f2	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  029f8	72 07		 jb	 SHORT $LN2@P_strform
$LN1@P_strform:
  029fa	e8 00 00 00 00	 call	 _badpointer
  029ff	eb 37		 jmp	 SHORT $LN6@P_strform
$LN2@P_strform:

; 1136 :     V sprintf((char *) S0, (char *) S1, S2);

  02a01	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02a06	8b 48 ec	 mov	 ecx, DWORD PTR [eax-20]
  02a09	51		 push	 ecx
  02a0a	8b 50 e8	 mov	 edx, DWORD PTR [eax-24]
  02a0d	52		 push	 edx
  02a0e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02a13	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  02a16	51		 push	 ecx
  02a17	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02a1d	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  02a20	50		 push	 eax
  02a21	e8 00 00 00 00	 call	 _sprintf
  02a26	83 c4 10	 add	 esp, 16			; 00000010H

; 1137 :     Npop(3);

  02a29	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02a2f	83 e9 18	 sub	 ecx, 24			; 00000018H
  02a32	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN6@P_strform:

; 1138 : }

  02a38	5d		 pop	 ebp
  02a39	c3		 ret	 0
_P_strform ENDP
_TEXT	ENDS
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_fstrform PROC

; 1142 : {                                     /* rvalue "%6.2f" str -- */

  02a40	55		 push	 ebp
  02a41	8b ec		 mov	 ebp, esp

; 1143 :     Sl(2 + Realsize);

  02a43	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02a48	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  02a4e	c1 f8 03	 sar	 eax, 3
  02a51	83 f8 03	 cmp	 eax, 3
  02a54	73 0a		 jae	 SHORT $LN5@P_fstrform
  02a56	e8 00 00 00 00	 call	 _stakunder
  02a5b	e9 89 00 00 00	 jmp	 $LN6@P_fstrform
$LN5@P_fstrform:

; 1144 :     Hpc(S0);

  02a60	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02a66	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  02a69	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  02a6f	72 10		 jb	 SHORT $LN3@P_fstrform
  02a71	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02a76	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  02a79	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  02a7f	72 07		 jb	 SHORT $LN4@P_fstrform
$LN3@P_fstrform:
  02a81	e8 00 00 00 00	 call	 _badpointer
  02a86	eb 61		 jmp	 SHORT $LN6@P_fstrform
$LN4@P_fstrform:

; 1145 :     Hpc(S1);

  02a88	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02a8e	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  02a91	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  02a97	72 11		 jb	 SHORT $LN1@P_fstrform
  02a99	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02a9f	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  02aa2	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  02aa8	72 07		 jb	 SHORT $LN2@P_fstrform
$LN1@P_fstrform:
  02aaa	e8 00 00 00 00	 call	 _badpointer
  02aaf	eb 38		 jmp	 SHORT $LN6@P_fstrform
$LN2@P_fstrform:

; 1146 :     V sprintf((char *) S0, (char *) S1, REAL2);

  02ab1	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02ab6	83 ec 08	 sub	 esp, 8
  02ab9	dd 40 e8	 fld	 QWORD PTR [eax-24]
  02abc	dd 1c 24	 fstp	 QWORD PTR [esp]
  02abf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02ac5	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  02ac8	52		 push	 edx
  02ac9	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02ace	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  02ad1	51		 push	 ecx
  02ad2	e8 00 00 00 00	 call	 _sprintf
  02ad7	83 c4 10	 add	 esp, 16			; 00000010H

; 1147 :     Npop(2 + Realsize);

  02ada	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02ae0	83 ea 18	 sub	 edx, 24			; 00000018H
  02ae3	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN6@P_fstrform:

; 1148 : }

  02ae9	5d		 pop	 ebp
  02aea	c3		 ret	 0
_P_fstrform ENDP
_TEXT	ENDS
EXTRN	_strtoul:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_eptr$ = -12						; size = 4
_is$ = -8						; size = 8
_P_strint PROC

; 1152 : {				      /* str -- endptr value */

  02af0	55		 push	 ebp
  02af1	8b ec		 mov	 ebp, esp
  02af3	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1153 :     stackitem is;
; 1154 :     char *eptr;
; 1155 : 
; 1156 :     Sl(1);

  02af6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02afb	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  02b01	c1 f8 03	 sar	 eax, 3
  02b04	83 f8 01	 cmp	 eax, 1
  02b07	7d 0a		 jge	 SHORT $LN4@P_strint
  02b09	e8 00 00 00 00	 call	 _stakunder
  02b0e	e9 91 00 00 00	 jmp	 $LN5@P_strint
$LN4@P_strint:

; 1157 :     So(1);

  02b13	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02b19	83 c1 08	 add	 ecx, 8
  02b1c	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _stacktop
  02b22	76 07		 jbe	 SHORT $LN3@P_strint
  02b24	e8 00 00 00 00	 call	 _stakover
  02b29	eb 79		 jmp	 SHORT $LN5@P_strint
$LN3@P_strint:

; 1158 :     Hpc(S0);

  02b2b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02b31	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  02b34	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  02b3a	72 11		 jb	 SHORT $LN1@P_strint
  02b3c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02b42	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  02b45	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  02b4b	72 07		 jb	 SHORT $LN2@P_strint
$LN1@P_strint:
  02b4d	e8 00 00 00 00	 call	 _badpointer
  02b52	eb 50		 jmp	 SHORT $LN5@P_strint
$LN2@P_strint:

; 1159 :     is = strtoul((char *) S0, &eptr, 0);

  02b54	6a 00		 push	 0
  02b56	8d 45 f4	 lea	 eax, DWORD PTR _eptr$[ebp]
  02b59	50		 push	 eax
  02b5a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02b60	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  02b63	52		 push	 edx
  02b64	e8 00 00 00 00	 call	 _strtoul
  02b69	83 c4 0c	 add	 esp, 12			; 0000000cH
  02b6c	33 c9		 xor	 ecx, ecx
  02b6e	89 45 f8	 mov	 DWORD PTR _is$[ebp], eax
  02b71	89 4d fc	 mov	 DWORD PTR _is$[ebp+4], ecx

; 1160 :     S0 = (stackitem) eptr;

  02b74	8b 45 f4	 mov	 eax, DWORD PTR _eptr$[ebp]
  02b77	99		 cdq
  02b78	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02b7e	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  02b81	89 51 fc	 mov	 DWORD PTR [ecx-4], edx

; 1161 :     Push = is;

  02b84	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02b8a	8b 45 f8	 mov	 eax, DWORD PTR _is$[ebp]
  02b8d	89 02		 mov	 DWORD PTR [edx], eax
  02b8f	8b 4d fc	 mov	 ecx, DWORD PTR _is$[ebp+4]
  02b92	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  02b95	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02b9b	83 c2 08	 add	 edx, 8
  02b9e	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN5@P_strint:

; 1162 : }

  02ba4	8b e5		 mov	 esp, ebp
  02ba6	5d		 pop	 ebp
  02ba7	c3		 ret	 0
_P_strint ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_strtod:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_eptr$ = -20						; size = 4
_fsu$ = -16						; size = 8
__$ArrayPad$ = -8					; size = 4
_i$ = -4						; size = 4
_P_strreal PROC

; 1166 : {				      /* str -- endptr value */

  02bb0	55		 push	 ebp
  02bb1	8b ec		 mov	 ebp, esp
  02bb3	83 ec 14	 sub	 esp, 20			; 00000014H
  02bb6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  02bbb	33 c5		 xor	 eax, ebp
  02bbd	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1167 :     int i;
; 1168 :     union {
; 1169 :     	atl_real fs;
; 1170 : 	stackitem fss[Realsize];
; 1171 :     } fsu;
; 1172 :     char *eptr;
; 1173 : 
; 1174 :     Sl(1);

  02bc0	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02bc5	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  02bcb	c1 f8 03	 sar	 eax, 3
  02bce	83 f8 01	 cmp	 eax, 1
  02bd1	7d 0a		 jge	 SHORT $LN7@P_strreal
  02bd3	e8 00 00 00 00	 call	 _stakunder
  02bd8	e9 ab 00 00 00	 jmp	 $LN1@P_strreal
$LN7@P_strreal:

; 1175 :     So(2);

  02bdd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02be3	83 c1 10	 add	 ecx, 16			; 00000010H
  02be6	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _stacktop
  02bec	76 0a		 jbe	 SHORT $LN6@P_strreal
  02bee	e8 00 00 00 00	 call	 _stakover
  02bf3	e9 90 00 00 00	 jmp	 $LN1@P_strreal
$LN6@P_strreal:

; 1176 :     Hpc(S0);

  02bf8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02bfe	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  02c01	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  02c07	72 11		 jb	 SHORT $LN4@P_strreal
  02c09	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02c0f	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  02c12	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  02c18	72 07		 jb	 SHORT $LN5@P_strreal
$LN4@P_strreal:
  02c1a	e8 00 00 00 00	 call	 _badpointer
  02c1f	eb 67		 jmp	 SHORT $LN1@P_strreal
$LN5@P_strreal:

; 1177 :     fsu.fs = strtod((char *) S0, &eptr);

  02c21	8d 45 ec	 lea	 eax, DWORD PTR _eptr$[ebp]
  02c24	50		 push	 eax
  02c25	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02c2b	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  02c2e	52		 push	 edx
  02c2f	e8 00 00 00 00	 call	 _strtod
  02c34	83 c4 08	 add	 esp, 8
  02c37	dd 5d f0	 fstp	 QWORD PTR _fsu$[ebp]

; 1178 :     S0 = (stackitem) eptr;

  02c3a	8b 45 ec	 mov	 eax, DWORD PTR _eptr$[ebp]
  02c3d	99		 cdq
  02c3e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02c44	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  02c47	89 51 fc	 mov	 DWORD PTR [ecx-4], edx

; 1179 :     for (i = 0; i < Realsize; i++) {

  02c4a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  02c51	eb 09		 jmp	 SHORT $LN3@P_strreal
$LN2@P_strreal:
  02c53	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  02c56	83 c2 01	 add	 edx, 1
  02c59	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN3@P_strreal:
  02c5c	83 7d fc 01	 cmp	 DWORD PTR _i$[ebp], 1
  02c60	73 26		 jae	 SHORT $LN1@P_strreal

; 1180 :     	Push = fsu.fss[i];

  02c62	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02c67	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  02c6a	8b 54 cd f0	 mov	 edx, DWORD PTR _fsu$[ebp+ecx*8]
  02c6e	89 10		 mov	 DWORD PTR [eax], edx
  02c70	8b 4c cd f4	 mov	 ecx, DWORD PTR _fsu$[ebp+ecx*8+4]
  02c74	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  02c77	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02c7d	83 c2 08	 add	 edx, 8
  02c80	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 1181 :     }

  02c86	eb cb		 jmp	 SHORT $LN2@P_strreal
$LN1@P_strreal:

; 1182 : }

  02c88	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02c8b	33 cd		 xor	 ecx, ebp
  02c8d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02c92	8b e5		 mov	 esp, ebp
  02c94	5d		 pop	 ebp
  02c95	c3		 ret	 0
_P_strreal ENDP
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_tr$83491 = -16						; size = 8
_i$ = -4						; size = 4
_P_flit	PROC

; 1191 : {

  02ca0	55		 push	 ebp
  02ca1	8b ec		 mov	 ebp, esp
  02ca3	83 ec 10	 sub	 esp, 16			; 00000010H

; 1192 :     int i;
; 1193 : 
; 1194 :     So(Realsize);

  02ca6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02cab	83 c0 08	 add	 eax, 8
  02cae	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  02cb4	76 0a		 jbe	 SHORT $LN5@P_flit
  02cb6	e8 00 00 00 00	 call	 _stakover
  02cbb	e9 80 00 00 00	 jmp	 $LN1@P_flit
$LN5@P_flit:

; 1195 : #ifdef TRACE
; 1196 :     if (atl_trace) {

  02cc0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl_trace
  02cc6	0b 0d 04 00 00
	00		 or	 ecx, DWORD PTR _atl_trace+4
  02ccc	74 28		 je	 SHORT $LN4@P_flit

; 1197 : 	atl_real tr;
; 1198 : 
; 1199 : 	V memcpy((char *) &tr, (char *) ip, sizeof(atl_real));

  02cce	6a 08		 push	 8
  02cd0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ip
  02cd6	52		 push	 edx
  02cd7	8d 45 f0	 lea	 eax, DWORD PTR _tr$83491[ebp]
  02cda	50		 push	 eax
  02cdb	e8 00 00 00 00	 call	 _memcpy

; 1200 :         V printf("%g ", tr);

  02ce0	83 c4 04	 add	 esp, 4
  02ce3	dd 45 f0	 fld	 QWORD PTR _tr$83491[ebp]
  02ce6	dd 1c 24	 fstp	 QWORD PTR [esp]
  02ce9	68 00 00 00 00	 push	 OFFSET $SG83497
  02cee	e8 00 00 00 00	 call	 _printf
  02cf3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@P_flit:

; 1201 :     }
; 1202 : #endif /* TRACE */
; 1203 :     for (i = 0; i < Realsize; i++) {

  02cf6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  02cfd	eb 09		 jmp	 SHORT $LN3@P_flit
$LN2@P_flit:
  02cff	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  02d02	83 c1 01	 add	 ecx, 1
  02d05	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN3@P_flit:
  02d08	83 7d fc 01	 cmp	 DWORD PTR _i$[ebp], 1
  02d0c	73 32		 jae	 SHORT $LN1@P_flit

; 1204 : 	Push = (stackitem) *ip++;

  02d0e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ip
  02d14	8b 02		 mov	 eax, DWORD PTR [edx]
  02d16	99		 cdq
  02d17	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02d1d	89 01		 mov	 DWORD PTR [ecx], eax
  02d1f	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  02d22	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02d28	83 c2 08	 add	 edx, 8
  02d2b	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
  02d31	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  02d36	83 c0 04	 add	 eax, 4
  02d39	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax

; 1205 :     }

  02d3e	eb bf		 jmp	 SHORT $LN2@P_flit
$LN1@P_flit:

; 1206 : }

  02d40	8b e5		 mov	 esp, ebp
  02d42	5d		 pop	 ebp
  02d43	c3		 ret	 0
_P_flit	ENDP
; Function compile flags: /Odtp
_P_fplus PROC

; 1209 : {

  02d50	55		 push	 ebp
  02d51	8b ec		 mov	 ebp, esp

; 1210 :     Sl(2 * Realsize);

  02d53	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02d58	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  02d5e	c1 f8 03	 sar	 eax, 3
  02d61	83 f8 02	 cmp	 eax, 2
  02d64	73 07		 jae	 SHORT $LN1@P_fplus
  02d66	e8 00 00 00 00	 call	 _stakunder
  02d6b	eb 29		 jmp	 SHORT $LN2@P_fplus
$LN1@P_fplus:

; 1211 :     SREAL1(REAL1 + REAL0);

  02d6d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02d73	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02d79	dd 41 f0	 fld	 QWORD PTR [ecx-16]
  02d7c	dc 42 f8	 fadd	 QWORD PTR [edx-8]
  02d7f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02d84	dd 58 f0	 fstp	 QWORD PTR [eax-16]

; 1212 :     Realpop;

  02d87	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02d8d	83 e9 08	 sub	 ecx, 8
  02d90	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN2@P_fplus:

; 1213 : }

  02d96	5d		 pop	 ebp
  02d97	c3		 ret	 0
_P_fplus ENDP
; Function compile flags: /Odtp
_P_fminus PROC

; 1216 : {

  02da0	55		 push	 ebp
  02da1	8b ec		 mov	 ebp, esp

; 1217 :     Sl(2 * Realsize);

  02da3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02da8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  02dae	c1 f8 03	 sar	 eax, 3
  02db1	83 f8 02	 cmp	 eax, 2
  02db4	73 07		 jae	 SHORT $LN1@P_fminus
  02db6	e8 00 00 00 00	 call	 _stakunder
  02dbb	eb 29		 jmp	 SHORT $LN2@P_fminus
$LN1@P_fminus:

; 1218 :     SREAL1(REAL1 - REAL0);

  02dbd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02dc3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02dc9	dd 41 f0	 fld	 QWORD PTR [ecx-16]
  02dcc	dc 62 f8	 fsub	 QWORD PTR [edx-8]
  02dcf	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02dd4	dd 58 f0	 fstp	 QWORD PTR [eax-16]

; 1219 :     Realpop;

  02dd7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02ddd	83 e9 08	 sub	 ecx, 8
  02de0	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN2@P_fminus:

; 1220 : }

  02de6	5d		 pop	 ebp
  02de7	c3		 ret	 0
_P_fminus ENDP
; Function compile flags: /Odtp
_P_ftimes PROC

; 1223 : {

  02df0	55		 push	 ebp
  02df1	8b ec		 mov	 ebp, esp

; 1224 :     Sl(2 * Realsize);

  02df3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02df8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  02dfe	c1 f8 03	 sar	 eax, 3
  02e01	83 f8 02	 cmp	 eax, 2
  02e04	73 07		 jae	 SHORT $LN1@P_ftimes
  02e06	e8 00 00 00 00	 call	 _stakunder
  02e0b	eb 29		 jmp	 SHORT $LN2@P_ftimes
$LN1@P_ftimes:

; 1225 :     SREAL1(REAL1 * REAL0);

  02e0d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02e13	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02e19	dd 41 f0	 fld	 QWORD PTR [ecx-16]
  02e1c	dc 4a f8	 fmul	 QWORD PTR [edx-8]
  02e1f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02e24	dd 58 f0	 fstp	 QWORD PTR [eax-16]

; 1226 :     Realpop;

  02e27	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02e2d	83 e9 08	 sub	 ecx, 8
  02e30	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN2@P_ftimes:

; 1227 : }

  02e36	5d		 pop	 ebp
  02e37	c3		 ret	 0
_P_ftimes ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp
CONST	ENDS
_TEXT	SEGMENT
_P_fdiv	PROC

; 1230 : {

  02e40	55		 push	 ebp
  02e41	8b ec		 mov	 ebp, esp

; 1231 :     Sl(2 * Realsize);

  02e43	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02e48	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  02e4e	c1 f8 03	 sar	 eax, 3
  02e51	83 f8 02	 cmp	 eax, 2
  02e54	73 07		 jae	 SHORT $LN2@P_fdiv
  02e56	e8 00 00 00 00	 call	 _stakunder
  02e5b	eb 44		 jmp	 SHORT $LN3@P_fdiv
$LN2@P_fdiv:

; 1232 : #ifndef NOMEMCHECK
; 1233 :     if (REAL0 == 0.0) {

  02e5d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02e63	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  02e66	d9 ee		 fldz
  02e68	da e9		 fucompp
  02e6a	df e0		 fnstsw	 ax
  02e6c	f6 c4 44	 test	 ah, 68			; 00000044H
  02e6f	7a 07		 jp	 SHORT $LN1@P_fdiv

; 1234 : 	divzero();

  02e71	e8 00 00 00 00	 call	 _divzero

; 1235 : 	return;

  02e76	eb 29		 jmp	 SHORT $LN3@P_fdiv
$LN1@P_fdiv:

; 1236 :     }
; 1237 : #endif /* NOMEMCHECK */
; 1238 :     SREAL1(REAL1 / REAL0);

  02e78	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02e7e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02e83	dd 42 f0	 fld	 QWORD PTR [edx-16]
  02e86	dc 70 f8	 fdiv	 QWORD PTR [eax-8]
  02e89	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02e8f	dd 59 f0	 fstp	 QWORD PTR [ecx-16]

; 1239 :     Realpop;

  02e92	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02e98	83 ea 08	 sub	 edx, 8
  02e9b	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN3@P_fdiv:

; 1240 : }

  02ea1	5d		 pop	 ebp
  02ea2	c3		 ret	 0
_P_fdiv	ENDP
; Function compile flags: /Odtp
tv77 = -8						; size = 8
_P_fmin	PROC

; 1243 : {

  02eb0	55		 push	 ebp
  02eb1	8b ec		 mov	 ebp, esp
  02eb3	83 ec 08	 sub	 esp, 8

; 1244 :     Sl(2 * Realsize);

  02eb6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02ebb	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  02ec1	c1 f8 03	 sar	 eax, 3
  02ec4	83 f8 02	 cmp	 eax, 2
  02ec7	73 07		 jae	 SHORT $LN1@P_fmin
  02ec9	e8 00 00 00 00	 call	 _stakunder
  02ece	eb 4b		 jmp	 SHORT $LN2@P_fmin
$LN1@P_fmin:

; 1245 :     SREAL1(min(REAL1, REAL0));

  02ed0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02ed6	dd 41 f0	 fld	 QWORD PTR [ecx-16]
  02ed9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02edf	dc 5a f8	 fcomp	 QWORD PTR [edx-8]
  02ee2	df e0		 fnstsw	 ax
  02ee4	f6 c4 41	 test	 ah, 65			; 00000041H
  02ee7	7a 0d		 jp	 SHORT $LN4@P_fmin
  02ee9	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02eee	dd 40 f0	 fld	 QWORD PTR [eax-16]
  02ef1	dd 5d f8	 fstp	 QWORD PTR tv77[ebp]
  02ef4	eb 0c		 jmp	 SHORT $LN5@P_fmin
$LN4@P_fmin:
  02ef6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02efc	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  02eff	dd 5d f8	 fstp	 QWORD PTR tv77[ebp]
$LN5@P_fmin:
  02f02	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02f08	dd 45 f8	 fld	 QWORD PTR tv77[ebp]
  02f0b	dd 5a f0	 fstp	 QWORD PTR [edx-16]

; 1246 :     Realpop;

  02f0e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02f13	83 e8 08	 sub	 eax, 8
  02f16	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_fmin:

; 1247 : }

  02f1b	8b e5		 mov	 esp, ebp
  02f1d	5d		 pop	 ebp
  02f1e	c3		 ret	 0
_P_fmin	ENDP
; Function compile flags: /Odtp
tv77 = -8						; size = 8
_P_fmax	PROC

; 1250 : {

  02f20	55		 push	 ebp
  02f21	8b ec		 mov	 ebp, esp
  02f23	83 ec 08	 sub	 esp, 8

; 1251 :     Sl(2 * Realsize);

  02f26	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02f2b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  02f31	c1 f8 03	 sar	 eax, 3
  02f34	83 f8 02	 cmp	 eax, 2
  02f37	73 07		 jae	 SHORT $LN1@P_fmax
  02f39	e8 00 00 00 00	 call	 _stakunder
  02f3e	eb 4b		 jmp	 SHORT $LN2@P_fmax
$LN1@P_fmax:

; 1252 :     SREAL1(max(REAL1, REAL0));

  02f40	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02f46	dd 41 f0	 fld	 QWORD PTR [ecx-16]
  02f49	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02f4f	dc 5a f8	 fcomp	 QWORD PTR [edx-8]
  02f52	df e0		 fnstsw	 ax
  02f54	f6 c4 41	 test	 ah, 65			; 00000041H
  02f57	75 0d		 jne	 SHORT $LN4@P_fmax
  02f59	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02f5e	dd 40 f0	 fld	 QWORD PTR [eax-16]
  02f61	dd 5d f8	 fstp	 QWORD PTR tv77[ebp]
  02f64	eb 0c		 jmp	 SHORT $LN5@P_fmax
$LN4@P_fmax:
  02f66	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02f6c	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  02f6f	dd 5d f8	 fstp	 QWORD PTR tv77[ebp]
$LN5@P_fmax:
  02f72	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02f78	dd 45 f8	 fld	 QWORD PTR tv77[ebp]
  02f7b	dd 5a f0	 fstp	 QWORD PTR [edx-16]

; 1253 :     Realpop;

  02f7e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02f83	83 e8 08	 sub	 eax, 8
  02f86	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_fmax:

; 1254 : }

  02f8b	8b e5		 mov	 esp, ebp
  02f8d	5d		 pop	 ebp
  02f8e	c3		 ret	 0
_P_fmax	ENDP
; Function compile flags: /Odtp
_P_fneg PROC

; 1257 : {

  02f90	55		 push	 ebp
  02f91	8b ec		 mov	 ebp, esp

; 1258 :     Sl(Realsize);

  02f93	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02f98	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  02f9e	c1 f8 03	 sar	 eax, 3
  02fa1	83 f8 01	 cmp	 eax, 1
  02fa4	73 07		 jae	 SHORT $LN1@P_fneg
  02fa6	e8 00 00 00 00	 call	 _stakunder
  02fab	eb 14		 jmp	 SHORT $LN2@P_fneg
$LN1@P_fneg:

; 1259 :     SREAL0(- REAL0);

  02fad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02fb3	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  02fb6	d9 e0		 fchs
  02fb8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  02fbe	dd 5a f8	 fstp	 QWORD PTR [edx-8]
$LN2@P_fneg:

; 1260 : }

  02fc1	5d		 pop	 ebp
  02fc2	c3		 ret	 0
_P_fneg	ENDP
; Function compile flags: /Odtp
tv76 = -8						; size = 8
_P_fabs	PROC

; 1263 : {

  02fd0	55		 push	 ebp
  02fd1	8b ec		 mov	 ebp, esp
  02fd3	83 ec 08	 sub	 esp, 8

; 1264 :     Sl(Realsize);

  02fd6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  02fdb	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  02fe1	c1 f8 03	 sar	 eax, 3
  02fe4	83 f8 01	 cmp	 eax, 1
  02fe7	73 07		 jae	 SHORT $LN1@P_fabs
  02fe9	e8 00 00 00 00	 call	 _stakunder
  02fee	eb 3d		 jmp	 SHORT $LN2@P_fabs
$LN1@P_fabs:

; 1265 :     SREAL0(abs(REAL0));

  02ff0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  02ff6	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  02ff9	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  02fff	df e0		 fnstsw	 ax
  03001	f6 c4 05	 test	 ah, 5
  03004	7a 10		 jp	 SHORT $LN4@P_fabs
  03006	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0300c	dd 42 f8	 fld	 QWORD PTR [edx-8]
  0300f	d9 e0		 fchs
  03011	dd 5d f8	 fstp	 QWORD PTR tv76[ebp]
  03014	eb 0b		 jmp	 SHORT $LN5@P_fabs
$LN4@P_fabs:
  03016	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0301b	dd 40 f8	 fld	 QWORD PTR [eax-8]
  0301e	dd 5d f8	 fstp	 QWORD PTR tv76[ebp]
$LN5@P_fabs:
  03021	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03027	dd 45 f8	 fld	 QWORD PTR tv76[ebp]
  0302a	dd 59 f8	 fstp	 QWORD PTR [ecx-8]
$LN2@P_fabs:

; 1266 : }

  0302d	8b e5		 mov	 esp, ebp
  0302f	5d		 pop	 ebp
  03030	c3		 ret	 0
_P_fabs	ENDP
; Function compile flags: /Odtp
tv70 = -12						; size = 4
_t$ = -8						; size = 8
_P_fequal PROC

; 1269 : {

  03040	55		 push	 ebp
  03041	8b ec		 mov	 ebp, esp
  03043	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1270 :     stackitem t;
; 1271 : 
; 1272 :     Sl(2 * Realsize);

  03046	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0304b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  03051	c1 f8 03	 sar	 eax, 3
  03054	83 f8 02	 cmp	 eax, 2
  03057	73 07		 jae	 SHORT $LN1@P_fequal
  03059	e8 00 00 00 00	 call	 _stakunder
  0305e	eb 62		 jmp	 SHORT $LN2@P_fequal
$LN1@P_fequal:

; 1273 :     t = (REAL1 == REAL0) ? Truth : Falsity;

  03060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03066	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0306c	dd 41 f0	 fld	 QWORD PTR [ecx-16]
  0306f	dd 42 f8	 fld	 QWORD PTR [edx-8]
  03072	da e9		 fucompp
  03074	df e0		 fnstsw	 ax
  03076	f6 c4 44	 test	 ah, 68			; 00000044H
  03079	7a 09		 jp	 SHORT $LN4@P_fequal
  0307b	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
  03082	eb 07		 jmp	 SHORT $LN5@P_fequal
$LN4@P_fequal:
  03084	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_fequal:
  0308b	8b 45 f4	 mov	 eax, DWORD PTR tv70[ebp]
  0308e	99		 cdq
  0308f	89 45 f8	 mov	 DWORD PTR _t$[ebp], eax
  03092	89 55 fc	 mov	 DWORD PTR _t$[ebp+4], edx

; 1274 :     Realpop2;

  03095	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0309a	83 e8 10	 sub	 eax, 16			; 00000010H
  0309d	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1275 :     Push = t;

  030a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  030a8	8b 55 f8	 mov	 edx, DWORD PTR _t$[ebp]
  030ab	89 11		 mov	 DWORD PTR [ecx], edx
  030ad	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp+4]
  030b0	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  030b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  030b9	83 c1 08	 add	 ecx, 8
  030bc	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN2@P_fequal:

; 1276 : }

  030c2	8b e5		 mov	 esp, ebp
  030c4	5d		 pop	 ebp
  030c5	c3		 ret	 0
_P_fequal ENDP
; Function compile flags: /Odtp
tv70 = -12						; size = 4
_t$ = -8						; size = 8
_P_funequal PROC

; 1279 : {

  030d0	55		 push	 ebp
  030d1	8b ec		 mov	 ebp, esp
  030d3	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1280 :     stackitem t;
; 1281 : 
; 1282 :     Sl(2 * Realsize);

  030d6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  030db	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  030e1	c1 f8 03	 sar	 eax, 3
  030e4	83 f8 02	 cmp	 eax, 2
  030e7	73 07		 jae	 SHORT $LN1@P_funequal
  030e9	e8 00 00 00 00	 call	 _stakunder
  030ee	eb 62		 jmp	 SHORT $LN2@P_funequal
$LN1@P_funequal:

; 1283 :     t = (REAL1 != REAL0) ? Truth : Falsity;

  030f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  030f6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  030fc	dd 41 f0	 fld	 QWORD PTR [ecx-16]
  030ff	dd 42 f8	 fld	 QWORD PTR [edx-8]
  03102	da e9		 fucompp
  03104	df e0		 fnstsw	 ax
  03106	f6 c4 44	 test	 ah, 68			; 00000044H
  03109	7b 09		 jnp	 SHORT $LN4@P_funequal
  0310b	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
  03112	eb 07		 jmp	 SHORT $LN5@P_funequal
$LN4@P_funequal:
  03114	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_funequal:
  0311b	8b 45 f4	 mov	 eax, DWORD PTR tv70[ebp]
  0311e	99		 cdq
  0311f	89 45 f8	 mov	 DWORD PTR _t$[ebp], eax
  03122	89 55 fc	 mov	 DWORD PTR _t$[ebp+4], edx

; 1284 :     Realpop2;

  03125	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0312a	83 e8 10	 sub	 eax, 16			; 00000010H
  0312d	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1285 :     Push = t;

  03132	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03138	8b 55 f8	 mov	 edx, DWORD PTR _t$[ebp]
  0313b	89 11		 mov	 DWORD PTR [ecx], edx
  0313d	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp+4]
  03140	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  03143	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03149	83 c1 08	 add	 ecx, 8
  0314c	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN2@P_funequal:

; 1286 : }

  03152	8b e5		 mov	 esp, ebp
  03154	5d		 pop	 ebp
  03155	c3		 ret	 0
_P_funequal ENDP
; Function compile flags: /Odtp
tv70 = -12						; size = 4
_t$ = -8						; size = 8
_P_fgtr	PROC

; 1289 : {

  03160	55		 push	 ebp
  03161	8b ec		 mov	 ebp, esp
  03163	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1290 :     stackitem t;
; 1291 : 
; 1292 :     Sl(2 * Realsize);

  03166	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0316b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  03171	c1 f8 03	 sar	 eax, 3
  03174	83 f8 02	 cmp	 eax, 2
  03177	73 07		 jae	 SHORT $LN1@P_fgtr
  03179	e8 00 00 00 00	 call	 _stakunder
  0317e	eb 60		 jmp	 SHORT $LN2@P_fgtr
$LN1@P_fgtr:

; 1293 :     t = (REAL1 > REAL0) ? Truth : Falsity;

  03180	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03186	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0318c	dd 42 f8	 fld	 QWORD PTR [edx-8]
  0318f	dc 59 f0	 fcomp	 QWORD PTR [ecx-16]
  03192	df e0		 fnstsw	 ax
  03194	f6 c4 05	 test	 ah, 5
  03197	7a 09		 jp	 SHORT $LN4@P_fgtr
  03199	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
  031a0	eb 07		 jmp	 SHORT $LN5@P_fgtr
$LN4@P_fgtr:
  031a2	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_fgtr:
  031a9	8b 45 f4	 mov	 eax, DWORD PTR tv70[ebp]
  031ac	99		 cdq
  031ad	89 45 f8	 mov	 DWORD PTR _t$[ebp], eax
  031b0	89 55 fc	 mov	 DWORD PTR _t$[ebp+4], edx

; 1294 :     Realpop2;

  031b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  031b8	83 e8 10	 sub	 eax, 16			; 00000010H
  031bb	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1295 :     Push = t;

  031c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  031c6	8b 55 f8	 mov	 edx, DWORD PTR _t$[ebp]
  031c9	89 11		 mov	 DWORD PTR [ecx], edx
  031cb	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp+4]
  031ce	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  031d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  031d7	83 c1 08	 add	 ecx, 8
  031da	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN2@P_fgtr:

; 1296 : }

  031e0	8b e5		 mov	 esp, ebp
  031e2	5d		 pop	 ebp
  031e3	c3		 ret	 0
_P_fgtr	ENDP
; Function compile flags: /Odtp
tv70 = -12						; size = 4
_t$ = -8						; size = 8
_P_flss	PROC

; 1299 : {

  031f0	55		 push	 ebp
  031f1	8b ec		 mov	 ebp, esp
  031f3	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1300 :     stackitem t;
; 1301 : 
; 1302 :     Sl(2 * Realsize);

  031f6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  031fb	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  03201	c1 f8 03	 sar	 eax, 3
  03204	83 f8 02	 cmp	 eax, 2
  03207	73 07		 jae	 SHORT $LN1@P_flss
  03209	e8 00 00 00 00	 call	 _stakunder
  0320e	eb 60		 jmp	 SHORT $LN2@P_flss
$LN1@P_flss:

; 1303 :     t = (REAL1 < REAL0) ? Truth : Falsity;

  03210	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03216	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0321c	dd 42 f8	 fld	 QWORD PTR [edx-8]
  0321f	dc 59 f0	 fcomp	 QWORD PTR [ecx-16]
  03222	df e0		 fnstsw	 ax
  03224	f6 c4 41	 test	 ah, 65			; 00000041H
  03227	75 09		 jne	 SHORT $LN4@P_flss
  03229	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
  03230	eb 07		 jmp	 SHORT $LN5@P_flss
$LN4@P_flss:
  03232	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_flss:
  03239	8b 45 f4	 mov	 eax, DWORD PTR tv70[ebp]
  0323c	99		 cdq
  0323d	89 45 f8	 mov	 DWORD PTR _t$[ebp], eax
  03240	89 55 fc	 mov	 DWORD PTR _t$[ebp+4], edx

; 1304 :     Realpop2;

  03243	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03248	83 e8 10	 sub	 eax, 16			; 00000010H
  0324b	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1305 :     Push = t;

  03250	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03256	8b 55 f8	 mov	 edx, DWORD PTR _t$[ebp]
  03259	89 11		 mov	 DWORD PTR [ecx], edx
  0325b	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp+4]
  0325e	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  03261	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03267	83 c1 08	 add	 ecx, 8
  0326a	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN2@P_flss:

; 1306 : }

  03270	8b e5		 mov	 esp, ebp
  03272	5d		 pop	 ebp
  03273	c3		 ret	 0
_P_flss	ENDP
; Function compile flags: /Odtp
tv70 = -12						; size = 4
_t$ = -8						; size = 8
_P_fgeq	PROC

; 1309 : {

  03280	55		 push	 ebp
  03281	8b ec		 mov	 ebp, esp
  03283	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1310 :     stackitem t;
; 1311 : 
; 1312 :     Sl(2 * Realsize);

  03286	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0328b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  03291	c1 f8 03	 sar	 eax, 3
  03294	83 f8 02	 cmp	 eax, 2
  03297	73 07		 jae	 SHORT $LN1@P_fgeq
  03299	e8 00 00 00 00	 call	 _stakunder
  0329e	eb 60		 jmp	 SHORT $LN2@P_fgeq
$LN1@P_fgeq:

; 1313 :     t = (REAL1 >= REAL0) ? Truth : Falsity;

  032a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  032a6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  032ac	dd 42 f8	 fld	 QWORD PTR [edx-8]
  032af	dc 59 f0	 fcomp	 QWORD PTR [ecx-16]
  032b2	df e0		 fnstsw	 ax
  032b4	f6 c4 41	 test	 ah, 65			; 00000041H
  032b7	7a 09		 jp	 SHORT $LN4@P_fgeq
  032b9	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
  032c0	eb 07		 jmp	 SHORT $LN5@P_fgeq
$LN4@P_fgeq:
  032c2	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_fgeq:
  032c9	8b 45 f4	 mov	 eax, DWORD PTR tv70[ebp]
  032cc	99		 cdq
  032cd	89 45 f8	 mov	 DWORD PTR _t$[ebp], eax
  032d0	89 55 fc	 mov	 DWORD PTR _t$[ebp+4], edx

; 1314 :     Realpop2;

  032d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  032d8	83 e8 10	 sub	 eax, 16			; 00000010H
  032db	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1315 :     Push = t;

  032e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  032e6	8b 55 f8	 mov	 edx, DWORD PTR _t$[ebp]
  032e9	89 11		 mov	 DWORD PTR [ecx], edx
  032eb	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp+4]
  032ee	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  032f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  032f7	83 c1 08	 add	 ecx, 8
  032fa	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN2@P_fgeq:

; 1316 : }

  03300	8b e5		 mov	 esp, ebp
  03302	5d		 pop	 ebp
  03303	c3		 ret	 0
_P_fgeq	ENDP
; Function compile flags: /Odtp
tv70 = -12						; size = 4
_t$ = -8						; size = 8
_P_fleq	PROC

; 1319 : {

  03310	55		 push	 ebp
  03311	8b ec		 mov	 ebp, esp
  03313	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1320 :     stackitem t;
; 1321 : 
; 1322 :     Sl(2 * Realsize);

  03316	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0331b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  03321	c1 f8 03	 sar	 eax, 3
  03324	83 f8 02	 cmp	 eax, 2
  03327	73 07		 jae	 SHORT $LN1@P_fleq
  03329	e8 00 00 00 00	 call	 _stakunder
  0332e	eb 60		 jmp	 SHORT $LN2@P_fleq
$LN1@P_fleq:

; 1323 :     t = (REAL1 <= REAL0) ? Truth : Falsity;

  03330	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03336	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0333c	dd 42 f8	 fld	 QWORD PTR [edx-8]
  0333f	dc 59 f0	 fcomp	 QWORD PTR [ecx-16]
  03342	df e0		 fnstsw	 ax
  03344	f6 c4 01	 test	 ah, 1
  03347	75 09		 jne	 SHORT $LN4@P_fleq
  03349	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
  03350	eb 07		 jmp	 SHORT $LN5@P_fleq
$LN4@P_fleq:
  03352	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_fleq:
  03359	8b 45 f4	 mov	 eax, DWORD PTR tv70[ebp]
  0335c	99		 cdq
  0335d	89 45 f8	 mov	 DWORD PTR _t$[ebp], eax
  03360	89 55 fc	 mov	 DWORD PTR _t$[ebp+4], edx

; 1324 :     Realpop2;

  03363	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03368	83 e8 10	 sub	 eax, 16			; 00000010H
  0336b	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1325 :     Push = t;

  03370	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03376	8b 55 f8	 mov	 edx, DWORD PTR _t$[ebp]
  03379	89 11		 mov	 DWORD PTR [ecx], edx
  0337b	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp+4]
  0337e	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  03381	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03387	83 c1 08	 add	 ecx, 8
  0338a	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN2@P_fleq:

; 1326 : }

  03390	8b e5		 mov	 esp, ebp
  03392	5d		 pop	 ebp
  03393	c3		 ret	 0
_P_fleq	ENDP
; Function compile flags: /Odtp
_P_fdot PROC

; 1329 : {

  033a0	55		 push	 ebp
  033a1	8b ec		 mov	 ebp, esp

; 1330 :     Sl(Realsize);

  033a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  033a8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  033ae	c1 f8 03	 sar	 eax, 3
  033b1	83 f8 01	 cmp	 eax, 1
  033b4	73 07		 jae	 SHORT $LN1@P_fdot
  033b6	e8 00 00 00 00	 call	 _stakunder
  033bb	eb 2b		 jmp	 SHORT $LN2@P_fdot
$LN1@P_fdot:

; 1331 :     V printf("%g ", REAL0);

  033bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  033c3	83 ec 08	 sub	 esp, 8
  033c6	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  033c9	dd 1c 24	 fstp	 QWORD PTR [esp]
  033cc	68 00 00 00 00	 push	 OFFSET $SG83653
  033d1	e8 00 00 00 00	 call	 _printf
  033d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1332 :     Realpop;

  033d9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  033df	83 ea 08	 sub	 edx, 8
  033e2	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN2@P_fdot:

; 1333 : }

  033e8	5d		 pop	 ebp
  033e9	c3		 ret	 0
_P_fdot	ENDP
; Function compile flags: /Odtp
_r$ = -8						; size = 8
_P_float PROC

; 1336 : {

  033f0	55		 push	 ebp
  033f1	8b ec		 mov	 ebp, esp
  033f3	83 ec 08	 sub	 esp, 8

; 1337 :     atl_real r;
; 1338 : 
; 1339 :     Sl(1)

  033f6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  033fb	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  03401	c1 f8 03	 sar	 eax, 3
  03404	83 f8 01	 cmp	 eax, 1
  03407	7d 07		 jge	 SHORT $LN2@P_float
  03409	e8 00 00 00 00	 call	 _stakunder
  0340e	eb 37		 jmp	 SHORT $LN3@P_float
$LN2@P_float:

; 1340 :     So(Realsize - 1);

  03410	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03416	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _stacktop
  0341c	76 07		 jbe	 SHORT $LN1@P_float
  0341e	e8 00 00 00 00	 call	 _stakover
  03423	eb 22		 jmp	 SHORT $LN3@P_float
$LN1@P_float:

; 1341 :     r = S0;

  03425	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0342b	df 6a f8	 fild	 QWORD PTR [edx-8]
  0342e	dd 5d f8	 fstp	 QWORD PTR _r$[ebp]

; 1342 :     stk += Realsize - 1;

  03431	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03436	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1343 :     SREAL0(r);

  0343b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03441	dd 45 f8	 fld	 QWORD PTR _r$[ebp]
  03444	dd 59 f8	 fstp	 QWORD PTR [ecx-8]
$LN3@P_float:

; 1344 : }

  03447	8b e5		 mov	 esp, ebp
  03449	5d		 pop	 ebp
  0344a	c3		 ret	 0
_P_float ENDP
_TEXT	ENDS
EXTRN	__ftol2_sse:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_i$ = -8						; size = 8
_P_fix	PROC

; 1347 : {

  03450	55		 push	 ebp
  03451	8b ec		 mov	 ebp, esp
  03453	83 ec 08	 sub	 esp, 8

; 1348 :     stackitem i;
; 1349 : 
; 1350 :     Sl(Realsize);

  03456	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0345b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  03461	c1 f8 03	 sar	 eax, 3
  03464	83 f8 01	 cmp	 eax, 1
  03467	73 07		 jae	 SHORT $LN1@P_fix
  03469	e8 00 00 00 00	 call	 _stakunder
  0346e	eb 41		 jmp	 SHORT $LN2@P_fix
$LN1@P_fix:

; 1351 :     i = (int) REAL0;

  03470	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03476	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  03479	e8 00 00 00 00	 call	 __ftol2_sse
  0347e	99		 cdq
  0347f	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  03482	89 55 fc	 mov	 DWORD PTR _i$[ebp+4], edx

; 1352 :     Realpop;

  03485	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0348b	83 ea 08	 sub	 edx, 8
  0348e	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 1353 :     Push = i;

  03494	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03499	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0349c	89 08		 mov	 DWORD PTR [eax], ecx
  0349e	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp+4]
  034a1	89 50 04	 mov	 DWORD PTR [eax+4], edx
  034a4	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  034a9	83 c0 08	 add	 eax, 8
  034ac	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_fix:

; 1354 : }

  034b1	8b e5		 mov	 esp, ebp
  034b3	5d		 pop	 ebp
  034b4	c3		 ret	 0
_P_fix	ENDP
_TEXT	ENDS
EXTRN	_acos:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_acos	PROC

; 1361 : {

  034c0	55		 push	 ebp
  034c1	8b ec		 mov	 ebp, esp

; 1362 :     Mathfunc(acos);

  034c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  034c8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  034ce	c1 f8 03	 sar	 eax, 3
  034d1	83 f8 01	 cmp	 eax, 1
  034d4	73 07		 jae	 SHORT $LN1@P_acos
  034d6	e8 00 00 00 00	 call	 _stakunder
  034db	eb 20		 jmp	 SHORT $LN2@P_acos
$LN1@P_acos:
  034dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  034e3	83 ec 08	 sub	 esp, 8
  034e6	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  034e9	dd 1c 24	 fstp	 QWORD PTR [esp]
  034ec	e8 00 00 00 00	 call	 _acos
  034f1	83 c4 08	 add	 esp, 8
  034f4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  034fa	dd 5a f8	 fstp	 QWORD PTR [edx-8]
$LN2@P_acos:

; 1363 : }

  034fd	5d		 pop	 ebp
  034fe	c3		 ret	 0
_P_acos	ENDP
_TEXT	ENDS
EXTRN	_asin:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_asin	PROC

; 1366 : {

  03500	55		 push	 ebp
  03501	8b ec		 mov	 ebp, esp

; 1367 :     Mathfunc(asin);

  03503	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03508	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0350e	c1 f8 03	 sar	 eax, 3
  03511	83 f8 01	 cmp	 eax, 1
  03514	73 07		 jae	 SHORT $LN1@P_asin
  03516	e8 00 00 00 00	 call	 _stakunder
  0351b	eb 20		 jmp	 SHORT $LN2@P_asin
$LN1@P_asin:
  0351d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03523	83 ec 08	 sub	 esp, 8
  03526	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  03529	dd 1c 24	 fstp	 QWORD PTR [esp]
  0352c	e8 00 00 00 00	 call	 _asin
  03531	83 c4 08	 add	 esp, 8
  03534	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0353a	dd 5a f8	 fstp	 QWORD PTR [edx-8]
$LN2@P_asin:

; 1368 : }

  0353d	5d		 pop	 ebp
  0353e	c3		 ret	 0
_P_asin	ENDP
_TEXT	ENDS
EXTRN	_atan:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_atan	PROC

; 1371 : {

  03540	55		 push	 ebp
  03541	8b ec		 mov	 ebp, esp

; 1372 :     Mathfunc(atan);

  03543	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03548	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0354e	c1 f8 03	 sar	 eax, 3
  03551	83 f8 01	 cmp	 eax, 1
  03554	73 07		 jae	 SHORT $LN1@P_atan
  03556	e8 00 00 00 00	 call	 _stakunder
  0355b	eb 20		 jmp	 SHORT $LN2@P_atan
$LN1@P_atan:
  0355d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03563	83 ec 08	 sub	 esp, 8
  03566	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  03569	dd 1c 24	 fstp	 QWORD PTR [esp]
  0356c	e8 00 00 00 00	 call	 _atan
  03571	83 c4 08	 add	 esp, 8
  03574	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0357a	dd 5a f8	 fstp	 QWORD PTR [edx-8]
$LN2@P_atan:

; 1373 : }

  0357d	5d		 pop	 ebp
  0357e	c3		 ret	 0
_P_atan	ENDP
_TEXT	ENDS
EXTRN	_atan2:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_atan2 PROC

; 1376 : {

  03580	55		 push	 ebp
  03581	8b ec		 mov	 ebp, esp

; 1377 :     Sl(2 * Realsize);

  03583	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03588	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0358e	c1 f8 03	 sar	 eax, 3
  03591	83 f8 02	 cmp	 eax, 2
  03594	73 07		 jae	 SHORT $LN1@P_atan2@2
  03596	e8 00 00 00 00	 call	 _stakunder
  0359b	eb 3d		 jmp	 SHORT $LN2@P_atan2@2
$LN1@P_atan2@2:

; 1378 :     SREAL1(atan2(REAL1, REAL0));

  0359d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  035a3	83 ec 08	 sub	 esp, 8
  035a6	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  035a9	dd 1c 24	 fstp	 QWORD PTR [esp]
  035ac	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  035b2	83 ec 08	 sub	 esp, 8
  035b5	dd 42 f0	 fld	 QWORD PTR [edx-16]
  035b8	dd 1c 24	 fstp	 QWORD PTR [esp]
  035bb	e8 00 00 00 00	 call	 _atan2
  035c0	83 c4 10	 add	 esp, 16			; 00000010H
  035c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  035c8	dd 58 f0	 fstp	 QWORD PTR [eax-16]

; 1379 :     Realpop;

  035cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  035d1	83 e9 08	 sub	 ecx, 8
  035d4	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN2@P_atan2@2:

; 1380 : }

  035da	5d		 pop	 ebp
  035db	c3		 ret	 0
_P_atan2 ENDP
_TEXT	ENDS
EXTRN	_cos:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_cos	PROC

; 1383 : {

  035e0	55		 push	 ebp
  035e1	8b ec		 mov	 ebp, esp

; 1384 :     Mathfunc(cos);

  035e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  035e8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  035ee	c1 f8 03	 sar	 eax, 3
  035f1	83 f8 01	 cmp	 eax, 1
  035f4	73 07		 jae	 SHORT $LN1@P_cos
  035f6	e8 00 00 00 00	 call	 _stakunder
  035fb	eb 20		 jmp	 SHORT $LN2@P_cos
$LN1@P_cos:
  035fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03603	83 ec 08	 sub	 esp, 8
  03606	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  03609	dd 1c 24	 fstp	 QWORD PTR [esp]
  0360c	e8 00 00 00 00	 call	 _cos
  03611	83 c4 08	 add	 esp, 8
  03614	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0361a	dd 5a f8	 fstp	 QWORD PTR [edx-8]
$LN2@P_cos:

; 1385 : }

  0361d	5d		 pop	 ebp
  0361e	c3		 ret	 0
_P_cos	ENDP
_TEXT	ENDS
EXTRN	_exp:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_exp	PROC

; 1388 : {

  03620	55		 push	 ebp
  03621	8b ec		 mov	 ebp, esp

; 1389 :     Mathfunc(exp);

  03623	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03628	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0362e	c1 f8 03	 sar	 eax, 3
  03631	83 f8 01	 cmp	 eax, 1
  03634	73 07		 jae	 SHORT $LN1@P_exp
  03636	e8 00 00 00 00	 call	 _stakunder
  0363b	eb 20		 jmp	 SHORT $LN2@P_exp
$LN1@P_exp:
  0363d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03643	83 ec 08	 sub	 esp, 8
  03646	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  03649	dd 1c 24	 fstp	 QWORD PTR [esp]
  0364c	e8 00 00 00 00	 call	 _exp
  03651	83 c4 08	 add	 esp, 8
  03654	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0365a	dd 5a f8	 fstp	 QWORD PTR [edx-8]
$LN2@P_exp:

; 1390 : }

  0365d	5d		 pop	 ebp
  0365e	c3		 ret	 0
_P_exp	ENDP
_TEXT	ENDS
EXTRN	_log:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_log	PROC

; 1393 : {

  03660	55		 push	 ebp
  03661	8b ec		 mov	 ebp, esp

; 1394 :     Mathfunc(log);

  03663	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03668	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0366e	c1 f8 03	 sar	 eax, 3
  03671	83 f8 01	 cmp	 eax, 1
  03674	73 07		 jae	 SHORT $LN1@P_log
  03676	e8 00 00 00 00	 call	 _stakunder
  0367b	eb 20		 jmp	 SHORT $LN2@P_log
$LN1@P_log:
  0367d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03683	83 ec 08	 sub	 esp, 8
  03686	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  03689	dd 1c 24	 fstp	 QWORD PTR [esp]
  0368c	e8 00 00 00 00	 call	 _log
  03691	83 c4 08	 add	 esp, 8
  03694	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0369a	dd 5a f8	 fstp	 QWORD PTR [edx-8]
$LN2@P_log:

; 1395 : }

  0369d	5d		 pop	 ebp
  0369e	c3		 ret	 0
_P_log	ENDP
_TEXT	ENDS
EXTRN	_pow:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_pow	PROC

; 1398 : {

  036a0	55		 push	 ebp
  036a1	8b ec		 mov	 ebp, esp

; 1399 :     Sl(2 * Realsize);

  036a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  036a8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  036ae	c1 f8 03	 sar	 eax, 3
  036b1	83 f8 02	 cmp	 eax, 2
  036b4	73 07		 jae	 SHORT $LN1@P_pow
  036b6	e8 00 00 00 00	 call	 _stakunder
  036bb	eb 3d		 jmp	 SHORT $LN2@P_pow
$LN1@P_pow:

; 1400 :     SREAL1(pow(REAL1, REAL0));

  036bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  036c3	83 ec 08	 sub	 esp, 8
  036c6	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  036c9	dd 1c 24	 fstp	 QWORD PTR [esp]
  036cc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  036d2	83 ec 08	 sub	 esp, 8
  036d5	dd 42 f0	 fld	 QWORD PTR [edx-16]
  036d8	dd 1c 24	 fstp	 QWORD PTR [esp]
  036db	e8 00 00 00 00	 call	 _pow
  036e0	83 c4 10	 add	 esp, 16			; 00000010H
  036e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  036e8	dd 58 f0	 fstp	 QWORD PTR [eax-16]

; 1401 :     Realpop;

  036eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  036f1	83 e9 08	 sub	 ecx, 8
  036f4	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN2@P_pow:

; 1402 : }

  036fa	5d		 pop	 ebp
  036fb	c3		 ret	 0
_P_pow	ENDP
_TEXT	ENDS
EXTRN	_sin:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_sin	PROC

; 1405 : {

  03700	55		 push	 ebp
  03701	8b ec		 mov	 ebp, esp

; 1406 :     Mathfunc(sin);

  03703	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03708	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0370e	c1 f8 03	 sar	 eax, 3
  03711	83 f8 01	 cmp	 eax, 1
  03714	73 07		 jae	 SHORT $LN1@P_sin
  03716	e8 00 00 00 00	 call	 _stakunder
  0371b	eb 20		 jmp	 SHORT $LN2@P_sin
$LN1@P_sin:
  0371d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03723	83 ec 08	 sub	 esp, 8
  03726	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  03729	dd 1c 24	 fstp	 QWORD PTR [esp]
  0372c	e8 00 00 00 00	 call	 _sin
  03731	83 c4 08	 add	 esp, 8
  03734	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0373a	dd 5a f8	 fstp	 QWORD PTR [edx-8]
$LN2@P_sin:

; 1407 : }

  0373d	5d		 pop	 ebp
  0373e	c3		 ret	 0
_P_sin	ENDP
_TEXT	ENDS
EXTRN	_sqrt:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_sqrt	PROC

; 1410 : {

  03740	55		 push	 ebp
  03741	8b ec		 mov	 ebp, esp

; 1411 :     Mathfunc(sqrt);

  03743	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03748	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0374e	c1 f8 03	 sar	 eax, 3
  03751	83 f8 01	 cmp	 eax, 1
  03754	73 07		 jae	 SHORT $LN1@P_sqrt
  03756	e8 00 00 00 00	 call	 _stakunder
  0375b	eb 20		 jmp	 SHORT $LN2@P_sqrt
$LN1@P_sqrt:
  0375d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03763	83 ec 08	 sub	 esp, 8
  03766	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  03769	dd 1c 24	 fstp	 QWORD PTR [esp]
  0376c	e8 00 00 00 00	 call	 _sqrt
  03771	83 c4 08	 add	 esp, 8
  03774	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0377a	dd 5a f8	 fstp	 QWORD PTR [edx-8]
$LN2@P_sqrt:

; 1412 : }

  0377d	5d		 pop	 ebp
  0377e	c3		 ret	 0
_P_sqrt	ENDP
_TEXT	ENDS
EXTRN	_tan:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_tan	PROC

; 1415 : {

  03780	55		 push	 ebp
  03781	8b ec		 mov	 ebp, esp

; 1416 :     Mathfunc(tan);

  03783	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03788	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0378e	c1 f8 03	 sar	 eax, 3
  03791	83 f8 01	 cmp	 eax, 1
  03794	73 07		 jae	 SHORT $LN1@P_tan
  03796	e8 00 00 00 00	 call	 _stakunder
  0379b	eb 20		 jmp	 SHORT $LN2@P_tan
$LN1@P_tan:
  0379d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  037a3	83 ec 08	 sub	 esp, 8
  037a6	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  037a9	dd 1c 24	 fstp	 QWORD PTR [esp]
  037ac	e8 00 00 00 00	 call	 _tan
  037b1	83 c4 08	 add	 esp, 8
  037b4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  037ba	dd 5a f8	 fstp	 QWORD PTR [edx-8]
$LN2@P_tan:

; 1417 : }

  037bd	5d		 pop	 ebp
  037be	c3		 ret	 0
_P_tan	ENDP
; Function compile flags: /Odtp
tv71 = -4						; size = 4
_P_dot	PROC

; 1427 : {

  037c0	55		 push	 ebp
  037c1	8b ec		 mov	 ebp, esp
  037c3	51		 push	 ecx

; 1428 :     Sl(1);

  037c4	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  037c9	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  037cf	c1 f8 03	 sar	 eax, 3
  037d2	83 f8 01	 cmp	 eax, 1
  037d5	7d 07		 jge	 SHORT $LN1@P_dot
  037d7	e8 00 00 00 00	 call	 _stakunder
  037dc	eb 42		 jmp	 SHORT $LN2@P_dot
$LN1@P_dot:

; 1429 :     V printf(base == 16 ? "%lX" : "%ld ", S0);

  037de	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR _base, 16	; 00000010H
  037e5	75 09		 jne	 SHORT $LN4@P_dot
  037e7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], OFFSET $SG83763
  037ee	eb 07		 jmp	 SHORT $LN5@P_dot
$LN4@P_dot:
  037f0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], OFFSET $SG83764
$LN5@P_dot:
  037f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  037fd	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  03800	52		 push	 edx
  03801	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  03804	50		 push	 eax
  03805	8b 4d fc	 mov	 ecx, DWORD PTR tv71[ebp]
  03808	51		 push	 ecx
  03809	e8 00 00 00 00	 call	 _printf
  0380e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1430 :     Pop;

  03811	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  03817	83 ea 08	 sub	 edx, 8
  0381a	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN2@P_dot:

; 1431 : }

  03820	8b e5		 mov	 esp, ebp
  03822	5d		 pop	 ebp
  03823	c3		 ret	 0
_P_dot	ENDP
; Function compile flags: /Odtp
tv78 = -4						; size = 4
_P_question PROC

; 1434 : {

  03830	55		 push	 ebp
  03831	8b ec		 mov	 ebp, esp
  03833	51		 push	 ecx

; 1435 :     Sl(1);

  03834	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03839	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0383f	c1 f8 03	 sar	 eax, 3
  03842	83 f8 01	 cmp	 eax, 1
  03845	7d 07		 jge	 SHORT $LN3@P_question
  03847	e8 00 00 00 00	 call	 _stakunder
  0384c	eb 6c		 jmp	 SHORT $LN4@P_question
$LN3@P_question:

; 1436 :     Hpc(S0);

  0384e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03854	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  03857	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  0385d	72 10		 jb	 SHORT $LN1@P_question
  0385f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03864	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  03867	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  0386d	72 07		 jb	 SHORT $LN2@P_question
$LN1@P_question:
  0386f	e8 00 00 00 00	 call	 _badpointer
  03874	eb 44		 jmp	 SHORT $LN4@P_question
$LN2@P_question:

; 1437 :     V printf(base == 16 ? "%lX" : "%ld ", *((stackitem *) S0));

  03876	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR _base, 16	; 00000010H
  0387d	75 09		 jne	 SHORT $LN6@P_question
  0387f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], OFFSET $SG83774
  03886	eb 07		 jmp	 SHORT $LN7@P_question
$LN6@P_question:
  03888	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], OFFSET $SG83775
$LN7@P_question:
  0388f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  03895	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  03898	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0389b	51		 push	 ecx
  0389c	8b 10		 mov	 edx, DWORD PTR [eax]
  0389e	52		 push	 edx
  0389f	8b 45 fc	 mov	 eax, DWORD PTR tv78[ebp]
  038a2	50		 push	 eax
  038a3	e8 00 00 00 00	 call	 _printf
  038a8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1438 :     Pop;

  038ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  038b1	83 e9 08	 sub	 ecx, 8
  038b4	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN4@P_question:

; 1439 : }

  038ba	8b e5		 mov	 esp, ebp
  038bc	5d		 pop	 ebp
  038bd	c3		 ret	 0
_P_question ENDP
; Function compile flags: /Odtp
_P_cr	PROC

; 1442 : {

  038c0	55		 push	 ebp
  038c1	8b ec		 mov	 ebp, esp

; 1443 :     V printf("\n");

  038c3	68 00 00 00 00	 push	 OFFSET $SG83779
  038c8	e8 00 00 00 00	 call	 _printf
  038cd	83 c4 04	 add	 esp, 4

; 1444 : }

  038d0	5d		 pop	 ebp
  038d1	c3		 ret	 0
_P_cr	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_stackbot DD	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
tv72 = -8						; size = 4
_tsp$ = -4						; size = 4
_P_dots	PROC

; 1447 : {

  038e0	55		 push	 ebp
  038e1	8b ec		 mov	 ebp, esp
  038e3	83 ec 08	 sub	 esp, 8

; 1448 :     stackitem *tsp;
; 1449 : 
; 1450 :     V printf("Stack: ");

  038e6	68 00 00 00 00	 push	 OFFSET $SG83784
  038eb	e8 00 00 00 00	 call	 _printf
  038f0	83 c4 04	 add	 esp, 4

; 1451 :     if (stk == stackbot)

  038f3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  038f8	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stackbot
  038fe	75 0f		 jne	 SHORT $LN5@P_dots

; 1452 :         V printf("Empty.");

  03900	68 00 00 00 00	 push	 OFFSET $SG83787
  03905	e8 00 00 00 00	 call	 _printf
  0390a	83 c4 04	 add	 esp, 4

; 1453 :     else {

  0390d	eb 50		 jmp	 SHORT $LN6@P_dots
$LN5@P_dots:

; 1454 : 	for (tsp = stack; tsp < stk; tsp++) {

  0390f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stack
  03915	89 4d fc	 mov	 DWORD PTR _tsp$[ebp], ecx
  03918	eb 09		 jmp	 SHORT $LN3@P_dots
$LN2@P_dots:
  0391a	8b 55 fc	 mov	 edx, DWORD PTR _tsp$[ebp]
  0391d	83 c2 08	 add	 edx, 8
  03920	89 55 fc	 mov	 DWORD PTR _tsp$[ebp], edx
$LN3@P_dots:
  03923	8b 45 fc	 mov	 eax, DWORD PTR _tsp$[ebp]
  03926	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stk
  0392c	73 31		 jae	 SHORT $LN6@P_dots

; 1455 :             V printf(base == 16 ? "%lX" : "%ld ", *tsp);

  0392e	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR _base, 16	; 00000010H
  03935	75 09		 jne	 SHORT $LN8@P_dots
  03937	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], OFFSET $SG83793
  0393e	eb 07		 jmp	 SHORT $LN9@P_dots
$LN8@P_dots:
  03940	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], OFFSET $SG83794
$LN9@P_dots:
  03947	8b 4d fc	 mov	 ecx, DWORD PTR _tsp$[ebp]
  0394a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0394d	52		 push	 edx
  0394e	8b 01		 mov	 eax, DWORD PTR [ecx]
  03950	50		 push	 eax
  03951	8b 4d f8	 mov	 ecx, DWORD PTR tv72[ebp]
  03954	51		 push	 ecx
  03955	e8 00 00 00 00	 call	 _printf
  0395a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1456 : 	}

  0395d	eb bb		 jmp	 SHORT $LN2@P_dots
$LN6@P_dots:

; 1457 :     }
; 1458 : }

  0395f	8b e5		 mov	 esp, ebp
  03961	5d		 pop	 ebp
  03962	c3		 ret	 0
_P_dots	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_dotparen DQ	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
tv69 = -4						; size = 4
_P_dotquote PROC

; 1461 : {

  03970	55		 push	 ebp
  03971	8b ec		 mov	 ebp, esp
  03973	51		 push	 ecx

; 1462 :     Compiling;

  03974	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  03979	89 45 fc	 mov	 DWORD PTR tv69[ebp], eax
  0397c	8b 4d fc	 mov	 ecx, DWORD PTR tv69[ebp]
  0397f	8b 55 fc	 mov	 edx, DWORD PTR tv69[ebp]
  03982	8b 01		 mov	 eax, DWORD PTR [ecx]
  03984	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  03987	75 07		 jne	 SHORT $LN2@P_dotquote
  03989	e8 00 00 00 00	 call	 _notcomp
  0398e	eb 47		 jmp	 SHORT $LN3@P_dotquote
$LN2@P_dotquote:

; 1463 :     stringlit = True;		      /* Set string literal expected */

  03990	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _stringlit, 1

; 1464 :     Compconst(s_dotparen);	      /* Compile .( word */

  0399a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  039a0	83 c1 08	 add	 ecx, 8
  039a3	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  039a9	76 07		 jbe	 SHORT $LN1@P_dotquote
  039ab	e8 00 00 00 00	 call	 _heapover
  039b0	eb 25		 jmp	 SHORT $LN3@P_dotquote
$LN1@P_dotquote:
  039b2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  039b8	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_dotparen
  039bd	89 02		 mov	 DWORD PTR [edx], eax
  039bf	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _s_dotparen+4
  039c5	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  039c8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  039ce	83 c2 08	 add	 edx, 8
  039d1	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx
$LN3@P_dotquote:

; 1465 : }

  039d7	8b e5		 mov	 esp, ebp
  039d9	5d		 pop	 ebp
  039da	c3		 ret	 0
_P_dotquote ENDP
; Function compile flags: /Odtp
_P_dotparen PROC

; 1468 : {

  039e0	55		 push	 ebp
  039e1	8b ec		 mov	 ebp, esp

; 1469 :     if (ip == NULL) {		      /* If interpreting */

  039e3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ip, 0
  039ea	75 0c		 jne	 SHORT $LN2@P_dotparen

; 1470 : 	stringlit = True;	      /* Set to print next string constant */

  039ec	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _stringlit, 1

; 1471 :     } else {			      /* Otherwise, */

  039f6	eb 2d		 jmp	 SHORT $LN3@P_dotparen
$LN2@P_dotparen:

; 1472 :         V printf("%s", ((char *) ip) + 1); /* print string literal

  039f8	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  039fd	83 c0 01	 add	 eax, 1
  03a00	50		 push	 eax
  03a01	68 00 00 00 00	 push	 OFFSET $SG83807
  03a06	e8 00 00 00 00	 call	 _printf
  03a0b	83 c4 08	 add	 esp, 8

; 1473 : 					 in in-line code. */
; 1474 : 	Skipstring;		      /* And advance IP past it */

  03a0e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ip
  03a14	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  03a17	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  03a1c	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  03a1f	89 0d 00 00 00
	00		 mov	 DWORD PTR _ip, ecx
$LN3@P_dotparen:

; 1475 :     }
; 1476 : }

  03a25	5d		 pop	 ebp
  03a26	c3		 ret	 0
_P_dotparen ENDP
; Function compile flags: /Odtp
_P_type PROC

; 1479 : {

  03a30	55		 push	 ebp
  03a31	8b ec		 mov	 ebp, esp

; 1480 :     Sl(1);

  03a33	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03a38	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  03a3e	c1 f8 03	 sar	 eax, 3
  03a41	83 f8 01	 cmp	 eax, 1
  03a44	7d 07		 jge	 SHORT $LN3@P_type
  03a46	e8 00 00 00 00	 call	 _stakunder
  03a4b	eb 4e		 jmp	 SHORT $LN4@P_type
$LN3@P_type:

; 1481 :     Hpc(S0);

  03a4d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03a53	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  03a56	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  03a5c	72 10		 jb	 SHORT $LN1@P_type
  03a5e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03a63	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  03a66	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  03a6c	72 07		 jb	 SHORT $LN2@P_type
$LN1@P_type:
  03a6e	e8 00 00 00 00	 call	 _badpointer
  03a73	eb 26		 jmp	 SHORT $LN4@P_type
$LN2@P_type:

; 1482 :     V printf("%s", (char *) S0);

  03a75	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  03a7b	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  03a7e	50		 push	 eax
  03a7f	68 00 00 00 00	 push	 OFFSET $SG83818
  03a84	e8 00 00 00 00	 call	 _printf
  03a89	83 c4 08	 add	 esp, 8

; 1483 :     Pop;

  03a8c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03a92	83 e9 08	 sub	 ecx, 8
  03a95	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN4@P_type:

; 1484 : }

  03a9b	5d		 pop	 ebp
  03a9c	c3		 ret	 0
_P_type	ENDP
; Function compile flags: /Odtp
_dw$ = -8						; size = 4
_key$ = -4						; size = 4
_P_words PROC

; 1487 : {

  03aa0	55		 push	 ebp
  03aa1	8b ec		 mov	 ebp, esp
  03aa3	83 ec 08	 sub	 esp, 8

; 1488 : #ifndef Keyhit
; 1489 :     int key = 0;

  03aa6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _key$[ebp], 0

; 1490 : #endif
; 1491 :     dictword *dw = dict;

  03aad	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  03ab2	89 45 f8	 mov	 DWORD PTR _dw$[ebp], eax
$LN3@P_words:

; 1492 : 
; 1493 :     while (dw != NULL) {

  03ab5	83 7d f8 00	 cmp	 DWORD PTR _dw$[ebp], 0
  03ab9	74 32		 je	 SHORT $LN2@P_words

; 1494 : 
; 1495 :         V printf("\n%s", dw->wname + 1);

  03abb	8b 4d f8	 mov	 ecx, DWORD PTR _dw$[ebp]
  03abe	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  03ac1	83 c2 01	 add	 edx, 1
  03ac4	52		 push	 edx
  03ac5	68 00 00 00 00	 push	 OFFSET $SG83828
  03aca	e8 00 00 00 00	 call	 _printf
  03acf	83 c4 08	 add	 esp, 8

; 1496 : 	dw = dw->wnext;

  03ad2	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  03ad5	8b 08		 mov	 ecx, DWORD PTR [eax]
  03ad7	89 4d f8	 mov	 DWORD PTR _dw$[ebp], ecx

; 1497 : #ifdef Keyhit
; 1498 : 	if (kbquit()) {
; 1499 : 	    break;
; 1500 : 	}
; 1501 : #else
; 1502 :         /* If this system can't trap keystrokes, just stop the WORDS
; 1503 : 	   listing after 20 words. */
; 1504 : 	if (++key >= 20)

  03ada	8b 55 fc	 mov	 edx, DWORD PTR _key$[ebp]
  03add	83 c2 01	 add	 edx, 1
  03ae0	89 55 fc	 mov	 DWORD PTR _key$[ebp], edx
  03ae3	83 7d fc 14	 cmp	 DWORD PTR _key$[ebp], 20 ; 00000014H
  03ae7	7c 02		 jl	 SHORT $LN1@P_words

; 1505 : 	    break;

  03ae9	eb 02		 jmp	 SHORT $LN2@P_words
$LN1@P_words:

; 1506 : #endif
; 1507 :     }

  03aeb	eb c8		 jmp	 SHORT $LN3@P_words
$LN2@P_words:

; 1508 :     V printf("\n");

  03aed	68 00 00 00 00	 push	 OFFSET $SG83831
  03af2	e8 00 00 00 00	 call	 _printf
  03af7	83 c4 04	 add	 esp, 4

; 1509 : }

  03afa	8b e5		 mov	 esp, ebp
  03afc	5d		 pop	 ebp
  03afd	c3		 ret	 0
_P_words ENDP
; Function compile flags: /Odtp
_P_file PROC

; 1515 : {

  03b00	55		 push	 ebp
  03b01	8b ec		 mov	 ebp, esp

; 1516 :     Ho(2);

  03b03	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  03b08	83 c0 10	 add	 eax, 16			; 00000010H
  03b0b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  03b11	76 07		 jbe	 SHORT $LN1@P_file
  03b13	e8 00 00 00 00	 call	 _heapover
  03b18	eb 48		 jmp	 SHORT $LN2@P_file
$LN1@P_file:

; 1517 :     P_create(); 		      /* Create variable */

  03b1a	e8 00 00 00 00	 call	 _P_create

; 1518 :     Hstore = FileSent;		      /* Store file sentinel */

  03b1f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  03b25	c7 01 9d df 1f
	83		 mov	 DWORD PTR [ecx], -2095063139 ; 831fdf9dH
  03b2b	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  03b32	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  03b38	83 c2 08	 add	 edx, 8
  03b3b	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 1519 :     Hstore = 0; 		      /* Mark file not open */

  03b41	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  03b46	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  03b4c	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  03b53	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  03b59	83 c1 08	 add	 ecx, 8
  03b5c	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx
$LN2@P_file:

; 1520 : }

  03b62	5d		 pop	 ebp
  03b63	c3		 ret	 0
_P_file	ENDP
_TEXT	ENDS
EXTRN	_fopen:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv145 = -16						; size = 4
_fd$ = -12						; size = 4
_stat$ = -8						; size = 8
_P_fopen PROC

; 1523 : {

  03b70	55		 push	 ebp
  03b71	8b ec		 mov	 ebp, esp
  03b73	83 ec 10	 sub	 esp, 16			; 00000010H

; 1524 :     FILE *fd;
; 1525 :     stackitem stat;
; 1526 : 
; 1527 :     Sl(3);

  03b76	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03b7b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  03b81	c1 f8 03	 sar	 eax, 3
  03b84	83 f8 03	 cmp	 eax, 3
  03b87	7d 0a		 jge	 SHORT $LN10@P_fopen
  03b89	e8 00 00 00 00	 call	 _stakunder
  03b8e	e9 3d 01 00 00	 jmp	 $LN11@P_fopen
$LN10@P_fopen:

; 1528 :     Hpc(S2);

  03b93	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03b99	8b 51 e8	 mov	 edx, DWORD PTR [ecx-24]
  03b9c	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  03ba2	72 10		 jb	 SHORT $LN8@P_fopen
  03ba4	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03ba9	8b 48 e8	 mov	 ecx, DWORD PTR [eax-24]
  03bac	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  03bb2	72 0a		 jb	 SHORT $LN9@P_fopen
$LN8@P_fopen:
  03bb4	e8 00 00 00 00	 call	 _badpointer
  03bb9	e9 12 01 00 00	 jmp	 $LN11@P_fopen
$LN9@P_fopen:

; 1529 :     Hpc(S0);

  03bbe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  03bc4	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  03bc7	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  03bcd	72 11		 jb	 SHORT $LN6@P_fopen
  03bcf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03bd5	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  03bd8	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  03bde	72 0a		 jb	 SHORT $LN7@P_fopen
$LN6@P_fopen:
  03be0	e8 00 00 00 00	 call	 _badpointer
  03be5	e9 e6 00 00 00	 jmp	 $LN11@P_fopen
$LN7@P_fopen:

; 1530 :     Isfile(S0);

  03bea	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03bef	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  03bf2	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  03bf8	72 11		 jb	 SHORT $LN4@P_fopen
  03bfa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  03c00	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  03c03	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  03c09	72 0a		 jb	 SHORT $LN5@P_fopen
$LN4@P_fopen:
  03c0b	e8 00 00 00 00	 call	 _badpointer
  03c10	e9 bb 00 00 00	 jmp	 $LN11@P_fopen
$LN5@P_fopen:
  03c15	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03c1b	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  03c1e	89 55 f0	 mov	 DWORD PTR tv145[ebp], edx
  03c21	8b 45 f0	 mov	 eax, DWORD PTR tv145[ebp]
  03c24	81 38 9d df 1f
	83		 cmp	 DWORD PTR [eax], -2095063139 ; 831fdf9dH
  03c2a	75 09		 jne	 SHORT $LN13@P_fopen
  03c2c	8b 4d f0	 mov	 ecx, DWORD PTR tv145[ebp]
  03c2f	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  03c33	74 12		 je	 SHORT $LN3@P_fopen
$LN13@P_fopen:
  03c35	68 00 00 00 00	 push	 OFFSET $SG83855
  03c3a	e8 00 00 00 00	 call	 _printf
  03c3f	83 c4 04	 add	 esp, 4
  03c42	e9 89 00 00 00	 jmp	 $LN11@P_fopen
$LN3@P_fopen:

; 1531 :     fd = fopen((char *) S2, fopenmodes[S1]);

  03c47	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  03c4d	6a 00		 push	 0
  03c4f	6a 04		 push	 4
  03c51	8b 42 f4	 mov	 eax, DWORD PTR [edx-12]
  03c54	50		 push	 eax
  03c55	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  03c58	51		 push	 ecx
  03c59	e8 00 00 00 00	 call	 __allmul
  03c5e	8b 90 00 00 00
	00		 mov	 edx, DWORD PTR _fopenmodes[eax]
  03c64	52		 push	 edx
  03c65	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03c6a	8b 48 e8	 mov	 ecx, DWORD PTR [eax-24]
  03c6d	51		 push	 ecx
  03c6e	e8 00 00 00 00	 call	 _fopen
  03c73	83 c4 08	 add	 esp, 8
  03c76	89 45 f4	 mov	 DWORD PTR _fd$[ebp], eax

; 1532 :     if (fd == NULL) {

  03c79	83 7d f4 00	 cmp	 DWORD PTR _fd$[ebp], 0
  03c7d	75 10		 jne	 SHORT $LN2@P_fopen

; 1533 : 	stat = Falsity;

  03c7f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _stat$[ebp], 0
  03c86	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _stat$[ebp+4], 0

; 1534 :     } else {

  03c8d	eb 21		 jmp	 SHORT $LN1@P_fopen
$LN2@P_fopen:

; 1535 : 	*(((stackitem *) S0) + 1) = (stackitem) fd;

  03c8f	8b 45 f4	 mov	 eax, DWORD PTR _fd$[ebp]
  03c92	99		 cdq
  03c93	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03c99	8b 49 f8	 mov	 ecx, DWORD PTR [ecx-8]
  03c9c	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  03c9f	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 1536 : 	stat = Truth;

  03ca2	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _stat$[ebp], -1
  03ca9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _stat$[ebp+4], -1
$LN1@P_fopen:

; 1537 :     }
; 1538 :     Pop2;

  03cb0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  03cb6	83 ea 10	 sub	 edx, 16			; 00000010H
  03cb9	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 1539 :     S0 = stat;

  03cbf	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03cc4	8b 4d f8	 mov	 ecx, DWORD PTR _stat$[ebp]
  03cc7	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  03cca	8b 55 fc	 mov	 edx, DWORD PTR _stat$[ebp+4]
  03ccd	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN11@P_fopen:

; 1540 : }

  03cd0	8b e5		 mov	 esp, ebp
  03cd2	5d		 pop	 ebp
  03cd3	c3		 ret	 0
_P_fopen ENDP
_TEXT	ENDS
EXTRN	_fclose:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv136 = -4						; size = 4
_P_fclose PROC

; 1543 : {

  03ce0	55		 push	 ebp
  03ce1	8b ec		 mov	 ebp, esp
  03ce3	51		 push	 ecx

; 1544 :     Sl(1);

  03ce4	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03ce9	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  03cef	c1 f8 03	 sar	 eax, 3
  03cf2	83 f8 01	 cmp	 eax, 1
  03cf5	7d 0a		 jge	 SHORT $LN7@P_fclose
  03cf7	e8 00 00 00 00	 call	 _stakunder
  03cfc	e9 dc 00 00 00	 jmp	 $LN8@P_fclose
$LN7@P_fclose:

; 1545 :     Hpc(S0);

  03d01	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03d07	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  03d0a	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  03d10	72 10		 jb	 SHORT $LN5@P_fclose
  03d12	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03d17	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  03d1a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  03d20	72 0a		 jb	 SHORT $LN6@P_fclose
$LN5@P_fclose:
  03d22	e8 00 00 00 00	 call	 _badpointer
  03d27	e9 b1 00 00 00	 jmp	 $LN8@P_fclose
$LN6@P_fclose:

; 1546 :     Isfile(S0);

  03d2c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  03d32	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  03d35	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  03d3b	72 11		 jb	 SHORT $LN3@P_fclose
  03d3d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03d43	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  03d46	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  03d4c	72 0a		 jb	 SHORT $LN4@P_fclose
$LN3@P_fclose:
  03d4e	e8 00 00 00 00	 call	 _badpointer
  03d53	e9 85 00 00 00	 jmp	 $LN8@P_fclose
$LN4@P_fclose:
  03d58	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03d5d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  03d60	89 4d fc	 mov	 DWORD PTR tv136[ebp], ecx
  03d63	8b 55 fc	 mov	 edx, DWORD PTR tv136[ebp]
  03d66	81 3a 9d df 1f
	83		 cmp	 DWORD PTR [edx], -2095063139 ; 831fdf9dH
  03d6c	75 09		 jne	 SHORT $LN10@P_fclose
  03d6e	8b 45 fc	 mov	 eax, DWORD PTR tv136[ebp]
  03d71	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  03d75	74 0f		 je	 SHORT $LN2@P_fclose
$LN10@P_fclose:
  03d77	68 00 00 00 00	 push	 OFFSET $SG83876
  03d7c	e8 00 00 00 00	 call	 _printf
  03d81	83 c4 04	 add	 esp, 4
  03d84	eb 57		 jmp	 SHORT $LN8@P_fclose
$LN2@P_fclose:

; 1547 :     Isopen(S0);

  03d86	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03d8c	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  03d8f	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  03d93	75 0f		 jne	 SHORT $LN1@P_fclose
  03d95	68 00 00 00 00	 push	 OFFSET $SG83882
  03d9a	e8 00 00 00 00	 call	 _printf
  03d9f	83 c4 04	 add	 esp, 4
  03da2	eb 39		 jmp	 SHORT $LN8@P_fclose
$LN1@P_fclose:

; 1548 :     V fclose(FileD(S0));

  03da4	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03da9	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  03dac	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  03daf	52		 push	 edx
  03db0	e8 00 00 00 00	 call	 _fclose
  03db5	83 c4 04	 add	 esp, 4

; 1549 :     *(((stackitem *) S0) + 1) = (stackitem) NULL;

  03db8	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03dbd	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  03dc0	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  03dc7	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 1550 :     Pop;

  03dce	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  03dd4	83 ea 08	 sub	 edx, 8
  03dd7	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN8@P_fclose:

; 1551 : }

  03ddd	8b e5		 mov	 esp, ebp
  03ddf	5d		 pop	 ebp
  03de0	c3		 ret	 0
_P_fclose ENDP
_TEXT	ENDS
EXTRN	__unlink:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_fdelete PROC

; 1554 : {

  03df0	55		 push	 ebp
  03df1	8b ec		 mov	 ebp, esp

; 1555 :     Sl(1);

  03df3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03df8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  03dfe	c1 f8 03	 sar	 eax, 3
  03e01	83 f8 01	 cmp	 eax, 1
  03e04	7d 07		 jge	 SHORT $LN3@P_fdelete
  03e06	e8 00 00 00 00	 call	 _stakunder
  03e0b	eb 50		 jmp	 SHORT $LN4@P_fdelete
$LN3@P_fdelete:

; 1556 :     Hpc(S0);

  03e0d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03e13	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  03e16	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  03e1c	72 10		 jb	 SHORT $LN1@P_fdelete
  03e1e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03e23	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  03e26	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  03e2c	72 07		 jb	 SHORT $LN2@P_fdelete
$LN1@P_fdelete:
  03e2e	e8 00 00 00 00	 call	 _badpointer
  03e33	eb 28		 jmp	 SHORT $LN4@P_fdelete
$LN2@P_fdelete:

; 1557 :     S0 = (unlink((char *) S0) == 0) ? Truth : Falsity;

  03e35	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  03e3b	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  03e3e	50		 push	 eax
  03e3f	e8 00 00 00 00	 call	 __unlink
  03e44	83 c4 04	 add	 esp, 4
  03e47	f7 d8		 neg	 eax
  03e49	1b c0		 sbb	 eax, eax
  03e4b	f7 d8		 neg	 eax
  03e4d	83 e8 01	 sub	 eax, 1
  03e50	99		 cdq
  03e51	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03e57	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  03e5a	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN4@P_fdelete:

; 1558 : }

  03e5d	5d		 pop	 ebp
  03e5e	c3		 ret	 0
_P_fdelete ENDP
; Function compile flags: /Odtp
tv141 = -4						; size = 4
_P_fgetline PROC

; 1561 : {

  03e60	55		 push	 ebp
  03e61	8b ec		 mov	 ebp, esp
  03e63	51		 push	 ecx

; 1562 :     Sl(2);

  03e64	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03e69	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  03e6f	c1 f8 03	 sar	 eax, 3
  03e72	83 f8 02	 cmp	 eax, 2
  03e75	7d 0a		 jge	 SHORT $LN9@P_fgetline
  03e77	e8 00 00 00 00	 call	 _stakunder
  03e7c	e9 01 01 00 00	 jmp	 $LN10@P_fgetline
$LN9@P_fgetline:

; 1563 :     Hpc(S0);

  03e81	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03e87	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  03e8a	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  03e90	72 10		 jb	 SHORT $LN7@P_fgetline
  03e92	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03e97	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  03e9a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  03ea0	72 0a		 jb	 SHORT $LN8@P_fgetline
$LN7@P_fgetline:
  03ea2	e8 00 00 00 00	 call	 _badpointer
  03ea7	e9 d6 00 00 00	 jmp	 $LN10@P_fgetline
$LN8@P_fgetline:

; 1564 :     Isfile(S1);

  03eac	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  03eb2	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  03eb5	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  03ebb	72 11		 jb	 SHORT $LN5@P_fgetline
  03ebd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03ec3	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  03ec6	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  03ecc	72 0a		 jb	 SHORT $LN6@P_fgetline
$LN5@P_fgetline:
  03ece	e8 00 00 00 00	 call	 _badpointer
  03ed3	e9 aa 00 00 00	 jmp	 $LN10@P_fgetline
$LN6@P_fgetline:
  03ed8	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03edd	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  03ee0	89 4d fc	 mov	 DWORD PTR tv141[ebp], ecx
  03ee3	8b 55 fc	 mov	 edx, DWORD PTR tv141[ebp]
  03ee6	81 3a 9d df 1f
	83		 cmp	 DWORD PTR [edx], -2095063139 ; 831fdf9dH
  03eec	75 09		 jne	 SHORT $LN12@P_fgetline
  03eee	8b 45 fc	 mov	 eax, DWORD PTR tv141[ebp]
  03ef1	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  03ef5	74 0f		 je	 SHORT $LN4@P_fgetline
$LN12@P_fgetline:
  03ef7	68 00 00 00 00	 push	 OFFSET $SG83911
  03efc	e8 00 00 00 00	 call	 _printf
  03f01	83 c4 04	 add	 esp, 4
  03f04	eb 7c		 jmp	 SHORT $LN10@P_fgetline
$LN4@P_fgetline:

; 1565 :     Isopen(S1);

  03f06	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03f0c	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  03f0f	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  03f13	75 0f		 jne	 SHORT $LN3@P_fgetline
  03f15	68 00 00 00 00	 push	 OFFSET $SG83917
  03f1a	e8 00 00 00 00	 call	 _printf
  03f1f	83 c4 04	 add	 esp, 4
  03f22	eb 5e		 jmp	 SHORT $LN10@P_fgetline
$LN3@P_fgetline:

; 1566 :     if (atl_fgetsp((char *) S0, 132, FileD(S1)) == NULL) {

  03f24	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03f29	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  03f2c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  03f2f	52		 push	 edx
  03f30	68 84 00 00 00	 push	 132			; 00000084H
  03f35	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03f3a	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  03f3d	51		 push	 ecx
  03f3e	e8 00 00 00 00	 call	 _atl_fgetsp
  03f43	83 c4 0c	 add	 esp, 12			; 0000000cH
  03f46	85 c0		 test	 eax, eax
  03f48	75 16		 jne	 SHORT $LN2@P_fgetline

; 1567 : 	S1 = Falsity;

  03f4a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  03f50	c7 42 f0 00 00
	00 00		 mov	 DWORD PTR [edx-16], 0
  03f57	c7 42 f4 00 00
	00 00		 mov	 DWORD PTR [edx-12], 0

; 1568 :     } else {

  03f5e	eb 13		 jmp	 SHORT $LN1@P_fgetline
$LN2@P_fgetline:

; 1569 : 	S1 = Truth;

  03f60	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  03f65	c7 40 f0 ff ff
	ff ff		 mov	 DWORD PTR [eax-16], -1
  03f6c	c7 40 f4 ff ff
	ff ff		 mov	 DWORD PTR [eax-12], -1
$LN1@P_fgetline:

; 1570 :     }
; 1571 :     Pop;

  03f73	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  03f79	83 e9 08	 sub	 ecx, 8
  03f7c	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN10@P_fgetline:

; 1572 : }

  03f82	8b e5		 mov	 esp, ebp
  03f84	5d		 pop	 ebp
  03f85	c3		 ret	 0
_P_fgetline ENDP
_TEXT	ENDS
EXTRN	_ungetc:PROC
EXTRN	_getc:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_ch$ = -8						; size = 4
_i$ = -4						; size = 4
_s$ = 8							; size = 4
_n$ = 12						; size = 4
_stream$ = 16						; size = 4
_atl_fgetsp PROC

; 480  : {

  03f90	55		 push	 ebp
  03f91	8b ec		 mov	 ebp, esp
  03f93	83 ec 08	 sub	 esp, 8

; 481  : 	int i = 0, ch;

  03f96	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN9@atl_fgetsp:

; 482  : 
; 483  : 	while (True) {

  03f9d	b8 01 00 00 00	 mov	 eax, 1
  03fa2	85 c0		 test	 eax, eax
  03fa4	0f 84 a2 00 00
	00		 je	 $LN8@atl_fgetsp

; 484  : 	   ch = getc(stream);

  03faa	8b 4d 10	 mov	 ecx, DWORD PTR _stream$[ebp]
  03fad	51		 push	 ecx
  03fae	e8 00 00 00 00	 call	 _getc
  03fb3	83 c4 04	 add	 esp, 4
  03fb6	89 45 f8	 mov	 DWORD PTR _ch$[ebp], eax

; 485  : 	   if (ch == EOF) {

  03fb9	83 7d f8 ff	 cmp	 DWORD PTR _ch$[ebp], -1
  03fbd	75 0f		 jne	 SHORT $LN7@atl_fgetsp

; 486  : 	      if (i == 0)

  03fbf	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  03fc3	75 07		 jne	 SHORT $LN6@atl_fgetsp

; 487  : 		 return NULL;

  03fc5	33 c0		 xor	 eax, eax
  03fc7	e9 8c 00 00 00	 jmp	 $LN10@atl_fgetsp
$LN6@atl_fgetsp:

; 488  : 	      break;

  03fcc	eb 7e		 jmp	 SHORT $LN8@atl_fgetsp
$LN7@atl_fgetsp:

; 489  : 	   }
; 490  :            if (ch == '\r') {

  03fce	83 7d f8 0d	 cmp	 DWORD PTR _ch$[ebp], 13	; 0000000dH
  03fd2	75 27		 jne	 SHORT $LN5@atl_fgetsp

; 491  : 	      ch = getc(stream);

  03fd4	8b 55 10	 mov	 edx, DWORD PTR _stream$[ebp]
  03fd7	52		 push	 edx
  03fd8	e8 00 00 00 00	 call	 _getc
  03fdd	83 c4 04	 add	 esp, 4
  03fe0	89 45 f8	 mov	 DWORD PTR _ch$[ebp], eax

; 492  :               if (ch != '\n')

  03fe3	83 7d f8 0a	 cmp	 DWORD PTR _ch$[ebp], 10	; 0000000aH
  03fe7	74 10		 je	 SHORT $LN4@atl_fgetsp

; 493  : 		 V ungetc(ch, stream);

  03fe9	8b 45 10	 mov	 eax, DWORD PTR _stream$[ebp]
  03fec	50		 push	 eax
  03fed	8b 4d f8	 mov	 ecx, DWORD PTR _ch$[ebp]
  03ff0	51		 push	 ecx
  03ff1	e8 00 00 00 00	 call	 _ungetc
  03ff6	83 c4 08	 add	 esp, 8
$LN4@atl_fgetsp:

; 494  : 	      break;

  03ff9	eb 51		 jmp	 SHORT $LN8@atl_fgetsp
$LN5@atl_fgetsp:

; 495  : 	   }
; 496  :            if (ch == '\n') {

  03ffb	83 7d f8 0a	 cmp	 DWORD PTR _ch$[ebp], 10	; 0000000aH
  03fff	75 27		 jne	 SHORT $LN3@atl_fgetsp

; 497  : 	      ch = getc(stream);

  04001	8b 55 10	 mov	 edx, DWORD PTR _stream$[ebp]
  04004	52		 push	 edx
  04005	e8 00 00 00 00	 call	 _getc
  0400a	83 c4 04	 add	 esp, 4
  0400d	89 45 f8	 mov	 DWORD PTR _ch$[ebp], eax

; 498  :               if (ch != '\r')

  04010	83 7d f8 0d	 cmp	 DWORD PTR _ch$[ebp], 13	; 0000000dH
  04014	74 10		 je	 SHORT $LN2@atl_fgetsp

; 499  : 		 V ungetc(ch, stream);

  04016	8b 45 10	 mov	 eax, DWORD PTR _stream$[ebp]
  04019	50		 push	 eax
  0401a	8b 4d f8	 mov	 ecx, DWORD PTR _ch$[ebp]
  0401d	51		 push	 ecx
  0401e	e8 00 00 00 00	 call	 _ungetc
  04023	83 c4 08	 add	 esp, 8
$LN2@atl_fgetsp:

; 500  : 	      break;

  04026	eb 24		 jmp	 SHORT $LN8@atl_fgetsp
$LN3@atl_fgetsp:

; 501  : 	   }
; 502  : 	   if (i < (n - 1))

  04028	8b 55 0c	 mov	 edx, DWORD PTR _n$[ebp]
  0402b	83 ea 01	 sub	 edx, 1
  0402e	39 55 fc	 cmp	 DWORD PTR _i$[ebp], edx
  04031	7d 14		 jge	 SHORT $LN1@atl_fgetsp

; 503  : 	      s[i++] = ch;

  04033	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  04036	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  04039	8a 4d f8	 mov	 cl, BYTE PTR _ch$[ebp]
  0403c	88 08		 mov	 BYTE PTR [eax], cl
  0403e	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  04041	83 c2 01	 add	 edx, 1
  04044	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN1@atl_fgetsp:

; 504  : 	}

  04047	e9 51 ff ff ff	 jmp	 $LN9@atl_fgetsp
$LN8@atl_fgetsp:

; 505  : 	s[i] = EOS;

  0404c	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0404f	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  04052	c6 00 00	 mov	 BYTE PTR [eax], 0

; 506  : 	return s;

  04055	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
$LN10@atl_fgetsp:

; 507  : }

  04058	8b e5		 mov	 esp, ebp
  0405a	5d		 pop	 ebp
  0405b	c3		 ret	 0
_atl_fgetsp ENDP
_TEXT	ENDS
EXTRN	_putc:PROC
EXTRN	_fputs:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv150 = -4						; size = 4
_P_fputline PROC

; 1575 : {

  04060	55		 push	 ebp
  04061	8b ec		 mov	 ebp, esp
  04063	51		 push	 ecx

; 1576 :     Sl(2);

  04064	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04069	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0406f	c1 f8 03	 sar	 eax, 3
  04072	83 f8 02	 cmp	 eax, 2
  04075	7d 0a		 jge	 SHORT $LN9@P_fputline
  04077	e8 00 00 00 00	 call	 _stakunder
  0407c	e9 17 01 00 00	 jmp	 $LN10@P_fputline
$LN9@P_fputline:

; 1577 :     Hpc(S1);

  04081	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04087	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  0408a	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  04090	72 10		 jb	 SHORT $LN7@P_fputline
  04092	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04097	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0409a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  040a0	72 0a		 jb	 SHORT $LN8@P_fputline
$LN7@P_fputline:
  040a2	e8 00 00 00 00	 call	 _badpointer
  040a7	e9 ec 00 00 00	 jmp	 $LN10@P_fputline
$LN8@P_fputline:

; 1578 :     Isfile(S0);

  040ac	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  040b2	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  040b5	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  040bb	72 11		 jb	 SHORT $LN5@P_fputline
  040bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  040c3	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  040c6	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  040cc	72 0a		 jb	 SHORT $LN6@P_fputline
$LN5@P_fputline:
  040ce	e8 00 00 00 00	 call	 _badpointer
  040d3	e9 c0 00 00 00	 jmp	 $LN10@P_fputline
$LN6@P_fputline:
  040d8	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  040dd	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  040e0	89 4d fc	 mov	 DWORD PTR tv150[ebp], ecx
  040e3	8b 55 fc	 mov	 edx, DWORD PTR tv150[ebp]
  040e6	81 3a 9d df 1f
	83		 cmp	 DWORD PTR [edx], -2095063139 ; 831fdf9dH
  040ec	75 09		 jne	 SHORT $LN12@P_fputline
  040ee	8b 45 fc	 mov	 eax, DWORD PTR tv150[ebp]
  040f1	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  040f5	74 12		 je	 SHORT $LN4@P_fputline
$LN12@P_fputline:
  040f7	68 00 00 00 00	 push	 OFFSET $SG83938
  040fc	e8 00 00 00 00	 call	 _printf
  04101	83 c4 04	 add	 esp, 4
  04104	e9 8f 00 00 00	 jmp	 $LN10@P_fputline
$LN4@P_fputline:

; 1579 :     Isopen(S0);

  04109	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0410f	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  04112	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  04116	75 0f		 jne	 SHORT $LN3@P_fputline
  04118	68 00 00 00 00	 push	 OFFSET $SG83944
  0411d	e8 00 00 00 00	 call	 _printf
  04122	83 c4 04	 add	 esp, 4
  04125	eb 71		 jmp	 SHORT $LN10@P_fputline
$LN3@P_fputline:

; 1580 :     if (fputs((char *) S1, FileD(S0)) == EOF) {

  04127	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0412c	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0412f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  04132	52		 push	 edx
  04133	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04138	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0413b	51		 push	 ecx
  0413c	e8 00 00 00 00	 call	 _fputs
  04141	83 c4 08	 add	 esp, 8
  04144	83 f8 ff	 cmp	 eax, -1
  04147	75 16		 jne	 SHORT $LN2@P_fputline

; 1581 : 	S1 = Falsity;

  04149	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0414f	c7 42 f0 00 00
	00 00		 mov	 DWORD PTR [edx-16], 0
  04156	c7 42 f4 00 00
	00 00		 mov	 DWORD PTR [edx-12], 0

; 1582 :     } else {

  0415d	eb 2a		 jmp	 SHORT $LN1@P_fputline
$LN2@P_fputline:

; 1583 :         S1 = putc('\n', FileD(S0)) == EOF ? Falsity : Truth;

  0415f	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04164	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  04167	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0416a	52		 push	 edx
  0416b	6a 0a		 push	 10			; 0000000aH
  0416d	e8 00 00 00 00	 call	 _putc
  04172	83 c4 08	 add	 esp, 8
  04175	83 e8 ff	 sub	 eax, -1
  04178	f7 d8		 neg	 eax
  0417a	1b c0		 sbb	 eax, eax
  0417c	99		 cdq
  0417d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04183	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  04186	89 51 f4	 mov	 DWORD PTR [ecx-12], edx
$LN1@P_fputline:

; 1584 :     }
; 1585 :     Pop;

  04189	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0418f	83 ea 08	 sub	 edx, 8
  04192	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN10@P_fputline:

; 1586 : }

  04198	8b e5		 mov	 esp, ebp
  0419a	5d		 pop	 ebp
  0419b	c3		 ret	 0
_P_fputline ENDP
_TEXT	ENDS
EXTRN	_fread:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv143 = -4						; size = 4
_P_fread PROC

; 1589 : {

  041a0	55		 push	 ebp
  041a1	8b ec		 mov	 ebp, esp
  041a3	51		 push	 ecx

; 1590 :     Sl(3);

  041a4	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  041a9	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  041af	c1 f8 03	 sar	 eax, 3
  041b2	83 f8 03	 cmp	 eax, 3
  041b5	7d 0a		 jge	 SHORT $LN7@P_fread
  041b7	e8 00 00 00 00	 call	 _stakunder
  041bc	e9 e7 00 00 00	 jmp	 $LN8@P_fread
$LN7@P_fread:

; 1591 :     Hpc(S0);

  041c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  041c7	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  041ca	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  041d0	72 10		 jb	 SHORT $LN5@P_fread
  041d2	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  041d7	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  041da	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  041e0	72 0a		 jb	 SHORT $LN6@P_fread
$LN5@P_fread:
  041e2	e8 00 00 00 00	 call	 _badpointer
  041e7	e9 bc 00 00 00	 jmp	 $LN8@P_fread
$LN6@P_fread:

; 1592 :     Isfile(S2);

  041ec	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  041f2	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  041f5	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  041fb	72 11		 jb	 SHORT $LN3@P_fread
  041fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04203	8b 51 e8	 mov	 edx, DWORD PTR [ecx-24]
  04206	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  0420c	72 0a		 jb	 SHORT $LN4@P_fread
$LN3@P_fread:
  0420e	e8 00 00 00 00	 call	 _badpointer
  04213	e9 90 00 00 00	 jmp	 $LN8@P_fread
$LN4@P_fread:
  04218	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0421d	8b 48 e8	 mov	 ecx, DWORD PTR [eax-24]
  04220	89 4d fc	 mov	 DWORD PTR tv143[ebp], ecx
  04223	8b 55 fc	 mov	 edx, DWORD PTR tv143[ebp]
  04226	81 3a 9d df 1f
	83		 cmp	 DWORD PTR [edx], -2095063139 ; 831fdf9dH
  0422c	75 09		 jne	 SHORT $LN10@P_fread
  0422e	8b 45 fc	 mov	 eax, DWORD PTR tv143[ebp]
  04231	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  04235	74 0f		 je	 SHORT $LN2@P_fread
$LN10@P_fread:
  04237	68 00 00 00 00	 push	 OFFSET $SG83966
  0423c	e8 00 00 00 00	 call	 _printf
  04241	83 c4 04	 add	 esp, 4
  04244	eb 62		 jmp	 SHORT $LN8@P_fread
$LN2@P_fread:

; 1593 :     Isopen(S2);

  04246	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0424c	8b 51 e8	 mov	 edx, DWORD PTR [ecx-24]
  0424f	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  04253	75 0f		 jne	 SHORT $LN1@P_fread
  04255	68 00 00 00 00	 push	 OFFSET $SG83972
  0425a	e8 00 00 00 00	 call	 _printf
  0425f	83 c4 04	 add	 esp, 4
  04262	eb 44		 jmp	 SHORT $LN8@P_fread
$LN1@P_fread:

; 1594 :     S2 = fread((char *) S0, 1, ((int) S1), FileD(S2));

  04264	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04269	8b 48 e8	 mov	 ecx, DWORD PTR [eax-24]
  0426c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0426f	52		 push	 edx
  04270	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04275	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  04278	51		 push	 ecx
  04279	6a 01		 push	 1
  0427b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04281	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  04284	50		 push	 eax
  04285	e8 00 00 00 00	 call	 _fread
  0428a	83 c4 10	 add	 esp, 16			; 00000010H
  0428d	33 c9		 xor	 ecx, ecx
  0428f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04295	89 42 e8	 mov	 DWORD PTR [edx-24], eax
  04298	89 4a ec	 mov	 DWORD PTR [edx-20], ecx

; 1595 :     Pop2;

  0429b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  042a0	83 e8 10	 sub	 eax, 16			; 00000010H
  042a3	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN8@P_fread:

; 1596 : }

  042a8	8b e5		 mov	 esp, ebp
  042aa	5d		 pop	 ebp
  042ab	c3		 ret	 0
_P_fread ENDP
_TEXT	ENDS
EXTRN	_fwrite:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv143 = -4						; size = 4
_P_fwrite PROC

; 1599 : {

  042b0	55		 push	 ebp
  042b1	8b ec		 mov	 ebp, esp
  042b3	51		 push	 ecx

; 1600 :     Sl(3);

  042b4	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  042b9	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  042bf	c1 f8 03	 sar	 eax, 3
  042c2	83 f8 03	 cmp	 eax, 3
  042c5	7d 0a		 jge	 SHORT $LN7@P_fwrite
  042c7	e8 00 00 00 00	 call	 _stakunder
  042cc	e9 e7 00 00 00	 jmp	 $LN8@P_fwrite
$LN7@P_fwrite:

; 1601 :     Hpc(S1);

  042d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  042d7	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  042da	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  042e0	72 10		 jb	 SHORT $LN5@P_fwrite
  042e2	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  042e7	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  042ea	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  042f0	72 0a		 jb	 SHORT $LN6@P_fwrite
$LN5@P_fwrite:
  042f2	e8 00 00 00 00	 call	 _badpointer
  042f7	e9 bc 00 00 00	 jmp	 $LN8@P_fwrite
$LN6@P_fwrite:

; 1602 :     Isfile(S0);

  042fc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04302	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  04305	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  0430b	72 11		 jb	 SHORT $LN3@P_fwrite
  0430d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04313	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  04316	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  0431c	72 0a		 jb	 SHORT $LN4@P_fwrite
$LN3@P_fwrite:
  0431e	e8 00 00 00 00	 call	 _badpointer
  04323	e9 90 00 00 00	 jmp	 $LN8@P_fwrite
$LN4@P_fwrite:
  04328	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0432d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  04330	89 4d fc	 mov	 DWORD PTR tv143[ebp], ecx
  04333	8b 55 fc	 mov	 edx, DWORD PTR tv143[ebp]
  04336	81 3a 9d df 1f
	83		 cmp	 DWORD PTR [edx], -2095063139 ; 831fdf9dH
  0433c	75 09		 jne	 SHORT $LN10@P_fwrite
  0433e	8b 45 fc	 mov	 eax, DWORD PTR tv143[ebp]
  04341	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  04345	74 0f		 je	 SHORT $LN2@P_fwrite
$LN10@P_fwrite:
  04347	68 00 00 00 00	 push	 OFFSET $SG83991
  0434c	e8 00 00 00 00	 call	 _printf
  04351	83 c4 04	 add	 esp, 4
  04354	eb 62		 jmp	 SHORT $LN8@P_fwrite
$LN2@P_fwrite:

; 1603 :     Isopen(S0);

  04356	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0435c	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  0435f	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  04363	75 0f		 jne	 SHORT $LN1@P_fwrite
  04365	68 00 00 00 00	 push	 OFFSET $SG83997
  0436a	e8 00 00 00 00	 call	 _printf
  0436f	83 c4 04	 add	 esp, 4
  04372	eb 44		 jmp	 SHORT $LN8@P_fwrite
$LN1@P_fwrite:

; 1604 :     S2 = fwrite((char *) S1, 1, ((int) S2), FileD(S0));

  04374	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04379	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0437c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0437f	52		 push	 edx
  04380	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04385	8b 48 e8	 mov	 ecx, DWORD PTR [eax-24]
  04388	51		 push	 ecx
  04389	6a 01		 push	 1
  0438b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04391	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  04394	50		 push	 eax
  04395	e8 00 00 00 00	 call	 _fwrite
  0439a	83 c4 10	 add	 esp, 16			; 00000010H
  0439d	33 c9		 xor	 ecx, ecx
  0439f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  043a5	89 42 e8	 mov	 DWORD PTR [edx-24], eax
  043a8	89 4a ec	 mov	 DWORD PTR [edx-20], ecx

; 1605 :     Pop2;

  043ab	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  043b0	83 e8 10	 sub	 eax, 16			; 00000010H
  043b3	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN8@P_fwrite:

; 1606 : }

  043b8	8b e5		 mov	 esp, ebp
  043ba	5d		 pop	 ebp
  043bb	c3		 ret	 0
_P_fwrite ENDP
; Function compile flags: /Odtp
tv95 = -4						; size = 4
_P_fgetc PROC

; 1609 : {

  043c0	55		 push	 ebp
  043c1	8b ec		 mov	 ebp, esp
  043c3	51		 push	 ecx

; 1610 :     Sl(1);

  043c4	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  043c9	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  043cf	c1 f8 03	 sar	 eax, 3
  043d2	83 f8 01	 cmp	 eax, 1
  043d5	7d 0a		 jge	 SHORT $LN5@P_fgetc
  043d7	e8 00 00 00 00	 call	 _stakunder
  043dc	e9 96 00 00 00	 jmp	 $LN6@P_fgetc
$LN5@P_fgetc:

; 1611 :     Isfile(S0);

  043e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  043e7	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  043ea	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  043f0	72 10		 jb	 SHORT $LN3@P_fgetc
  043f2	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  043f7	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  043fa	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  04400	72 07		 jb	 SHORT $LN4@P_fgetc
$LN3@P_fgetc:
  04402	e8 00 00 00 00	 call	 _badpointer
  04407	eb 6e		 jmp	 SHORT $LN6@P_fgetc
$LN4@P_fgetc:
  04409	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0440f	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  04412	89 45 fc	 mov	 DWORD PTR tv95[ebp], eax
  04415	8b 4d fc	 mov	 ecx, DWORD PTR tv95[ebp]
  04418	81 39 9d df 1f
	83		 cmp	 DWORD PTR [ecx], -2095063139 ; 831fdf9dH
  0441e	75 09		 jne	 SHORT $LN8@P_fgetc
  04420	8b 55 fc	 mov	 edx, DWORD PTR tv95[ebp]
  04423	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  04427	74 0f		 je	 SHORT $LN2@P_fgetc
$LN8@P_fgetc:
  04429	68 00 00 00 00	 push	 OFFSET $SG84012
  0442e	e8 00 00 00 00	 call	 _printf
  04433	83 c4 04	 add	 esp, 4
  04436	eb 3f		 jmp	 SHORT $LN6@P_fgetc
$LN2@P_fgetc:

; 1612 :     Isopen(S0);

  04438	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0443d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  04440	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  04444	75 0f		 jne	 SHORT $LN1@P_fgetc
  04446	68 00 00 00 00	 push	 OFFSET $SG84018
  0444b	e8 00 00 00 00	 call	 _printf
  04450	83 c4 04	 add	 esp, 4
  04453	eb 22		 jmp	 SHORT $LN6@P_fgetc
$LN1@P_fgetc:

; 1613 :     S0 = getc(FileD(S0));	      /* Returns -1 if EOF hit */

  04455	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0445b	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  0445e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  04461	51		 push	 ecx
  04462	e8 00 00 00 00	 call	 _getc
  04467	83 c4 04	 add	 esp, 4
  0446a	99		 cdq
  0446b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04471	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  04474	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN6@P_fgetc:

; 1614 : }

  04477	8b e5		 mov	 esp, ebp
  04479	5d		 pop	 ebp
  0447a	c3		 ret	 0
_P_fgetc ENDP
; Function compile flags: /Odtp
tv132 = -4						; size = 4
_P_fputc PROC

; 1617 : {

  04480	55		 push	 ebp
  04481	8b ec		 mov	 ebp, esp
  04483	51		 push	 ecx

; 1618 :     Sl(2);

  04484	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04489	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0448f	c1 f8 03	 sar	 eax, 3
  04492	83 f8 02	 cmp	 eax, 2
  04495	7d 0a		 jge	 SHORT $LN5@P_fputc
  04497	e8 00 00 00 00	 call	 _stakunder
  0449c	e9 b3 00 00 00	 jmp	 $LN6@P_fputc
$LN5@P_fputc:

; 1619 :     Isfile(S0);

  044a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  044a7	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  044aa	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  044b0	72 10		 jb	 SHORT $LN3@P_fputc
  044b2	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  044b7	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  044ba	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  044c0	72 0a		 jb	 SHORT $LN4@P_fputc
$LN3@P_fputc:
  044c2	e8 00 00 00 00	 call	 _badpointer
  044c7	e9 88 00 00 00	 jmp	 $LN6@P_fputc
$LN4@P_fputc:
  044cc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  044d2	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  044d5	89 45 fc	 mov	 DWORD PTR tv132[ebp], eax
  044d8	8b 4d fc	 mov	 ecx, DWORD PTR tv132[ebp]
  044db	81 39 9d df 1f
	83		 cmp	 DWORD PTR [ecx], -2095063139 ; 831fdf9dH
  044e1	75 09		 jne	 SHORT $LN8@P_fputc
  044e3	8b 55 fc	 mov	 edx, DWORD PTR tv132[ebp]
  044e6	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  044ea	74 0f		 je	 SHORT $LN2@P_fputc
$LN8@P_fputc:
  044ec	68 00 00 00 00	 push	 OFFSET $SG84031
  044f1	e8 00 00 00 00	 call	 _printf
  044f6	83 c4 04	 add	 esp, 4
  044f9	eb 59		 jmp	 SHORT $LN6@P_fputc
$LN2@P_fputc:

; 1620 :     Isopen(S0);

  044fb	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04500	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  04503	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  04507	75 0f		 jne	 SHORT $LN1@P_fputc
  04509	68 00 00 00 00	 push	 OFFSET $SG84037
  0450e	e8 00 00 00 00	 call	 _printf
  04513	83 c4 04	 add	 esp, 4
  04516	eb 3c		 jmp	 SHORT $LN6@P_fputc
$LN1@P_fputc:

; 1621 :     S1 = putc((char) S1, FileD(S0));

  04518	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0451e	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  04521	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  04524	51		 push	 ecx
  04525	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0452b	0f be 42 f0	 movsx	 eax, BYTE PTR [edx-16]
  0452f	50		 push	 eax
  04530	e8 00 00 00 00	 call	 _putc
  04535	83 c4 08	 add	 esp, 8
  04538	99		 cdq
  04539	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0453f	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  04542	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 1622 :     Pop;

  04545	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0454b	83 ea 08	 sub	 edx, 8
  0454e	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN6@P_fputc:

; 1623 : }

  04554	8b e5		 mov	 esp, ebp
  04556	5d		 pop	 ebp
  04557	c3		 ret	 0
_P_fputc ENDP
_TEXT	ENDS
EXTRN	_ftell:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv95 = -4						; size = 4
_P_ftell PROC

; 1626 : {

  04560	55		 push	 ebp
  04561	8b ec		 mov	 ebp, esp
  04563	51		 push	 ecx

; 1627 :     Sl(1);

  04564	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04569	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0456f	c1 f8 03	 sar	 eax, 3
  04572	83 f8 01	 cmp	 eax, 1
  04575	7d 0a		 jge	 SHORT $LN5@P_ftell
  04577	e8 00 00 00 00	 call	 _stakunder
  0457c	e9 96 00 00 00	 jmp	 $LN6@P_ftell
$LN5@P_ftell:

; 1628 :     Isfile(S0);

  04581	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04587	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  0458a	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  04590	72 10		 jb	 SHORT $LN3@P_ftell
  04592	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04597	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0459a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  045a0	72 07		 jb	 SHORT $LN4@P_ftell
$LN3@P_ftell:
  045a2	e8 00 00 00 00	 call	 _badpointer
  045a7	eb 6e		 jmp	 SHORT $LN6@P_ftell
$LN4@P_ftell:
  045a9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  045af	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  045b2	89 45 fc	 mov	 DWORD PTR tv95[ebp], eax
  045b5	8b 4d fc	 mov	 ecx, DWORD PTR tv95[ebp]
  045b8	81 39 9d df 1f
	83		 cmp	 DWORD PTR [ecx], -2095063139 ; 831fdf9dH
  045be	75 09		 jne	 SHORT $LN8@P_ftell
  045c0	8b 55 fc	 mov	 edx, DWORD PTR tv95[ebp]
  045c3	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  045c7	74 0f		 je	 SHORT $LN2@P_ftell
$LN8@P_ftell:
  045c9	68 00 00 00 00	 push	 OFFSET $SG84051
  045ce	e8 00 00 00 00	 call	 _printf
  045d3	83 c4 04	 add	 esp, 4
  045d6	eb 3f		 jmp	 SHORT $LN6@P_ftell
$LN2@P_ftell:

; 1629 :     Isopen(S0);

  045d8	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  045dd	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  045e0	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  045e4	75 0f		 jne	 SHORT $LN1@P_ftell
  045e6	68 00 00 00 00	 push	 OFFSET $SG84057
  045eb	e8 00 00 00 00	 call	 _printf
  045f0	83 c4 04	 add	 esp, 4
  045f3	eb 22		 jmp	 SHORT $LN6@P_ftell
$LN1@P_ftell:

; 1630 :     S0 = (stackitem) ftell(FileD(S0));

  045f5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  045fb	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  045fe	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  04601	51		 push	 ecx
  04602	e8 00 00 00 00	 call	 _ftell
  04607	83 c4 04	 add	 esp, 4
  0460a	99		 cdq
  0460b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04611	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  04614	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN6@P_ftell:

; 1631 : }

  04617	8b e5		 mov	 esp, ebp
  04619	5d		 pop	 ebp
  0461a	c3		 ret	 0
_P_ftell ENDP
_TEXT	ENDS
EXTRN	_fseek:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv131 = -4						; size = 4
_P_fseek PROC

; 1634 : {

  04620	55		 push	 ebp
  04621	8b ec		 mov	 ebp, esp
  04623	51		 push	 ecx

; 1635 :     Sl(3);

  04624	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04629	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0462f	c1 f8 03	 sar	 eax, 3
  04632	83 f8 03	 cmp	 eax, 3
  04635	7d 0a		 jge	 SHORT $LN5@P_fseek
  04637	e8 00 00 00 00	 call	 _stakunder
  0463c	e9 ac 00 00 00	 jmp	 $LN6@P_fseek
$LN5@P_fseek:

; 1636 :     Isfile(S0);

  04641	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04647	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  0464a	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  04650	72 10		 jb	 SHORT $LN3@P_fseek
  04652	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04657	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0465a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  04660	72 0a		 jb	 SHORT $LN4@P_fseek
$LN3@P_fseek:
  04662	e8 00 00 00 00	 call	 _badpointer
  04667	e9 81 00 00 00	 jmp	 $LN6@P_fseek
$LN4@P_fseek:
  0466c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04672	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  04675	89 45 fc	 mov	 DWORD PTR tv131[ebp], eax
  04678	8b 4d fc	 mov	 ecx, DWORD PTR tv131[ebp]
  0467b	81 39 9d df 1f
	83		 cmp	 DWORD PTR [ecx], -2095063139 ; 831fdf9dH
  04681	75 09		 jne	 SHORT $LN8@P_fseek
  04683	8b 55 fc	 mov	 edx, DWORD PTR tv131[ebp]
  04686	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0468a	74 0f		 je	 SHORT $LN2@P_fseek
$LN8@P_fseek:
  0468c	68 00 00 00 00	 push	 OFFSET $SG84071
  04691	e8 00 00 00 00	 call	 _printf
  04696	83 c4 04	 add	 esp, 4
  04699	eb 52		 jmp	 SHORT $LN6@P_fseek
$LN2@P_fseek:

; 1637 :     Isopen(S0);

  0469b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  046a0	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  046a3	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  046a7	75 0f		 jne	 SHORT $LN1@P_fseek
  046a9	68 00 00 00 00	 push	 OFFSET $SG84077
  046ae	e8 00 00 00 00	 call	 _printf
  046b3	83 c4 04	 add	 esp, 4
  046b6	eb 35		 jmp	 SHORT $LN6@P_fseek
$LN1@P_fseek:

; 1638 :     V fseek(FileD(S0), (long) S2, (int) S1);

  046b8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  046be	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  046c1	50		 push	 eax
  046c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  046c8	8b 51 e8	 mov	 edx, DWORD PTR [ecx-24]
  046cb	52		 push	 edx
  046cc	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  046d1	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  046d4	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  046d7	52		 push	 edx
  046d8	e8 00 00 00 00	 call	 _fseek
  046dd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1639 :     Npop(3);

  046e0	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  046e5	83 e8 18	 sub	 eax, 24			; 00000018H
  046e8	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN6@P_fseek:

; 1640 : }

  046ed	8b e5		 mov	 esp, ebp
  046ef	5d		 pop	 ebp
  046f0	c3		 ret	 0
_P_fseek ENDP
_TEXT	ENDS
PUBLIC	_atl_load
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv130 = -12						; size = 4
_fd$ = -8						; size = 4
_estat$ = -4						; size = 4
_P_fload PROC

; 1643 : {

  04700	55		 push	 ebp
  04701	8b ec		 mov	 ebp, esp
  04703	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1644 :     int estat;
; 1645 :     FILE *fd;
; 1646 : 
; 1647 :     Sl(1);

  04706	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0470b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  04711	c1 f8 03	 sar	 eax, 3
  04714	83 f8 01	 cmp	 eax, 1
  04717	7d 0a		 jge	 SHORT $LN6@P_fload
  04719	e8 00 00 00 00	 call	 _stakunder
  0471e	e9 dd 00 00 00	 jmp	 $LN7@P_fload
$LN6@P_fload:

; 1648 :     Isfile(S0);

  04723	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04729	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  0472c	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  04732	72 10		 jb	 SHORT $LN4@P_fload
  04734	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04739	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0473c	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  04742	72 0a		 jb	 SHORT $LN5@P_fload
$LN4@P_fload:
  04744	e8 00 00 00 00	 call	 _badpointer
  04749	e9 b2 00 00 00	 jmp	 $LN7@P_fload
$LN5@P_fload:
  0474e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04754	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  04757	89 45 f4	 mov	 DWORD PTR tv130[ebp], eax
  0475a	8b 4d f4	 mov	 ecx, DWORD PTR tv130[ebp]
  0475d	81 39 9d df 1f
	83		 cmp	 DWORD PTR [ecx], -2095063139 ; 831fdf9dH
  04763	75 09		 jne	 SHORT $LN9@P_fload
  04765	8b 55 f4	 mov	 edx, DWORD PTR tv130[ebp]
  04768	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0476c	74 12		 je	 SHORT $LN3@P_fload
$LN9@P_fload:
  0476e	68 00 00 00 00	 push	 OFFSET $SG84095
  04773	e8 00 00 00 00	 call	 _printf
  04778	83 c4 04	 add	 esp, 4
  0477b	e9 80 00 00 00	 jmp	 $LN7@P_fload
$LN3@P_fload:

; 1649 :     Isopen(S0);

  04780	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04785	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  04788	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  0478c	75 0f		 jne	 SHORT $LN2@P_fload
  0478e	68 00 00 00 00	 push	 OFFSET $SG84101
  04793	e8 00 00 00 00	 call	 _printf
  04798	83 c4 04	 add	 esp, 4
  0479b	eb 63		 jmp	 SHORT $LN7@P_fload
$LN2@P_fload:

; 1650 :     fd = FileD(S0);

  0479d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  047a3	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  047a6	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  047a9	89 4d f8	 mov	 DWORD PTR _fd$[ebp], ecx

; 1651 :     Pop;

  047ac	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  047b2	83 ea 08	 sub	 edx, 8
  047b5	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 1652 :     estat = atl_load(fd);

  047bb	8b 45 f8	 mov	 eax, DWORD PTR _fd$[ebp]
  047be	50		 push	 eax
  047bf	e8 00 00 00 00	 call	 _atl_load
  047c4	83 c4 04	 add	 esp, 4
  047c7	89 45 fc	 mov	 DWORD PTR _estat$[ebp], eax

; 1653 :     So(1);

  047ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  047d0	83 c1 08	 add	 ecx, 8
  047d3	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _stacktop
  047d9	76 07		 jbe	 SHORT $LN1@P_fload
  047db	e8 00 00 00 00	 call	 _stakover
  047e0	eb 1e		 jmp	 SHORT $LN7@P_fload
$LN1@P_fload:

; 1654 :     Push = estat;

  047e2	8b 45 fc	 mov	 eax, DWORD PTR _estat$[ebp]
  047e5	99		 cdq
  047e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  047ec	89 01		 mov	 DWORD PTR [ecx], eax
  047ee	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  047f1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  047f7	83 c2 08	 add	 edx, 8
  047fa	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN7@P_fload:

; 1655 : }

  04800	8b e5		 mov	 esp, ebp
  04802	5d		 pop	 ebp
  04803	c3		 ret	 0
_P_fload ENDP
_TEXT	ENDS
PUBLIC	_atl_unwind
PUBLIC	_atl_eval
PUBLIC	_atl_mark
; Function compile flags: /Odtp
_TEXT	SEGMENT
_scomm$ = -40						; size = 8
_estring$ = -32						; size = 4
_es$ = -28						; size = 4
_sinstr$ = -24						; size = 4
_sip$ = -20						; size = 4
_mk$ = -16						; size = 16
_P_evaluate PROC

; 1661 : {				      /* string -- status */

  04810	55		 push	 ebp
  04811	8b ec		 mov	 ebp, esp
  04813	83 ec 28	 sub	 esp, 40			; 00000028H

; 1662 :     int es = ATL_SNORM;

  04816	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _es$[ebp], 0

; 1663 :     atl_statemark mk;
; 1664 :     atl_int scomm = atl_comment;      /* Stack comment pending state */

  0481d	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_comment
  04822	89 45 d8	 mov	 DWORD PTR _scomm$[ebp], eax
  04825	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _atl_comment+4
  0482b	89 4d dc	 mov	 DWORD PTR _scomm$[ebp+4], ecx

; 1665 :     dictword **sip = ip;	      /* Stack instruction pointer */

  0482e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ip
  04834	89 55 ec	 mov	 DWORD PTR _sip$[ebp], edx

; 1666 :     char *sinstr = instream;	      /* Stack input stream */

  04837	a1 00 00 00 00	 mov	 eax, DWORD PTR _instream
  0483c	89 45 e8	 mov	 DWORD PTR _sinstr$[ebp], eax

; 1667 :     char *estring;
; 1668 : 
; 1669 :     Sl(1);

  0483f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04845	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _stack
  0484b	c1 f9 03	 sar	 ecx, 3
  0484e	83 f9 01	 cmp	 ecx, 1
  04851	7d 0a		 jge	 SHORT $LN6@P_evaluate
  04853	e8 00 00 00 00	 call	 _stakunder
  04858	e9 fb 00 00 00	 jmp	 $LN7@P_evaluate
$LN6@P_evaluate:

; 1670 :     Hpc(S0);

  0485d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04863	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  04866	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  0486c	72 11		 jb	 SHORT $LN4@P_evaluate
  0486e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04874	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  04877	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  0487d	72 0a		 jb	 SHORT $LN5@P_evaluate
$LN4@P_evaluate:
  0487f	e8 00 00 00 00	 call	 _badpointer
  04884	e9 cf 00 00 00	 jmp	 $LN7@P_evaluate
$LN5@P_evaluate:

; 1671 :     estring = (char *) S0;	      /* Get string to evaluate */

  04889	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0488e	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  04891	89 4d e0	 mov	 DWORD PTR _estring$[ebp], ecx

; 1672 :     Pop;			      /* Pop so it sees arguments below it */

  04894	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0489a	83 ea 08	 sub	 edx, 8
  0489d	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 1673 :     atl_mark(&mk);		      /* Mark in case of error */

  048a3	8d 45 f0	 lea	 eax, DWORD PTR _mk$[ebp]
  048a6	50		 push	 eax
  048a7	e8 00 00 00 00	 call	 _atl_mark
  048ac	83 c4 04	 add	 esp, 4

; 1674 :     ip = NULL;			      /* Fool atl_eval into interp state */

  048af	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ip, 0

; 1675 :     if ((es = atl_eval(estring)) != ATL_SNORM) {

  048b9	8b 4d e0	 mov	 ecx, DWORD PTR _estring$[ebp]
  048bc	51		 push	 ecx
  048bd	e8 00 00 00 00	 call	 _atl_eval
  048c2	83 c4 04	 add	 esp, 4
  048c5	89 45 e4	 mov	 DWORD PTR _es$[ebp], eax
  048c8	83 7d e4 00	 cmp	 DWORD PTR _es$[ebp], 0
  048cc	74 0c		 je	 SHORT $LN3@P_evaluate

; 1676 : 	atl_unwind(&mk);

  048ce	8d 55 f0	 lea	 edx, DWORD PTR _mk$[ebp]
  048d1	52		 push	 edx
  048d2	e8 00 00 00 00	 call	 _atl_unwind
  048d7	83 c4 04	 add	 esp, 4
$LN3@P_evaluate:

; 1677 :     }
; 1678 :     /* If there were no other errors, check for a runaway comment.  If
; 1679 :        we ended the file in comment-ignore mode, set the runaway comment
; 1680 :        error status and unwind the file.  */
; 1681 :     if ((es == ATL_SNORM) && (atl_comment != 0)) {

  048da	83 7d e4 00	 cmp	 DWORD PTR _es$[ebp], 0
  048de	75 20		 jne	 SHORT $LN2@P_evaluate
  048e0	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_comment
  048e5	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _atl_comment+4
  048eb	74 13		 je	 SHORT $LN2@P_evaluate

; 1682 : 	es = ATL_RUNCOMM;

  048ed	c7 45 e4 f5 ff
	ff ff		 mov	 DWORD PTR _es$[ebp], -11 ; fffffff5H

; 1683 : 	atl_unwind(&mk);

  048f4	8d 4d f0	 lea	 ecx, DWORD PTR _mk$[ebp]
  048f7	51		 push	 ecx
  048f8	e8 00 00 00 00	 call	 _atl_unwind
  048fd	83 c4 04	 add	 esp, 4
$LN2@P_evaluate:

; 1684 :     }
; 1685 :     atl_comment = scomm;	      /* Unstack comment pending status */

  04900	8b 55 d8	 mov	 edx, DWORD PTR _scomm$[ebp]
  04903	89 15 00 00 00
	00		 mov	 DWORD PTR _atl_comment, edx
  04909	8b 45 dc	 mov	 eax, DWORD PTR _scomm$[ebp+4]
  0490c	a3 04 00 00 00	 mov	 DWORD PTR _atl_comment+4, eax

; 1686 :     ip = sip;			      /* Unstack instruction pointer */

  04911	8b 4d ec	 mov	 ecx, DWORD PTR _sip$[ebp]
  04914	89 0d 00 00 00
	00		 mov	 DWORD PTR _ip, ecx

; 1687 :     instream = sinstr;		      /* Unstack input stream */

  0491a	8b 55 e8	 mov	 edx, DWORD PTR _sinstr$[ebp]
  0491d	89 15 00 00 00
	00		 mov	 DWORD PTR _instream, edx

; 1688 :     So(1);

  04923	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04928	83 c0 08	 add	 eax, 8
  0492b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  04931	76 07		 jbe	 SHORT $LN1@P_evaluate
  04933	e8 00 00 00 00	 call	 _stakover
  04938	eb 1e		 jmp	 SHORT $LN7@P_evaluate
$LN1@P_evaluate:

; 1689 :     Push = es;			      /* Return eval status on top of stack */

  0493a	8b 45 e4	 mov	 eax, DWORD PTR _es$[ebp]
  0493d	99		 cdq
  0493e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04944	89 01		 mov	 DWORD PTR [ecx], eax
  04946	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  04949	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0494f	83 c2 08	 add	 edx, 8
  04952	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN7@P_evaluate:

; 1690 : }

  04958	8b e5		 mov	 esp, ebp
  0495a	5d		 pop	 ebp
  0495b	c3		 ret	 0
_P_evaluate ENDP
; Function compile flags: /Odtp
_s$ = -8						; size = 8
_P_depth PROC

; 1696 : {

  04960	55		 push	 ebp
  04961	8b ec		 mov	 ebp, esp
  04963	83 ec 08	 sub	 esp, 8

; 1697 :     stackitem s = stk - stack;

  04966	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0496b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  04971	c1 f8 03	 sar	 eax, 3
  04974	99		 cdq
  04975	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  04978	89 55 fc	 mov	 DWORD PTR _s$[ebp+4], edx

; 1698 : 
; 1699 :     So(1);

  0497b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04980	83 c0 08	 add	 eax, 8
  04983	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  04989	76 07		 jbe	 SHORT $LN1@P_depth
  0498b	e8 00 00 00 00	 call	 _stakover
  04990	eb 20		 jmp	 SHORT $LN2@P_depth
$LN1@P_depth:

; 1700 :     Push = s;

  04992	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04998	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  0499b	89 11		 mov	 DWORD PTR [ecx], edx
  0499d	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp+4]
  049a0	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  049a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  049a9	83 c1 08	 add	 ecx, 8
  049ac	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN2@P_depth:

; 1701 : }

  049b2	8b e5		 mov	 esp, ebp
  049b4	5d		 pop	 ebp
  049b5	c3		 ret	 0
_P_depth ENDP
; Function compile flags: /Odtp
_P_clear PROC

; 1704 : {

  049c0	55		 push	 ebp
  049c1	8b ec		 mov	 ebp, esp

; 1705 :     stk = stack;

  049c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stack
  049c8	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1706 : }

  049cd	5d		 pop	 ebp
  049ce	c3		 ret	 0
_P_clear ENDP
; Function compile flags: /Odtp
_s$ = -8						; size = 8
_P_dup	PROC

; 1709 : {

  049d0	55		 push	 ebp
  049d1	8b ec		 mov	 ebp, esp
  049d3	83 ec 08	 sub	 esp, 8

; 1710 :     stackitem s;
; 1711 : 
; 1712 :     Sl(1);

  049d6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  049db	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  049e1	c1 f8 03	 sar	 eax, 3
  049e4	83 f8 01	 cmp	 eax, 1
  049e7	7d 07		 jge	 SHORT $LN2@P_dup
  049e9	e8 00 00 00 00	 call	 _stakunder
  049ee	eb 4a		 jmp	 SHORT $LN3@P_dup
$LN2@P_dup:

; 1713 :     So(1);

  049f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  049f6	83 c1 08	 add	 ecx, 8
  049f9	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _stacktop
  049ff	76 07		 jbe	 SHORT $LN1@P_dup
  04a01	e8 00 00 00 00	 call	 _stakover
  04a06	eb 32		 jmp	 SHORT $LN3@P_dup
$LN1@P_dup:

; 1714 :     s = S0;

  04a08	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04a0e	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  04a11	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  04a14	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  04a17	89 4d fc	 mov	 DWORD PTR _s$[ebp+4], ecx

; 1715 :     Push = s;

  04a1a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04a20	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  04a23	89 02		 mov	 DWORD PTR [edx], eax
  04a25	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp+4]
  04a28	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  04a2b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04a31	83 c2 08	 add	 edx, 8
  04a34	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN3@P_dup:

; 1716 : }

  04a3a	8b e5		 mov	 esp, ebp
  04a3c	5d		 pop	 ebp
  04a3d	c3		 ret	 0
_P_dup	ENDP
; Function compile flags: /Odtp
_P_drop PROC

; 1719 : {

  04a40	55		 push	 ebp
  04a41	8b ec		 mov	 ebp, esp

; 1720 :     Sl(1);

  04a43	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04a48	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  04a4e	c1 f8 03	 sar	 eax, 3
  04a51	83 f8 01	 cmp	 eax, 1
  04a54	7d 07		 jge	 SHORT $LN1@P_drop
  04a56	e8 00 00 00 00	 call	 _stakunder
  04a5b	eb 0f		 jmp	 SHORT $LN2@P_drop
$LN1@P_drop:

; 1721 :     Pop;

  04a5d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04a63	83 e9 08	 sub	 ecx, 8
  04a66	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN2@P_drop:

; 1722 : }

  04a6c	5d		 pop	 ebp
  04a6d	c3		 ret	 0
_P_drop	ENDP
; Function compile flags: /Odtp
_t$ = -8						; size = 8
_P_swap	PROC

; 1725 : {

  04a70	55		 push	 ebp
  04a71	8b ec		 mov	 ebp, esp
  04a73	83 ec 08	 sub	 esp, 8

; 1726 :     stackitem t;
; 1727 : 
; 1728 :     Sl(2);

  04a76	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04a7b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  04a81	c1 f8 03	 sar	 eax, 3
  04a84	83 f8 02	 cmp	 eax, 2
  04a87	7d 07		 jge	 SHORT $LN1@P_swap
  04a89	e8 00 00 00 00	 call	 _stakunder
  04a8e	eb 3b		 jmp	 SHORT $LN2@P_swap
$LN1@P_swap:

; 1729 :     t = S1;

  04a90	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04a96	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  04a99	89 55 f8	 mov	 DWORD PTR _t$[ebp], edx
  04a9c	8b 41 f4	 mov	 eax, DWORD PTR [ecx-12]
  04a9f	89 45 fc	 mov	 DWORD PTR _t$[ebp+4], eax

; 1730 :     S1 = S0;

  04aa2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04aa8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04aae	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  04ab1	89 41 f0	 mov	 DWORD PTR [ecx-16], eax
  04ab4	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  04ab7	89 51 f4	 mov	 DWORD PTR [ecx-12], edx

; 1731 :     S0 = t;

  04aba	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04abf	8b 4d f8	 mov	 ecx, DWORD PTR _t$[ebp]
  04ac2	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  04ac5	8b 55 fc	 mov	 edx, DWORD PTR _t$[ebp+4]
  04ac8	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_swap:

; 1732 : }

  04acb	8b e5		 mov	 esp, ebp
  04acd	5d		 pop	 ebp
  04ace	c3		 ret	 0
_P_swap	ENDP
; Function compile flags: /Odtp
_s$ = -8						; size = 8
_P_over	PROC

; 1735 : {

  04ad0	55		 push	 ebp
  04ad1	8b ec		 mov	 ebp, esp
  04ad3	83 ec 08	 sub	 esp, 8

; 1736 :     stackitem s;
; 1737 : 
; 1738 :     Sl(2);

  04ad6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04adb	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  04ae1	c1 f8 03	 sar	 eax, 3
  04ae4	83 f8 02	 cmp	 eax, 2
  04ae7	7d 07		 jge	 SHORT $LN2@P_over
  04ae9	e8 00 00 00 00	 call	 _stakunder
  04aee	eb 4a		 jmp	 SHORT $LN3@P_over
$LN2@P_over:

; 1739 :     So(1);

  04af0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04af6	83 c1 08	 add	 ecx, 8
  04af9	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _stacktop
  04aff	76 07		 jbe	 SHORT $LN1@P_over
  04b01	e8 00 00 00 00	 call	 _stakover
  04b06	eb 32		 jmp	 SHORT $LN3@P_over
$LN1@P_over:

; 1740 :     s = S1;

  04b08	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04b0e	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  04b11	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  04b14	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  04b17	89 4d fc	 mov	 DWORD PTR _s$[ebp+4], ecx

; 1741 :     Push = s;

  04b1a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04b20	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  04b23	89 02		 mov	 DWORD PTR [edx], eax
  04b25	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp+4]
  04b28	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  04b2b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04b31	83 c2 08	 add	 edx, 8
  04b34	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN3@P_over:

; 1742 : }

  04b3a	8b e5		 mov	 esp, ebp
  04b3c	5d		 pop	 ebp
  04b3d	c3		 ret	 0
_P_over	ENDP
; Function compile flags: /Odtp
_P_pick PROC

; 1745 : {

  04b40	55		 push	 ebp
  04b41	8b ec		 mov	 ebp, esp
  04b43	56		 push	 esi

; 1746 :     Sl(2);

  04b44	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04b49	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  04b4f	c1 f8 03	 sar	 eax, 3
  04b52	83 f8 02	 cmp	 eax, 2
  04b55	7d 07		 jge	 SHORT $LN1@P_pick
  04b57	e8 00 00 00 00	 call	 _stakunder
  04b5c	eb 3d		 jmp	 SHORT $LN2@P_pick
$LN1@P_pick:

; 1747 :     S0 = stk[-(2 + S0)];

  04b5e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04b64	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  04b67	83 c2 02	 add	 edx, 2
  04b6a	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  04b6d	83 d0 00	 adc	 eax, 0
  04b70	f7 da		 neg	 edx
  04b72	83 d0 00	 adc	 eax, 0
  04b75	f7 d8		 neg	 eax
  04b77	6a 00		 push	 0
  04b79	6a 08		 push	 8
  04b7b	50		 push	 eax
  04b7c	52		 push	 edx
  04b7d	e8 00 00 00 00	 call	 __allmul
  04b82	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04b88	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04b8e	8b 34 02	 mov	 esi, DWORD PTR [edx+eax]
  04b91	89 71 f8	 mov	 DWORD PTR [ecx-8], esi
  04b94	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  04b98	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN2@P_pick:

; 1748 : }

  04b9b	5e		 pop	 esi
  04b9c	5d		 pop	 ebp
  04b9d	c3		 ret	 0
_P_pick	ENDP
; Function compile flags: /Odtp
_t$ = -8						; size = 8
_P_rot	PROC

; 1751 : {

  04ba0	55		 push	 ebp
  04ba1	8b ec		 mov	 ebp, esp
  04ba3	83 ec 08	 sub	 esp, 8

; 1752 :     stackitem t;
; 1753 : 
; 1754 :     Sl(3);

  04ba6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04bab	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  04bb1	c1 f8 03	 sar	 eax, 3
  04bb4	83 f8 03	 cmp	 eax, 3
  04bb7	7d 07		 jge	 SHORT $LN1@P_rot
  04bb9	e8 00 00 00 00	 call	 _stakunder
  04bbe	eb 53		 jmp	 SHORT $LN2@P_rot
$LN1@P_rot:

; 1755 :     t = S0;

  04bc0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04bc6	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  04bc9	89 55 f8	 mov	 DWORD PTR _t$[ebp], edx
  04bcc	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  04bcf	89 45 fc	 mov	 DWORD PTR _t$[ebp+4], eax

; 1756 :     S0 = S2;

  04bd2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04bd8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04bde	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  04be1	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  04be4	8b 52 ec	 mov	 edx, DWORD PTR [edx-20]
  04be7	89 51 fc	 mov	 DWORD PTR [ecx-4], edx

; 1757 :     S2 = S1;

  04bea	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04bef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04bf5	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  04bf8	89 50 e8	 mov	 DWORD PTR [eax-24], edx
  04bfb	8b 49 f4	 mov	 ecx, DWORD PTR [ecx-12]
  04bfe	89 48 ec	 mov	 DWORD PTR [eax-20], ecx

; 1758 :     S1 = t;

  04c01	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04c07	8b 45 f8	 mov	 eax, DWORD PTR _t$[ebp]
  04c0a	89 42 f0	 mov	 DWORD PTR [edx-16], eax
  04c0d	8b 4d fc	 mov	 ecx, DWORD PTR _t$[ebp+4]
  04c10	89 4a f4	 mov	 DWORD PTR [edx-12], ecx
$LN2@P_rot:

; 1759 : }

  04c13	8b e5		 mov	 esp, ebp
  04c15	5d		 pop	 ebp
  04c16	c3		 ret	 0
_P_rot	ENDP
; Function compile flags: /Odtp
_t$ = -8						; size = 8
_P_minusrot PROC

; 1762 : {

  04c20	55		 push	 ebp
  04c21	8b ec		 mov	 ebp, esp
  04c23	83 ec 08	 sub	 esp, 8

; 1763 :     stackitem t;
; 1764 : 
; 1765 :     Sl(3);

  04c26	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04c2b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  04c31	c1 f8 03	 sar	 eax, 3
  04c34	83 f8 03	 cmp	 eax, 3
  04c37	7d 07		 jge	 SHORT $LN1@P_minusrot
  04c39	e8 00 00 00 00	 call	 _stakunder
  04c3e	eb 53		 jmp	 SHORT $LN2@P_minusrot
$LN1@P_minusrot:

; 1766 :     t = S0;

  04c40	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04c46	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  04c49	89 55 f8	 mov	 DWORD PTR _t$[ebp], edx
  04c4c	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  04c4f	89 45 fc	 mov	 DWORD PTR _t$[ebp+4], eax

; 1767 :     S0 = S1;

  04c52	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04c58	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04c5e	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  04c61	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  04c64	8b 52 f4	 mov	 edx, DWORD PTR [edx-12]
  04c67	89 51 fc	 mov	 DWORD PTR [ecx-4], edx

; 1768 :     S1 = S2;

  04c6a	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04c6f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04c75	8b 51 e8	 mov	 edx, DWORD PTR [ecx-24]
  04c78	89 50 f0	 mov	 DWORD PTR [eax-16], edx
  04c7b	8b 49 ec	 mov	 ecx, DWORD PTR [ecx-20]
  04c7e	89 48 f4	 mov	 DWORD PTR [eax-12], ecx

; 1769 :     S2 = t;

  04c81	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04c87	8b 45 f8	 mov	 eax, DWORD PTR _t$[ebp]
  04c8a	89 42 e8	 mov	 DWORD PTR [edx-24], eax
  04c8d	8b 4d fc	 mov	 ecx, DWORD PTR _t$[ebp+4]
  04c90	89 4a ec	 mov	 DWORD PTR [edx-20], ecx
$LN2@P_minusrot:

; 1770 : }

  04c93	8b e5		 mov	 esp, ebp
  04c95	5d		 pop	 ebp
  04c96	c3		 ret	 0
_P_minusrot ENDP
; Function compile flags: /Odtp
tv144 = -40						; size = 8
tv141 = -32						; size = 8
_j$ = -24						; size = 8
_t$ = -16						; size = 8
_i$ = -8						; size = 8
_P_roll	PROC

; 1773 : {

  04ca0	55		 push	 ebp
  04ca1	8b ec		 mov	 ebp, esp
  04ca3	83 ec 28	 sub	 esp, 40			; 00000028H
  04ca6	56		 push	 esi
  04ca7	57		 push	 edi

; 1774 :     stackitem i, j, t;
; 1775 : 
; 1776 :     Sl(1);

  04ca8	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04cad	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  04cb3	c1 f8 03	 sar	 eax, 3
  04cb6	83 f8 01	 cmp	 eax, 1
  04cb9	7d 0a		 jge	 SHORT $LN5@P_roll
  04cbb	e8 00 00 00 00	 call	 _stakunder
  04cc0	e9 27 01 00 00	 jmp	 $LN6@P_roll
$LN5@P_roll:

; 1777 :     i = S0;

  04cc5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04ccb	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  04cce	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
  04cd1	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  04cd4	89 45 fc	 mov	 DWORD PTR _i$[ebp+4], eax

; 1778 :     Pop;

  04cd7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04cdd	83 e9 08	 sub	 ecx, 8
  04ce0	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx

; 1779 :     Sl(i + 1);

  04ce6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04ceb	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  04cf1	c1 f8 03	 sar	 eax, 3
  04cf4	99		 cdq
  04cf5	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  04cf8	83 c1 01	 add	 ecx, 1
  04cfb	8b 75 fc	 mov	 esi, DWORD PTR _i$[ebp+4]
  04cfe	83 d6 00	 adc	 esi, 0
  04d01	89 45 e0	 mov	 DWORD PTR tv141[ebp], eax
  04d04	89 55 e4	 mov	 DWORD PTR tv141[ebp+4], edx
  04d07	89 4d d8	 mov	 DWORD PTR tv144[ebp], ecx
  04d0a	89 75 dc	 mov	 DWORD PTR tv144[ebp+4], esi
  04d0d	8b 55 e4	 mov	 edx, DWORD PTR tv141[ebp+4]
  04d10	3b 55 dc	 cmp	 edx, DWORD PTR tv144[ebp+4]
  04d13	7f 14		 jg	 SHORT $LN4@P_roll
  04d15	7c 08		 jl	 SHORT $LN8@P_roll
  04d17	8b 45 e0	 mov	 eax, DWORD PTR tv141[ebp]
  04d1a	3b 45 d8	 cmp	 eax, DWORD PTR tv144[ebp]
  04d1d	73 0a		 jae	 SHORT $LN4@P_roll
$LN8@P_roll:
  04d1f	e8 00 00 00 00	 call	 _stakunder
  04d24	e9 c3 00 00 00	 jmp	 $LN6@P_roll
$LN4@P_roll:

; 1780 :     t = stk[-(i + 1)];

  04d29	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  04d2c	83 c1 01	 add	 ecx, 1
  04d2f	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp+4]
  04d32	83 d2 00	 adc	 edx, 0
  04d35	f7 d9		 neg	 ecx
  04d37	83 d2 00	 adc	 edx, 0
  04d3a	f7 da		 neg	 edx
  04d3c	6a 00		 push	 0
  04d3e	6a 08		 push	 8
  04d40	52		 push	 edx
  04d41	51		 push	 ecx
  04d42	e8 00 00 00 00	 call	 __allmul
  04d47	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04d4d	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  04d50	89 55 f0	 mov	 DWORD PTR _t$[ebp], edx
  04d53	8b 44 01 04	 mov	 eax, DWORD PTR [ecx+eax+4]
  04d57	89 45 f4	 mov	 DWORD PTR _t$[ebp+4], eax

; 1781 :     for (j = -(i + 1); j < -1; j++)

  04d5a	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  04d5d	83 c1 01	 add	 ecx, 1
  04d60	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp+4]
  04d63	83 d2 00	 adc	 edx, 0
  04d66	f7 d9		 neg	 ecx
  04d68	83 d2 00	 adc	 edx, 0
  04d6b	f7 da		 neg	 edx
  04d6d	89 4d e8	 mov	 DWORD PTR _j$[ebp], ecx
  04d70	89 55 ec	 mov	 DWORD PTR _j$[ebp+4], edx
  04d73	eb 12		 jmp	 SHORT $LN3@P_roll
$LN2@P_roll:
  04d75	8b 45 e8	 mov	 eax, DWORD PTR _j$[ebp]
  04d78	83 c0 01	 add	 eax, 1
  04d7b	8b 4d ec	 mov	 ecx, DWORD PTR _j$[ebp+4]
  04d7e	83 d1 00	 adc	 ecx, 0
  04d81	89 45 e8	 mov	 DWORD PTR _j$[ebp], eax
  04d84	89 4d ec	 mov	 DWORD PTR _j$[ebp+4], ecx
$LN3@P_roll:
  04d87	83 7d ec ff	 cmp	 DWORD PTR _j$[ebp+4], -1
  04d8b	7f 4e		 jg	 SHORT $LN1@P_roll
  04d8d	7c 06		 jl	 SHORT $LN9@P_roll
  04d8f	83 7d e8 ff	 cmp	 DWORD PTR _j$[ebp], -1
  04d93	73 46		 jae	 SHORT $LN1@P_roll
$LN9@P_roll:

; 1782 : 	stk[j] = stk[j + 1];

  04d95	8b 55 e8	 mov	 edx, DWORD PTR _j$[ebp]
  04d98	83 c2 01	 add	 edx, 1
  04d9b	8b 45 ec	 mov	 eax, DWORD PTR _j$[ebp+4]
  04d9e	83 d0 00	 adc	 eax, 0
  04da1	6a 00		 push	 0
  04da3	6a 08		 push	 8
  04da5	50		 push	 eax
  04da6	52		 push	 edx
  04da7	e8 00 00 00 00	 call	 __allmul
  04dac	8b f0		 mov	 esi, eax
  04dae	6a 00		 push	 0
  04db0	6a 08		 push	 8
  04db2	8b 4d ec	 mov	 ecx, DWORD PTR _j$[ebp+4]
  04db5	51		 push	 ecx
  04db6	8b 55 e8	 mov	 edx, DWORD PTR _j$[ebp]
  04db9	52		 push	 edx
  04dba	e8 00 00 00 00	 call	 __allmul
  04dbf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04dc5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04dcb	8b 3c 32	 mov	 edi, DWORD PTR [edx+esi]
  04dce	89 3c 01	 mov	 DWORD PTR [ecx+eax], edi
  04dd1	8b 54 32 04	 mov	 edx, DWORD PTR [edx+esi+4]
  04dd5	89 54 01 04	 mov	 DWORD PTR [ecx+eax+4], edx
  04dd9	eb 9a		 jmp	 SHORT $LN2@P_roll
$LN1@P_roll:

; 1783 :     S0 = t;

  04ddb	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04de0	8b 4d f0	 mov	 ecx, DWORD PTR _t$[ebp]
  04de3	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  04de6	8b 55 f4	 mov	 edx, DWORD PTR _t$[ebp+4]
  04de9	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN6@P_roll:

; 1784 : }

  04dec	5f		 pop	 edi
  04ded	5e		 pop	 esi
  04dee	8b e5		 mov	 esp, ebp
  04df0	5d		 pop	 ebp
  04df1	c3		 ret	 0
_P_roll	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_rstacktop DD	01H DUP (?)
_rstk	DD	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
_P_tor	PROC

; 1787 : {

  04e00	55		 push	 ebp
  04e01	8b ec		 mov	 ebp, esp

; 1788 :     Rso(1);

  04e03	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  04e08	83 c0 04	 add	 eax, 4
  04e0b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _rstacktop
  04e11	76 07		 jbe	 SHORT $LN2@P_tor@2
  04e13	e8 00 00 00 00	 call	 _rstakover
  04e18	eb 48		 jmp	 SHORT $LN3@P_tor@2
$LN2@P_tor@2:

; 1789 :     Sl(1);

  04e1a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04e20	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _stack
  04e26	c1 f9 03	 sar	 ecx, 3
  04e29	83 f9 01	 cmp	 ecx, 1
  04e2c	7d 07		 jge	 SHORT $LN1@P_tor@2
  04e2e	e8 00 00 00 00	 call	 _stakunder
  04e33	eb 2d		 jmp	 SHORT $LN3@P_tor@2
$LN1@P_tor@2:

; 1790 :     Rpush = (rstackitem) S0;

  04e35	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04e3b	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  04e3e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  04e44	89 01		 mov	 DWORD PTR [ecx], eax
  04e46	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  04e4c	83 c2 04	 add	 edx, 4
  04e4f	89 15 00 00 00
	00		 mov	 DWORD PTR _rstk, edx

; 1791 :     Pop;

  04e55	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04e5a	83 e8 08	 sub	 eax, 8
  04e5d	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN3@P_tor@2:

; 1792 : }

  04e62	5d		 pop	 ebp
  04e63	c3		 ret	 0
_P_tor	ENDP
; Function compile flags: /Odtp
_P_rfrom PROC

; 1795 : {

  04e70	55		 push	 ebp
  04e71	8b ec		 mov	 ebp, esp

; 1796 :     Rsl(1);

  04e73	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  04e78	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _rstack
  04e7e	c1 f8 02	 sar	 eax, 2
  04e81	83 f8 01	 cmp	 eax, 1
  04e84	7d 07		 jge	 SHORT $LN2@P_rfrom
  04e86	e8 00 00 00 00	 call	 _rstakunder
  04e8b	eb 49		 jmp	 SHORT $LN3@P_rfrom
$LN2@P_rfrom:

; 1797 :     So(1);

  04e8d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04e93	83 c1 08	 add	 ecx, 8
  04e96	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _stacktop
  04e9c	76 07		 jbe	 SHORT $LN1@P_rfrom
  04e9e	e8 00 00 00 00	 call	 _stakover
  04ea3	eb 31		 jmp	 SHORT $LN3@P_rfrom
$LN1@P_rfrom:

; 1798 :     Push = (stackitem) R0;

  04ea5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  04eab	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  04eae	99		 cdq
  04eaf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04eb5	89 01		 mov	 DWORD PTR [ecx], eax
  04eb7	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  04eba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04ec0	83 c2 08	 add	 edx, 8
  04ec3	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 1799 :     Rpop;

  04ec9	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  04ece	83 e8 04	 sub	 eax, 4
  04ed1	a3 00 00 00 00	 mov	 DWORD PTR _rstk, eax
$LN3@P_rfrom:

; 1800 : }

  04ed6	5d		 pop	 ebp
  04ed7	c3		 ret	 0
_P_rfrom ENDP
; Function compile flags: /Odtp
_P_rfetch PROC

; 1803 : {

  04ee0	55		 push	 ebp
  04ee1	8b ec		 mov	 ebp, esp

; 1804 :     Rsl(1);

  04ee3	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  04ee8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _rstack
  04eee	c1 f8 02	 sar	 eax, 2
  04ef1	83 f8 01	 cmp	 eax, 1
  04ef4	7d 07		 jge	 SHORT $LN2@P_rfetch
  04ef6	e8 00 00 00 00	 call	 _rstakunder
  04efb	eb 3c		 jmp	 SHORT $LN3@P_rfetch
$LN2@P_rfetch:

; 1805 :     So(1);

  04efd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04f03	83 c1 08	 add	 ecx, 8
  04f06	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _stacktop
  04f0c	76 07		 jbe	 SHORT $LN1@P_rfetch
  04f0e	e8 00 00 00 00	 call	 _stakover
  04f13	eb 24		 jmp	 SHORT $LN3@P_rfetch
$LN1@P_rfetch:

; 1806 :     Push = (stackitem) R0;

  04f15	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  04f1b	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  04f1e	99		 cdq
  04f1f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04f25	89 01		 mov	 DWORD PTR [ecx], eax
  04f27	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  04f2a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04f30	83 c2 08	 add	 edx, 8
  04f33	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN3@P_rfetch:

; 1807 : }

  04f39	5d		 pop	 ebp
  04f3a	c3		 ret	 0
_P_rfetch ENDP
; Function compile flags: /Odtp
_s$ = -8						; size = 8
_P_2dup	PROC

; 1814 : {

  04f40	55		 push	 ebp
  04f41	8b ec		 mov	 ebp, esp
  04f43	83 ec 08	 sub	 esp, 8

; 1815 :     stackitem s;
; 1816 : 
; 1817 :     Sl(2);

  04f46	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04f4b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  04f51	c1 f8 03	 sar	 eax, 3
  04f54	83 f8 02	 cmp	 eax, 2
  04f57	7d 07		 jge	 SHORT $LN2@P_2dup
  04f59	e8 00 00 00 00	 call	 _stakunder
  04f5e	eb 78		 jmp	 SHORT $LN3@P_2dup
$LN2@P_2dup:

; 1818 :     So(2);

  04f60	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  04f66	83 c1 10	 add	 ecx, 16			; 00000010H
  04f69	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _stacktop
  04f6f	76 07		 jbe	 SHORT $LN1@P_2dup
  04f71	e8 00 00 00 00	 call	 _stakover
  04f76	eb 60		 jmp	 SHORT $LN3@P_2dup
$LN1@P_2dup:

; 1819 :     s = S1;

  04f78	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04f7e	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  04f81	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  04f84	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  04f87	89 4d fc	 mov	 DWORD PTR _s$[ebp+4], ecx

; 1820 :     Push = s;

  04f8a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04f90	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  04f93	89 02		 mov	 DWORD PTR [edx], eax
  04f95	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp+4]
  04f98	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  04f9b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  04fa1	83 c2 08	 add	 edx, 8
  04fa4	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 1821 :     s = S1;

  04faa	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04faf	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  04fb2	89 4d f8	 mov	 DWORD PTR _s$[ebp], ecx
  04fb5	8b 50 f4	 mov	 edx, DWORD PTR [eax-12]
  04fb8	89 55 fc	 mov	 DWORD PTR _s$[ebp+4], edx

; 1822 :     Push = s;

  04fbb	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04fc0	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  04fc3	89 08		 mov	 DWORD PTR [eax], ecx
  04fc5	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp+4]
  04fc8	89 50 04	 mov	 DWORD PTR [eax+4], edx
  04fcb	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04fd0	83 c0 08	 add	 eax, 8
  04fd3	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN3@P_2dup:

; 1823 : }

  04fd8	8b e5		 mov	 esp, ebp
  04fda	5d		 pop	 ebp
  04fdb	c3		 ret	 0
_P_2dup	ENDP
; Function compile flags: /Odtp
_P_2drop PROC

; 1826 : {

  04fe0	55		 push	 ebp
  04fe1	8b ec		 mov	 ebp, esp

; 1827 :     Sl(2);

  04fe3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  04fe8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  04fee	c1 f8 03	 sar	 eax, 3
  04ff1	83 f8 02	 cmp	 eax, 2
  04ff4	7d 07		 jge	 SHORT $LN1@P_2drop
  04ff6	e8 00 00 00 00	 call	 _stakunder
  04ffb	eb 0f		 jmp	 SHORT $LN2@P_2drop
$LN1@P_2drop:

; 1828 :     stk -= 2;

  04ffd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  05003	83 e9 10	 sub	 ecx, 16			; 00000010H
  05006	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN2@P_2drop:

; 1829 : }

  0500c	5d		 pop	 ebp
  0500d	c3		 ret	 0
_P_2drop ENDP
; Function compile flags: /Odtp
_t$ = -8						; size = 8
_P_2swap PROC

; 1832 : {

  05010	55		 push	 ebp
  05011	8b ec		 mov	 ebp, esp
  05013	83 ec 08	 sub	 esp, 8

; 1833 :     stackitem t;
; 1834 : 
; 1835 :     Sl(4);

  05016	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0501b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  05021	c1 f8 03	 sar	 eax, 3
  05024	83 f8 04	 cmp	 eax, 4
  05027	7d 07		 jge	 SHORT $LN1@P_2swap
  05029	e8 00 00 00 00	 call	 _stakunder
  0502e	eb 75		 jmp	 SHORT $LN2@P_2swap
$LN1@P_2swap:

; 1836 :     t = S2;

  05030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  05036	8b 51 e8	 mov	 edx, DWORD PTR [ecx-24]
  05039	89 55 f8	 mov	 DWORD PTR _t$[ebp], edx
  0503c	8b 41 ec	 mov	 eax, DWORD PTR [ecx-20]
  0503f	89 45 fc	 mov	 DWORD PTR _t$[ebp+4], eax

; 1837 :     S2 = S0;

  05042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  05048	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0504e	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  05051	89 41 e8	 mov	 DWORD PTR [ecx-24], eax
  05054	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  05057	89 51 ec	 mov	 DWORD PTR [ecx-20], edx

; 1838 :     S0 = t;

  0505a	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0505f	8b 4d f8	 mov	 ecx, DWORD PTR _t$[ebp]
  05062	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  05065	8b 55 fc	 mov	 edx, DWORD PTR _t$[ebp+4]
  05068	89 50 fc	 mov	 DWORD PTR [eax-4], edx

; 1839 :     t = S3;

  0506b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  05070	8b 48 e0	 mov	 ecx, DWORD PTR [eax-32]
  05073	89 4d f8	 mov	 DWORD PTR _t$[ebp], ecx
  05076	8b 50 e4	 mov	 edx, DWORD PTR [eax-28]
  05079	89 55 fc	 mov	 DWORD PTR _t$[ebp+4], edx

; 1840 :     S3 = S1;

  0507c	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  05081	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  05087	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  0508a	89 50 e0	 mov	 DWORD PTR [eax-32], edx
  0508d	8b 49 f4	 mov	 ecx, DWORD PTR [ecx-12]
  05090	89 48 e4	 mov	 DWORD PTR [eax-28], ecx

; 1841 :     S1 = t;

  05093	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  05099	8b 45 f8	 mov	 eax, DWORD PTR _t$[ebp]
  0509c	89 42 f0	 mov	 DWORD PTR [edx-16], eax
  0509f	8b 4d fc	 mov	 ecx, DWORD PTR _t$[ebp+4]
  050a2	89 4a f4	 mov	 DWORD PTR [edx-12], ecx
$LN2@P_2swap:

; 1842 : }

  050a5	8b e5		 mov	 esp, ebp
  050a7	5d		 pop	 ebp
  050a8	c3		 ret	 0
_P_2swap ENDP
; Function compile flags: /Odtp
_s$ = -8						; size = 8
_P_2over PROC

; 1845 : {

  050b0	55		 push	 ebp
  050b1	8b ec		 mov	 ebp, esp
  050b3	83 ec 08	 sub	 esp, 8

; 1846 :     stackitem s;
; 1847 : 
; 1848 :     Sl(4);

  050b6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  050bb	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  050c1	c1 f8 03	 sar	 eax, 3
  050c4	83 f8 04	 cmp	 eax, 4
  050c7	7d 07		 jge	 SHORT $LN2@P_2over
  050c9	e8 00 00 00 00	 call	 _stakunder
  050ce	eb 78		 jmp	 SHORT $LN3@P_2over
$LN2@P_2over:

; 1849 :     So(2);

  050d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  050d6	83 c1 10	 add	 ecx, 16			; 00000010H
  050d9	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _stacktop
  050df	76 07		 jbe	 SHORT $LN1@P_2over
  050e1	e8 00 00 00 00	 call	 _stakover
  050e6	eb 60		 jmp	 SHORT $LN3@P_2over
$LN1@P_2over:

; 1850 :     s = S3;

  050e8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  050ee	8b 42 e0	 mov	 eax, DWORD PTR [edx-32]
  050f1	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  050f4	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  050f7	89 4d fc	 mov	 DWORD PTR _s$[ebp+4], ecx

; 1851 :     Push = s;

  050fa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  05100	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  05103	89 02		 mov	 DWORD PTR [edx], eax
  05105	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp+4]
  05108	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0510b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  05111	83 c2 08	 add	 edx, 8
  05114	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 1852 :     s = S3;

  0511a	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0511f	8b 48 e0	 mov	 ecx, DWORD PTR [eax-32]
  05122	89 4d f8	 mov	 DWORD PTR _s$[ebp], ecx
  05125	8b 50 e4	 mov	 edx, DWORD PTR [eax-28]
  05128	89 55 fc	 mov	 DWORD PTR _s$[ebp+4], edx

; 1853 :     Push = s;

  0512b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  05130	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  05133	89 08		 mov	 DWORD PTR [eax], ecx
  05135	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp+4]
  05138	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0513b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  05140	83 c0 08	 add	 eax, 8
  05143	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN3@P_2over:

; 1854 : }

  05148	8b e5		 mov	 esp, ebp
  0514a	5d		 pop	 ebp
  0514b	c3		 ret	 0
_P_2over ENDP
; Function compile flags: /Odtp
_t1$ = -16						; size = 8
_t2$ = -8						; size = 8
_P_2rot	PROC

; 1857 : {

  05150	55		 push	 ebp
  05151	8b ec		 mov	 ebp, esp
  05153	83 ec 10	 sub	 esp, 16			; 00000010H

; 1858 :     stackitem t1, t2;
; 1859 : 
; 1860 :     Sl(6);

  05156	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0515b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  05161	c1 f8 03	 sar	 eax, 3
  05164	83 f8 06	 cmp	 eax, 6
  05167	7d 0a		 jge	 SHORT $LN1@P_2rot
  05169	e8 00 00 00 00	 call	 _stakunder
  0516e	e9 a4 00 00 00	 jmp	 $LN2@P_2rot
$LN1@P_2rot:

; 1861 :     t2 = S5;

  05173	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  05179	8b 51 d0	 mov	 edx, DWORD PTR [ecx-48]
  0517c	89 55 f8	 mov	 DWORD PTR _t2$[ebp], edx
  0517f	8b 41 d4	 mov	 eax, DWORD PTR [ecx-44]
  05182	89 45 fc	 mov	 DWORD PTR _t2$[ebp+4], eax

; 1862 :     t1 = S4;

  05185	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0518b	8b 51 d8	 mov	 edx, DWORD PTR [ecx-40]
  0518e	89 55 f0	 mov	 DWORD PTR _t1$[ebp], edx
  05191	8b 41 dc	 mov	 eax, DWORD PTR [ecx-36]
  05194	89 45 f4	 mov	 DWORD PTR _t1$[ebp+4], eax

; 1863 :     S5 = S3;

  05197	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0519d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  051a3	8b 42 e0	 mov	 eax, DWORD PTR [edx-32]
  051a6	89 41 d0	 mov	 DWORD PTR [ecx-48], eax
  051a9	8b 52 e4	 mov	 edx, DWORD PTR [edx-28]
  051ac	89 51 d4	 mov	 DWORD PTR [ecx-44], edx

; 1864 :     S4 = S2;

  051af	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  051b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  051ba	8b 51 e8	 mov	 edx, DWORD PTR [ecx-24]
  051bd	89 50 d8	 mov	 DWORD PTR [eax-40], edx
  051c0	8b 49 ec	 mov	 ecx, DWORD PTR [ecx-20]
  051c3	89 48 dc	 mov	 DWORD PTR [eax-36], ecx

; 1865 :     S3 = S1;

  051c6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  051cc	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  051d1	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  051d4	89 4a e0	 mov	 DWORD PTR [edx-32], ecx
  051d7	8b 40 f4	 mov	 eax, DWORD PTR [eax-12]
  051da	89 42 e4	 mov	 DWORD PTR [edx-28], eax

; 1866 :     S2 = S0;

  051dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  051e3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  051e9	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  051ec	89 41 e8	 mov	 DWORD PTR [ecx-24], eax
  051ef	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  051f2	89 51 ec	 mov	 DWORD PTR [ecx-20], edx

; 1867 :     S1 = t2;

  051f5	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  051fa	8b 4d f8	 mov	 ecx, DWORD PTR _t2$[ebp]
  051fd	89 48 f0	 mov	 DWORD PTR [eax-16], ecx
  05200	8b 55 fc	 mov	 edx, DWORD PTR _t2$[ebp+4]
  05203	89 50 f4	 mov	 DWORD PTR [eax-12], edx

; 1868 :     S0 = t1;

  05206	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0520b	8b 4d f0	 mov	 ecx, DWORD PTR _t1$[ebp]
  0520e	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  05211	8b 55 f4	 mov	 edx, DWORD PTR _t1$[ebp+4]
  05214	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_2rot:

; 1869 : }

  05217	8b e5		 mov	 esp, ebp
  05219	5d		 pop	 ebp
  0521a	c3		 ret	 0
_P_2rot	ENDP
; Function compile flags: /Odtp
_P_2variable PROC

; 1872 : {

  05220	55		 push	 ebp
  05221	8b ec		 mov	 ebp, esp

; 1873 :     P_create(); 		      /* Create dictionary item */

  05223	e8 00 00 00 00	 call	 _P_create

; 1874 :     Ho(2);

  05228	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0522d	83 c0 10	 add	 eax, 16			; 00000010H
  05230	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  05236	76 07		 jbe	 SHORT $LN1@P_2variabl
  05238	e8 00 00 00 00	 call	 _heapover
  0523d	eb 43		 jmp	 SHORT $LN2@P_2variabl
$LN1@P_2variabl:

; 1875 :     Hstore = 0; 		      /* Initial value = 0... */

  0523f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  05245	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0524b	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  05252	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  05258	83 c2 08	 add	 edx, 8
  0525b	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 1876 :     Hstore = 0; 		      /* ...in both words */

  05261	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  05266	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0526c	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  05273	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  05279	83 c1 08	 add	 ecx, 8
  0527c	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx
$LN2@P_2variabl:

; 1877 : }

  05282	5d		 pop	 ebp
  05283	c3		 ret	 0
_P_2variable ENDP
; Function compile flags: /Odtp
_P_2constant PROC

; 1887 : {

  05290	55		 push	 ebp
  05291	8b ec		 mov	 ebp, esp

; 1888 :     Sl(1);

  05293	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  05298	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0529e	c1 f8 03	 sar	 eax, 3
  052a1	83 f8 01	 cmp	 eax, 1
  052a4	7d 0a		 jge	 SHORT $LN2@P_2constan
  052a6	e8 00 00 00 00	 call	 _stakunder
  052ab	e9 81 00 00 00	 jmp	 $LN3@P_2constan
$LN2@P_2constan:

; 1889 :     P_create(); 		      /* Create dictionary item */

  052b0	e8 00 00 00 00	 call	 _P_create

; 1890 :     createword->wcode = P_2con;       /* Set code to constant push */

  052b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _createword
  052bb	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], OFFSET _P_2con

; 1891 :     Ho(2);

  052c2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  052c8	83 c2 10	 add	 edx, 16			; 00000010H
  052cb	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  052d1	76 07		 jbe	 SHORT $LN1@P_2constan
  052d3	e8 00 00 00 00	 call	 _heapover
  052d8	eb 57		 jmp	 SHORT $LN3@P_2constan
$LN1@P_2constan:

; 1892 :     Hstore = S1;		      /* Store double word constant value */

  052da	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  052df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  052e5	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  052e8	89 10		 mov	 DWORD PTR [eax], edx
  052ea	8b 49 f4	 mov	 ecx, DWORD PTR [ecx-12]
  052ed	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  052f0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  052f6	83 c2 08	 add	 edx, 8
  052f9	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 1893 :     Hstore = S0;		      /* in the two words of body */

  052ff	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  05304	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0530a	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  0530d	89 10		 mov	 DWORD PTR [eax], edx
  0530f	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  05312	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  05315	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  0531b	83 c2 08	 add	 edx, 8
  0531e	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 1894 :     Pop2;

  05324	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  05329	83 e8 10	 sub	 eax, 16			; 00000010H
  0532c	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN3@P_2constan:

; 1895 : }

  05331	5d		 pop	 ebp
  05332	c3		 ret	 0
_P_2constant ENDP
; Function compile flags: /Odtp
_P_2con PROC

; 1880 : {

  05340	55		 push	 ebp
  05341	8b ec		 mov	 ebp, esp

; 1881 :     So(2);

  05343	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  05348	83 c0 10	 add	 eax, 16			; 00000010H
  0534b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  05351	76 07		 jbe	 SHORT $LN1@P_2con
  05353	e8 00 00 00 00	 call	 _stakover
  05358	eb 48		 jmp	 SHORT $LN2@P_2con
$LN1@P_2con:

; 1882 :     Push = *(((stackitem *) curword) + Dictwordl);

  0535a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  05360	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _curword
  05366	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  05369	89 01		 mov	 DWORD PTR [ecx], eax
  0536b	8b 52 14	 mov	 edx, DWORD PTR [edx+20]
  0536e	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  05371	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  05376	83 c0 08	 add	 eax, 8
  05379	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 1883 :     Push = *(((stackitem *) curword) + Dictwordl + 1);

  0537e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  05384	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _curword
  0538a	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0538d	89 01		 mov	 DWORD PTR [ecx], eax
  0538f	8b 52 1c	 mov	 edx, DWORD PTR [edx+28]
  05392	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  05395	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0539a	83 c0 08	 add	 eax, 8
  0539d	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN2@P_2con:

; 1884 : }

  053a2	5d		 pop	 ebp
  053a3	c3		 ret	 0
_P_2con	ENDP
; Function compile flags: /Odtp
_sp$ = -4						; size = 4
_P_2bang PROC

; 1898 : {

  053b0	55		 push	 ebp
  053b1	8b ec		 mov	 ebp, esp
  053b3	51		 push	 ecx

; 1899 :     stackitem *sp;
; 1900 : 
; 1901 :     Sl(2);

  053b4	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  053b9	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  053bf	c1 f8 03	 sar	 eax, 3
  053c2	83 f8 02	 cmp	 eax, 2
  053c5	7d 07		 jge	 SHORT $LN3@P_2bang
  053c7	e8 00 00 00 00	 call	 _stakunder
  053cc	eb 72		 jmp	 SHORT $LN4@P_2bang
$LN3@P_2bang:

; 1902 :     Hpc(S0);

  053ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  053d4	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  053d7	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  053dd	72 10		 jb	 SHORT $LN1@P_2bang
  053df	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  053e4	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  053e7	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  053ed	72 07		 jb	 SHORT $LN2@P_2bang
$LN1@P_2bang:
  053ef	e8 00 00 00 00	 call	 _badpointer
  053f4	eb 4a		 jmp	 SHORT $LN4@P_2bang
$LN2@P_2bang:

; 1903 :     sp = (stackitem *) S0;

  053f6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  053fc	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  053ff	89 45 fc	 mov	 DWORD PTR _sp$[ebp], eax

; 1904 :     *sp++ = S2;

  05402	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  05405	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0540b	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  0540e	89 01		 mov	 DWORD PTR [ecx], eax
  05410	8b 52 ec	 mov	 edx, DWORD PTR [edx-20]
  05413	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  05416	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  05419	83 c0 08	 add	 eax, 8
  0541c	89 45 fc	 mov	 DWORD PTR _sp$[ebp], eax

; 1905 :     *sp = S1;

  0541f	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  05422	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  05428	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  0542b	89 01		 mov	 DWORD PTR [ecx], eax
  0542d	8b 52 f4	 mov	 edx, DWORD PTR [edx-12]
  05430	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 1906 :     Npop(3);

  05433	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  05438	83 e8 18	 sub	 eax, 24			; 00000018H
  0543b	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN4@P_2bang:

; 1907 : }

  05440	8b e5		 mov	 esp, ebp
  05442	5d		 pop	 ebp
  05443	c3		 ret	 0
_P_2bang ENDP
; Function compile flags: /Odtp
_sp$ = -4						; size = 4
_P_2at	PROC

; 1910 : {

  05450	55		 push	 ebp
  05451	8b ec		 mov	 ebp, esp
  05453	51		 push	 ecx

; 1911 :     stackitem *sp;
; 1912 : 
; 1913 :     Sl(1);

  05454	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  05459	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0545f	c1 f8 03	 sar	 eax, 3
  05462	83 f8 01	 cmp	 eax, 1
  05465	7d 0a		 jge	 SHORT $LN4@P_2at
  05467	e8 00 00 00 00	 call	 _stakunder
  0546c	e9 8b 00 00 00	 jmp	 $LN5@P_2at
$LN4@P_2at:

; 1914 :     So(1);

  05471	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  05477	83 c1 08	 add	 ecx, 8
  0547a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _stacktop
  05480	76 07		 jbe	 SHORT $LN3@P_2at
  05482	e8 00 00 00 00	 call	 _stakover
  05487	eb 73		 jmp	 SHORT $LN5@P_2at
$LN3@P_2at:

; 1915 :     Hpc(S0);

  05489	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0548f	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  05492	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  05498	72 11		 jb	 SHORT $LN1@P_2at
  0549a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  054a0	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  054a3	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  054a9	72 07		 jb	 SHORT $LN2@P_2at
$LN1@P_2at:
  054ab	e8 00 00 00 00	 call	 _badpointer
  054b0	eb 4a		 jmp	 SHORT $LN5@P_2at
$LN2@P_2at:

; 1916 :     sp = (stackitem *) S0;

  054b2	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  054b7	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  054ba	89 4d fc	 mov	 DWORD PTR _sp$[ebp], ecx

; 1917 :     S0 = *sp++;

  054bd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  054c3	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  054c6	8b 08		 mov	 ecx, DWORD PTR [eax]
  054c8	89 4a f8	 mov	 DWORD PTR [edx-8], ecx
  054cb	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  054ce	89 42 fc	 mov	 DWORD PTR [edx-4], eax
  054d1	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  054d4	83 c1 08	 add	 ecx, 8
  054d7	89 4d fc	 mov	 DWORD PTR _sp$[ebp], ecx

; 1918 :     Push = *sp;

  054da	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  054e0	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  054e3	8b 08		 mov	 ecx, DWORD PTR [eax]
  054e5	89 0a		 mov	 DWORD PTR [edx], ecx
  054e7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  054ea	89 42 04	 mov	 DWORD PTR [edx+4], eax
  054ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  054f3	83 c1 08	 add	 ecx, 8
  054f6	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN5@P_2at:

; 1919 : }

  054fc	8b e5		 mov	 esp, ebp
  054fe	5d		 pop	 ebp
  054ff	c3		 ret	 0
_P_2at	ENDP
; Function compile flags: /Odtp
_P_dolit PROC

; 1925 : {

  05500	55		 push	 ebp
  05501	8b ec		 mov	 ebp, esp

; 1926 :     So(1);

  05503	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  05508	83 c0 08	 add	 eax, 8
  0550b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  05511	76 07		 jbe	 SHORT $LN2@P_dolit
  05513	e8 00 00 00 00	 call	 _stakover
  05518	eb 54		 jmp	 SHORT $LN3@P_dolit
$LN2@P_dolit:

; 1927 : #ifdef TRACE
; 1928 :     if (atl_trace) {

  0551a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl_trace
  05520	0b 0d 04 00 00
	00		 or	 ecx, DWORD PTR _atl_trace+4
  05526	74 16		 je	 SHORT $LN1@P_dolit

; 1929 :         V printf("%ld ", (long) *ip);

  05528	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ip
  0552e	8b 02		 mov	 eax, DWORD PTR [edx]
  05530	50		 push	 eax
  05531	68 00 00 00 00	 push	 OFFSET $SG84247
  05536	e8 00 00 00 00	 call	 _printf
  0553b	83 c4 08	 add	 esp, 8
$LN1@P_dolit:

; 1930 :     }
; 1931 : #endif
; 1932 :     Push = (stackitem) *ip++;	      /* Push the next datum from the

  0553e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ip
  05544	8b 01		 mov	 eax, DWORD PTR [ecx]
  05546	99		 cdq
  05547	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0554d	89 01		 mov	 DWORD PTR [ecx], eax
  0554f	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  05552	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  05558	83 c2 08	 add	 edx, 8
  0555b	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
  05561	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  05566	83 c0 04	 add	 eax, 4
  05569	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax
$LN3@P_dolit:

; 1933 : 					 instruction stream. */
; 1934 : }

  0556e	5d		 pop	 ebp
  0556f	c3		 ret	 0
_P_dolit ENDP
_TEXT	ENDS
_BSS	SEGMENT
_wbptr	DD	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
_P_nest	PROC

; 1939 : {

  05570	55		 push	 ebp
  05571	8b ec		 mov	 ebp, esp

; 1940 :     Rso(1);

  05573	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  05578	83 c0 04	 add	 eax, 4
  0557b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _rstacktop
  05581	76 07		 jbe	 SHORT $LN1@P_nest
  05583	e8 00 00 00 00	 call	 _rstakover
  05588	eb 45		 jmp	 SHORT $LN2@P_nest
$LN1@P_nest:

; 1941 : #ifdef WALKBACK
; 1942 :     *wbptr++ = curword; 	      /* Place word on walkback stack */

  0558a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _wbptr
  05590	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _curword
  05596	89 11		 mov	 DWORD PTR [ecx], edx
  05598	a1 00 00 00 00	 mov	 eax, DWORD PTR _wbptr
  0559d	83 c0 04	 add	 eax, 4
  055a0	a3 00 00 00 00	 mov	 DWORD PTR _wbptr, eax

; 1943 : #endif
; 1944 :     Rpush = ip; 		      /* Push instruction pointer */

  055a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  055ab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ip
  055b1	89 11		 mov	 DWORD PTR [ecx], edx
  055b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  055b8	83 c0 04	 add	 eax, 4
  055bb	a3 00 00 00 00	 mov	 DWORD PTR _rstk, eax

; 1945 :     ip = (((dictword **) curword) + Dictwordl);

  055c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _curword
  055c6	83 c1 08	 add	 ecx, 8
  055c9	89 0d 00 00 00
	00		 mov	 DWORD PTR _ip, ecx
$LN2@P_nest:

; 1946 : }

  055cf	5d		 pop	 ebp
  055d0	c3		 ret	 0
_P_nest	ENDP
; Function compile flags: /Odtp
tv69 = -4						; size = 4
_P_exit	PROC

; 1949 : {

  055e0	55		 push	 ebp
  055e1	8b ec		 mov	 ebp, esp
  055e3	51		 push	 ecx

; 1950 :     Rsl(1);

  055e4	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  055e9	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _rstack
  055ef	c1 f8 02	 sar	 eax, 2
  055f2	83 f8 01	 cmp	 eax, 1
  055f5	7d 07		 jge	 SHORT $LN1@P_exit
  055f7	e8 00 00 00 00	 call	 _rstakunder
  055fc	eb 4a		 jmp	 SHORT $LN2@P_exit
$LN1@P_exit:

; 1951 : #ifdef WALKBACK
; 1952 :     wbptr = (wbptr > wback) ? wbptr - 1 : wback;

  055fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _wbptr
  05604	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _wback
  0560a	76 0e		 jbe	 SHORT $LN4@P_exit
  0560c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _wbptr
  05612	83 ea 04	 sub	 edx, 4
  05615	89 55 fc	 mov	 DWORD PTR tv69[ebp], edx
  05618	eb 08		 jmp	 SHORT $LN5@P_exit
$LN4@P_exit:
  0561a	a1 00 00 00 00	 mov	 eax, DWORD PTR _wback
  0561f	89 45 fc	 mov	 DWORD PTR tv69[ebp], eax
$LN5@P_exit:
  05622	8b 4d fc	 mov	 ecx, DWORD PTR tv69[ebp]
  05625	89 0d 00 00 00
	00		 mov	 DWORD PTR _wbptr, ecx

; 1953 : #endif
; 1954 :     ip = R0;			      /* Set IP to top of return stack */

  0562b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  05631	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  05634	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax

; 1955 :     Rpop;

  05639	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  0563f	83 e9 04	 sub	 ecx, 4
  05642	89 0d 00 00 00
	00		 mov	 DWORD PTR _rstk, ecx
$LN2@P_exit:

; 1956 : }

  05648	8b e5		 mov	 esp, ebp
  0564a	5d		 pop	 ebp
  0564b	c3		 ret	 0
_P_exit	ENDP
; Function compile flags: /Odtp
_P_branch PROC

; 1959 : {

  05650	55		 push	 ebp
  05651	8b ec		 mov	 ebp, esp

; 1960 :     ip += (stackitem) *ip;	      /* Jump addresses are IP-relative */

  05653	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  05658	8b 00		 mov	 eax, DWORD PTR [eax]
  0565a	99		 cdq
  0565b	6a 00		 push	 0
  0565d	6a 04		 push	 4
  0565f	52		 push	 edx
  05660	50		 push	 eax
  05661	e8 00 00 00 00	 call	 __allmul
  05666	03 05 00 00 00
	00		 add	 eax, DWORD PTR _ip
  0566c	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax

; 1961 : }

  05671	5d		 pop	 ebp
  05672	c3		 ret	 0
_P_branch ENDP
; Function compile flags: /Odtp
tv77 = -4						; size = 4
_P_qbranch PROC

; 1964 : {

  05680	55		 push	 ebp
  05681	8b ec		 mov	 ebp, esp
  05683	51		 push	 ecx

; 1965 :     Sl(1);

  05684	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  05689	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0568f	c1 f8 03	 sar	 eax, 3
  05692	83 f8 01	 cmp	 eax, 1
  05695	7d 07		 jge	 SHORT $LN3@P_qbranch
  05697	e8 00 00 00 00	 call	 _stakunder
  0569c	eb 54		 jmp	 SHORT $LN4@P_qbranch
$LN3@P_qbranch:

; 1966 :     if (S0 == 0)		      /* If flag is false */

  0569e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  056a4	89 4d fc	 mov	 DWORD PTR tv77[ebp], ecx
  056a7	8b 55 fc	 mov	 edx, DWORD PTR tv77[ebp]
  056aa	8b 45 fc	 mov	 eax, DWORD PTR tv77[ebp]
  056ad	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  056b0	0b 48 fc	 or	 ecx, DWORD PTR [eax-4]
  056b3	75 21		 jne	 SHORT $LN2@P_qbranch

; 1967 : 	ip += (stackitem) *ip;	      /* then branch. */

  056b5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ip
  056bb	8b 02		 mov	 eax, DWORD PTR [edx]
  056bd	99		 cdq
  056be	6a 00		 push	 0
  056c0	6a 04		 push	 4
  056c2	52		 push	 edx
  056c3	50		 push	 eax
  056c4	e8 00 00 00 00	 call	 __allmul
  056c9	03 05 00 00 00
	00		 add	 eax, DWORD PTR _ip
  056cf	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax

; 1968 :     else			      /* Otherwise */

  056d4	eb 0d		 jmp	 SHORT $LN1@P_qbranch
$LN2@P_qbranch:

; 1969 : 	ip++;			      /* skip the in-line address. */

  056d6	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  056db	83 c0 04	 add	 eax, 4
  056de	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax
$LN1@P_qbranch:

; 1970 :     Pop;

  056e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  056e9	83 e9 08	 sub	 ecx, 8
  056ec	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN4@P_qbranch:

; 1971 : }

  056f2	8b e5		 mov	 esp, ebp
  056f4	5d		 pop	 ebp
  056f5	c3		 ret	 0
_P_qbranch ENDP
_TEXT	ENDS
_BSS	SEGMENT
	ALIGN	8

_s_qbranch DQ	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
tv76 = -4						; size = 4
_P_if	PROC

; 1974 : {

  05700	55		 push	 ebp
  05701	8b ec		 mov	 ebp, esp
  05703	51		 push	 ecx

; 1975 :     Compiling;

  05704	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  05709	89 45 fc	 mov	 DWORD PTR tv76[ebp], eax
  0570c	8b 4d fc	 mov	 ecx, DWORD PTR tv76[ebp]
  0570f	8b 55 fc	 mov	 edx, DWORD PTR tv76[ebp]
  05712	8b 01		 mov	 eax, DWORD PTR [ecx]
  05714	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  05717	75 0a		 jne	 SHORT $LN4@P_if
  05719	e8 00 00 00 00	 call	 _notcomp
  0571e	e9 b0 00 00 00	 jmp	 $LN5@P_if
$LN4@P_if:

; 1976 :     Compconst(s_qbranch);	      /* Compile question branch */

  05723	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  05729	83 c1 08	 add	 ecx, 8
  0572c	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  05732	76 0a		 jbe	 SHORT $LN3@P_if
  05734	e8 00 00 00 00	 call	 _heapover
  05739	e9 95 00 00 00	 jmp	 $LN5@P_if
$LN3@P_if:
  0573e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  05744	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_qbranch
  05749	89 02		 mov	 DWORD PTR [edx], eax
  0574b	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _s_qbranch+4
  05751	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  05754	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  0575a	83 c2 08	 add	 edx, 8
  0575d	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 1977 :     So(1);

  05763	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  05768	83 c0 08	 add	 eax, 8
  0576b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  05771	76 07		 jbe	 SHORT $LN2@P_if
  05773	e8 00 00 00 00	 call	 _stakover
  05778	eb 59		 jmp	 SHORT $LN5@P_if
$LN2@P_if:

; 1978 :     Push = (stackitem) hptr;	      /* Save backpatch address on stack */

  0577a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0577f	99		 cdq
  05780	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  05786	89 01		 mov	 DWORD PTR [ecx], eax
  05788	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0578b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  05791	83 c2 08	 add	 edx, 8
  05794	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 1979 :     Compconst(0);		      /* Compile place-holder address cell */

  0579a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0579f	83 c0 08	 add	 eax, 8
  057a2	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  057a8	76 07		 jbe	 SHORT $LN1@P_if
  057aa	e8 00 00 00 00	 call	 _heapover
  057af	eb 22		 jmp	 SHORT $LN5@P_if
$LN1@P_if:
  057b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  057b7	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  057bd	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  057c4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  057ca	83 c2 08	 add	 edx, 8
  057cd	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx
$LN5@P_if:

; 1980 : }

  057d3	8b e5		 mov	 esp, ebp
  057d5	5d		 pop	 ebp
  057d6	c3		 ret	 0
_P_if	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_branch DQ	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
tv89 = -8						; size = 4
_bp$ = -4						; size = 4
_P_else	PROC

; 1983 : {

  057e0	55		 push	 ebp
  057e1	8b ec		 mov	 ebp, esp
  057e3	83 ec 08	 sub	 esp, 8

; 1984 :     stackitem *bp;
; 1985 : 
; 1986 :     Compiling;

  057e6	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  057eb	89 45 f8	 mov	 DWORD PTR tv89[ebp], eax
  057ee	8b 4d f8	 mov	 ecx, DWORD PTR tv89[ebp]
  057f1	8b 55 f8	 mov	 edx, DWORD PTR tv89[ebp]
  057f4	8b 01		 mov	 eax, DWORD PTR [ecx]
  057f6	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  057f9	75 0a		 jne	 SHORT $LN6@P_else
  057fb	e8 00 00 00 00	 call	 _notcomp
  05800	e9 f1 00 00 00	 jmp	 $LN7@P_else
$LN6@P_else:

; 1987 :     Sl(1);

  05805	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0580b	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _stack
  05811	c1 f9 03	 sar	 ecx, 3
  05814	83 f9 01	 cmp	 ecx, 1
  05817	7d 0a		 jge	 SHORT $LN5@P_else
  05819	e8 00 00 00 00	 call	 _stakunder
  0581e	e9 d3 00 00 00	 jmp	 $LN7@P_else
$LN5@P_else:

; 1988 :     Compconst(s_branch);	      /* Compile branch around other clause */

  05823	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  05829	83 c2 08	 add	 edx, 8
  0582c	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  05832	76 0a		 jbe	 SHORT $LN4@P_else
  05834	e8 00 00 00 00	 call	 _heapover
  05839	e9 b8 00 00 00	 jmp	 $LN7@P_else
$LN4@P_else:
  0583e	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  05843	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_branch
  05849	89 08		 mov	 DWORD PTR [eax], ecx
  0584b	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_branch+4
  05851	89 50 04	 mov	 DWORD PTR [eax+4], edx
  05854	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  05859	83 c0 08	 add	 eax, 8
  0585c	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 1989 :     Compconst(0);		      /* Compile place-holder address cell */

  05861	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  05867	83 c1 08	 add	 ecx, 8
  0586a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  05870	76 07		 jbe	 SHORT $LN3@P_else
  05872	e8 00 00 00 00	 call	 _heapover
  05877	eb 7d		 jmp	 SHORT $LN7@P_else
$LN3@P_else:
  05879	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  0587f	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  05885	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
  0588c	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  05891	83 c0 08	 add	 eax, 8
  05894	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 1990 :     Hpc(S0);

  05899	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0589f	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  058a2	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  058a8	72 10		 jb	 SHORT $LN1@P_else
  058aa	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  058af	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  058b2	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  058b8	72 07		 jb	 SHORT $LN2@P_else
$LN1@P_else:
  058ba	e8 00 00 00 00	 call	 _badpointer
  058bf	eb 35		 jmp	 SHORT $LN7@P_else
$LN2@P_else:

; 1991 :     bp = (stackitem *) S0;	      /* Get IF backpatch address */

  058c1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  058c7	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  058ca	89 45 fc	 mov	 DWORD PTR _bp$[ebp], eax

; 1992 :     *bp = hptr - bp;

  058cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  058d2	2b 45 fc	 sub	 eax, DWORD PTR _bp$[ebp]
  058d5	c1 f8 03	 sar	 eax, 3
  058d8	99		 cdq
  058d9	8b 4d fc	 mov	 ecx, DWORD PTR _bp$[ebp]
  058dc	89 01		 mov	 DWORD PTR [ecx], eax
  058de	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 1993 :     S0 = (stackitem) (hptr - 1);      /* Update backpatch for THEN */

  058e1	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  058e6	83 e8 08	 sub	 eax, 8
  058e9	99		 cdq
  058ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  058f0	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  058f3	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN7@P_else:

; 1994 : }

  058f6	8b e5		 mov	 esp, ebp
  058f8	5d		 pop	 ebp
  058f9	c3		 ret	 0
_P_else	ENDP
; Function compile flags: /Odtp
tv81 = -8						; size = 4
_bp$ = -4						; size = 4
_P_then	PROC

; 1997 : {

  05900	55		 push	 ebp
  05901	8b ec		 mov	 ebp, esp
  05903	83 ec 08	 sub	 esp, 8

; 1998 :     stackitem *bp;
; 1999 : 
; 2000 :     Compiling;

  05906	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  0590b	89 45 f8	 mov	 DWORD PTR tv81[ebp], eax
  0590e	8b 4d f8	 mov	 ecx, DWORD PTR tv81[ebp]
  05911	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  05914	8b 01		 mov	 eax, DWORD PTR [ecx]
  05916	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  05919	75 07		 jne	 SHORT $LN4@P_then
  0591b	e8 00 00 00 00	 call	 _notcomp
  05920	eb 72		 jmp	 SHORT $LN5@P_then
$LN4@P_then:

; 2001 :     Sl(1);

  05922	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  05928	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _stack
  0592e	c1 f9 03	 sar	 ecx, 3
  05931	83 f9 01	 cmp	 ecx, 1
  05934	7d 07		 jge	 SHORT $LN3@P_then
  05936	e8 00 00 00 00	 call	 _stakunder
  0593b	eb 57		 jmp	 SHORT $LN5@P_then
$LN3@P_then:

; 2002 :     Hpc(S0);

  0593d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  05943	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  05946	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  0594c	72 11		 jb	 SHORT $LN1@P_then
  0594e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  05954	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  05957	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  0595d	72 07		 jb	 SHORT $LN2@P_then
$LN1@P_then:
  0595f	e8 00 00 00 00	 call	 _badpointer
  05964	eb 2e		 jmp	 SHORT $LN5@P_then
$LN2@P_then:

; 2003 :     bp = (stackitem *) S0;	      /* Get IF/ELSE backpatch address */

  05966	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0596b	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0596e	89 4d fc	 mov	 DWORD PTR _bp$[ebp], ecx

; 2004 :     *bp = hptr - bp;

  05971	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  05976	2b 45 fc	 sub	 eax, DWORD PTR _bp$[ebp]
  05979	c1 f8 03	 sar	 eax, 3
  0597c	99		 cdq
  0597d	8b 4d fc	 mov	 ecx, DWORD PTR _bp$[ebp]
  05980	89 01		 mov	 DWORD PTR [ecx], eax
  05982	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 2005 :     Pop;

  05985	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0598b	83 ea 08	 sub	 edx, 8
  0598e	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN5@P_then:

; 2006 : }

  05994	8b e5		 mov	 esp, ebp
  05996	5d		 pop	 ebp
  05997	c3		 ret	 0
_P_then	ENDP
; Function compile flags: /Odtp
tv75 = -12						; size = 4
_s$84306 = -8						; size = 8
_P_qdup	PROC

; 2009 : {

  059a0	55		 push	 ebp
  059a1	8b ec		 mov	 ebp, esp
  059a3	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2010 :     Sl(1);

  059a6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  059ab	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  059b1	c1 f8 03	 sar	 eax, 3
  059b4	83 f8 01	 cmp	 eax, 1
  059b7	7d 07		 jge	 SHORT $LN3@P_qdup
  059b9	e8 00 00 00 00	 call	 _stakunder
  059be	eb 5e		 jmp	 SHORT $LN4@P_qdup
$LN3@P_qdup:

; 2011 :     if (S0 != 0) {

  059c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  059c6	89 4d f4	 mov	 DWORD PTR tv75[ebp], ecx
  059c9	8b 55 f4	 mov	 edx, DWORD PTR tv75[ebp]
  059cc	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  059cf	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  059d2	0b 48 fc	 or	 ecx, DWORD PTR [eax-4]
  059d5	74 47		 je	 SHORT $LN4@P_qdup

; 2012 : 	stackitem s = S0;

  059d7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  059dd	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  059e0	89 45 f8	 mov	 DWORD PTR _s$84306[ebp], eax
  059e3	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  059e6	89 4d fc	 mov	 DWORD PTR _s$84306[ebp+4], ecx

; 2013 : 	So(1);

  059e9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  059ef	83 c2 08	 add	 edx, 8
  059f2	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _stacktop
  059f8	76 07		 jbe	 SHORT $LN1@P_qdup
  059fa	e8 00 00 00 00	 call	 _stakover
  059ff	eb 1d		 jmp	 SHORT $LN4@P_qdup
$LN1@P_qdup:

; 2014 : 	Push = s;

  05a01	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  05a06	8b 4d f8	 mov	 ecx, DWORD PTR _s$84306[ebp]
  05a09	89 08		 mov	 DWORD PTR [eax], ecx
  05a0b	8b 55 fc	 mov	 edx, DWORD PTR _s$84306[ebp+4]
  05a0e	89 50 04	 mov	 DWORD PTR [eax+4], edx
  05a11	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  05a16	83 c0 08	 add	 eax, 8
  05a19	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN4@P_qdup:

; 2015 :     }
; 2016 : }

  05a1e	8b e5		 mov	 esp, ebp
  05a20	5d		 pop	 ebp
  05a21	c3		 ret	 0
_P_qdup	ENDP
; Function compile flags: /Odtp
tv70 = -4						; size = 4
_P_begin PROC

; 2019 : {

  05a30	55		 push	 ebp
  05a31	8b ec		 mov	 ebp, esp
  05a33	51		 push	 ecx

; 2020 :     Compiling;

  05a34	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  05a39	89 45 fc	 mov	 DWORD PTR tv70[ebp], eax
  05a3c	8b 4d fc	 mov	 ecx, DWORD PTR tv70[ebp]
  05a3f	8b 55 fc	 mov	 edx, DWORD PTR tv70[ebp]
  05a42	8b 01		 mov	 eax, DWORD PTR [ecx]
  05a44	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  05a47	75 07		 jne	 SHORT $LN2@P_begin
  05a49	e8 00 00 00 00	 call	 _notcomp
  05a4e	eb 38		 jmp	 SHORT $LN3@P_begin
$LN2@P_begin:

; 2021 :     So(1);

  05a50	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  05a56	83 c1 08	 add	 ecx, 8
  05a59	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _stacktop
  05a5f	76 07		 jbe	 SHORT $LN1@P_begin
  05a61	e8 00 00 00 00	 call	 _stakover
  05a66	eb 20		 jmp	 SHORT $LN3@P_begin
$LN1@P_begin:

; 2022 :     Push = (stackitem) hptr;	      /* Save jump back address on stack */

  05a68	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  05a6d	99		 cdq
  05a6e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  05a74	89 01		 mov	 DWORD PTR [ecx], eax
  05a76	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  05a79	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  05a7f	83 c2 08	 add	 edx, 8
  05a82	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN3@P_begin:

; 2023 : }

  05a88	8b e5		 mov	 esp, ebp
  05a8a	5d		 pop	 ebp
  05a8b	c3		 ret	 0
_P_begin ENDP
; Function compile flags: /Odtp
tv88 = -20						; size = 4
_off$ = -16						; size = 8
_bp$ = -4						; size = 4
_P_until PROC

; 2026 : {

  05a90	55		 push	 ebp
  05a91	8b ec		 mov	 ebp, esp
  05a93	83 ec 14	 sub	 esp, 20			; 00000014H

; 2027 :     stackitem off;
; 2028 :     stackitem *bp;
; 2029 : 
; 2030 :     Compiling;

  05a96	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  05a9b	89 45 ec	 mov	 DWORD PTR tv88[ebp], eax
  05a9e	8b 4d ec	 mov	 ecx, DWORD PTR tv88[ebp]
  05aa1	8b 55 ec	 mov	 edx, DWORD PTR tv88[ebp]
  05aa4	8b 01		 mov	 eax, DWORD PTR [ecx]
  05aa6	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  05aa9	75 0a		 jne	 SHORT $LN6@P_until
  05aab	e8 00 00 00 00	 call	 _notcomp
  05ab0	e9 e9 00 00 00	 jmp	 $LN7@P_until
$LN6@P_until:

; 2031 :     Sl(1);

  05ab5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  05abb	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _stack
  05ac1	c1 f9 03	 sar	 ecx, 3
  05ac4	83 f9 01	 cmp	 ecx, 1
  05ac7	7d 0a		 jge	 SHORT $LN5@P_until
  05ac9	e8 00 00 00 00	 call	 _stakunder
  05ace	e9 cb 00 00 00	 jmp	 $LN7@P_until
$LN5@P_until:

; 2032 :     Compconst(s_qbranch);	      /* Compile question branch */

  05ad3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  05ad9	83 c2 08	 add	 edx, 8
  05adc	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  05ae2	76 0a		 jbe	 SHORT $LN4@P_until
  05ae4	e8 00 00 00 00	 call	 _heapover
  05ae9	e9 b0 00 00 00	 jmp	 $LN7@P_until
$LN4@P_until:
  05aee	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  05af3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_qbranch
  05af9	89 08		 mov	 DWORD PTR [eax], ecx
  05afb	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_qbranch+4
  05b01	89 50 04	 mov	 DWORD PTR [eax+4], edx
  05b04	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  05b09	83 c0 08	 add	 eax, 8
  05b0c	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2033 :     Hpc(S0);

  05b11	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  05b17	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  05b1a	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  05b20	72 10		 jb	 SHORT $LN2@P_until
  05b22	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  05b27	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  05b2a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  05b30	72 07		 jb	 SHORT $LN3@P_until
$LN2@P_until:
  05b32	e8 00 00 00 00	 call	 _badpointer
  05b37	eb 65		 jmp	 SHORT $LN7@P_until
$LN3@P_until:

; 2034 :     bp = (stackitem *) S0;	      /* Get BEGIN address */

  05b39	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  05b3f	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  05b42	89 45 fc	 mov	 DWORD PTR _bp$[ebp], eax

; 2035 :     off = -(hptr - bp);

  05b45	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  05b4a	2b 45 fc	 sub	 eax, DWORD PTR _bp$[ebp]
  05b4d	c1 f8 03	 sar	 eax, 3
  05b50	f7 d8		 neg	 eax
  05b52	99		 cdq
  05b53	89 45 f0	 mov	 DWORD PTR _off$[ebp], eax
  05b56	89 55 f4	 mov	 DWORD PTR _off$[ebp+4], edx

; 2036 :     Compconst(off);		      /* Compile negative jumpback address */

  05b59	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  05b5f	83 c1 08	 add	 ecx, 8
  05b62	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  05b68	76 07		 jbe	 SHORT $LN1@P_until
  05b6a	e8 00 00 00 00	 call	 _heapover
  05b6f	eb 2d		 jmp	 SHORT $LN7@P_until
$LN1@P_until:
  05b71	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  05b77	8b 45 f0	 mov	 eax, DWORD PTR _off$[ebp]
  05b7a	89 02		 mov	 DWORD PTR [edx], eax
  05b7c	8b 4d f4	 mov	 ecx, DWORD PTR _off$[ebp+4]
  05b7f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  05b82	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  05b88	83 c2 08	 add	 edx, 8
  05b8b	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 2037 :     Pop;

  05b91	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  05b96	83 e8 08	 sub	 eax, 8
  05b99	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN7@P_until:

; 2038 : }

  05b9e	8b e5		 mov	 esp, ebp
  05ba0	5d		 pop	 ebp
  05ba1	c3		 ret	 0
_P_until ENDP
; Function compile flags: /Odtp
tv85 = -20						; size = 4
_off$ = -16						; size = 8
_bp$ = -4						; size = 4
_P_again PROC

; 2041 : {

  05bb0	55		 push	 ebp
  05bb1	8b ec		 mov	 ebp, esp
  05bb3	83 ec 14	 sub	 esp, 20			; 00000014H

; 2042 :     stackitem off;
; 2043 :     stackitem *bp;
; 2044 : 
; 2045 :     Compiling;

  05bb6	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  05bbb	89 45 ec	 mov	 DWORD PTR tv85[ebp], eax
  05bbe	8b 4d ec	 mov	 ecx, DWORD PTR tv85[ebp]
  05bc1	8b 55 ec	 mov	 edx, DWORD PTR tv85[ebp]
  05bc4	8b 01		 mov	 eax, DWORD PTR [ecx]
  05bc6	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  05bc9	75 0a		 jne	 SHORT $LN5@P_again
  05bcb	e8 00 00 00 00	 call	 _notcomp
  05bd0	e9 ce 00 00 00	 jmp	 $LN6@P_again
$LN5@P_again:

; 2046 :     Compconst(s_branch);	      /* Compile unconditional branch */

  05bd5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  05bdb	83 c1 08	 add	 ecx, 8
  05bde	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  05be4	76 0a		 jbe	 SHORT $LN4@P_again
  05be6	e8 00 00 00 00	 call	 _heapover
  05beb	e9 b3 00 00 00	 jmp	 $LN6@P_again
$LN4@P_again:
  05bf0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  05bf6	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_branch
  05bfb	89 02		 mov	 DWORD PTR [edx], eax
  05bfd	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _s_branch+4
  05c03	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  05c06	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  05c0c	83 c2 08	 add	 edx, 8
  05c0f	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 2047 :     Hpc(S0);

  05c15	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  05c1a	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  05c1d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  05c23	72 11		 jb	 SHORT $LN2@P_again
  05c25	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  05c2b	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  05c2e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  05c34	72 07		 jb	 SHORT $LN3@P_again
$LN2@P_again:
  05c36	e8 00 00 00 00	 call	 _badpointer
  05c3b	eb 66		 jmp	 SHORT $LN6@P_again
$LN3@P_again:

; 2048 :     bp = (stackitem *) S0;	      /* Get BEGIN address */

  05c3d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  05c43	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  05c46	89 55 fc	 mov	 DWORD PTR _bp$[ebp], edx

; 2049 :     off = -(hptr - bp);

  05c49	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  05c4e	2b 45 fc	 sub	 eax, DWORD PTR _bp$[ebp]
  05c51	c1 f8 03	 sar	 eax, 3
  05c54	f7 d8		 neg	 eax
  05c56	99		 cdq
  05c57	89 45 f0	 mov	 DWORD PTR _off$[ebp], eax
  05c5a	89 55 f4	 mov	 DWORD PTR _off$[ebp+4], edx

; 2050 :     Compconst(off);		      /* Compile negative jumpback address */

  05c5d	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  05c62	83 c0 08	 add	 eax, 8
  05c65	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  05c6b	76 07		 jbe	 SHORT $LN1@P_again
  05c6d	e8 00 00 00 00	 call	 _heapover
  05c72	eb 2f		 jmp	 SHORT $LN6@P_again
$LN1@P_again:
  05c74	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  05c7a	8b 55 f0	 mov	 edx, DWORD PTR _off$[ebp]
  05c7d	89 11		 mov	 DWORD PTR [ecx], edx
  05c7f	8b 45 f4	 mov	 eax, DWORD PTR _off$[ebp+4]
  05c82	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  05c85	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  05c8b	83 c1 08	 add	 ecx, 8
  05c8e	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx

; 2051 :     Pop;

  05c94	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  05c9a	83 ea 08	 sub	 edx, 8
  05c9d	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN6@P_again:

; 2052 : }

  05ca3	8b e5		 mov	 esp, ebp
  05ca5	5d		 pop	 ebp
  05ca6	c3		 ret	 0
_P_again ENDP
; Function compile flags: /Odtp
tv77 = -4						; size = 4
_P_while PROC

; 2055 : {

  05cb0	55		 push	 ebp
  05cb1	8b ec		 mov	 ebp, esp
  05cb3	51		 push	 ecx

; 2056 :     Compiling;

  05cb4	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  05cb9	89 45 fc	 mov	 DWORD PTR tv77[ebp], eax
  05cbc	8b 4d fc	 mov	 ecx, DWORD PTR tv77[ebp]
  05cbf	8b 55 fc	 mov	 edx, DWORD PTR tv77[ebp]
  05cc2	8b 01		 mov	 eax, DWORD PTR [ecx]
  05cc4	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  05cc7	75 0a		 jne	 SHORT $LN4@P_while
  05cc9	e8 00 00 00 00	 call	 _notcomp
  05cce	e9 b1 00 00 00	 jmp	 $LN5@P_while
$LN4@P_while:

; 2057 :     So(1);

  05cd3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  05cd9	83 c1 08	 add	 ecx, 8
  05cdc	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _stacktop
  05ce2	76 0a		 jbe	 SHORT $LN3@P_while
  05ce4	e8 00 00 00 00	 call	 _stakover
  05ce9	e9 96 00 00 00	 jmp	 $LN5@P_while
$LN3@P_while:

; 2058 :     Compconst(s_qbranch);	      /* Compile question branch */

  05cee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  05cf4	83 c2 08	 add	 edx, 8
  05cf7	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  05cfd	76 07		 jbe	 SHORT $LN2@P_while
  05cff	e8 00 00 00 00	 call	 _heapover
  05d04	eb 7e		 jmp	 SHORT $LN5@P_while
$LN2@P_while:
  05d06	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  05d0b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_qbranch
  05d11	89 08		 mov	 DWORD PTR [eax], ecx
  05d13	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_qbranch+4
  05d19	89 50 04	 mov	 DWORD PTR [eax+4], edx
  05d1c	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  05d21	83 c0 08	 add	 eax, 8
  05d24	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2059 :     Compconst(0);		      /* Compile place-holder address cell */

  05d29	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  05d2f	83 c1 08	 add	 ecx, 8
  05d32	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  05d38	76 07		 jbe	 SHORT $LN1@P_while
  05d3a	e8 00 00 00 00	 call	 _heapover
  05d3f	eb 43		 jmp	 SHORT $LN5@P_while
$LN1@P_while:
  05d41	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  05d47	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  05d4d	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
  05d54	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  05d59	83 c0 08	 add	 eax, 8
  05d5c	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2060 :     Push = (stackitem) (hptr - 1);    /* Queue backpatch for REPEAT */

  05d61	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  05d66	83 e8 08	 sub	 eax, 8
  05d69	99		 cdq
  05d6a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  05d70	89 01		 mov	 DWORD PTR [ecx], eax
  05d72	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  05d75	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  05d7b	83 c2 08	 add	 edx, 8
  05d7e	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN5@P_while:

; 2061 : }

  05d84	8b e5		 mov	 esp, ebp
  05d86	5d		 pop	 ebp
  05d87	c3		 ret	 0
_P_while ENDP
; Function compile flags: /Odtp
tv132 = -24						; size = 4
_bp1$ = -20						; size = 4
_off$ = -16						; size = 8
_bp$ = -4						; size = 4
_P_repeat PROC

; 2064 : {

  05d90	55		 push	 ebp
  05d91	8b ec		 mov	 ebp, esp
  05d93	83 ec 18	 sub	 esp, 24			; 00000018H

; 2065 :     stackitem off;
; 2066 :     stackitem *bp1, *bp;
; 2067 : 
; 2068 :     Compiling;

  05d96	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  05d9b	89 45 e8	 mov	 DWORD PTR tv132[ebp], eax
  05d9e	8b 4d e8	 mov	 ecx, DWORD PTR tv132[ebp]
  05da1	8b 55 e8	 mov	 edx, DWORD PTR tv132[ebp]
  05da4	8b 01		 mov	 eax, DWORD PTR [ecx]
  05da6	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  05da9	75 0a		 jne	 SHORT $LN8@P_repeat
  05dab	e8 00 00 00 00	 call	 _notcomp
  05db0	e9 43 01 00 00	 jmp	 $LN9@P_repeat
$LN8@P_repeat:

; 2069 :     Sl(2);

  05db5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  05dbb	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _stack
  05dc1	c1 f9 03	 sar	 ecx, 3
  05dc4	83 f9 02	 cmp	 ecx, 2
  05dc7	7d 0a		 jge	 SHORT $LN7@P_repeat
  05dc9	e8 00 00 00 00	 call	 _stakunder
  05dce	e9 25 01 00 00	 jmp	 $LN9@P_repeat
$LN7@P_repeat:

; 2070 :     Hpc(S0);

  05dd3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  05dd9	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  05ddc	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  05de2	72 11		 jb	 SHORT $LN5@P_repeat
  05de4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  05dea	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  05ded	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  05df3	72 0a		 jb	 SHORT $LN6@P_repeat
$LN5@P_repeat:
  05df5	e8 00 00 00 00	 call	 _badpointer
  05dfa	e9 f9 00 00 00	 jmp	 $LN9@P_repeat
$LN6@P_repeat:

; 2071 :     bp1 = (stackitem *) S0;	      /* Get WHILE backpatch address */

  05dff	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  05e04	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  05e07	89 4d ec	 mov	 DWORD PTR _bp1$[ebp], ecx

; 2072 :     Pop;

  05e0a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  05e10	83 ea 08	 sub	 edx, 8
  05e13	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 2073 :     Compconst(s_branch);	      /* Compile unconditional branch */

  05e19	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  05e1e	83 c0 08	 add	 eax, 8
  05e21	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  05e27	76 0a		 jbe	 SHORT $LN4@P_repeat
  05e29	e8 00 00 00 00	 call	 _heapover
  05e2e	e9 c5 00 00 00	 jmp	 $LN9@P_repeat
$LN4@P_repeat:
  05e33	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  05e39	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _s_branch
  05e3f	89 11		 mov	 DWORD PTR [ecx], edx
  05e41	a1 04 00 00 00	 mov	 eax, DWORD PTR _s_branch+4
  05e46	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  05e49	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  05e4f	83 c1 08	 add	 ecx, 8
  05e52	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx

; 2074 :     Hpc(S0);

  05e58	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  05e5e	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  05e61	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  05e67	72 11		 jb	 SHORT $LN2@P_repeat
  05e69	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  05e6f	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  05e72	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  05e78	72 07		 jb	 SHORT $LN3@P_repeat
$LN2@P_repeat:
  05e7a	e8 00 00 00 00	 call	 _badpointer
  05e7f	eb 77		 jmp	 SHORT $LN9@P_repeat
$LN3@P_repeat:

; 2075 :     bp = (stackitem *) S0;	      /* Get BEGIN address */

  05e81	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  05e86	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  05e89	89 4d fc	 mov	 DWORD PTR _bp$[ebp], ecx

; 2076 :     off = -(hptr - bp);

  05e8c	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  05e91	2b 45 fc	 sub	 eax, DWORD PTR _bp$[ebp]
  05e94	c1 f8 03	 sar	 eax, 3
  05e97	f7 d8		 neg	 eax
  05e99	99		 cdq
  05e9a	89 45 f0	 mov	 DWORD PTR _off$[ebp], eax
  05e9d	89 55 f4	 mov	 DWORD PTR _off$[ebp+4], edx

; 2077 :     Compconst(off);		      /* Compile negative jumpback address */

  05ea0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  05ea6	83 c2 08	 add	 edx, 8
  05ea9	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  05eaf	76 07		 jbe	 SHORT $LN1@P_repeat
  05eb1	e8 00 00 00 00	 call	 _heapover
  05eb6	eb 40		 jmp	 SHORT $LN9@P_repeat
$LN1@P_repeat:
  05eb8	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  05ebd	8b 4d f0	 mov	 ecx, DWORD PTR _off$[ebp]
  05ec0	89 08		 mov	 DWORD PTR [eax], ecx
  05ec2	8b 55 f4	 mov	 edx, DWORD PTR _off$[ebp+4]
  05ec5	89 50 04	 mov	 DWORD PTR [eax+4], edx
  05ec8	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  05ecd	83 c0 08	 add	 eax, 8
  05ed0	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2078 :     *bp1 = hptr - bp1;                /* Backpatch REPEAT's jump out of loop */

  05ed5	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  05eda	2b 45 ec	 sub	 eax, DWORD PTR _bp1$[ebp]
  05edd	c1 f8 03	 sar	 eax, 3
  05ee0	99		 cdq
  05ee1	8b 4d ec	 mov	 ecx, DWORD PTR _bp1$[ebp]
  05ee4	89 01		 mov	 DWORD PTR [ecx], eax
  05ee6	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 2079 :     Pop;

  05ee9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  05eef	83 ea 08	 sub	 edx, 8
  05ef2	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN9@P_repeat:

; 2080 : }

  05ef8	8b e5		 mov	 esp, ebp
  05efa	5d		 pop	 ebp
  05efb	c3		 ret	 0
_P_repeat ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_xdo	DQ	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
tv76 = -4						; size = 4
_P_do	PROC

; 2083 : {

  05f00	55		 push	 ebp
  05f01	8b ec		 mov	 ebp, esp
  05f03	51		 push	 ecx

; 2084 :     Compiling;

  05f04	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  05f09	89 45 fc	 mov	 DWORD PTR tv76[ebp], eax
  05f0c	8b 4d fc	 mov	 ecx, DWORD PTR tv76[ebp]
  05f0f	8b 55 fc	 mov	 edx, DWORD PTR tv76[ebp]
  05f12	8b 01		 mov	 eax, DWORD PTR [ecx]
  05f14	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  05f17	75 0a		 jne	 SHORT $LN4@P_do
  05f19	e8 00 00 00 00	 call	 _notcomp
  05f1e	e9 af 00 00 00	 jmp	 $LN5@P_do
$LN4@P_do:

; 2085 :     Compconst(s_xdo);		      /* Compile runtime DO word */

  05f23	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  05f29	83 c1 08	 add	 ecx, 8
  05f2c	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  05f32	76 0a		 jbe	 SHORT $LN3@P_do
  05f34	e8 00 00 00 00	 call	 _heapover
  05f39	e9 94 00 00 00	 jmp	 $LN5@P_do
$LN3@P_do:
  05f3e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  05f44	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_xdo
  05f49	89 02		 mov	 DWORD PTR [edx], eax
  05f4b	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _s_xdo+4
  05f51	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  05f54	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  05f5a	83 c2 08	 add	 edx, 8
  05f5d	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 2086 :     So(1);

  05f63	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  05f68	83 c0 08	 add	 eax, 8
  05f6b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  05f71	76 07		 jbe	 SHORT $LN2@P_do
  05f73	e8 00 00 00 00	 call	 _stakover
  05f78	eb 58		 jmp	 SHORT $LN5@P_do
$LN2@P_do:

; 2087 :     Compconst(0);		      /* Reserve cell for LEAVE-taking */

  05f7a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  05f80	83 c1 08	 add	 ecx, 8
  05f83	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  05f89	76 07		 jbe	 SHORT $LN1@P_do
  05f8b	e8 00 00 00 00	 call	 _heapover
  05f90	eb 40		 jmp	 SHORT $LN5@P_do
$LN1@P_do:
  05f92	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  05f98	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  05f9e	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
  05fa5	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  05faa	83 c0 08	 add	 eax, 8
  05fad	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2088 :     Push = (stackitem) hptr;	      /* Save jump back address on stack */

  05fb2	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  05fb7	99		 cdq
  05fb8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  05fbe	89 01		 mov	 DWORD PTR [ecx], eax
  05fc0	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  05fc3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  05fc9	83 c2 08	 add	 edx, 8
  05fcc	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN5@P_do:

; 2089 : }

  05fd2	8b e5		 mov	 esp, ebp
  05fd4	5d		 pop	 ebp
  05fd5	c3		 ret	 0
_P_do	ENDP
; Function compile flags: /Odtp
_P_xdo	PROC

; 2092 : {

  05fe0	55		 push	 ebp
  05fe1	8b ec		 mov	 ebp, esp

; 2093 :     Sl(2);

  05fe3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  05fe8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  05fee	c1 f8 03	 sar	 eax, 3
  05ff1	83 f8 02	 cmp	 eax, 2
  05ff4	7d 0a		 jge	 SHORT $LN2@P_xdo
  05ff6	e8 00 00 00 00	 call	 _stakunder
  05ffb	e9 a5 00 00 00	 jmp	 $LN3@P_xdo
$LN2@P_xdo:

; 2094 :     Rso(3);

  06000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  06006	83 c1 0c	 add	 ecx, 12			; 0000000cH
  06009	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _rstacktop
  0600f	76 0a		 jbe	 SHORT $LN1@P_xdo
  06011	e8 00 00 00 00	 call	 _rstakover
  06016	e9 8a 00 00 00	 jmp	 $LN3@P_xdo
$LN1@P_xdo:

; 2095 :     Rpush = ip + ((stackitem) *ip);   /* Push exit address from loop */

  0601b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ip
  06021	8b 02		 mov	 eax, DWORD PTR [edx]
  06023	99		 cdq
  06024	6a 00		 push	 0
  06026	6a 04		 push	 4
  06028	52		 push	 edx
  06029	50		 push	 eax
  0602a	e8 00 00 00 00	 call	 __allmul
  0602f	03 05 00 00 00
	00		 add	 eax, DWORD PTR _ip
  06035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  0603b	89 01		 mov	 DWORD PTR [ecx], eax
  0603d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  06043	83 c2 04	 add	 edx, 4
  06046	89 15 00 00 00
	00		 mov	 DWORD PTR _rstk, edx

; 2096 :     ip++;			      /* Increment past exit address word */

  0604c	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  06051	83 c0 04	 add	 eax, 4
  06054	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax

; 2097 :     Rpush = (rstackitem) S1;	      /* Push loop limit on return stack */

  06059	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0605f	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  06062	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  06067	89 10		 mov	 DWORD PTR [eax], edx
  06069	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  0606f	83 c1 04	 add	 ecx, 4
  06072	89 0d 00 00 00
	00		 mov	 DWORD PTR _rstk, ecx

; 2098 :     Rpush = (rstackitem) S0;	      /* Iteration variable initial value to

  06078	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0607e	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  06081	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  06087	89 01		 mov	 DWORD PTR [ecx], eax
  06089	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  0608f	83 c2 04	 add	 edx, 4
  06092	89 15 00 00 00
	00		 mov	 DWORD PTR _rstk, edx

; 2099 : 					 return stack */
; 2100 :     stk -= 2;

  06098	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0609d	83 e8 10	 sub	 eax, 16			; 00000010H
  060a0	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN3@P_xdo:

; 2101 : }

  060a5	5d		 pop	 ebp
  060a6	c3		 ret	 0
_P_xdo	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_xqdo	DQ	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
tv76 = -4						; size = 4
_P_qdo	PROC

; 2104 : {

  060b0	55		 push	 ebp
  060b1	8b ec		 mov	 ebp, esp
  060b3	51		 push	 ecx

; 2105 :     Compiling;

  060b4	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  060b9	89 45 fc	 mov	 DWORD PTR tv76[ebp], eax
  060bc	8b 4d fc	 mov	 ecx, DWORD PTR tv76[ebp]
  060bf	8b 55 fc	 mov	 edx, DWORD PTR tv76[ebp]
  060c2	8b 01		 mov	 eax, DWORD PTR [ecx]
  060c4	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  060c7	75 0a		 jne	 SHORT $LN4@P_qdo
  060c9	e8 00 00 00 00	 call	 _notcomp
  060ce	e9 af 00 00 00	 jmp	 $LN5@P_qdo
$LN4@P_qdo:

; 2106 :     Compconst(s_xqdo);		      /* Compile runtime ?DO word */

  060d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  060d9	83 c1 08	 add	 ecx, 8
  060dc	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  060e2	76 0a		 jbe	 SHORT $LN3@P_qdo
  060e4	e8 00 00 00 00	 call	 _heapover
  060e9	e9 94 00 00 00	 jmp	 $LN5@P_qdo
$LN3@P_qdo:
  060ee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  060f4	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_xqdo
  060f9	89 02		 mov	 DWORD PTR [edx], eax
  060fb	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _s_xqdo+4
  06101	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  06104	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  0610a	83 c2 08	 add	 edx, 8
  0610d	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 2107 :     So(1);

  06113	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  06118	83 c0 08	 add	 eax, 8
  0611b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  06121	76 07		 jbe	 SHORT $LN2@P_qdo
  06123	e8 00 00 00 00	 call	 _stakover
  06128	eb 58		 jmp	 SHORT $LN5@P_qdo
$LN2@P_qdo:

; 2108 :     Compconst(0);		      /* Reserve cell for LEAVE-taking */

  0612a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  06130	83 c1 08	 add	 ecx, 8
  06133	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  06139	76 07		 jbe	 SHORT $LN1@P_qdo
  0613b	e8 00 00 00 00	 call	 _heapover
  06140	eb 40		 jmp	 SHORT $LN5@P_qdo
$LN1@P_qdo:
  06142	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  06148	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0614e	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
  06155	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0615a	83 c0 08	 add	 eax, 8
  0615d	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2109 :     Push = (stackitem) hptr;	      /* Save jump back address on stack */

  06162	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  06167	99		 cdq
  06168	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0616e	89 01		 mov	 DWORD PTR [ecx], eax
  06170	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  06173	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  06179	83 c2 08	 add	 edx, 8
  0617c	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN5@P_qdo:

; 2110 : }

  06182	8b e5		 mov	 esp, ebp
  06184	5d		 pop	 ebp
  06185	c3		 ret	 0
_P_qdo	ENDP
; Function compile flags: /Odtp
tv93 = -8						; size = 4
tv92 = -4						; size = 4
_P_xqdo	PROC

; 2113 : {

  06190	55		 push	 ebp
  06191	8b ec		 mov	 ebp, esp
  06193	83 ec 08	 sub	 esp, 8

; 2114 :     Sl(2);

  06196	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0619b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  061a1	c1 f8 03	 sar	 eax, 3
  061a4	83 f8 02	 cmp	 eax, 2
  061a7	7d 0a		 jge	 SHORT $LN4@P_xqdo
  061a9	e8 00 00 00 00	 call	 _stakunder
  061ae	e9 f6 00 00 00	 jmp	 $LN5@P_xqdo
$LN4@P_xqdo:

; 2115 :     if (S0 == S1) {

  061b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  061b9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  061bf	89 4d fc	 mov	 DWORD PTR tv92[ebp], ecx
  061c2	89 55 f8	 mov	 DWORD PTR tv93[ebp], edx
  061c5	8b 45 fc	 mov	 eax, DWORD PTR tv92[ebp]
  061c8	8b 4d f8	 mov	 ecx, DWORD PTR tv93[ebp]
  061cb	8b 50 f8	 mov	 edx, DWORD PTR [eax-8]
  061ce	3b 51 f0	 cmp	 edx, DWORD PTR [ecx-16]
  061d1	75 31		 jne	 SHORT $LN3@P_xqdo
  061d3	8b 45 fc	 mov	 eax, DWORD PTR tv92[ebp]
  061d6	8b 4d f8	 mov	 ecx, DWORD PTR tv93[ebp]
  061d9	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  061dc	3b 51 f4	 cmp	 edx, DWORD PTR [ecx-12]
  061df	75 23		 jne	 SHORT $LN3@P_xqdo

; 2116 : 	ip += (stackitem) *ip;

  061e1	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  061e6	8b 00		 mov	 eax, DWORD PTR [eax]
  061e8	99		 cdq
  061e9	6a 00		 push	 0
  061eb	6a 04		 push	 4
  061ed	52		 push	 edx
  061ee	50		 push	 eax
  061ef	e8 00 00 00 00	 call	 __allmul
  061f4	03 05 00 00 00
	00		 add	 eax, DWORD PTR _ip
  061fa	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax

; 2117 :     } else {

  061ff	e9 98 00 00 00	 jmp	 $LN2@P_xqdo
$LN3@P_xqdo:

; 2118 : 	Rso(3);

  06204	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  0620a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0620d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _rstacktop
  06213	76 0a		 jbe	 SHORT $LN1@P_xqdo
  06215	e8 00 00 00 00	 call	 _rstakover
  0621a	e9 8a 00 00 00	 jmp	 $LN5@P_xqdo
$LN1@P_xqdo:

; 2119 : 	Rpush = ip + ((stackitem) *ip);/* Push exit address from loop */

  0621f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ip
  06225	8b 02		 mov	 eax, DWORD PTR [edx]
  06227	99		 cdq
  06228	6a 00		 push	 0
  0622a	6a 04		 push	 4
  0622c	52		 push	 edx
  0622d	50		 push	 eax
  0622e	e8 00 00 00 00	 call	 __allmul
  06233	03 05 00 00 00
	00		 add	 eax, DWORD PTR _ip
  06239	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  0623f	89 01		 mov	 DWORD PTR [ecx], eax
  06241	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  06247	83 c2 04	 add	 edx, 4
  0624a	89 15 00 00 00
	00		 mov	 DWORD PTR _rstk, edx

; 2120 : 	ip++;			      /* Increment past exit address word */

  06250	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  06255	83 c0 04	 add	 eax, 4
  06258	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax

; 2121 : 	Rpush = (rstackitem) S1;      /* Push loop limit on return stack */

  0625d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  06263	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  06266	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  0626b	89 10		 mov	 DWORD PTR [eax], edx
  0626d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  06273	83 c1 04	 add	 ecx, 4
  06276	89 0d 00 00 00
	00		 mov	 DWORD PTR _rstk, ecx

; 2122 : 	Rpush = (rstackitem) S0;      /* Iteration variable initial value to

  0627c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  06282	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  06285	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  0628b	89 01		 mov	 DWORD PTR [ecx], eax
  0628d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  06293	83 c2 04	 add	 edx, 4
  06296	89 15 00 00 00
	00		 mov	 DWORD PTR _rstk, edx
$LN2@P_xqdo:

; 2123 : 					 return stack */
; 2124 :     }
; 2125 :     stk -= 2;

  0629c	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  062a1	83 e8 10	 sub	 eax, 16			; 00000010H
  062a4	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN5@P_xqdo:

; 2126 : }

  062a9	8b e5		 mov	 esp, ebp
  062ab	5d		 pop	 ebp
  062ac	c3		 ret	 0
_P_xqdo	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_xloop DQ	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
tv93 = -20						; size = 4
_off$ = -16						; size = 8
_bp$ = -4						; size = 4
_P_loop	PROC

; 2129 : {

  062b0	55		 push	 ebp
  062b1	8b ec		 mov	 ebp, esp
  062b3	83 ec 14	 sub	 esp, 20			; 00000014H

; 2130 :     stackitem off;
; 2131 :     stackitem *bp;
; 2132 : 
; 2133 :     Compiling;

  062b6	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  062bb	89 45 ec	 mov	 DWORD PTR tv93[ebp], eax
  062be	8b 4d ec	 mov	 ecx, DWORD PTR tv93[ebp]
  062c1	8b 55 ec	 mov	 edx, DWORD PTR tv93[ebp]
  062c4	8b 01		 mov	 eax, DWORD PTR [ecx]
  062c6	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  062c9	75 0a		 jne	 SHORT $LN6@P_loop
  062cb	e8 00 00 00 00	 call	 _notcomp
  062d0	e9 03 01 00 00	 jmp	 $LN7@P_loop
$LN6@P_loop:

; 2134 :     Sl(1);

  062d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  062db	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _stack
  062e1	c1 f9 03	 sar	 ecx, 3
  062e4	83 f9 01	 cmp	 ecx, 1
  062e7	7d 0a		 jge	 SHORT $LN5@P_loop
  062e9	e8 00 00 00 00	 call	 _stakunder
  062ee	e9 e5 00 00 00	 jmp	 $LN7@P_loop
$LN5@P_loop:

; 2135 :     Compconst(s_xloop); 	      /* Compile runtime loop */

  062f3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  062f9	83 c2 08	 add	 edx, 8
  062fc	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  06302	76 0a		 jbe	 SHORT $LN4@P_loop
  06304	e8 00 00 00 00	 call	 _heapover
  06309	e9 ca 00 00 00	 jmp	 $LN7@P_loop
$LN4@P_loop:
  0630e	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  06313	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_xloop
  06319	89 08		 mov	 DWORD PTR [eax], ecx
  0631b	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_xloop+4
  06321	89 50 04	 mov	 DWORD PTR [eax+4], edx
  06324	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  06329	83 c0 08	 add	 eax, 8
  0632c	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2136 :     Hpc(S0);

  06331	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  06337	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  0633a	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  06340	72 10		 jb	 SHORT $LN2@P_loop
  06342	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  06347	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0634a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  06350	72 07		 jb	 SHORT $LN3@P_loop
$LN2@P_loop:
  06352	e8 00 00 00 00	 call	 _badpointer
  06357	eb 7f		 jmp	 SHORT $LN7@P_loop
$LN3@P_loop:

; 2137 :     bp = (stackitem *) S0;	      /* Get DO address */

  06359	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0635f	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  06362	89 45 fc	 mov	 DWORD PTR _bp$[ebp], eax

; 2138 :     off = -(hptr - bp);

  06365	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0636a	2b 45 fc	 sub	 eax, DWORD PTR _bp$[ebp]
  0636d	c1 f8 03	 sar	 eax, 3
  06370	f7 d8		 neg	 eax
  06372	99		 cdq
  06373	89 45 f0	 mov	 DWORD PTR _off$[ebp], eax
  06376	89 55 f4	 mov	 DWORD PTR _off$[ebp+4], edx

; 2139 :     Compconst(off);		      /* Compile negative jumpback address */

  06379	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  0637f	83 c1 08	 add	 ecx, 8
  06382	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  06388	76 07		 jbe	 SHORT $LN1@P_loop
  0638a	e8 00 00 00 00	 call	 _heapover
  0638f	eb 47		 jmp	 SHORT $LN7@P_loop
$LN1@P_loop:
  06391	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  06397	8b 45 f0	 mov	 eax, DWORD PTR _off$[ebp]
  0639a	89 02		 mov	 DWORD PTR [edx], eax
  0639c	8b 4d f4	 mov	 ecx, DWORD PTR _off$[ebp+4]
  0639f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  063a2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  063a8	83 c2 08	 add	 edx, 8
  063ab	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 2140 :     *(bp - 1) = (hptr - bp) + 1;      /* Backpatch exit address offset */

  063b1	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  063b6	2b 45 fc	 sub	 eax, DWORD PTR _bp$[ebp]
  063b9	c1 f8 03	 sar	 eax, 3
  063bc	83 c0 01	 add	 eax, 1
  063bf	99		 cdq
  063c0	8b 4d fc	 mov	 ecx, DWORD PTR _bp$[ebp]
  063c3	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  063c6	89 51 fc	 mov	 DWORD PTR [ecx-4], edx

; 2141 :     Pop;

  063c9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  063cf	83 ea 08	 sub	 edx, 8
  063d2	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN7@P_loop:

; 2142 : }

  063d8	8b e5		 mov	 esp, ebp
  063da	5d		 pop	 ebp
  063db	c3		 ret	 0
_P_loop	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_pxloop DQ	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
tv93 = -20						; size = 4
_off$ = -16						; size = 8
_bp$ = -4						; size = 4
_P_ploop PROC

; 2145 : {

  063e0	55		 push	 ebp
  063e1	8b ec		 mov	 ebp, esp
  063e3	83 ec 14	 sub	 esp, 20			; 00000014H

; 2146 :     stackitem off;
; 2147 :     stackitem *bp;
; 2148 : 
; 2149 :     Compiling;

  063e6	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  063eb	89 45 ec	 mov	 DWORD PTR tv93[ebp], eax
  063ee	8b 4d ec	 mov	 ecx, DWORD PTR tv93[ebp]
  063f1	8b 55 ec	 mov	 edx, DWORD PTR tv93[ebp]
  063f4	8b 01		 mov	 eax, DWORD PTR [ecx]
  063f6	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  063f9	75 0a		 jne	 SHORT $LN6@P_ploop
  063fb	e8 00 00 00 00	 call	 _notcomp
  06400	e9 03 01 00 00	 jmp	 $LN7@P_ploop
$LN6@P_ploop:

; 2150 :     Sl(1);

  06405	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0640b	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _stack
  06411	c1 f9 03	 sar	 ecx, 3
  06414	83 f9 01	 cmp	 ecx, 1
  06417	7d 0a		 jge	 SHORT $LN5@P_ploop
  06419	e8 00 00 00 00	 call	 _stakunder
  0641e	e9 e5 00 00 00	 jmp	 $LN7@P_ploop
$LN5@P_ploop:

; 2151 :     Compconst(s_pxloop);	      /* Compile runtime +loop */

  06423	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  06429	83 c2 08	 add	 edx, 8
  0642c	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  06432	76 0a		 jbe	 SHORT $LN4@P_ploop
  06434	e8 00 00 00 00	 call	 _heapover
  06439	e9 ca 00 00 00	 jmp	 $LN7@P_ploop
$LN4@P_ploop:
  0643e	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  06443	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_pxloop
  06449	89 08		 mov	 DWORD PTR [eax], ecx
  0644b	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_pxloop+4
  06451	89 50 04	 mov	 DWORD PTR [eax+4], edx
  06454	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  06459	83 c0 08	 add	 eax, 8
  0645c	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2152 :     Hpc(S0);

  06461	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  06467	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  0646a	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  06470	72 10		 jb	 SHORT $LN2@P_ploop
  06472	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  06477	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0647a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  06480	72 07		 jb	 SHORT $LN3@P_ploop
$LN2@P_ploop:
  06482	e8 00 00 00 00	 call	 _badpointer
  06487	eb 7f		 jmp	 SHORT $LN7@P_ploop
$LN3@P_ploop:

; 2153 :     bp = (stackitem *) S0;	      /* Get DO address */

  06489	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0648f	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  06492	89 45 fc	 mov	 DWORD PTR _bp$[ebp], eax

; 2154 :     off = -(hptr - bp);

  06495	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0649a	2b 45 fc	 sub	 eax, DWORD PTR _bp$[ebp]
  0649d	c1 f8 03	 sar	 eax, 3
  064a0	f7 d8		 neg	 eax
  064a2	99		 cdq
  064a3	89 45 f0	 mov	 DWORD PTR _off$[ebp], eax
  064a6	89 55 f4	 mov	 DWORD PTR _off$[ebp+4], edx

; 2155 :     Compconst(off);		      /* Compile negative jumpback address */

  064a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  064af	83 c1 08	 add	 ecx, 8
  064b2	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  064b8	76 07		 jbe	 SHORT $LN1@P_ploop
  064ba	e8 00 00 00 00	 call	 _heapover
  064bf	eb 47		 jmp	 SHORT $LN7@P_ploop
$LN1@P_ploop:
  064c1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  064c7	8b 45 f0	 mov	 eax, DWORD PTR _off$[ebp]
  064ca	89 02		 mov	 DWORD PTR [edx], eax
  064cc	8b 4d f4	 mov	 ecx, DWORD PTR _off$[ebp+4]
  064cf	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  064d2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  064d8	83 c2 08	 add	 edx, 8
  064db	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 2156 :     *(bp - 1) = (hptr - bp) + 1;      /* Backpatch exit address offset */

  064e1	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  064e6	2b 45 fc	 sub	 eax, DWORD PTR _bp$[ebp]
  064e9	c1 f8 03	 sar	 eax, 3
  064ec	83 c0 01	 add	 eax, 1
  064ef	99		 cdq
  064f0	8b 4d fc	 mov	 ecx, DWORD PTR _bp$[ebp]
  064f3	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  064f6	89 51 fc	 mov	 DWORD PTR [ecx-4], edx

; 2157 :     Pop;

  064f9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  064ff	83 ea 08	 sub	 edx, 8
  06502	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN7@P_ploop:

; 2158 : }

  06508	8b e5		 mov	 esp, ebp
  0650a	5d		 pop	 ebp
  0650b	c3		 ret	 0
_P_ploop ENDP
; Function compile flags: /Odtp
tv144 = -16						; size = 8
tv141 = -8						; size = 8
_P_xloop PROC

; 2161 : {

  06510	55		 push	 ebp
  06511	8b ec		 mov	 ebp, esp
  06513	83 ec 10	 sub	 esp, 16			; 00000010H
  06516	56		 push	 esi

; 2162 :     Rsl(3);

  06517	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  0651c	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _rstack
  06522	c1 f8 02	 sar	 eax, 2
  06525	83 f8 03	 cmp	 eax, 3
  06528	7d 0a		 jge	 SHORT $LN3@P_xloop
  0652a	e8 00 00 00 00	 call	 _rstakunder
  0652f	e9 89 00 00 00	 jmp	 $LN4@P_xloop
$LN3@P_xloop:

; 2163 :     R0 = (rstackitem) (((stackitem) R0) + 1);

  06534	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  0653a	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0653d	99		 cdq
  0653e	83 c0 01	 add	 eax, 1
  06541	83 d2 00	 adc	 edx, 0
  06544	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  0654a	89 42 fc	 mov	 DWORD PTR [edx-4], eax

; 2164 :     if (((stackitem) R0) == ((stackitem) R1)) {

  0654d	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  06552	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  06555	99		 cdq
  06556	8b c8		 mov	 ecx, eax
  06558	8b f2		 mov	 esi, edx
  0655a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  06560	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  06563	99		 cdq
  06564	89 4d f8	 mov	 DWORD PTR tv141[ebp], ecx
  06567	89 75 fc	 mov	 DWORD PTR tv141[ebp+4], esi
  0656a	89 45 f0	 mov	 DWORD PTR tv144[ebp], eax
  0656d	89 55 f4	 mov	 DWORD PTR tv144[ebp+4], edx
  06570	8b 45 f8	 mov	 eax, DWORD PTR tv141[ebp]
  06573	3b 45 f0	 cmp	 eax, DWORD PTR tv144[ebp]
  06576	75 26		 jne	 SHORT $LN2@P_xloop
  06578	8b 4d fc	 mov	 ecx, DWORD PTR tv141[ebp+4]
  0657b	3b 4d f4	 cmp	 ecx, DWORD PTR tv144[ebp+4]
  0657e	75 1e		 jne	 SHORT $LN2@P_xloop

; 2165 : 	rstk -= 3;		      /* Pop iteration variable and limit */

  06580	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  06586	83 ea 0c	 sub	 edx, 12			; 0000000cH
  06589	89 15 00 00 00
	00		 mov	 DWORD PTR _rstk, edx

; 2166 : 	ip++;			      /* Skip the jump address */

  0658f	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  06594	83 c0 04	 add	 eax, 4
  06597	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax

; 2167 :     } else {

  0659c	eb 1f		 jmp	 SHORT $LN4@P_xloop
$LN2@P_xloop:

; 2168 : 	ip += (stackitem) *ip;

  0659e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ip
  065a4	8b 01		 mov	 eax, DWORD PTR [ecx]
  065a6	99		 cdq
  065a7	6a 00		 push	 0
  065a9	6a 04		 push	 4
  065ab	52		 push	 edx
  065ac	50		 push	 eax
  065ad	e8 00 00 00 00	 call	 __allmul
  065b2	03 05 00 00 00
	00		 add	 eax, DWORD PTR _ip
  065b8	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax
$LN4@P_xloop:

; 2169 :     }
; 2170 : }

  065bd	5e		 pop	 esi
  065be	8b e5		 mov	 esp, ebp
  065c0	5d		 pop	 ebp
  065c1	c3		 ret	 0
_P_xloop ENDP
; Function compile flags: /Odtp
tv169 = -32						; size = 8
tv166 = -24						; size = 8
tv145 = -16						; size = 8
_niter$ = -8						; size = 8
_P_xploop PROC

; 2173 : {

  065d0	55		 push	 ebp
  065d1	8b ec		 mov	 ebp, esp
  065d3	83 ec 20	 sub	 esp, 32			; 00000020H
  065d6	56		 push	 esi

; 2174 :     stackitem niter;
; 2175 : 
; 2176 :     Sl(1);

  065d7	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  065dc	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  065e2	c1 f8 03	 sar	 eax, 3
  065e5	83 f8 01	 cmp	 eax, 1
  065e8	7d 0a		 jge	 SHORT $LN4@P_xploop
  065ea	e8 00 00 00 00	 call	 _stakunder
  065ef	e9 e7 00 00 00	 jmp	 $LN5@P_xploop
$LN4@P_xploop:

; 2177 :     Rsl(3);

  065f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  065fa	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _rstack
  06600	c1 f9 02	 sar	 ecx, 2
  06603	83 f9 03	 cmp	 ecx, 3
  06606	7d 0a		 jge	 SHORT $LN3@P_xploop
  06608	e8 00 00 00 00	 call	 _rstakunder
  0660d	e9 c9 00 00 00	 jmp	 $LN5@P_xploop
$LN3@P_xploop:

; 2178 : 
; 2179 :     niter = ((stackitem) R0) + S0;

  06612	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  06618	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  0661b	99		 cdq
  0661c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  06622	03 41 f8	 add	 eax, DWORD PTR [ecx-8]
  06625	13 51 fc	 adc	 edx, DWORD PTR [ecx-4]
  06628	89 45 f8	 mov	 DWORD PTR _niter$[ebp], eax
  0662b	89 55 fc	 mov	 DWORD PTR _niter$[ebp+4], edx

; 2180 :     Pop;

  0662e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  06634	83 ea 08	 sub	 edx, 8
  06637	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 2181 :     if ((niter >= ((stackitem) R1)) &&
; 2182 : 	(((stackitem) R0) < ((stackitem) R1))) {

  0663d	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  06642	8b 40 f8	 mov	 eax, DWORD PTR [eax-8]
  06645	99		 cdq
  06646	89 45 f0	 mov	 DWORD PTR tv145[ebp], eax
  06649	89 55 f4	 mov	 DWORD PTR tv145[ebp+4], edx
  0664c	8b 4d fc	 mov	 ecx, DWORD PTR _niter$[ebp+4]
  0664f	3b 4d f4	 cmp	 ecx, DWORD PTR tv145[ebp+4]
  06652	7c 5d		 jl	 SHORT $LN2@P_xploop
  06654	7f 08		 jg	 SHORT $LN7@P_xploop
  06656	8b 55 f8	 mov	 edx, DWORD PTR _niter$[ebp]
  06659	3b 55 f0	 cmp	 edx, DWORD PTR tv145[ebp]
  0665c	72 53		 jb	 SHORT $LN2@P_xploop
$LN7@P_xploop:
  0665e	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  06663	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  06666	99		 cdq
  06667	8b c8		 mov	 ecx, eax
  06669	8b f2		 mov	 esi, edx
  0666b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  06671	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  06674	99		 cdq
  06675	89 4d e8	 mov	 DWORD PTR tv166[ebp], ecx
  06678	89 75 ec	 mov	 DWORD PTR tv166[ebp+4], esi
  0667b	89 45 e0	 mov	 DWORD PTR tv169[ebp], eax
  0667e	89 55 e4	 mov	 DWORD PTR tv169[ebp+4], edx
  06681	8b 45 ec	 mov	 eax, DWORD PTR tv166[ebp+4]
  06684	3b 45 e4	 cmp	 eax, DWORD PTR tv169[ebp+4]
  06687	7f 28		 jg	 SHORT $LN2@P_xploop
  06689	7c 08		 jl	 SHORT $LN8@P_xploop
  0668b	8b 4d e8	 mov	 ecx, DWORD PTR tv166[ebp]
  0668e	3b 4d e0	 cmp	 ecx, DWORD PTR tv169[ebp]
  06691	73 1e		 jae	 SHORT $LN2@P_xploop
$LN8@P_xploop:

; 2183 : 	rstk -= 3;		      /* Pop iteration variable and limit */

  06693	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  06699	83 ea 0c	 sub	 edx, 12			; 0000000cH
  0669c	89 15 00 00 00
	00		 mov	 DWORD PTR _rstk, edx

; 2184 : 	ip++;			      /* Skip the jump address */

  066a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  066a7	83 c0 04	 add	 eax, 4
  066aa	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax

; 2185 :     } else {

  066af	eb 2a		 jmp	 SHORT $LN5@P_xploop
$LN2@P_xploop:

; 2186 : 	ip += (stackitem) *ip;

  066b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ip
  066b7	8b 01		 mov	 eax, DWORD PTR [ecx]
  066b9	99		 cdq
  066ba	6a 00		 push	 0
  066bc	6a 04		 push	 4
  066be	52		 push	 edx
  066bf	50		 push	 eax
  066c0	e8 00 00 00 00	 call	 __allmul
  066c5	03 05 00 00 00
	00		 add	 eax, DWORD PTR _ip
  066cb	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax

; 2187 : 	R0 = (rstackitem) niter;

  066d0	8b 55 f8	 mov	 edx, DWORD PTR _niter$[ebp]
  066d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  066d8	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN5@P_xploop:

; 2188 :     }
; 2189 : }

  066db	5e		 pop	 esi
  066dc	8b e5		 mov	 esp, ebp
  066de	5d		 pop	 ebp
  066df	c3		 ret	 0
_P_xploop ENDP
; Function compile flags: /Odtp
_P_leave PROC

; 2192 : {

  066e0	55		 push	 ebp
  066e1	8b ec		 mov	 ebp, esp

; 2193 :     Rsl(3);

  066e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  066e8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _rstack
  066ee	c1 f8 02	 sar	 eax, 2
  066f1	83 f8 03	 cmp	 eax, 3
  066f4	7d 07		 jge	 SHORT $LN1@P_leave
  066f6	e8 00 00 00 00	 call	 _rstakunder
  066fb	eb 1c		 jmp	 SHORT $LN2@P_leave
$LN1@P_leave:

; 2194 :     ip = R2;

  066fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  06703	8b 51 f4	 mov	 edx, DWORD PTR [ecx-12]
  06706	89 15 00 00 00
	00		 mov	 DWORD PTR _ip, edx

; 2195 :     rstk -= 3;

  0670c	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  06711	83 e8 0c	 sub	 eax, 12			; 0000000cH
  06714	a3 00 00 00 00	 mov	 DWORD PTR _rstk, eax
$LN2@P_leave:

; 2196 : }

  06719	5d		 pop	 ebp
  0671a	c3		 ret	 0
_P_leave ENDP
; Function compile flags: /Odtp
_P_i	PROC

; 2199 : {

  06720	55		 push	 ebp
  06721	8b ec		 mov	 ebp, esp

; 2200 :     Rsl(3);

  06723	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  06728	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _rstack
  0672e	c1 f8 02	 sar	 eax, 2
  06731	83 f8 03	 cmp	 eax, 3
  06734	7d 07		 jge	 SHORT $LN2@P_i
  06736	e8 00 00 00 00	 call	 _rstakunder
  0673b	eb 3c		 jmp	 SHORT $LN3@P_i
$LN2@P_i:

; 2201 :     So(1);

  0673d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  06743	83 c1 08	 add	 ecx, 8
  06746	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _stacktop
  0674c	76 07		 jbe	 SHORT $LN1@P_i
  0674e	e8 00 00 00 00	 call	 _stakover
  06753	eb 24		 jmp	 SHORT $LN3@P_i
$LN1@P_i:

; 2202 :     Push = (stackitem) R0;            /* It's the top item on return stack */

  06755	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  0675b	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  0675e	99		 cdq
  0675f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  06765	89 01		 mov	 DWORD PTR [ecx], eax
  06767	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0676a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  06770	83 c2 08	 add	 edx, 8
  06773	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN3@P_i:

; 2203 : }

  06779	5d		 pop	 ebp
  0677a	c3		 ret	 0
_P_i	ENDP
; Function compile flags: /Odtp
_P_j	PROC

; 2206 : {

  06780	55		 push	 ebp
  06781	8b ec		 mov	 ebp, esp

; 2207 :     Rsl(6);

  06783	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  06788	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _rstack
  0678e	c1 f8 02	 sar	 eax, 2
  06791	83 f8 06	 cmp	 eax, 6
  06794	7d 07		 jge	 SHORT $LN2@P_j
  06796	e8 00 00 00 00	 call	 _rstakunder
  0679b	eb 3c		 jmp	 SHORT $LN3@P_j
$LN2@P_j:

; 2208 :     So(1);

  0679d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  067a3	83 c1 08	 add	 ecx, 8
  067a6	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _stacktop
  067ac	76 07		 jbe	 SHORT $LN1@P_j
  067ae	e8 00 00 00 00	 call	 _stakover
  067b3	eb 24		 jmp	 SHORT $LN3@P_j
$LN1@P_j:

; 2209 :     Push = (stackitem) rstk[-4];      /* It's the 4th item on return stack */

  067b5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  067bb	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  067be	99		 cdq
  067bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  067c5	89 01		 mov	 DWORD PTR [ecx], eax
  067c7	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  067ca	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  067d0	83 c2 08	 add	 edx, 8
  067d3	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN3@P_j:

; 2210 : }

  067d9	5d		 pop	 ebp
  067da	c3		 ret	 0
_P_j	ENDP
; Function compile flags: /Odtp
_P_quit PROC

; 2213 : {

  067e0	55		 push	 ebp
  067e1	8b ec		 mov	 ebp, esp

; 2214 :     rstk = rstack;		      /* Clear return stack */

  067e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstack
  067e8	a3 00 00 00 00	 mov	 DWORD PTR _rstk, eax

; 2215 : #ifdef WALKBACK
; 2216 :     wbptr = wback;

  067ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _wback
  067f3	89 0d 00 00 00
	00		 mov	 DWORD PTR _wbptr, ecx

; 2217 : #endif
; 2218 :     ip = NULL;			      /* Stop execution of current word */

  067f9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ip, 0

; 2219 : }

  06803	5d		 pop	 ebp
  06804	c3		 ret	 0
_P_quit	ENDP
; Function compile flags: /Odtp
_P_abort PROC

; 2222 : {

  06810	55		 push	 ebp
  06811	8b ec		 mov	 ebp, esp

; 2223 :     P_clear();			      /* Clear the data stack */

  06813	e8 00 00 00 00	 call	 _P_clear

; 2224 :     P_quit();			      /* Shut down execution */

  06818	e8 00 00 00 00	 call	 _P_quit

; 2225 : }

  0681d	5d		 pop	 ebp
  0681e	c3		 ret	 0
_P_abort ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_abortq DQ	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
tv71 = -4						; size = 4
_P_abortq PROC

; 2228 : {

  06820	55		 push	 ebp
  06821	8b ec		 mov	 ebp, esp
  06823	51		 push	 ecx

; 2229 :     if (state) {

  06824	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  06829	89 45 fc	 mov	 DWORD PTR tv71[ebp], eax
  0682c	8b 4d fc	 mov	 ecx, DWORD PTR tv71[ebp]
  0682f	8b 55 fc	 mov	 edx, DWORD PTR tv71[ebp]
  06832	8b 01		 mov	 eax, DWORD PTR [ecx]
  06834	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  06837	74 4c		 je	 SHORT $LN3@P_abortq

; 2230 : 	stringlit = True;	      /* Set string literal expected */

  06839	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _stringlit, 1

; 2231 : 	Compconst(s_abortq);	      /* Compile ourselves */

  06843	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  06849	83 c1 08	 add	 ecx, 8
  0684c	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  06852	76 0a		 jbe	 SHORT $LN2@P_abortq
  06854	e8 00 00 00 00	 call	 _heapover
  06859	e9 a3 00 00 00	 jmp	 $LN4@P_abortq
$LN2@P_abortq:
  0685e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  06864	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_abortq
  06869	89 02		 mov	 DWORD PTR [edx], eax
  0686b	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _s_abortq+4
  06871	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  06874	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  0687a	83 c2 08	 add	 edx, 8
  0687d	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 2232 :     } else {

  06883	eb 7c		 jmp	 SHORT $LN4@P_abortq
$LN3@P_abortq:

; 2233 :         V printf("%s", (char *) ip);  /* Otherwise, print string literal

  06885	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  0688a	50		 push	 eax
  0688b	68 00 00 00 00	 push	 OFFSET $SG84486
  06890	e8 00 00 00 00	 call	 _printf
  06895	83 c4 08	 add	 esp, 8

; 2234 : 					 in in-line code. */
; 2235 : #ifdef WALKBACK
; 2236 : 	pwalkback();

  06898	e8 00 00 00 00	 call	 _pwalkback

; 2237 : #endif /* WALKBACK */
; 2238 : 	P_abort();		      /* Abort */

  0689d	e8 00 00 00 00	 call	 _P_abort

; 2239 : 	atl_comment = state = Falsity;/* Reset all interpretation state */

  068a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _heap
  068a8	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  068ae	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  068b5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl_comment, 0
  068bf	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl_comment+4, 0

; 2240 : 	forgetpend = defpend = stringlit =
; 2241 : 		     tickpend = ctickpend = False;

  068c9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ctickpend, 0
  068d3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ctickpend
  068d9	89 15 00 00 00
	00		 mov	 DWORD PTR _tickpend, edx
  068df	a1 00 00 00 00	 mov	 eax, DWORD PTR _tickpend
  068e4	a3 00 00 00 00	 mov	 DWORD PTR _stringlit, eax
  068e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stringlit
  068ef	89 0d 00 00 00
	00		 mov	 DWORD PTR _defpend, ecx
  068f5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _defpend
  068fb	89 15 00 00 00
	00		 mov	 DWORD PTR _forgetpend, edx
$LN4@P_abortq:

; 2242 :     }
; 2243 : }

  06901	8b e5		 mov	 esp, ebp
  06903	5d		 pop	 ebp
  06904	c3		 ret	 0
_P_abortq ENDP
; Function compile flags: /Odtp
_P_immediate PROC

; 2248 : {

  06910	55		 push	 ebp
  06911	8b ec		 mov	 ebp, esp

; 2249 :     dict->wname[0] |= IMMEDIATE;

  06913	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  06918	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0691b	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0691e	83 ca 01	 or	 edx, 1
  06921	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  06926	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  06929	88 11		 mov	 BYTE PTR [ecx], dl

; 2250 : }

  0692b	5d		 pop	 ebp
  0692c	c3		 ret	 0
_P_immediate ENDP
; Function compile flags: /Odtp
tv66 = -4						; size = 4
_P_lbrack PROC

; 2253 : {

  06930	55		 push	 ebp
  06931	8b ec		 mov	 ebp, esp
  06933	51		 push	 ecx

; 2254 :     Compiling;

  06934	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  06939	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0693c	8b 4d fc	 mov	 ecx, DWORD PTR tv66[ebp]
  0693f	8b 55 fc	 mov	 edx, DWORD PTR tv66[ebp]
  06942	8b 01		 mov	 eax, DWORD PTR [ecx]
  06944	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  06947	75 07		 jne	 SHORT $LN1@P_lbrack
  06949	e8 00 00 00 00	 call	 _notcomp
  0694e	eb 13		 jmp	 SHORT $LN2@P_lbrack
$LN1@P_lbrack:

; 2255 :     state = Falsity;

  06950	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _heap
  06956	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0695c	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
$LN2@P_lbrack:

; 2256 : }

  06963	8b e5		 mov	 esp, ebp
  06965	5d		 pop	 ebp
  06966	c3		 ret	 0
_P_lbrack ENDP
; Function compile flags: /Odtp
_P_rbrack PROC

; 2259 : {

  06970	55		 push	 ebp
  06971	8b ec		 mov	 ebp, esp

; 2260 :     state = Truth;

  06973	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  06978	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0697e	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1

; 2261 : }

  06985	5d		 pop	 ebp
  06986	c3		 ret	 0
_P_rbrack ENDP
; Function compile flags: /Odtp
tv81 = -12						; size = 4
_hp$84511 = -8						; size = 4
_sp$84509 = -4						; size = 4
_P_does	PROC

; 2283 : {

  06990	55		 push	 ebp
  06991	8b ec		 mov	 ebp, esp
  06993	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2284 : 
; 2285 :     /* O.K., we were compiling our way through this definition and we've
; 2286 :        encountered the Dreaded and Dastardly Does.  Here's what we do
; 2287 :        about it.  The problem is that when we execute the word, we
; 2288 :        want to push its address on the stack and call the code for the
; 2289 :        DOES> clause by diverting the IP to that address.  But...how
; 2290 :        are we to know where the DOES> clause goes without adding a
; 2291 :        field to every word in the system just to remember it.  Recall
; 2292 :        that since this system is portable we can't cop-out through
; 2293 :        machine code.  Further, we can't compile something into the
; 2294 :        word because the defining code may have already allocated heap
; 2295 :        for the word's body.  Yukkkk.  Oh well, how about this?  Let's
; 2296 :        copy any and all heap allocated for the word down one stackitem
; 2297 :        and then jam the DOES> code address BEFORE the link field in
; 2298 :        the word we're defining.
; 2299 : 
; 2300 :        Then, when (DOES>) (P_dodoes) is called to execute the word, it
; 2301 :        will fetch that code address by backing up past the start of
; 2302 :        the word and seting IP to it.  Note that FORGET must recognise
; 2303 :        such words (by the presence of the pointer to P_dodoes() in
; 2304 :        their wcode field, in case you're wondering), and make sure to
; 2305 :        deallocate the heap word containing the link when a
; 2306 :        DOES>-defined word is deleted.  */
; 2307 : 
; 2308 :     if (createword != NULL) {

  06996	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _createword, 0
  0699d	0f 84 f7 00 00
	00		 je	 $LN7@P_does

; 2309 : 	stackitem *sp = ((stackitem *) createword), *hp;

  069a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _createword
  069a8	89 45 fc	 mov	 DWORD PTR _sp$84509[ebp], eax

; 2310 : 
; 2311 : 	Rsl(1);

  069ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  069b1	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _rstack
  069b7	c1 f9 02	 sar	 ecx, 2
  069ba	83 f9 01	 cmp	 ecx, 1
  069bd	7d 0a		 jge	 SHORT $LN5@P_does
  069bf	e8 00 00 00 00	 call	 _rstakunder
  069c4	e9 d1 00 00 00	 jmp	 $LN7@P_does
$LN5@P_does:

; 2312 : 	Ho(1);

  069c9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  069cf	83 c2 08	 add	 edx, 8
  069d2	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  069d8	76 0a		 jbe	 SHORT $LN4@P_does
  069da	e8 00 00 00 00	 call	 _heapover
  069df	e9 b6 00 00 00	 jmp	 $LN7@P_does
$LN4@P_does:

; 2313 : 
; 2314 : 	/* Copy the word definition one word down in the heap to
; 2315 : 	   permit us to prefix it with the DOES clause address. */
; 2316 : 
; 2317 : 	for (hp = hptr - 1; hp >= sp; hp--)

  069e4	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  069e9	83 e8 08	 sub	 eax, 8
  069ec	89 45 f8	 mov	 DWORD PTR _hp$84511[ebp], eax
  069ef	eb 09		 jmp	 SHORT $LN3@P_does
$LN2@P_does:
  069f1	8b 4d f8	 mov	 ecx, DWORD PTR _hp$84511[ebp]
  069f4	83 e9 08	 sub	 ecx, 8
  069f7	89 4d f8	 mov	 DWORD PTR _hp$84511[ebp], ecx
$LN3@P_does:
  069fa	8b 55 f8	 mov	 edx, DWORD PTR _hp$84511[ebp]
  069fd	3b 55 fc	 cmp	 edx, DWORD PTR _sp$84509[ebp]
  06a00	72 13		 jb	 SHORT $LN1@P_does

; 2318 : 	    *(hp + 1) = *hp;

  06a02	8b 45 f8	 mov	 eax, DWORD PTR _hp$84511[ebp]
  06a05	8b 4d f8	 mov	 ecx, DWORD PTR _hp$84511[ebp]
  06a08	8b 11		 mov	 edx, DWORD PTR [ecx]
  06a0a	89 50 08	 mov	 DWORD PTR [eax+8], edx
  06a0d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  06a10	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  06a13	eb dc		 jmp	 SHORT $LN2@P_does
$LN1@P_does:

; 2319 : 	hptr++; 		      /* Expand allocated length of word */

  06a15	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  06a1b	83 c2 08	 add	 edx, 8
  06a1e	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 2320 : 	*sp++ = (stackitem) ip;       /* Store DOES> clause address before

  06a24	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  06a29	99		 cdq
  06a2a	8b 4d fc	 mov	 ecx, DWORD PTR _sp$84509[ebp]
  06a2d	89 01		 mov	 DWORD PTR [ecx], eax
  06a2f	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  06a32	8b 55 fc	 mov	 edx, DWORD PTR _sp$84509[ebp]
  06a35	83 c2 08	 add	 edx, 8
  06a38	89 55 fc	 mov	 DWORD PTR _sp$84509[ebp], edx

; 2321 :                                          word's definition structure. */
; 2322 : 	createword = (dictword *) sp; /* Move word definition down 1 item */

  06a3b	8b 45 fc	 mov	 eax, DWORD PTR _sp$84509[ebp]
  06a3e	a3 00 00 00 00	 mov	 DWORD PTR _createword, eax

; 2323 : 	createword->wcode = P_dodoes; /* Set code field to indirect jump */

  06a43	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _createword
  06a49	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], OFFSET _P_dodoes

; 2324 : 
; 2325 : 	/* Now simulate an EXIT to bail out of the definition without
; 2326 : 	   executing the DOES> clause at definition time. */
; 2327 : 
; 2328 : 	ip = R0;		      /* Set IP to top of return stack */

  06a50	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  06a56	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  06a59	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax

; 2329 : #ifdef WALKBACK
; 2330 : 	wbptr = (wbptr > wback) ? wbptr - 1 : wback;

  06a5e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _wbptr
  06a64	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _wback
  06a6a	76 0e		 jbe	 SHORT $LN9@P_does
  06a6c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _wbptr
  06a72	83 ea 04	 sub	 edx, 4
  06a75	89 55 f4	 mov	 DWORD PTR tv81[ebp], edx
  06a78	eb 08		 jmp	 SHORT $LN10@P_does
$LN9@P_does:
  06a7a	a1 00 00 00 00	 mov	 eax, DWORD PTR _wback
  06a7f	89 45 f4	 mov	 DWORD PTR tv81[ebp], eax
$LN10@P_does:
  06a82	8b 4d f4	 mov	 ecx, DWORD PTR tv81[ebp]
  06a85	89 0d 00 00 00
	00		 mov	 DWORD PTR _wbptr, ecx

; 2331 : #endif
; 2332 : 	Rpop;			      /* Pop the return stack */

  06a8b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  06a91	83 ea 04	 sub	 edx, 4
  06a94	89 15 00 00 00
	00		 mov	 DWORD PTR _rstk, edx
$LN7@P_does:

; 2333 :     }
; 2334 : }

  06a9a	8b e5		 mov	 esp, ebp
  06a9c	5d		 pop	 ebp
  06a9d	c3		 ret	 0
_P_does	ENDP
; Function compile flags: /Odtp
_P_dodoes PROC

; 2264 : {

  06aa0	55		 push	 ebp
  06aa1	8b ec		 mov	 ebp, esp

; 2265 :     Rso(1);

  06aa3	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  06aa8	83 c0 04	 add	 eax, 4
  06aab	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _rstacktop
  06ab1	76 0a		 jbe	 SHORT $LN2@P_dodoes
  06ab3	e8 00 00 00 00	 call	 _rstakover
  06ab8	e9 81 00 00 00	 jmp	 $LN3@P_dodoes
$LN2@P_dodoes:

; 2266 :     So(1);

  06abd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  06ac3	83 c1 08	 add	 ecx, 8
  06ac6	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _stacktop
  06acc	76 07		 jbe	 SHORT $LN1@P_dodoes
  06ace	e8 00 00 00 00	 call	 _stakover
  06ad3	eb 69		 jmp	 SHORT $LN3@P_dodoes
$LN1@P_dodoes:

; 2267 :     Rpush = ip; 		      /* Push instruction pointer */

  06ad5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  06adb	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  06ae0	89 02		 mov	 DWORD PTR [edx], eax
  06ae2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  06ae8	83 c1 04	 add	 ecx, 4
  06aeb	89 0d 00 00 00
	00		 mov	 DWORD PTR _rstk, ecx

; 2268 : #ifdef WALKBACK
; 2269 :     *wbptr++ = curword; 	      /* Place word on walkback stack */

  06af1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _wbptr
  06af7	a1 00 00 00 00	 mov	 eax, DWORD PTR _curword
  06afc	89 02		 mov	 DWORD PTR [edx], eax
  06afe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _wbptr
  06b04	83 c1 04	 add	 ecx, 4
  06b07	89 0d 00 00 00
	00		 mov	 DWORD PTR _wbptr, ecx

; 2270 : #endif
; 2271 :     /* The compiler having craftily squirreled away the DOES> clause
; 2272 :        address before the word definition on the heap, we back up to
; 2273 :        the heap cell before the current word and load the pointer from
; 2274 :        there.  This is an ABSOLUTE heap address, not a relative offset. */
; 2275 :     ip = *((dictword ***) (((stackitem *) curword) - 1));

  06b0d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _curword
  06b13	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  06b16	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax

; 2276 : 
; 2277 :     /* Push the address of this word's body as the argument to the
; 2278 :        DOES> clause. */
; 2279 :     Push = (stackitem) (((stackitem *) curword) + Dictwordl);

  06b1b	a1 00 00 00 00	 mov	 eax, DWORD PTR _curword
  06b20	83 c0 10	 add	 eax, 16			; 00000010H
  06b23	99		 cdq
  06b24	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  06b2a	89 01		 mov	 DWORD PTR [ecx], eax
  06b2c	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  06b2f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  06b35	83 c2 08	 add	 edx, 8
  06b38	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN3@P_dodoes:

; 2280 : }

  06b3e	5d		 pop	 ebp
  06b3f	c3		 ret	 0
_P_dodoes ENDP
; Function compile flags: /Odtp
_P_colon PROC

; 2337 : {

  06b40	55		 push	 ebp
  06b41	8b ec		 mov	 ebp, esp

; 2338 :     state = Truth;		      /* Set compilation underway */

  06b43	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  06b48	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  06b4e	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1

; 2339 :     P_create(); 		      /* Create conventional word */

  06b55	e8 00 00 00 00	 call	 _P_create

; 2340 : }

  06b5a	5d		 pop	 ebp
  06b5b	c3		 ret	 0
_P_colon ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_exit	DQ	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
tv71 = -4						; size = 4
_P_semicolon PROC

; 2343 : {

  06b60	55		 push	 ebp
  06b61	8b ec		 mov	 ebp, esp
  06b63	51		 push	 ecx

; 2344 :     Compiling;

  06b64	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  06b69	89 45 fc	 mov	 DWORD PTR tv71[ebp], eax
  06b6c	8b 4d fc	 mov	 ecx, DWORD PTR tv71[ebp]
  06b6f	8b 55 fc	 mov	 edx, DWORD PTR tv71[ebp]
  06b72	8b 01		 mov	 eax, DWORD PTR [ecx]
  06b74	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  06b77	75 07		 jne	 SHORT $LN3@P_semicolo
  06b79	e8 00 00 00 00	 call	 _notcomp
  06b7e	eb 6f		 jmp	 SHORT $LN4@P_semicolo
$LN3@P_semicolo:

; 2345 :     Ho(1);

  06b80	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  06b86	83 c1 08	 add	 ecx, 8
  06b89	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  06b8f	76 07		 jbe	 SHORT $LN2@P_semicolo
  06b91	e8 00 00 00 00	 call	 _heapover
  06b96	eb 57		 jmp	 SHORT $LN4@P_semicolo
$LN2@P_semicolo:

; 2346 :     Hstore = s_exit;

  06b98	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  06b9e	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_exit
  06ba3	89 02		 mov	 DWORD PTR [edx], eax
  06ba5	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _s_exit+4
  06bab	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  06bae	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  06bb4	83 c2 08	 add	 edx, 8
  06bb7	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 2347 :     state = Falsity;		      /* No longer compiling */

  06bbd	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  06bc2	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  06bc8	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 2348 :     /* We wait until now to plug the P_nest code so that it will be
; 2349 :        present only in completed definitions. */
; 2350 :     if (createword != NULL)

  06bcf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _createword, 0
  06bd6	74 0d		 je	 SHORT $LN1@P_semicolo

; 2351 : 	createword->wcode = P_nest;   /* Use P_nest for code */

  06bd8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _createword
  06bde	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], OFFSET _P_nest
$LN1@P_semicolo:

; 2352 :     createword = NULL;		      /* Flag no word being created */

  06be5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _createword, 0
$LN4@P_semicolo:

; 2353 : }

  06bef	8b e5		 mov	 esp, ebp
  06bf1	5d		 pop	 ebp
  06bf2	c3		 ret	 0
_P_semicolon ENDP
_TEXT	ENDS
_BSS	SEGMENT
_tokbuf	DB	080H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
_di$84533 = -8						; size = 4
_i$ = -4						; size = 4
_P_tick	PROC

; 2356 : {

  06c00	55		 push	 ebp
  06c01	8b ec		 mov	 ebp, esp
  06c03	83 ec 08	 sub	 esp, 8

; 2357 :     int i;
; 2358 : 
; 2359 :     /* Try to get next symbol from the input stream.  If
; 2360 :        we can't, and we're executing a compiled word,
; 2361 :        report an error.  Since we can't call back to the
; 2362 :        calling program for more input, we're stuck. */
; 2363 : 
; 2364 :     i = token(&instream);	      /* Scan for next token */

  06c06	68 00 00 00 00	 push	 OFFSET _instream
  06c0b	e8 00 00 00 00	 call	 _token
  06c10	83 c4 04	 add	 esp, 4
  06c13	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 2365 :     if (i != TokNull) {

  06c16	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  06c1a	0f 84 88 00 00
	00		 je	 $LN9@P_tick

; 2366 : 	if (i == TokWord) {

  06c20	83 7d fc 01	 cmp	 DWORD PTR _i$[ebp], 1
  06c24	75 6e		 jne	 SHORT $LN8@P_tick

; 2367 : 	    dictword *di;
; 2368 : 
; 2369 : 	    ucase(tokbuf);

  06c26	68 00 00 00 00	 push	 OFFSET _tokbuf
  06c2b	e8 00 00 00 00	 call	 _ucase
  06c30	83 c4 04	 add	 esp, 4

; 2370 : 	    if ((di = lookup(tokbuf)) != NULL) {

  06c33	68 00 00 00 00	 push	 OFFSET _tokbuf
  06c38	e8 00 00 00 00	 call	 _lookup
  06c3d	83 c4 04	 add	 esp, 4
  06c40	89 45 f8	 mov	 DWORD PTR _di$84533[ebp], eax
  06c43	83 7d f8 00	 cmp	 DWORD PTR _di$84533[ebp], 0
  06c47	74 37		 je	 SHORT $LN7@P_tick

; 2371 : 		So(1);

  06c49	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  06c4e	83 c0 08	 add	 eax, 8
  06c51	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  06c57	76 07		 jbe	 SHORT $LN6@P_tick
  06c59	e8 00 00 00 00	 call	 _stakover
  06c5e	eb 6f		 jmp	 SHORT $LN10@P_tick
$LN6@P_tick:

; 2372 : 		Push = (stackitem) di; /* Push word compile address */

  06c60	8b 45 f8	 mov	 eax, DWORD PTR _di$84533[ebp]
  06c63	99		 cdq
  06c64	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  06c6a	89 01		 mov	 DWORD PTR [ecx], eax
  06c6c	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  06c6f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  06c75	83 c2 08	 add	 edx, 8
  06c78	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 2373 : 	    } else {

  06c7e	eb 12		 jmp	 SHORT $LN5@P_tick
$LN7@P_tick:

; 2374 :                 V printf(" '%s' undefined ", tokbuf);

  06c80	68 00 00 00 00	 push	 OFFSET _tokbuf
  06c85	68 00 00 00 00	 push	 OFFSET $SG84540
  06c8a	e8 00 00 00 00	 call	 _printf
  06c8f	83 c4 08	 add	 esp, 8
$LN5@P_tick:

; 2375 : 	    }
; 2376 : 	} else {

  06c92	eb 12		 jmp	 SHORT $LN4@P_tick
$LN8@P_tick:

; 2377 :             V printf("\nWord not specified when expected.\n");

  06c94	68 00 00 00 00	 push	 OFFSET $SG84543
  06c99	e8 00 00 00 00	 call	 _printf
  06c9e	83 c4 04	 add	 esp, 4

; 2378 : 	    P_abort();

  06ca1	e8 00 00 00 00	 call	 _P_abort
$LN4@P_tick:

; 2379 : 	}
; 2380 :     } else {

  06ca6	eb 27		 jmp	 SHORT $LN10@P_tick
$LN9@P_tick:

; 2381 : 	/* O.K., there was nothing in the input stream.  Set the
; 2382 : 	   tickpend flag to cause the compilation address of the next
; 2383 :            token to be pushed when it's supplied on a subsequent input
; 2384 : 	   line. */
; 2385 : 	if (ip == NULL) {

  06ca8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ip, 0
  06caf	75 0c		 jne	 SHORT $LN2@P_tick

; 2386 : 	    tickpend = True;	      /* Set tick pending */

  06cb1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _tickpend, 1

; 2387 : 	} else {

  06cbb	eb 12		 jmp	 SHORT $LN10@P_tick
$LN2@P_tick:

; 2388 :             V printf("\nWord requested by ` not on same input line.\n");

  06cbd	68 00 00 00 00	 push	 OFFSET $SG84549
  06cc2	e8 00 00 00 00	 call	 _printf
  06cc7	83 c4 04	 add	 esp, 4

; 2389 : 	    P_abort();

  06cca	e8 00 00 00 00	 call	 _P_abort
$LN10@P_tick:

; 2390 : 	}
; 2391 :     }
; 2392 : }

  06ccf	8b e5		 mov	 esp, ebp
  06cd1	5d		 pop	 ebp
  06cd2	c3		 ret	 0
_P_tick	ENDP
_TEXT	ENDS
EXTRN	_toupper:PROC
EXTRN	_islower:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_ch$ = -1						; size = 1
_c$ = 8							; size = 4
_ucase	PROC

; 260  : {

  06ce0	55		 push	 ebp
  06ce1	8b ec		 mov	 ebp, esp
  06ce3	51		 push	 ecx
$LN3@ucase:

; 261  :     char ch;
; 262  : 
; 263  :     while ((ch = *c) != EOS) {

  06ce4	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  06ce7	8a 08		 mov	 cl, BYTE PTR [eax]
  06ce9	88 4d ff	 mov	 BYTE PTR _ch$[ebp], cl
  06cec	0f be 55 ff	 movsx	 edx, BYTE PTR _ch$[ebp]
  06cf0	85 d2		 test	 edx, edx
  06cf2	74 2e		 je	 SHORT $LN4@ucase

; 264  : 	if (islower(ch))

  06cf4	0f be 45 ff	 movsx	 eax, BYTE PTR _ch$[ebp]
  06cf8	50		 push	 eax
  06cf9	e8 00 00 00 00	 call	 _islower
  06cfe	83 c4 04	 add	 esp, 4
  06d01	85 c0		 test	 eax, eax
  06d03	74 12		 je	 SHORT $LN1@ucase

; 265  : 	    *c = toupper(ch);

  06d05	0f be 4d ff	 movsx	 ecx, BYTE PTR _ch$[ebp]
  06d09	51		 push	 ecx
  06d0a	e8 00 00 00 00	 call	 _toupper
  06d0f	83 c4 04	 add	 esp, 4
  06d12	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  06d15	88 02		 mov	 BYTE PTR [edx], al
$LN1@ucase:

; 266  : 	c++;

  06d17	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  06d1a	83 c0 01	 add	 eax, 1
  06d1d	89 45 08	 mov	 DWORD PTR _c$[ebp], eax

; 267  :     }

  06d20	eb c2		 jmp	 SHORT $LN3@ucase
$LN4@ucase:

; 268  : }

  06d22	8b e5		 mov	 esp, ebp
  06d24	5d		 pop	 ebp
  06d25	c3		 ret	 0
_ucase	ENDP
_TEXT	ENDS
EXTRN	_sscanf:PROC
EXTRN	_isdigit:PROC
EXTRN	_isspace:PROC
_BSS	SEGMENT
_tokreal DQ	01H DUP (?)
_tokint	DD	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
tv95 = -36						; size = 4
_tc$83001 = -29						; size = 1
_tcp$83002 = -28					; size = 4
_c$82978 = -22						; size = 1
_c$82957 = -21						; size = 1
_tp$82941 = -20						; size = 4
_rstring$82944 = -16					; size = 4
_istring$82943 = -12					; size = 4
_tl$82942 = -8						; size = 4
_sp$ = -4						; size = 4
_cp$ = 8						; size = 4
_token	PROC

; 274  : {

  06d30	55		 push	 ebp
  06d31	8b ec		 mov	 ebp, esp
  06d33	83 ec 24	 sub	 esp, 36			; 00000024H

; 275  :     char *sp = *cp;

  06d36	8b 45 08	 mov	 eax, DWORD PTR _cp$[ebp]
  06d39	8b 08		 mov	 ecx, DWORD PTR [eax]
  06d3b	89 4d fc	 mov	 DWORD PTR _sp$[ebp], ecx
$LN46@token:

; 276  : 
; 277  :     while (True) {

  06d3e	ba 01 00 00 00	 mov	 edx, 1
  06d43	85 d2		 test	 edx, edx
  06d45	0f 84 9c 03 00
	00		 je	 $LN47@token

; 278  : 	char *tp = tokbuf;

  06d4b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _tp$82941[ebp], OFFSET _tokbuf

; 279  : 	int tl = 0;

  06d52	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _tl$82942[ebp], 0

; 280  : 	Boolean istring = False, rstring = False;

  06d59	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _istring$82943[ebp], 0
  06d60	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _rstring$82944[ebp], 0

; 281  : 
; 282  : 	if (atl_comment) {

  06d67	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_comment
  06d6c	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _atl_comment+4
  06d72	74 4c		 je	 SHORT $LN40@token
$LN43@token:

; 283  :             while (*sp != ')') {

  06d74	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  06d77	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  06d7a	83 fa 29	 cmp	 edx, 41			; 00000029H
  06d7d	74 24		 je	 SHORT $LN42@token

; 284  : 		if (*sp == EOS) {

  06d7f	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  06d82	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  06d85	85 c9		 test	 ecx, ecx
  06d87	75 0f		 jne	 SHORT $LN41@token

; 285  : 		    *cp = sp;

  06d89	8b 55 08	 mov	 edx, DWORD PTR _cp$[ebp]
  06d8c	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  06d8f	89 02		 mov	 DWORD PTR [edx], eax

; 286  : 		    return TokNull;

  06d91	33 c0		 xor	 eax, eax
  06d93	e9 4f 03 00 00	 jmp	 $LN47@token
$LN41@token:

; 287  : 		}
; 288  : 		sp++;

  06d98	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  06d9b	83 c1 01	 add	 ecx, 1
  06d9e	89 4d fc	 mov	 DWORD PTR _sp$[ebp], ecx

; 289  : 	    }

  06da1	eb d1		 jmp	 SHORT $LN43@token
$LN42@token:

; 290  : 	    sp++;

  06da3	8b 55 fc	 mov	 edx, DWORD PTR _sp$[ebp]
  06da6	83 c2 01	 add	 edx, 1
  06da9	89 55 fc	 mov	 DWORD PTR _sp$[ebp], edx

; 291  : 	    atl_comment = Falsity;

  06dac	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl_comment, 0
  06db6	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl_comment+4, 0
$LN40@token:

; 292  : 	}
; 293  : 
; 294  : 	while (isspace(*sp))		  /* Skip leading blanks */

  06dc0	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  06dc3	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  06dc6	51		 push	 ecx
  06dc7	e8 00 00 00 00	 call	 _isspace
  06dcc	83 c4 04	 add	 esp, 4
  06dcf	85 c0		 test	 eax, eax
  06dd1	74 0b		 je	 SHORT $LN39@token

; 295  : 	    sp++;

  06dd3	8b 55 fc	 mov	 edx, DWORD PTR _sp$[ebp]
  06dd6	83 c2 01	 add	 edx, 1
  06dd9	89 55 fc	 mov	 DWORD PTR _sp$[ebp], edx
  06ddc	eb e2		 jmp	 SHORT $LN40@token
$LN39@token:

; 296  : 
; 297  :         if (*sp == '"') {                 /* Is this a string ? */

  06dde	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  06de1	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  06de4	83 f9 22	 cmp	 ecx, 34			; 00000022H
  06de7	0f 85 11 01 00
	00		 jne	 $LN20@token

; 298  : 
; 299  : 	    /* Assemble string token. */
; 300  : 
; 301  : 	    sp++;

  06ded	8b 55 fc	 mov	 edx, DWORD PTR _sp$[ebp]
  06df0	83 c2 01	 add	 edx, 1
  06df3	89 55 fc	 mov	 DWORD PTR _sp$[ebp], edx
$LN37@token:

; 302  : 	    while (True) {

  06df6	b8 01 00 00 00	 mov	 eax, 1
  06dfb	85 c0		 test	 eax, eax
  06dfd	0f 84 f2 00 00
	00		 je	 $LN36@token

; 303  : 		char c = *sp++;

  06e03	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  06e06	8a 11		 mov	 dl, BYTE PTR [ecx]
  06e08	88 55 eb	 mov	 BYTE PTR _c$82957[ebp], dl
  06e0b	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  06e0e	83 c0 01	 add	 eax, 1
  06e11	89 45 fc	 mov	 DWORD PTR _sp$[ebp], eax

; 304  : 
; 305  :                 if (c == '"') {

  06e14	0f be 4d eb	 movsx	 ecx, BYTE PTR _c$82957[ebp]
  06e18	83 f9 22	 cmp	 ecx, 34			; 00000022H
  06e1b	75 1f		 jne	 SHORT $LN35@token

; 306  : 		    sp++;

  06e1d	8b 55 fc	 mov	 edx, DWORD PTR _sp$[ebp]
  06e20	83 c2 01	 add	 edx, 1
  06e23	89 55 fc	 mov	 DWORD PTR _sp$[ebp], edx

; 307  : 		    *tp++ = EOS;

  06e26	8b 45 ec	 mov	 eax, DWORD PTR _tp$82941[ebp]
  06e29	c6 00 00	 mov	 BYTE PTR [eax], 0
  06e2c	8b 4d ec	 mov	 ecx, DWORD PTR _tp$82941[ebp]
  06e2f	83 c1 01	 add	 ecx, 1
  06e32	89 4d ec	 mov	 DWORD PTR _tp$82941[ebp], ecx

; 308  : 		    break;

  06e35	e9 bb 00 00 00	 jmp	 $LN36@token
  06e3a	eb 23		 jmp	 SHORT $LN34@token
$LN35@token:

; 309  : 		} else if (c == EOS) {

  06e3c	0f be 55 eb	 movsx	 edx, BYTE PTR _c$82957[ebp]
  06e40	85 d2		 test	 edx, edx
  06e42	75 1b		 jne	 SHORT $LN34@token

; 310  : 		    rstring = True;

  06e44	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _rstring$82944[ebp], 1

; 311  : 		    *tp++ = EOS;

  06e4b	8b 45 ec	 mov	 eax, DWORD PTR _tp$82941[ebp]
  06e4e	c6 00 00	 mov	 BYTE PTR [eax], 0
  06e51	8b 4d ec	 mov	 ecx, DWORD PTR _tp$82941[ebp]
  06e54	83 c1 01	 add	 ecx, 1
  06e57	89 4d ec	 mov	 DWORD PTR _tp$82941[ebp], ecx

; 312  : 		    break;

  06e5a	e9 96 00 00 00	 jmp	 $LN36@token
$LN34@token:

; 313  : 		}
; 314  :                 if (c == '\\') {

  06e5f	0f be 55 eb	 movsx	 edx, BYTE PTR _c$82957[ebp]
  06e63	83 fa 5c	 cmp	 edx, 92			; 0000005cH
  06e66	75 5f		 jne	 SHORT $LN32@token

; 315  : 		    c = *sp++;

  06e68	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  06e6b	8a 08		 mov	 cl, BYTE PTR [eax]
  06e6d	88 4d eb	 mov	 BYTE PTR _c$82957[ebp], cl
  06e70	8b 55 fc	 mov	 edx, DWORD PTR _sp$[ebp]
  06e73	83 c2 01	 add	 edx, 1
  06e76	89 55 fc	 mov	 DWORD PTR _sp$[ebp], edx

; 316  : 		    if (c == EOS) {

  06e79	0f be 45 eb	 movsx	 eax, BYTE PTR _c$82957[ebp]
  06e7d	85 c0		 test	 eax, eax
  06e7f	75 09		 jne	 SHORT $LN31@token

; 317  : 			rstring = True;

  06e81	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _rstring$82944[ebp], 1

; 318  : 			break;

  06e88	eb 6b		 jmp	 SHORT $LN36@token
$LN31@token:

; 319  : 		    }
; 320  : 		    switch (c) {

  06e8a	0f be 4d eb	 movsx	 ecx, BYTE PTR _c$82957[ebp]
  06e8e	89 4d dc	 mov	 DWORD PTR tv95[ebp], ecx
  06e91	8b 55 dc	 mov	 edx, DWORD PTR tv95[ebp]
  06e94	83 ea 62	 sub	 edx, 98			; 00000062H
  06e97	89 55 dc	 mov	 DWORD PTR tv95[ebp], edx
  06e9a	83 7d dc 12	 cmp	 DWORD PTR tv95[ebp], 18	; 00000012H
  06e9e	77 27		 ja	 SHORT $LN32@token
  06ea0	8b 45 dc	 mov	 eax, DWORD PTR tv95[ebp]
  06ea3	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN49@token[eax]
  06eaa	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN50@token[ecx*4]
$LN28@token:

; 321  :                         case 'b':
; 322  :                             c = '\b';

  06eb1	c6 45 eb 08	 mov	 BYTE PTR _c$82957[ebp], 8

; 323  : 			    break;

  06eb5	eb 10		 jmp	 SHORT $LN32@token
$LN27@token:

; 324  :                         case 'n':
; 325  :                             c = '\n';

  06eb7	c6 45 eb 0a	 mov	 BYTE PTR _c$82957[ebp], 10 ; 0000000aH

; 326  : 			    break;

  06ebb	eb 0a		 jmp	 SHORT $LN32@token
$LN26@token:

; 327  :                         case 'r':
; 328  :                             c = '\r';

  06ebd	c6 45 eb 0d	 mov	 BYTE PTR _c$82957[ebp], 13 ; 0000000dH

; 329  : 			    break;

  06ec1	eb 04		 jmp	 SHORT $LN32@token
$LN25@token:

; 330  :                         case 't':
; 331  :                             c = '\t';

  06ec3	c6 45 eb 09	 mov	 BYTE PTR _c$82957[ebp], 9
$LN32@token:

; 332  : 			    break;
; 333  : 			default:
; 334  : 			    break;
; 335  : 		    }
; 336  : 		}
; 337  : 		if (tl < (sizeof tokbuf) - 1) {

  06ec7	83 7d f8 7f	 cmp	 DWORD PTR _tl$82942[ebp], 127 ; 0000007fH
  06ecb	73 1c		 jae	 SHORT $LN23@token

; 338  : 		   *tp++ = c;

  06ecd	8b 55 ec	 mov	 edx, DWORD PTR _tp$82941[ebp]
  06ed0	8a 45 eb	 mov	 al, BYTE PTR _c$82957[ebp]
  06ed3	88 02		 mov	 BYTE PTR [edx], al
  06ed5	8b 4d ec	 mov	 ecx, DWORD PTR _tp$82941[ebp]
  06ed8	83 c1 01	 add	 ecx, 1
  06edb	89 4d ec	 mov	 DWORD PTR _tp$82941[ebp], ecx

; 339  : 		   tl++;

  06ede	8b 55 f8	 mov	 edx, DWORD PTR _tl$82942[ebp]
  06ee1	83 c2 01	 add	 edx, 1
  06ee4	89 55 f8	 mov	 DWORD PTR _tl$82942[ebp], edx

; 340  : 		} else {

  06ee7	eb 07		 jmp	 SHORT $LN22@token
$LN23@token:

; 341  : 		    rstring = True;

  06ee9	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _rstring$82944[ebp], 1
$LN22@token:

; 342  : 		}
; 343  : 	    }

  06ef0	e9 01 ff ff ff	 jmp	 $LN37@token
$LN36@token:

; 344  : 	    istring = True;

  06ef5	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _istring$82943[ebp], 1

; 345  : 	} else {

  06efc	eb 66		 jmp	 SHORT $LN21@token
$LN20@token:

; 346  : 
; 347  : 	    /* Scan the next raw token */
; 348  : 
; 349  : 	    while (True) {

  06efe	b8 01 00 00 00	 mov	 eax, 1
  06f03	85 c0		 test	 eax, eax
  06f05	74 5d		 je	 SHORT $LN21@token

; 350  : 		char c = *sp++;

  06f07	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  06f0a	8a 11		 mov	 dl, BYTE PTR [ecx]
  06f0c	88 55 ea	 mov	 BYTE PTR _c$82978[ebp], dl
  06f0f	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  06f12	83 c0 01	 add	 eax, 1
  06f15	89 45 fc	 mov	 DWORD PTR _sp$[ebp], eax

; 351  : 
; 352  : 		if (c == EOS || isspace(c)) {

  06f18	0f be 4d ea	 movsx	 ecx, BYTE PTR _c$82978[ebp]
  06f1c	85 c9		 test	 ecx, ecx
  06f1e	74 11		 je	 SHORT $LN17@token
  06f20	0f be 55 ea	 movsx	 edx, BYTE PTR _c$82978[ebp]
  06f24	52		 push	 edx
  06f25	e8 00 00 00 00	 call	 _isspace
  06f2a	83 c4 04	 add	 esp, 4
  06f2d	85 c0		 test	 eax, eax
  06f2f	74 11		 je	 SHORT $LN18@token
$LN17@token:

; 353  : 		    *tp++ = EOS;

  06f31	8b 45 ec	 mov	 eax, DWORD PTR _tp$82941[ebp]
  06f34	c6 00 00	 mov	 BYTE PTR [eax], 0
  06f37	8b 4d ec	 mov	 ecx, DWORD PTR _tp$82941[ebp]
  06f3a	83 c1 01	 add	 ecx, 1
  06f3d	89 4d ec	 mov	 DWORD PTR _tp$82941[ebp], ecx

; 354  : 		    break;

  06f40	eb 22		 jmp	 SHORT $LN21@token
$LN18@token:

; 355  : 		}
; 356  : 		if (tl < (sizeof tokbuf) - 1) {

  06f42	83 7d f8 7f	 cmp	 DWORD PTR _tl$82942[ebp], 127 ; 0000007fH
  06f46	73 1a		 jae	 SHORT $LN16@token

; 357  : 		    *tp++ = c;

  06f48	8b 55 ec	 mov	 edx, DWORD PTR _tp$82941[ebp]
  06f4b	8a 45 ea	 mov	 al, BYTE PTR _c$82978[ebp]
  06f4e	88 02		 mov	 BYTE PTR [edx], al
  06f50	8b 4d ec	 mov	 ecx, DWORD PTR _tp$82941[ebp]
  06f53	83 c1 01	 add	 ecx, 1
  06f56	89 4d ec	 mov	 DWORD PTR _tp$82941[ebp], ecx

; 358  : 		    tl++;

  06f59	8b 55 f8	 mov	 edx, DWORD PTR _tl$82942[ebp]
  06f5c	83 c2 01	 add	 edx, 1
  06f5f	89 55 f8	 mov	 DWORD PTR _tl$82942[ebp], edx
$LN16@token:

; 359  : 		}
; 360  : 	    }

  06f62	eb 9a		 jmp	 SHORT $LN20@token
$LN21@token:

; 361  : 	}
; 362  : 	*cp = --sp;			  /* Store end of scan pointer */

  06f64	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  06f67	83 e8 01	 sub	 eax, 1
  06f6a	89 45 fc	 mov	 DWORD PTR _sp$[ebp], eax
  06f6d	8b 4d 08	 mov	 ecx, DWORD PTR _cp$[ebp]
  06f70	8b 55 fc	 mov	 edx, DWORD PTR _sp$[ebp]
  06f73	89 11		 mov	 DWORD PTR [ecx], edx

; 363  : 
; 364  : 	if (istring) {

  06f75	83 7d f4 00	 cmp	 DWORD PTR _istring$82943[ebp], 0
  06f79	74 33		 je	 SHORT $LN15@token

; 365  : 	    if (rstring) {

  06f7b	83 7d f0 00	 cmp	 DWORD PTR _rstring$82944[ebp], 0
  06f7f	74 23		 je	 SHORT $LN14@token

; 366  : #ifdef MEMMESSAGE
; 367  :                 V printf("\nRunaway string: %s\n", tokbuf);

  06f81	68 00 00 00 00	 push	 OFFSET _tokbuf
  06f86	68 00 00 00 00	 push	 OFFSET $SG82985
  06f8b	e8 00 00 00 00	 call	 _printf
  06f90	83 c4 08	 add	 esp, 8

; 368  : #endif
; 369  : 		evalstat = ATL_RUNSTRING;

  06f93	c7 05 00 00 00
	00 f6 ff ff ff	 mov	 DWORD PTR _evalstat, -10 ; fffffff6H

; 370  : 		return TokNull;

  06f9d	33 c0		 xor	 eax, eax
  06f9f	e9 43 01 00 00	 jmp	 $LN47@token
$LN14@token:

; 371  : 	    }
; 372  : 	    return TokString;

  06fa4	b8 04 00 00 00	 mov	 eax, 4
  06fa9	e9 39 01 00 00	 jmp	 $LN47@token
$LN15@token:

; 373  : 	}
; 374  : 
; 375  : 	if (tokbuf[0] == EOS)

  06fae	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR _tokbuf
  06fb5	85 c0		 test	 eax, eax
  06fb7	75 07		 jne	 SHORT $LN13@token

; 376  : 	    return TokNull;

  06fb9	33 c0		 xor	 eax, eax
  06fbb	e9 27 01 00 00	 jmp	 $LN47@token
$LN13@token:

; 377  : 
; 378  : 	/* See if token is a comment to end of line character.	If so, discard
; 379  : 	   the rest of the line and return null for this token request. */
; 380  : 
; 381  :         if (strcmp(tokbuf, "\\") == 0) {

  06fc0	68 00 00 00 00	 push	 OFFSET $SG82988
  06fc5	68 00 00 00 00	 push	 OFFSET _tokbuf
  06fca	e8 00 00 00 00	 call	 _strcmp
  06fcf	83 c4 08	 add	 esp, 8
  06fd2	85 c0		 test	 eax, eax
  06fd4	75 24		 jne	 SHORT $LN12@token
$LN11@token:

; 382  : 	    while (*sp != EOS)

  06fd6	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  06fd9	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  06fdc	85 d2		 test	 edx, edx
  06fde	74 0b		 je	 SHORT $LN10@token

; 383  : 		sp++;

  06fe0	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  06fe3	83 c0 01	 add	 eax, 1
  06fe6	89 45 fc	 mov	 DWORD PTR _sp$[ebp], eax
  06fe9	eb eb		 jmp	 SHORT $LN11@token
$LN10@token:

; 384  : 	    *cp = sp;

  06feb	8b 4d 08	 mov	 ecx, DWORD PTR _cp$[ebp]
  06fee	8b 55 fc	 mov	 edx, DWORD PTR _sp$[ebp]
  06ff1	89 11		 mov	 DWORD PTR [ecx], edx

; 385  : 	    return TokNull;

  06ff3	33 c0		 xor	 eax, eax
  06ff5	e9 ed 00 00 00	 jmp	 $LN47@token
$LN12@token:

; 386  : 	}
; 387  : 
; 388  : 	/* See if this token is a comment open delimiter.  If so, set to
; 389  : 	   ignore all characters until the matching comment close delimiter. */
; 390  : 
; 391  :         if (strcmp(tokbuf, "(") == 0) {

  06ffa	68 00 00 00 00	 push	 OFFSET $SG82993
  06fff	68 00 00 00 00	 push	 OFFSET _tokbuf
  07004	e8 00 00 00 00	 call	 _strcmp
  07009	83 c4 08	 add	 esp, 8
  0700c	85 c0		 test	 eax, eax
  0700e	75 5b		 jne	 SHORT $LN9@token
$LN8@token:

; 392  : 	    while (*sp != EOS) {

  07010	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  07013	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  07016	85 c9		 test	 ecx, ecx
  07018	74 18		 je	 SHORT $LN7@token

; 393  :                 if (*sp == ')')

  0701a	8b 55 fc	 mov	 edx, DWORD PTR _sp$[ebp]
  0701d	0f be 02	 movsx	 eax, BYTE PTR [edx]
  07020	83 f8 29	 cmp	 eax, 41			; 00000029H
  07023	75 02		 jne	 SHORT $LN6@token

; 394  : 		    break;

  07025	eb 0b		 jmp	 SHORT $LN7@token
$LN6@token:

; 395  : 		sp++;

  07027	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  0702a	83 c1 01	 add	 ecx, 1
  0702d	89 4d fc	 mov	 DWORD PTR _sp$[ebp], ecx

; 396  : 	    }

  07030	eb de		 jmp	 SHORT $LN8@token
$LN7@token:

; 397  :             if (*sp == ')') {

  07032	8b 55 fc	 mov	 edx, DWORD PTR _sp$[ebp]
  07035	0f be 02	 movsx	 eax, BYTE PTR [edx]
  07038	83 f8 29	 cmp	 eax, 41			; 00000029H
  0703b	75 0e		 jne	 SHORT $LN5@token

; 398  : 		sp++;

  0703d	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  07040	83 c1 01	 add	 ecx, 1
  07043	89 4d fc	 mov	 DWORD PTR _sp$[ebp], ecx

; 399  : 		continue;

  07046	e9 f3 fc ff ff	 jmp	 $LN46@token
$LN5@token:

; 400  : 	    }
; 401  : 	    atl_comment = Truth;

  0704b	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _atl_comment, -1
  07055	c7 05 04 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _atl_comment+4, -1

; 402  : 	    *cp = sp;

  0705f	8b 55 08	 mov	 edx, DWORD PTR _cp$[ebp]
  07062	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  07065	89 02		 mov	 DWORD PTR [edx], eax

; 403  : 	    return TokNull;

  07067	33 c0		 xor	 eax, eax
  07069	eb 7c		 jmp	 SHORT $LN47@token
$LN9@token:

; 404  : 	}
; 405  : 
; 406  : 	/* See if the token is a number. */
; 407  : 
; 408  :         if (isdigit(tokbuf[0]) || tokbuf[0] == '-') {

  0706b	0f be 0d 00 00
	00 00		 movsx	 ecx, BYTE PTR _tokbuf
  07072	51		 push	 ecx
  07073	e8 00 00 00 00	 call	 _isdigit
  07078	83 c4 04	 add	 esp, 4
  0707b	85 c0		 test	 eax, eax
  0707d	75 0c		 jne	 SHORT $LN3@token
  0707f	0f be 15 00 00
	00 00		 movsx	 edx, BYTE PTR _tokbuf
  07086	83 fa 2d	 cmp	 edx, 45			; 0000002dH
  07089	75 50		 jne	 SHORT $LN4@token
$LN3@token:

; 409  : 	    char tc;
; 410  : 	    char *tcp;
; 411  : 
; 412  : #ifdef USE_SSCANF
; 413  :             if (sscanf(tokbuf, "%li%c", &tokint, &tc) == 1)
; 414  : 		return TokInt;
; 415  : #else
; 416  :     	    tokint = strtoul(tokbuf, &tcp, 0);

  0708b	6a 00		 push	 0
  0708d	8d 45 e4	 lea	 eax, DWORD PTR _tcp$83002[ebp]
  07090	50		 push	 eax
  07091	68 00 00 00 00	 push	 OFFSET _tokbuf
  07096	e8 00 00 00 00	 call	 _strtoul
  0709b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0709e	a3 00 00 00 00	 mov	 DWORD PTR _tokint, eax

; 417  : 	    if (*tcp == 0) {

  070a3	8b 4d e4	 mov	 ecx, DWORD PTR _tcp$83002[ebp]
  070a6	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  070a9	85 d2		 test	 edx, edx
  070ab	75 07		 jne	 SHORT $LN2@token

; 418  : 	    	return TokInt;

  070ad	b8 02 00 00 00	 mov	 eax, 2
  070b2	eb 33		 jmp	 SHORT $LN47@token
$LN2@token:

; 419  : 	    }
; 420  : #endif
; 421  : #ifdef REAL
; 422  :             if (sscanf(tokbuf, "%lf%c", &tokreal, &tc) == 1)

  070b4	8d 45 e3	 lea	 eax, DWORD PTR _tc$83001[ebp]
  070b7	50		 push	 eax
  070b8	68 00 00 00 00	 push	 OFFSET _tokreal
  070bd	68 00 00 00 00	 push	 OFFSET $SG83005
  070c2	68 00 00 00 00	 push	 OFFSET _tokbuf
  070c7	e8 00 00 00 00	 call	 _sscanf
  070cc	83 c4 10	 add	 esp, 16			; 00000010H
  070cf	83 f8 01	 cmp	 eax, 1
  070d2	75 07		 jne	 SHORT $LN4@token

; 423  : 		return TokReal;

  070d4	b8 03 00 00 00	 mov	 eax, 3
  070d9	eb 0c		 jmp	 SHORT $LN47@token
$LN4@token:

; 424  : #endif
; 425  : 	}
; 426  : 	return TokWord;

  070db	b8 01 00 00 00	 mov	 eax, 1
  070e0	eb 05		 jmp	 SHORT $LN47@token

; 427  :     }

  070e2	e9 57 fc ff ff	 jmp	 $LN46@token
$LN47@token:

; 428  : }

  070e7	8b e5		 mov	 esp, ebp
  070e9	5d		 pop	 ebp
  070ea	c3		 ret	 0
  070eb	90		 npad	 1
$LN50@token:
  070ec	00 00 00 00	 DD	 $LN28@token
  070f0	00 00 00 00	 DD	 $LN27@token
  070f4	00 00 00 00	 DD	 $LN26@token
  070f8	00 00 00 00	 DD	 $LN25@token
  070fc	00 00 00 00	 DD	 $LN32@token
$LN49@token:
  07100	00		 DB	 0
  07101	04		 DB	 4
  07102	04		 DB	 4
  07103	04		 DB	 4
  07104	04		 DB	 4
  07105	04		 DB	 4
  07106	04		 DB	 4
  07107	04		 DB	 4
  07108	04		 DB	 4
  07109	04		 DB	 4
  0710a	04		 DB	 4
  0710b	04		 DB	 4
  0710c	01		 DB	 1
  0710d	04		 DB	 4
  0710e	04		 DB	 4
  0710f	04		 DB	 4
  07110	02		 DB	 2
  07111	04		 DB	 4
  07112	03		 DB	 3
_token	ENDP
; Function compile flags: /Odtp
_dw$ = -8						; size = 4
_tkname$ = 8						; size = 4
_lookup	PROC

; 434  : {

  07120	55		 push	 ebp
  07121	8b ec		 mov	 ebp, esp
  07123	83 ec 08	 sub	 esp, 8

; 435  :     dictword *dw = dict;

  07126	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  0712b	89 45 f8	 mov	 DWORD PTR _dw$[ebp], eax

; 436  : 	char a;
; 437  :     ucase(tkname);		      /* Force name to upper case */

  0712e	8b 4d 08	 mov	 ecx, DWORD PTR _tkname$[ebp]
  07131	51		 push	 ecx
  07132	e8 00 00 00 00	 call	 _ucase
  07137	83 c4 04	 add	 esp, 4
$LN3@lookup:

; 438  :     while (dw != NULL) {

  0713a	83 7d f8 00	 cmp	 DWORD PTR _dw$[ebp], 0
  0713e	74 48		 je	 SHORT $LN2@lookup

; 439  : 	if (!(dw->wname[0] & WORDHIDDEN) &&
; 440  : 	     (strcmp(dw->wname + 1, tkname) == 0)) {

  07140	8b 55 f8	 mov	 edx, DWORD PTR _dw$[ebp]
  07143	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  07146	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  07149	83 e1 04	 and	 ecx, 4
  0714c	75 30		 jne	 SHORT $LN1@lookup
  0714e	8b 55 08	 mov	 edx, DWORD PTR _tkname$[ebp]
  07151	52		 push	 edx
  07152	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  07155	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  07158	83 c1 01	 add	 ecx, 1
  0715b	51		 push	 ecx
  0715c	e8 00 00 00 00	 call	 _strcmp
  07161	83 c4 08	 add	 esp, 8
  07164	85 c0		 test	 eax, eax
  07166	75 16		 jne	 SHORT $LN1@lookup

; 441  : #ifdef WORDSUSED
; 442  : 		/*a=dw->wname[0] | WORDUSED;
; 443  : 	    memcpy(&dw->wname[0],&a ,1);*/ /* Mark this word used */
; 444  : 	 *(dw->wname) |= WORDUSED;   /* bug access violation with msvc */

  07168	8b 55 f8	 mov	 edx, DWORD PTR _dw$[ebp]
  0716b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0716e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  07171	83 c9 02	 or	 ecx, 2
  07174	8b 55 f8	 mov	 edx, DWORD PTR _dw$[ebp]
  07177	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0717a	88 08		 mov	 BYTE PTR [eax], cl

; 445  : #endif
; 446  : 	    break;

  0717c	eb 0a		 jmp	 SHORT $LN2@lookup
$LN1@lookup:

; 447  : 	}
; 448  : 	dw = dw->wnext;

  0717e	8b 4d f8	 mov	 ecx, DWORD PTR _dw$[ebp]
  07181	8b 11		 mov	 edx, DWORD PTR [ecx]
  07183	89 55 f8	 mov	 DWORD PTR _dw$[ebp], edx

; 449  :     }

  07186	eb b2		 jmp	 SHORT $LN3@lookup
$LN2@lookup:

; 450  :     return dw;

  07188	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]

; 451  : }

  0718b	8b e5		 mov	 esp, ebp
  0718d	5d		 pop	 ebp
  0718e	c3		 ret	 0
_lookup	ENDP
; Function compile flags: /Odtp
tv66 = -4						; size = 4
_P_bracktick PROC

; 2395 : {

  07190	55		 push	 ebp
  07191	8b ec		 mov	 ebp, esp
  07193	51		 push	 ecx

; 2396 :     Compiling;

  07194	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  07199	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0719c	8b 4d fc	 mov	 ecx, DWORD PTR tv66[ebp]
  0719f	8b 55 fc	 mov	 edx, DWORD PTR tv66[ebp]
  071a2	8b 01		 mov	 eax, DWORD PTR [ecx]
  071a4	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  071a7	75 07		 jne	 SHORT $LN1@P_bracktic
  071a9	e8 00 00 00 00	 call	 _notcomp
  071ae	eb 0a		 jmp	 SHORT $LN2@P_bracktic
$LN1@P_bracktic:

; 2397 :     ctickpend = True;		      /* Force literal treatment of next

  071b0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _ctickpend, 1
$LN2@P_bracktic:

; 2398 : 					 word in compile stream */
; 2399 : }

  071ba	8b e5		 mov	 esp, ebp
  071bc	5d		 pop	 ebp
  071bd	c3		 ret	 0
_P_bracktick ENDP
; Function compile flags: /Odtp
_wp$ = -4						; size = 4
_P_execute PROC

; 2402 : {

  071c0	55		 push	 ebp
  071c1	8b ec		 mov	 ebp, esp
  071c3	51		 push	 ecx

; 2403 :     dictword *wp;
; 2404 : 
; 2405 :     Sl(1);

  071c4	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  071c9	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  071cf	c1 f8 03	 sar	 eax, 3
  071d2	83 f8 01	 cmp	 eax, 1
  071d5	7d 07		 jge	 SHORT $LN1@P_execute
  071d7	e8 00 00 00 00	 call	 _stakunder
  071dc	eb 25		 jmp	 SHORT $LN2@P_execute
$LN1@P_execute:

; 2406 :     wp = (dictword *) S0;	      /* Load word address from stack */

  071de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  071e4	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  071e7	89 55 fc	 mov	 DWORD PTR _wp$[ebp], edx

; 2407 :     Pop;			      /* Pop data stack before execution */

  071ea	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  071ef	83 e8 08	 sub	 eax, 8
  071f2	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 2408 :     exword(wp); 		      /* Recursively call exword() to run

  071f7	8b 4d fc	 mov	 ecx, DWORD PTR _wp$[ebp]
  071fa	51		 push	 ecx
  071fb	e8 00 00 00 00	 call	 _exword
  07200	83 c4 04	 add	 esp, 4
$LN2@P_execute:

; 2409 : 					 the word. */
; 2410 : }

  07203	8b e5		 mov	 esp, ebp
  07205	5d		 pop	 ebp
  07206	c3		 ret	 0
_P_execute ENDP
; Function compile flags: /Odtp
_P_body PROC

; 2413 : {

  07210	55		 push	 ebp
  07211	8b ec		 mov	 ebp, esp

; 2414 :     Sl(1);

  07213	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  07218	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0721e	c1 f8 03	 sar	 eax, 3
  07221	83 f8 01	 cmp	 eax, 1
  07224	7d 07		 jge	 SHORT $LN1@P_body
  07226	e8 00 00 00 00	 call	 _stakunder
  0722b	eb 1e		 jmp	 SHORT $LN2@P_body
$LN1@P_body:

; 2415 :     S0 += Dictwordl * sizeof(stackitem);

  0722d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07233	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  07236	83 c2 10	 add	 edx, 16			; 00000010H
  07239	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0723c	83 d0 00	 adc	 eax, 0
  0723f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07245	89 51 f8	 mov	 DWORD PTR [ecx-8], edx
  07248	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN2@P_body:

; 2416 : }

  0724b	5d		 pop	 ebp
  0724c	c3		 ret	 0
_P_body	ENDP
; Function compile flags: /Odtp
_P_state PROC

; 2419 : {

  07250	55		 push	 ebp
  07251	8b ec		 mov	 ebp, esp

; 2420 :     So(1);

  07253	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  07258	83 c0 08	 add	 eax, 8
  0725b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  07261	76 07		 jbe	 SHORT $LN1@P_state
  07263	e8 00 00 00 00	 call	 _stakover
  07268	eb 20		 jmp	 SHORT $LN2@P_state
$LN1@P_state:

; 2421 :     Push = (stackitem) &state;

  0726a	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  0726f	99		 cdq
  07270	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07276	89 01		 mov	 DWORD PTR [ecx], eax
  07278	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0727b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  07281	83 c2 08	 add	 edx, 8
  07284	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN2@P_state:

; 2422 : }

  0728a	5d		 pop	 ebp
  0728b	c3		 ret	 0
_P_state ENDP
; Function compile flags: /Odtp
_dw$ = -4						; size = 4
_P_find	PROC

; 2429 : {

  07290	55		 push	 ebp
  07291	8b ec		 mov	 ebp, esp
  07293	51		 push	 ecx

; 2430 :     dictword *dw;
; 2431 : 
; 2432 :     Sl(1);

  07294	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  07299	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0729f	c1 f8 03	 sar	 eax, 3
  072a2	83 f8 01	 cmp	 eax, 1
  072a5	7d 0a		 jge	 SHORT $LN6@P_find
  072a7	e8 00 00 00 00	 call	 _stakunder
  072ac	e9 d7 00 00 00	 jmp	 $LN7@P_find
$LN6@P_find:

; 2433 :     So(1);

  072b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  072b7	83 c1 08	 add	 ecx, 8
  072ba	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _stacktop
  072c0	76 0a		 jbe	 SHORT $LN5@P_find
  072c2	e8 00 00 00 00	 call	 _stakover
  072c7	e9 bc 00 00 00	 jmp	 $LN7@P_find
$LN5@P_find:

; 2434 :     Hpc(S0);

  072cc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  072d2	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  072d5	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  072db	72 11		 jb	 SHORT $LN3@P_find
  072dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  072e3	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  072e6	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  072ec	72 0a		 jb	 SHORT $LN4@P_find
$LN3@P_find:
  072ee	e8 00 00 00 00	 call	 _badpointer
  072f3	e9 90 00 00 00	 jmp	 $LN7@P_find
$LN4@P_find:

; 2435 :     V strcpy(tokbuf, (char *) S0);    /* Use built-in token buffer... */

  072f8	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  072fd	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  07300	51		 push	 ecx
  07301	68 00 00 00 00	 push	 OFFSET _tokbuf
  07306	e8 00 00 00 00	 call	 _strcpy
  0730b	83 c4 08	 add	 esp, 8

; 2436 :     dw = lookup(tokbuf);              /* So ucase() in lookup() doesn't wipe */

  0730e	68 00 00 00 00	 push	 OFFSET _tokbuf
  07313	e8 00 00 00 00	 call	 _lookup
  07318	83 c4 04	 add	 esp, 4
  0731b	89 45 fc	 mov	 DWORD PTR _dw$[ebp], eax

; 2437 : 				      /* the token on the stack */
; 2438 :     if (dw != NULL) {

  0731e	83 7d fc 00	 cmp	 DWORD PTR _dw$[ebp], 0
  07322	74 43		 je	 SHORT $LN2@P_find

; 2439 : 	S0 = (stackitem) dw;

  07324	8b 45 fc	 mov	 eax, DWORD PTR _dw$[ebp]
  07327	99		 cdq
  07328	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0732e	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  07331	89 51 fc	 mov	 DWORD PTR [ecx-4], edx

; 2440 : 	/* Push immediate flag */
; 2441 : 	Push = (dw->wname[0] & IMMEDIATE) ? 1 : -1;

  07334	8b 55 fc	 mov	 edx, DWORD PTR _dw$[ebp]
  07337	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0733a	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0733d	83 e0 01	 and	 eax, 1
  07340	f7 d8		 neg	 eax
  07342	1b c0		 sbb	 eax, eax
  07344	83 e0 02	 and	 eax, 2
  07347	83 c0 ff	 add	 eax, -1
  0734a	99		 cdq
  0734b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07351	89 01		 mov	 DWORD PTR [ecx], eax
  07353	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  07356	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0735c	83 c2 08	 add	 edx, 8
  0735f	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 2442 :     } else {

  07365	eb 21		 jmp	 SHORT $LN7@P_find
$LN2@P_find:

; 2443 : 	Push = 0;

  07367	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0736c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  07372	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  07379	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0737f	83 c1 08	 add	 ecx, 8
  07382	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN7@P_find:

; 2444 :     }
; 2445 : }

  07388	8b e5		 mov	 esp, ebp
  0738a	5d		 pop	 ebp
  0738b	c3		 ret	 0
_P_find	ENDP
; Function compile flags: /Odtp
_P_toname PROC

; 2450 : {

  07390	55		 push	 ebp
  07391	8b ec		 mov	 ebp, esp

; 2451 :     Sl(1);

  07393	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  07398	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0739e	c1 f8 03	 sar	 eax, 3
  073a1	83 f8 01	 cmp	 eax, 1
  073a4	7d 07		 jge	 SHORT $LN1@P_toname
  073a6	e8 00 00 00 00	 call	 _stakunder
  073ab	eb 27		 jmp	 SHORT $LN2@P_toname
$LN1@P_toname:

; 2452 :     S0 += DfOff(wname);

  073ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  073b2	83 c0 04	 add	 eax, 4
  073b5	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dict
  073bb	99		 cdq
  073bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  073c2	03 41 f8	 add	 eax, DWORD PTR [ecx-8]
  073c5	13 51 fc	 adc	 edx, DWORD PTR [ecx-4]
  073c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  073ce	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  073d1	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN2@P_toname:

; 2453 : }

  073d4	5d		 pop	 ebp
  073d5	c3		 ret	 0
_P_toname ENDP
; Function compile flags: /Odtp
_P_tolink PROC

; 2456 : {

  073e0	55		 push	 ebp
  073e1	8b ec		 mov	 ebp, esp

; 2457 : if (DfOff(wnext) != 0) V printf("\n>LINK Foulup--wnext is not at zero!\n");

  073e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  073e8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dict
  073ee	74 0d		 je	 SHORT $LN2@P_tolink
  073f0	68 00 00 00 00	 push	 OFFSET $SG84595
  073f5	e8 00 00 00 00	 call	 _printf
  073fa	83 c4 04	 add	 esp, 4
$LN2@P_tolink:

; 2458 : /*  Sl(1);
; 2459 :     S0 += DfOff(wnext);  */	      /* Null operation.  Wnext is first */
; 2460 : }

  073fd	5d		 pop	 ebp
  073fe	c3		 ret	 0
_P_tolink ENDP
; Function compile flags: /Odtp
_P_frombody PROC

; 2463 : {

  07400	55		 push	 ebp
  07401	8b ec		 mov	 ebp, esp

; 2464 :     Sl(1);

  07403	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  07408	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0740e	c1 f8 03	 sar	 eax, 3
  07411	83 f8 01	 cmp	 eax, 1
  07414	7d 07		 jge	 SHORT $LN1@P_frombody
  07416	e8 00 00 00 00	 call	 _stakunder
  0741b	eb 1e		 jmp	 SHORT $LN2@P_frombody
$LN1@P_frombody:

; 2465 :     S0 -= Dictwordl * sizeof(stackitem);

  0741d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07423	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  07426	83 ea 10	 sub	 edx, 16			; 00000010H
  07429	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0742c	83 d8 00	 sbb	 eax, 0
  0742f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07435	89 51 f8	 mov	 DWORD PTR [ecx-8], edx
  07438	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN2@P_frombody:

; 2466 : }

  0743b	5d		 pop	 ebp
  0743c	c3		 ret	 0
_P_frombody ENDP
; Function compile flags: /Odtp
_P_fromname PROC

; 2469 : {

  07440	55		 push	 ebp
  07441	8b ec		 mov	 ebp, esp
  07443	56		 push	 esi

; 2470 :     Sl(1);

  07444	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  07449	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0744f	c1 f8 03	 sar	 eax, 3
  07452	83 f8 01	 cmp	 eax, 1
  07455	7d 07		 jge	 SHORT $LN1@P_fromname
  07457	e8 00 00 00 00	 call	 _stakunder
  0745c	eb 2b		 jmp	 SHORT $LN2@P_fromname
$LN1@P_fromname:

; 2471 :     S0 -= DfOff(wname);

  0745e	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  07463	83 c0 04	 add	 eax, 4
  07466	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dict
  0746c	99		 cdq
  0746d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07473	8b 71 f8	 mov	 esi, DWORD PTR [ecx-8]
  07476	2b f0		 sub	 esi, eax
  07478	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0747b	1b c2		 sbb	 eax, edx
  0747d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07483	89 71 f8	 mov	 DWORD PTR [ecx-8], esi
  07486	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN2@P_fromname:

; 2472 : }

  07489	5e		 pop	 esi
  0748a	5d		 pop	 ebp
  0748b	c3		 ret	 0
_P_fromname ENDP
; Function compile flags: /Odtp
_P_fromlink PROC

; 2475 : {

  07490	55		 push	 ebp
  07491	8b ec		 mov	 ebp, esp

; 2476 : if (DfOff(wnext) != 0) V printf("\nLINK> Foulup--wnext is not at zero!\n");

  07493	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  07498	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dict
  0749e	74 0d		 je	 SHORT $LN2@P_fromlink
  074a0	68 00 00 00 00	 push	 OFFSET $SG84614
  074a5	e8 00 00 00 00	 call	 _printf
  074aa	83 c4 04	 add	 esp, 4
$LN2@P_fromlink:

; 2477 : /*  Sl(1);
; 2478 :     S0 -= DfOff(wnext);  */	      /* Null operation.  Wnext is first */
; 2479 : }

  074ad	5d		 pop	 ebp
  074ae	c3		 ret	 0
_P_fromlink ENDP
; Function compile flags: /Odtp
_from$ = -8						; size = 4
_to$ = -4						; size = 4
_P_nametolink PROC

; 2486 : {

  074b0	55		 push	 ebp
  074b1	8b ec		 mov	 ebp, esp
  074b3	83 ec 08	 sub	 esp, 8
  074b6	56		 push	 esi

; 2487 :     char *from, *to;
; 2488 : 
; 2489 :     Sl(1);

  074b7	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  074bc	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  074c2	c1 f8 03	 sar	 eax, 3
  074c5	83 f8 01	 cmp	 eax, 1
  074c8	7d 07		 jge	 SHORT $LN1@P_nametoli
  074ca	e8 00 00 00 00	 call	 _stakunder
  074cf	eb 38		 jmp	 SHORT $LN2@P_nametoli
$LN1@P_nametoli:

; 2490 :     /*
; 2491 :     S0 -= DfTran(wnext, wname);
; 2492 :     */
; 2493 :     from = (char *) &(dict->wnext);

  074d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dict
  074d7	89 4d f8	 mov	 DWORD PTR _from$[ebp], ecx

; 2494 :     to = (char *) &(dict->wname);

  074da	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dict
  074e0	83 c2 04	 add	 edx, 4
  074e3	89 55 fc	 mov	 DWORD PTR _to$[ebp], edx

; 2495 :     S0 -= (to - from);

  074e6	8b 45 fc	 mov	 eax, DWORD PTR _to$[ebp]
  074e9	2b 45 f8	 sub	 eax, DWORD PTR _from$[ebp]
  074ec	99		 cdq
  074ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  074f3	8b 71 f8	 mov	 esi, DWORD PTR [ecx-8]
  074f6	2b f0		 sub	 esi, eax
  074f8	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  074fb	1b c2		 sbb	 eax, edx
  074fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07503	89 71 f8	 mov	 DWORD PTR [ecx-8], esi
  07506	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN2@P_nametoli:

; 2496 : }

  07509	5e		 pop	 esi
  0750a	8b e5		 mov	 esp, ebp
  0750c	5d		 pop	 ebp
  0750d	c3		 ret	 0
_P_nametolink ENDP
; Function compile flags: /Odtp
_from$ = -8						; size = 4
_to$ = -4						; size = 4
_P_linktoname PROC

; 2499 : {

  07510	55		 push	 ebp
  07511	8b ec		 mov	 ebp, esp
  07513	83 ec 08	 sub	 esp, 8

; 2500 :     char *from, *to;
; 2501 : 
; 2502 :     Sl(1);

  07516	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0751b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  07521	c1 f8 03	 sar	 eax, 3
  07524	83 f8 01	 cmp	 eax, 1
  07527	7d 07		 jge	 SHORT $LN1@P_linktona
  07529	e8 00 00 00 00	 call	 _stakunder
  0752e	eb 34		 jmp	 SHORT $LN2@P_linktona
$LN1@P_linktona:

; 2503 :     /*
; 2504 :     S0 += DfTran(wnext, wname);
; 2505 :     */
; 2506 :     from = (char *) &(dict->wnext);

  07530	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dict
  07536	89 4d f8	 mov	 DWORD PTR _from$[ebp], ecx

; 2507 :     to = (char *) &(dict->wname);

  07539	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dict
  0753f	83 c2 04	 add	 edx, 4
  07542	89 55 fc	 mov	 DWORD PTR _to$[ebp], edx

; 2508 :     S0 += (to - from);

  07545	8b 45 fc	 mov	 eax, DWORD PTR _to$[ebp]
  07548	2b 45 f8	 sub	 eax, DWORD PTR _from$[ebp]
  0754b	99		 cdq
  0754c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07552	03 41 f8	 add	 eax, DWORD PTR [ecx-8]
  07555	13 51 fc	 adc	 edx, DWORD PTR [ecx-4]
  07558	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0755e	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  07561	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN2@P_linktona:

; 2509 : }

  07564	8b e5		 mov	 esp, ebp
  07566	5d		 pop	 ebp
  07567	c3		 ret	 0
_P_linktoname ENDP
; Function compile flags: /Odtp
_P_fetchname PROC

; 2512 : {

  07570	55		 push	 ebp
  07571	8b ec		 mov	 ebp, esp

; 2513 :     Sl(2);			      /* nfa string -- */

  07573	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  07578	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0757e	c1 f8 03	 sar	 eax, 3
  07581	83 f8 02	 cmp	 eax, 2
  07584	7d 07		 jge	 SHORT $LN5@P_fetchnam
  07586	e8 00 00 00 00	 call	 _stakunder
  0758b	eb 7f		 jmp	 SHORT $LN6@P_fetchnam
$LN5@P_fetchnam:

; 2514 :     Hpc(S0);

  0758d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07593	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  07596	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  0759c	72 10		 jb	 SHORT $LN3@P_fetchnam
  0759e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  075a3	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  075a6	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  075ac	72 07		 jb	 SHORT $LN4@P_fetchnam
$LN3@P_fetchnam:
  075ae	e8 00 00 00 00	 call	 _badpointer
  075b3	eb 57		 jmp	 SHORT $LN6@P_fetchnam
$LN4@P_fetchnam:

; 2515 :     Hpc(S1);

  075b5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  075bb	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  075be	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  075c4	72 11		 jb	 SHORT $LN1@P_fetchnam
  075c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  075cc	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  075cf	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  075d5	72 07		 jb	 SHORT $LN2@P_fetchnam
$LN1@P_fetchnam:
  075d7	e8 00 00 00 00	 call	 _badpointer
  075dc	eb 2e		 jmp	 SHORT $LN6@P_fetchnam
$LN2@P_fetchnam:

; 2516 :     /* Since the name buffers aren't in the system heap, but
; 2517 :        rather are separately allocated with alloc(), we can't
; 2518 :        check the name pointer references.  But, hey, if the user's
; 2519 :        futzing with word dictionary items on the heap in the first
; 2520 :        place, there's a billion other ways to bring us down at
; 2521 :        his command. */
; 2522 :     V strcpy((char *) S0, *((char **) S1) + 1);

  075de	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  075e3	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  075e6	8b 11		 mov	 edx, DWORD PTR [ecx]
  075e8	83 c2 01	 add	 edx, 1
  075eb	52		 push	 edx
  075ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  075f1	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  075f4	51		 push	 ecx
  075f5	e8 00 00 00 00	 call	 _strcpy
  075fa	83 c4 08	 add	 esp, 8

; 2523 :     Pop2;

  075fd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  07603	83 ea 10	 sub	 edx, 16			; 00000010H
  07606	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN6@P_fetchnam:

; 2524 : }

  0760c	5d		 pop	 ebp
  0760d	c3		 ret	 0
_P_fetchname ENDP
_TEXT	ENDS
EXTRN	_free:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_tflags$ = -5						; size = 1
_cp$ = -4						; size = 4
_P_storename PROC

; 2527 : {

  07610	55		 push	 ebp
  07611	8b ec		 mov	 ebp, esp
  07613	83 ec 08	 sub	 esp, 8

; 2528 :     char tflags;
; 2529 :     char *cp;
; 2530 : 
; 2531 :     Sl(2);			      /* string nfa -- */

  07616	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0761b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  07621	c1 f8 03	 sar	 eax, 3
  07624	83 f8 02	 cmp	 eax, 2
  07627	7d 0a		 jge	 SHORT $LN5@P_storenam
  07629	e8 00 00 00 00	 call	 _stakunder
  0762e	e9 d7 00 00 00	 jmp	 $LN6@P_storenam
$LN5@P_storenam:

; 2532 :     Hpc(S0);			      /* See comments in P_fetchname above */

  07633	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07639	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  0763c	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  07642	72 10		 jb	 SHORT $LN3@P_storenam
  07644	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  07649	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0764c	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  07652	72 0a		 jb	 SHORT $LN4@P_storenam
$LN3@P_storenam:
  07654	e8 00 00 00 00	 call	 _badpointer
  07659	e9 ac 00 00 00	 jmp	 $LN6@P_storenam
$LN4@P_storenam:

; 2533 :     Hpc(S1);			      /* checking name pointers */

  0765e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  07664	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  07667	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  0766d	72 11		 jb	 SHORT $LN1@P_storenam
  0766f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07675	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  07678	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  0767e	72 0a		 jb	 SHORT $LN2@P_storenam
$LN1@P_storenam:
  07680	e8 00 00 00 00	 call	 _badpointer
  07685	e9 80 00 00 00	 jmp	 $LN6@P_storenam
$LN2@P_storenam:

; 2534 :     tflags = **((char **) S0);

  0768a	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0768f	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  07692	8b 11		 mov	 edx, DWORD PTR [ecx]
  07694	8a 02		 mov	 al, BYTE PTR [edx]
  07696	88 45 fb	 mov	 BYTE PTR _tflags$[ebp], al

; 2535 :     free(*((char **) S0));

  07699	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0769f	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  076a2	8b 02		 mov	 eax, DWORD PTR [edx]
  076a4	50		 push	 eax
  076a5	e8 00 00 00 00	 call	 _free
  076aa	83 c4 04	 add	 esp, 4

; 2536 :     *((char **) S0) = cp = alloc((unsigned int) (strlen((char *) S1) + 2));

  076ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  076b3	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  076b6	52		 push	 edx
  076b7	e8 00 00 00 00	 call	 _strlen
  076bc	83 c4 04	 add	 esp, 4
  076bf	83 c0 02	 add	 eax, 2
  076c2	50		 push	 eax
  076c3	e8 00 00 00 00	 call	 _alloc
  076c8	83 c4 04	 add	 esp, 4
  076cb	89 45 fc	 mov	 DWORD PTR _cp$[ebp], eax
  076ce	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  076d3	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  076d6	8b 55 fc	 mov	 edx, DWORD PTR _cp$[ebp]
  076d9	89 11		 mov	 DWORD PTR [ecx], edx

; 2537 :     V strcpy(cp + 1, (char *) S1);

  076db	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  076e0	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  076e3	51		 push	 ecx
  076e4	8b 55 fc	 mov	 edx, DWORD PTR _cp$[ebp]
  076e7	83 c2 01	 add	 edx, 1
  076ea	52		 push	 edx
  076eb	e8 00 00 00 00	 call	 _strcpy
  076f0	83 c4 08	 add	 esp, 8

; 2538 :     *cp = tflags;

  076f3	8b 45 fc	 mov	 eax, DWORD PTR _cp$[ebp]
  076f6	8a 4d fb	 mov	 cl, BYTE PTR _tflags$[ebp]
  076f9	88 08		 mov	 BYTE PTR [eax], cl

; 2539 :     Pop2;

  076fb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  07701	83 ea 10	 sub	 edx, 16			; 00000010H
  07704	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN6@P_storenam:

; 2540 : }

  0770a	8b e5		 mov	 esp, ebp
  0770c	5d		 pop	 ebp
  0770d	c3		 ret	 0
_P_storename ENDP
_TEXT	ENDS
EXTRN	_abort:PROC
EXTRN	_malloc:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_cp$ = -4						; size = 4
_size$ = 8						; size = 4
_alloc	PROC

; 245  : {

  07710	55		 push	 ebp
  07711	8b ec		 mov	 ebp, esp
  07713	51		 push	 ecx

; 246  :     char *cp = malloc(size);

  07714	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  07717	50		 push	 eax
  07718	e8 00 00 00 00	 call	 _malloc
  0771d	83 c4 04	 add	 esp, 4
  07720	89 45 fc	 mov	 DWORD PTR _cp$[ebp], eax

; 247  : 
; 248  : /* printf("\nAlloc %u", size); */
; 249  :     if (cp == NULL) {

  07723	83 7d fc 00	 cmp	 DWORD PTR _cp$[ebp], 0
  07727	75 1f		 jne	 SHORT $LN1@alloc

; 250  :         V fprintf(stderr, "\n\nOut of memory!  %u bytes requested.\n", size);

  07729	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  0772c	51		 push	 ecx
  0772d	68 00 00 00 00	 push	 OFFSET $SG82923
  07732	e8 00 00 00 00	 call	 ___iob_func
  07737	83 c0 40	 add	 eax, 64			; 00000040H
  0773a	50		 push	 eax
  0773b	e8 00 00 00 00	 call	 _fprintf
  07740	83 c4 0c	 add	 esp, 12			; 0000000cH

; 251  : 	abort();

  07743	e8 00 00 00 00	 call	 _abort
$LN1@alloc:

; 252  :     }
; 253  :     return cp;

  07748	8b 45 fc	 mov	 eax, DWORD PTR _cp$[ebp]

; 254  : }

  0774b	8b e5		 mov	 esp, ebp
  0774d	5d		 pop	 ebp
  0774e	c3		 ret	 0
_alloc	ENDP
_TEXT	ENDS
EXTRN	_system:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_system PROC

; 2546 : {				      /* string -- status */

  07750	55		 push	 ebp
  07751	8b ec		 mov	 ebp, esp

; 2547 :     Sl(1);

  07753	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  07758	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  0775e	c1 f8 03	 sar	 eax, 3
  07761	83 f8 01	 cmp	 eax, 1
  07764	7d 07		 jge	 SHORT $LN3@P_system
  07766	e8 00 00 00 00	 call	 _stakunder
  0776b	eb 47		 jmp	 SHORT $LN4@P_system
$LN3@P_system:

; 2548 :     Hpc(S0);

  0776d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07773	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  07776	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heapbot
  0777c	72 10		 jb	 SHORT $LN1@P_system
  0777e	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  07783	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  07786	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  0778c	72 07		 jb	 SHORT $LN2@P_system
$LN1@P_system:
  0778e	e8 00 00 00 00	 call	 _badpointer
  07793	eb 1f		 jmp	 SHORT $LN4@P_system
$LN2@P_system:

; 2549 :     S0 = system((char *) S0);

  07795	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0779b	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  0779e	50		 push	 eax
  0779f	e8 00 00 00 00	 call	 _system
  077a4	83 c4 04	 add	 esp, 4
  077a7	99		 cdq
  077a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  077ae	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  077b1	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN4@P_system:

; 2550 : }

  077b4	5d		 pop	 ebp
  077b5	c3		 ret	 0
_P_system ENDP
; Function compile flags: /Odtp
tv69 = -8						; size = 4
tv74 = -4						; size = 4
_P_trace PROC

; 2555 : {

  077c0	55		 push	 ebp
  077c1	8b ec		 mov	 ebp, esp
  077c3	83 ec 08	 sub	 esp, 8

; 2556 :     Sl(1);

  077c6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  077cb	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  077d1	c1 f8 03	 sar	 eax, 3
  077d4	83 f8 01	 cmp	 eax, 1
  077d7	7d 07		 jge	 SHORT $LN1@P_trace
  077d9	e8 00 00 00 00	 call	 _stakunder
  077de	eb 45		 jmp	 SHORT $LN2@P_trace
$LN1@P_trace:

; 2557 :     atl_trace = (S0 == 0) ? Falsity : Truth;

  077e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  077e6	89 4d fc	 mov	 DWORD PTR tv74[ebp], ecx
  077e9	8b 55 fc	 mov	 edx, DWORD PTR tv74[ebp]
  077ec	8b 45 fc	 mov	 eax, DWORD PTR tv74[ebp]
  077ef	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  077f2	0b 48 fc	 or	 ecx, DWORD PTR [eax-4]
  077f5	75 09		 jne	 SHORT $LN4@P_trace
  077f7	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  077fe	eb 07		 jmp	 SHORT $LN5@P_trace
$LN4@P_trace:
  07800	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv69[ebp], -1
$LN5@P_trace:
  07807	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]
  0780a	99		 cdq
  0780b	a3 00 00 00 00	 mov	 DWORD PTR _atl_trace, eax
  07810	89 15 04 00 00
	00		 mov	 DWORD PTR _atl_trace+4, edx

; 2558 :     Pop;

  07816	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0781c	83 ea 08	 sub	 edx, 8
  0781f	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN2@P_trace:

; 2559 : }

  07825	8b e5		 mov	 esp, ebp
  07827	5d		 pop	 ebp
  07828	c3		 ret	 0
_P_trace ENDP
; Function compile flags: /Odtp
tv69 = -8						; size = 4
tv74 = -4						; size = 4
_P_walkback PROC

; 2564 : {

  07830	55		 push	 ebp
  07831	8b ec		 mov	 ebp, esp
  07833	83 ec 08	 sub	 esp, 8

; 2565 :     Sl(1);

  07836	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  0783b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _stack
  07841	c1 f8 03	 sar	 eax, 3
  07844	83 f8 01	 cmp	 eax, 1
  07847	7d 07		 jge	 SHORT $LN1@P_walkback
  07849	e8 00 00 00 00	 call	 _stakunder
  0784e	eb 45		 jmp	 SHORT $LN2@P_walkback
$LN1@P_walkback:

; 2566 :     atl_walkback = (S0 == 0) ? Falsity : Truth;

  07850	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07856	89 4d fc	 mov	 DWORD PTR tv74[ebp], ecx
  07859	8b 55 fc	 mov	 edx, DWORD PTR tv74[ebp]
  0785c	8b 45 fc	 mov	 eax, DWORD PTR tv74[ebp]
  0785f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  07862	0b 48 fc	 or	 ecx, DWORD PTR [eax-4]
  07865	75 09		 jne	 SHORT $LN4@P_walkback
  07867	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  0786e	eb 07		 jmp	 SHORT $LN5@P_walkback
$LN4@P_walkback:
  07870	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv69[ebp], -1
$LN5@P_walkback:
  07877	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]
  0787a	99		 cdq
  0787b	a3 00 00 00 00	 mov	 DWORD PTR _atl_walkback, eax
  07880	89 15 04 00 00
	00		 mov	 DWORD PTR _atl_walkback+4, edx

; 2567 :     Pop;

  07886	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  0788c	83 ea 08	 sub	 edx, 8
  0788f	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN2@P_walkback:

; 2568 : }

  07895	8b e5		 mov	 esp, ebp
  07897	5d		 pop	 ebp
  07898	c3		 ret	 0
_P_walkback ENDP
; Function compile flags: /Odtp
_dw$ = -4						; size = 4
_P_wordsused PROC

; 2574 : {

  078a0	55		 push	 ebp
  078a1	8b ec		 mov	 ebp, esp
  078a3	51		 push	 ecx

; 2575 :     dictword *dw = dict;

  078a4	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  078a9	89 45 fc	 mov	 DWORD PTR _dw$[ebp], eax
$LN3@P_wordsuse:

; 2576 : 
; 2577 :     while (dw != NULL) {

  078ac	83 7d fc 00	 cmp	 DWORD PTR _dw$[ebp], 0
  078b0	74 2f		 je	 SHORT $LN2@P_wordsuse

; 2578 : 	if (*(dw->wname) & WORDUSED) {

  078b2	8b 4d fc	 mov	 ecx, DWORD PTR _dw$[ebp]
  078b5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  078b8	0f be 02	 movsx	 eax, BYTE PTR [edx]
  078bb	83 e0 02	 and	 eax, 2
  078be	74 17		 je	 SHORT $LN1@P_wordsuse

; 2579 :            V printf("\n%s", dw->wname + 1);

  078c0	8b 4d fc	 mov	 ecx, DWORD PTR _dw$[ebp]
  078c3	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  078c6	83 c2 01	 add	 edx, 1
  078c9	52		 push	 edx
  078ca	68 00 00 00 00	 push	 OFFSET $SG84686
  078cf	e8 00 00 00 00	 call	 _printf
  078d4	83 c4 08	 add	 esp, 8
$LN1@P_wordsuse:

; 2580 : 	}
; 2581 : #ifdef Keyhit
; 2582 : 	if (kbquit()) {
; 2583 : 	    break;
; 2584 : 	}
; 2585 : #endif
; 2586 : 	dw = dw->wnext;

  078d7	8b 45 fc	 mov	 eax, DWORD PTR _dw$[ebp]
  078da	8b 08		 mov	 ecx, DWORD PTR [eax]
  078dc	89 4d fc	 mov	 DWORD PTR _dw$[ebp], ecx

; 2587 :     }

  078df	eb cb		 jmp	 SHORT $LN3@P_wordsuse
$LN2@P_wordsuse:

; 2588 :     V printf("\n");

  078e1	68 00 00 00 00	 push	 OFFSET $SG84688
  078e6	e8 00 00 00 00	 call	 _printf
  078eb	83 c4 04	 add	 esp, 4

; 2589 : }

  078ee	8b e5		 mov	 esp, ebp
  078f0	5d		 pop	 ebp
  078f1	c3		 ret	 0
_P_wordsused ENDP
; Function compile flags: /Odtp
_dw$ = -4						; size = 4
_P_wordsunused PROC

; 2592 : {

  07900	55		 push	 ebp
  07901	8b ec		 mov	 ebp, esp
  07903	51		 push	 ecx

; 2593 :     dictword *dw = dict;

  07904	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  07909	89 45 fc	 mov	 DWORD PTR _dw$[ebp], eax
$LN3@P_wordsunu:

; 2594 : 
; 2595 :     while (dw != NULL) {

  0790c	83 7d fc 00	 cmp	 DWORD PTR _dw$[ebp], 0
  07910	74 2f		 je	 SHORT $LN2@P_wordsunu

; 2596 : 	if (!(*(dw->wname) & WORDUSED)) {

  07912	8b 4d fc	 mov	 ecx, DWORD PTR _dw$[ebp]
  07915	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  07918	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0791b	83 e0 02	 and	 eax, 2
  0791e	75 17		 jne	 SHORT $LN1@P_wordsunu

; 2597 :            V printf("\n%s", dw->wname + 1);

  07920	8b 4d fc	 mov	 ecx, DWORD PTR _dw$[ebp]
  07923	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  07926	83 c2 01	 add	 edx, 1
  07929	52		 push	 edx
  0792a	68 00 00 00 00	 push	 OFFSET $SG84698
  0792f	e8 00 00 00 00	 call	 _printf
  07934	83 c4 08	 add	 esp, 8
$LN1@P_wordsunu:

; 2598 : 	}
; 2599 : #ifdef Keyhit
; 2600 : 	if (kbquit()) {
; 2601 : 	    break;
; 2602 : 	}
; 2603 : #endif
; 2604 : 	dw = dw->wnext;

  07937	8b 45 fc	 mov	 eax, DWORD PTR _dw$[ebp]
  0793a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0793c	89 4d fc	 mov	 DWORD PTR _dw$[ebp], ecx

; 2605 :     }

  0793f	eb cb		 jmp	 SHORT $LN3@P_wordsunu
$LN2@P_wordsunu:

; 2606 :     V printf("\n");

  07941	68 00 00 00 00	 push	 OFFSET $SG84700
  07946	e8 00 00 00 00	 call	 _printf
  0794b	83 c4 04	 add	 esp, 4

; 2607 : }

  0794e	8b e5		 mov	 esp, ebp
  07950	5d		 pop	 ebp
  07951	c3		 ret	 0
_P_wordsunused ENDP
; Function compile flags: /Odtp
tv66 = -4						; size = 4
_P_brackcompile PROC

; 2613 : {

  07960	55		 push	 ebp
  07961	8b ec		 mov	 ebp, esp
  07963	51		 push	 ecx

; 2614 :     Compiling;

  07964	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  07969	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0796c	8b 4d fc	 mov	 ecx, DWORD PTR tv66[ebp]
  0796f	8b 55 fc	 mov	 edx, DWORD PTR tv66[ebp]
  07972	8b 01		 mov	 eax, DWORD PTR [ecx]
  07974	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  07977	75 07		 jne	 SHORT $LN1@P_brackcom
  07979	e8 00 00 00 00	 call	 _notcomp
  0797e	eb 0a		 jmp	 SHORT $LN2@P_brackcom
$LN1@P_brackcom:

; 2615 :     cbrackpend = True;		      /* Set [COMPILE] pending */

  07980	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _cbrackpend, 1
$LN2@P_brackcom:

; 2616 : }

  0798a	8b e5		 mov	 esp, ebp
  0798c	5d		 pop	 ebp
  0798d	c3		 ret	 0
_P_brackcompile ENDP
_TEXT	ENDS
_BSS	SEGMENT
	ALIGN	8

_s_lit	DQ	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
tv75 = -4						; size = 4
_P_literal PROC

; 2619 : {

  07990	55		 push	 ebp
  07991	8b ec		 mov	 ebp, esp
  07993	51		 push	 ecx

; 2620 :     Compiling;

  07994	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  07999	89 45 fc	 mov	 DWORD PTR tv75[ebp], eax
  0799c	8b 4d fc	 mov	 ecx, DWORD PTR tv75[ebp]
  0799f	8b 55 fc	 mov	 edx, DWORD PTR tv75[ebp]
  079a2	8b 01		 mov	 eax, DWORD PTR [ecx]
  079a4	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  079a7	75 0a		 jne	 SHORT $LN3@P_literal
  079a9	e8 00 00 00 00	 call	 _notcomp
  079ae	e9 89 00 00 00	 jmp	 $LN4@P_literal
$LN3@P_literal:

; 2621 :     Sl(1);

  079b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  079b9	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _stack
  079bf	c1 f9 03	 sar	 ecx, 3
  079c2	83 f9 01	 cmp	 ecx, 1
  079c5	7d 07		 jge	 SHORT $LN2@P_literal
  079c7	e8 00 00 00 00	 call	 _stakunder
  079cc	eb 6e		 jmp	 SHORT $LN4@P_literal
$LN2@P_literal:

; 2622 :     Ho(2);

  079ce	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  079d4	83 c2 10	 add	 edx, 16			; 00000010H
  079d7	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  079dd	76 07		 jbe	 SHORT $LN1@P_literal
  079df	e8 00 00 00 00	 call	 _heapover
  079e4	eb 56		 jmp	 SHORT $LN4@P_literal
$LN1@P_literal:

; 2623 :     Hstore = s_lit;		      /* Compile load literal word */

  079e6	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  079eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_lit
  079f1	89 08		 mov	 DWORD PTR [eax], ecx
  079f3	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_lit+4
  079f9	89 50 04	 mov	 DWORD PTR [eax+4], edx
  079fc	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  07a01	83 c0 08	 add	 eax, 8
  07a04	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2624 :     Hstore = S0;		      /* Compile top of stack in line */

  07a09	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  07a0f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  07a15	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  07a18	89 01		 mov	 DWORD PTR [ecx], eax
  07a1a	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  07a1d	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  07a20	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  07a25	83 c0 08	 add	 eax, 8
  07a28	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2625 :     Pop;

  07a2d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07a33	83 e9 08	 sub	 ecx, 8
  07a36	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN4@P_literal:

; 2626 : }

  07a3c	8b e5		 mov	 esp, ebp
  07a3e	5d		 pop	 ebp
  07a3f	c3		 ret	 0
_P_literal ENDP
; Function compile flags: /Odtp
tv71 = -4						; size = 4
_P_compile PROC

; 2629 : {

  07a40	55		 push	 ebp
  07a41	8b ec		 mov	 ebp, esp
  07a43	51		 push	 ecx

; 2630 :     Compiling;

  07a44	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  07a49	89 45 fc	 mov	 DWORD PTR tv71[ebp], eax
  07a4c	8b 4d fc	 mov	 ecx, DWORD PTR tv71[ebp]
  07a4f	8b 55 fc	 mov	 edx, DWORD PTR tv71[ebp]
  07a52	8b 01		 mov	 eax, DWORD PTR [ecx]
  07a54	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  07a57	75 07		 jne	 SHORT $LN2@P_compile
  07a59	e8 00 00 00 00	 call	 _notcomp
  07a5e	eb 48		 jmp	 SHORT $LN3@P_compile
$LN2@P_compile:

; 2631 :     Ho(1);

  07a60	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  07a66	83 c1 08	 add	 ecx, 8
  07a69	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  07a6f	76 07		 jbe	 SHORT $LN1@P_compile
  07a71	e8 00 00 00 00	 call	 _heapover
  07a76	eb 30		 jmp	 SHORT $LN3@P_compile
$LN1@P_compile:

; 2632 :     Hstore = (stackitem) *ip++;       /* Compile the next datum from the

  07a78	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ip
  07a7e	8b 02		 mov	 eax, DWORD PTR [edx]
  07a80	99		 cdq
  07a81	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  07a87	89 01		 mov	 DWORD PTR [ecx], eax
  07a89	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  07a8c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  07a92	83 c2 08	 add	 edx, 8
  07a95	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx
  07a9b	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  07aa0	83 c0 04	 add	 eax, 4
  07aa3	a3 00 00 00 00	 mov	 DWORD PTR _ip, eax
$LN3@P_compile:

; 2633 : 					 instruction stream. */
; 2634 : }

  07aa8	8b e5		 mov	 esp, ebp
  07aaa	5d		 pop	 ebp
  07aab	c3		 ret	 0
_P_compile ENDP
; Function compile flags: /Odtp
tv70 = -4						; size = 4
_P_backmark PROC

; 2637 : {

  07ab0	55		 push	 ebp
  07ab1	8b ec		 mov	 ebp, esp
  07ab3	51		 push	 ecx

; 2638 :     Compiling;

  07ab4	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  07ab9	89 45 fc	 mov	 DWORD PTR tv70[ebp], eax
  07abc	8b 4d fc	 mov	 ecx, DWORD PTR tv70[ebp]
  07abf	8b 55 fc	 mov	 edx, DWORD PTR tv70[ebp]
  07ac2	8b 01		 mov	 eax, DWORD PTR [ecx]
  07ac4	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  07ac7	75 07		 jne	 SHORT $LN2@P_backmark
  07ac9	e8 00 00 00 00	 call	 _notcomp
  07ace	eb 38		 jmp	 SHORT $LN3@P_backmark
$LN2@P_backmark:

; 2639 :     So(1);

  07ad0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07ad6	83 c1 08	 add	 ecx, 8
  07ad9	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _stacktop
  07adf	76 07		 jbe	 SHORT $LN1@P_backmark
  07ae1	e8 00 00 00 00	 call	 _stakover
  07ae6	eb 20		 jmp	 SHORT $LN3@P_backmark
$LN1@P_backmark:

; 2640 :     Push = (stackitem) hptr;	      /* Push heap address onto stack */

  07ae8	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  07aed	99		 cdq
  07aee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07af4	89 01		 mov	 DWORD PTR [ecx], eax
  07af6	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  07af9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  07aff	83 c2 08	 add	 edx, 8
  07b02	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN3@P_backmark:

; 2641 : }

  07b08	8b e5		 mov	 esp, ebp
  07b0a	5d		 pop	 ebp
  07b0b	c3		 ret	 0
_P_backmark ENDP
; Function compile flags: /Odtp
tv85 = -12						; size = 4
_offset$ = -8						; size = 8
_P_backresolve PROC

; 2644 : {

  07b10	55		 push	 ebp
  07b11	8b ec		 mov	 ebp, esp
  07b13	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2645 :     stackitem offset;
; 2646 : 
; 2647 :     Compiling;

  07b16	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  07b1b	89 45 f4	 mov	 DWORD PTR tv85[ebp], eax
  07b1e	8b 4d f4	 mov	 ecx, DWORD PTR tv85[ebp]
  07b21	8b 55 f4	 mov	 edx, DWORD PTR tv85[ebp]
  07b24	8b 01		 mov	 eax, DWORD PTR [ecx]
  07b26	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  07b29	75 0a		 jne	 SHORT $LN5@P_backreso
  07b2b	e8 00 00 00 00	 call	 _notcomp
  07b30	e9 a6 00 00 00	 jmp	 $LN6@P_backreso
$LN5@P_backreso:

; 2648 :     Sl(1);

  07b35	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07b3b	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _stack
  07b41	c1 f9 03	 sar	 ecx, 3
  07b44	83 f9 01	 cmp	 ecx, 1
  07b47	7d 0a		 jge	 SHORT $LN4@P_backreso
  07b49	e8 00 00 00 00	 call	 _stakunder
  07b4e	e9 88 00 00 00	 jmp	 $LN6@P_backreso
$LN4@P_backreso:

; 2649 :     Ho(1);

  07b53	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  07b59	83 c2 08	 add	 edx, 8
  07b5c	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  07b62	76 07		 jbe	 SHORT $LN3@P_backreso
  07b64	e8 00 00 00 00	 call	 _heapover
  07b69	eb 70		 jmp	 SHORT $LN6@P_backreso
$LN3@P_backreso:

; 2650 :     Hpc(S0);

  07b6b	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  07b70	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  07b73	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heapbot
  07b79	72 11		 jb	 SHORT $LN1@P_backreso
  07b7b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  07b81	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  07b84	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  07b8a	72 07		 jb	 SHORT $LN2@P_backreso
$LN1@P_backreso:
  07b8c	e8 00 00 00 00	 call	 _badpointer
  07b91	eb 48		 jmp	 SHORT $LN6@P_backreso
$LN2@P_backreso:

; 2651 :     offset = -(hptr - (stackitem *) S0);

  07b93	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07b99	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  07b9c	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  07ba1	2b c2		 sub	 eax, edx
  07ba3	c1 f8 03	 sar	 eax, 3
  07ba6	f7 d8		 neg	 eax
  07ba8	99		 cdq
  07ba9	89 45 f8	 mov	 DWORD PTR _offset$[ebp], eax
  07bac	89 55 fc	 mov	 DWORD PTR _offset$[ebp+4], edx

; 2652 :     Hstore = offset;

  07baf	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  07bb4	8b 4d f8	 mov	 ecx, DWORD PTR _offset$[ebp]
  07bb7	89 08		 mov	 DWORD PTR [eax], ecx
  07bb9	8b 55 fc	 mov	 edx, DWORD PTR _offset$[ebp+4]
  07bbc	89 50 04	 mov	 DWORD PTR [eax+4], edx
  07bbf	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  07bc4	83 c0 08	 add	 eax, 8
  07bc7	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 2653 :     Pop;

  07bcc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07bd2	83 e9 08	 sub	 ecx, 8
  07bd5	89 0d 00 00 00
	00		 mov	 DWORD PTR _stk, ecx
$LN6@P_backreso:

; 2654 : }

  07bdb	8b e5		 mov	 esp, ebp
  07bdd	5d		 pop	 ebp
  07bde	c3		 ret	 0
_P_backresolve ENDP
; Function compile flags: /Odtp
tv71 = -4						; size = 4
_P_fwdmark PROC

; 2657 : {

  07be0	55		 push	 ebp
  07be1	8b ec		 mov	 ebp, esp
  07be3	51		 push	 ecx

; 2658 :     Compiling;

  07be4	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  07be9	89 45 fc	 mov	 DWORD PTR tv71[ebp], eax
  07bec	8b 4d fc	 mov	 ecx, DWORD PTR tv71[ebp]
  07bef	8b 55 fc	 mov	 edx, DWORD PTR tv71[ebp]
  07bf2	8b 01		 mov	 eax, DWORD PTR [ecx]
  07bf4	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  07bf7	75 07		 jne	 SHORT $LN2@P_fwdmark
  07bf9	e8 00 00 00 00	 call	 _notcomp
  07bfe	eb 59		 jmp	 SHORT $LN3@P_fwdmark
$LN2@P_fwdmark:

; 2659 :     Ho(1);

  07c00	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  07c06	83 c1 08	 add	 ecx, 8
  07c09	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  07c0f	76 07		 jbe	 SHORT $LN1@P_fwdmark
  07c11	e8 00 00 00 00	 call	 _heapover
  07c16	eb 41		 jmp	 SHORT $LN3@P_fwdmark
$LN1@P_fwdmark:

; 2660 :     Push = (stackitem) hptr;	      /* Push heap address onto stack */

  07c18	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  07c1d	99		 cdq
  07c1e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07c24	89 01		 mov	 DWORD PTR [ecx], eax
  07c26	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  07c29	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  07c2f	83 c2 08	 add	 edx, 8
  07c32	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 2661 :     Hstore = 0;

  07c38	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  07c3d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  07c43	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  07c4a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  07c50	83 c1 08	 add	 ecx, 8
  07c53	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx
$LN3@P_fwdmark:

; 2662 : }

  07c59	8b e5		 mov	 esp, ebp
  07c5b	5d		 pop	 ebp
  07c5c	c3		 ret	 0
_P_fwdmark ENDP
; Function compile flags: /Odtp
tv83 = -12						; size = 4
_offset$ = -8						; size = 8
_P_fwdresolve PROC

; 2665 : {

  07c60	55		 push	 ebp
  07c61	8b ec		 mov	 ebp, esp
  07c63	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2666 :     stackitem offset;
; 2667 : 
; 2668 :     Compiling;

  07c66	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  07c6b	89 45 f4	 mov	 DWORD PTR tv83[ebp], eax
  07c6e	8b 4d f4	 mov	 ecx, DWORD PTR tv83[ebp]
  07c71	8b 55 f4	 mov	 edx, DWORD PTR tv83[ebp]
  07c74	8b 01		 mov	 eax, DWORD PTR [ecx]
  07c76	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  07c79	75 07		 jne	 SHORT $LN4@P_fwdresol
  07c7b	e8 00 00 00 00	 call	 _notcomp
  07c80	eb 7e		 jmp	 SHORT $LN5@P_fwdresol
$LN4@P_fwdresol:

; 2669 :     Sl(1);

  07c82	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07c88	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _stack
  07c8e	c1 f9 03	 sar	 ecx, 3
  07c91	83 f9 01	 cmp	 ecx, 1
  07c94	7d 07		 jge	 SHORT $LN3@P_fwdresol
  07c96	e8 00 00 00 00	 call	 _stakunder
  07c9b	eb 63		 jmp	 SHORT $LN5@P_fwdresol
$LN3@P_fwdresol:

; 2670 :     Hpc(S0);

  07c9d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  07ca3	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  07ca6	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heapbot
  07cac	72 11		 jb	 SHORT $LN1@P_fwdresol
  07cae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  07cb4	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  07cb7	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  07cbd	72 07		 jb	 SHORT $LN2@P_fwdresol
$LN1@P_fwdresol:
  07cbf	e8 00 00 00 00	 call	 _badpointer
  07cc4	eb 3a		 jmp	 SHORT $LN5@P_fwdresol
$LN2@P_fwdresol:

; 2671 :     offset = (hptr - (stackitem *) S0);

  07cc6	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  07ccb	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  07cce	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  07cd3	2b c1		 sub	 eax, ecx
  07cd5	c1 f8 03	 sar	 eax, 3
  07cd8	99		 cdq
  07cd9	89 45 f8	 mov	 DWORD PTR _offset$[ebp], eax
  07cdc	89 55 fc	 mov	 DWORD PTR _offset$[ebp+4], edx

; 2672 :     *((stackitem *) S0) = offset;

  07cdf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  07ce5	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  07ce8	8b 4d f8	 mov	 ecx, DWORD PTR _offset$[ebp]
  07ceb	89 08		 mov	 DWORD PTR [eax], ecx
  07ced	8b 55 fc	 mov	 edx, DWORD PTR _offset$[ebp+4]
  07cf0	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 2673 :     Pop;

  07cf3	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  07cf8	83 e8 08	 sub	 eax, 8
  07cfb	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax
$LN5@P_fwdresol:

; 2674 : }

  07d00	8b e5		 mov	 esp, ebp
  07d02	5d		 pop	 ebp
  07d03	c3		 ret	 0
_P_fwdresolve ENDP
; Function compile flags: /Odtp
_wb$84975 = -4						; size = 4
_pwalkback PROC

; 3023 : {

  07d10	55		 push	 ebp
  07d11	8b ec		 mov	 ebp, esp
  07d13	51		 push	 ecx

; 3024 :     if (atl_walkback && ((curword != NULL) || (wbptr > wback))) {

  07d14	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_walkback
  07d19	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _atl_walkback+4
  07d1f	0f 84 87 00 00
	00		 je	 $LN6@pwalkback
  07d25	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _curword, 0
  07d2c	75 0e		 jne	 SHORT $LN4@pwalkback
  07d2e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _wbptr
  07d34	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _wback
  07d3a	76 70		 jbe	 SHORT $LN6@pwalkback
$LN4@pwalkback:

; 3025 :         V printf("Walkback:\n");

  07d3c	68 00 00 00 00	 push	 OFFSET $SG84967
  07d41	e8 00 00 00 00	 call	 _printf
  07d46	83 c4 04	 add	 esp, 4

; 3026 : 	if (curword != NULL) {

  07d49	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _curword, 0
  07d50	74 1a		 je	 SHORT $LN2@pwalkback

; 3027 :             V printf("   %s\n", curword->wname + 1);

  07d52	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _curword
  07d58	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  07d5b	83 c0 01	 add	 eax, 1
  07d5e	50		 push	 eax
  07d5f	68 00 00 00 00	 push	 OFFSET $SG84971
  07d64	e8 00 00 00 00	 call	 _printf
  07d69	83 c4 08	 add	 esp, 8
$LN2@pwalkback:

; 3028 : 	}
; 3029 : 	while (wbptr > wback) {

  07d6c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _wbptr
  07d72	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _wback
  07d78	76 32		 jbe	 SHORT $LN6@pwalkback

; 3030 : 	    dictword *wb = *(--wbptr);

  07d7a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _wbptr
  07d80	83 ea 04	 sub	 edx, 4
  07d83	89 15 00 00 00
	00		 mov	 DWORD PTR _wbptr, edx
  07d89	a1 00 00 00 00	 mov	 eax, DWORD PTR _wbptr
  07d8e	8b 08		 mov	 ecx, DWORD PTR [eax]
  07d90	89 4d fc	 mov	 DWORD PTR _wb$84975[ebp], ecx

; 3031 :             V printf("   %s\n", wb->wname + 1);

  07d93	8b 55 fc	 mov	 edx, DWORD PTR _wb$84975[ebp]
  07d96	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  07d99	83 c0 01	 add	 eax, 1
  07d9c	50		 push	 eax
  07d9d	68 00 00 00 00	 push	 OFFSET $SG84977
  07da2	e8 00 00 00 00	 call	 _printf
  07da7	83 c4 08	 add	 esp, 8

; 3032 : 	}

  07daa	eb c0		 jmp	 SHORT $LN2@pwalkback
$LN6@pwalkback:

; 3033 :     }
; 3034 : }

  07dac	8b e5		 mov	 esp, ebp
  07dae	5d		 pop	 ebp
  07daf	c3		 ret	 0
_pwalkback ENDP
; Function compile flags: /Odtp
_kind$ = 8						; size = 4
_trouble PROC

; 3041 : {

  07db0	55		 push	 ebp
  07db1	8b ec		 mov	 ebp, esp

; 3042 : #ifdef MEMMESSAGE
; 3043 :     V printf("\n%s.\n", kind);

  07db3	8b 45 08	 mov	 eax, DWORD PTR _kind$[ebp]
  07db6	50		 push	 eax
  07db7	68 00 00 00 00	 push	 OFFSET $SG84982
  07dbc	e8 00 00 00 00	 call	 _printf
  07dc1	83 c4 08	 add	 esp, 8

; 3044 : #endif
; 3045 : #ifdef WALKBACK
; 3046 :     pwalkback();

  07dc4	e8 00 00 00 00	 call	 _pwalkback

; 3047 : #endif /* WALKBACK */
; 3048 :     P_abort();			      /* Abort */

  07dc9	e8 00 00 00 00	 call	 _P_abort

; 3049 :     atl_comment = state = Falsity;    /* Reset all interpretation state */

  07dce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _heap
  07dd4	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  07dda	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  07de1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl_comment, 0
  07deb	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl_comment+4, 0

; 3050 :     forgetpend = defpend = stringlit =
; 3051 : 	tickpend = ctickpend = False;

  07df5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ctickpend, 0
  07dff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ctickpend
  07e05	89 15 00 00 00
	00		 mov	 DWORD PTR _tickpend, edx
  07e0b	a1 00 00 00 00	 mov	 eax, DWORD PTR _tickpend
  07e10	a3 00 00 00 00	 mov	 DWORD PTR _stringlit, eax
  07e15	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stringlit
  07e1b	89 0d 00 00 00
	00		 mov	 DWORD PTR _defpend, ecx
  07e21	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _defpend
  07e27	89 15 00 00 00
	00		 mov	 DWORD PTR _forgetpend, edx

; 3052 : }

  07e2d	5d		 pop	 ebp
  07e2e	c3		 ret	 0
_trouble ENDP
; Function compile flags: /Odtp
_stakover PROC

; 3068 : {

  07e30	55		 push	 ebp
  07e31	8b ec		 mov	 ebp, esp

; 3069 :     trouble("Stack overflow");

  07e33	68 00 00 00 00	 push	 OFFSET $SG84987
  07e38	e8 00 00 00 00	 call	 _trouble
  07e3d	83 c4 04	 add	 esp, 4

; 3070 :     evalstat = ATL_STACKOVER;

  07e40	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _evalstat, -1

; 3071 : }

  07e4a	5d		 pop	 ebp
  07e4b	c3		 ret	 0
_stakover ENDP
; Function compile flags: /Odtp
_stakunder PROC

; 3076 : {

  07e50	55		 push	 ebp
  07e51	8b ec		 mov	 ebp, esp

; 3077 :     trouble("Stack underflow");

  07e53	68 00 00 00 00	 push	 OFFSET $SG84989
  07e58	e8 00 00 00 00	 call	 _trouble
  07e5d	83 c4 04	 add	 esp, 4

; 3078 :     evalstat = ATL_STACKUNDER;

  07e60	c7 05 00 00 00
	00 fe ff ff ff	 mov	 DWORD PTR _evalstat, -2	; fffffffeH

; 3079 : }

  07e6a	5d		 pop	 ebp
  07e6b	c3		 ret	 0
_stakunder ENDP
; Function compile flags: /Odtp
_rstakover PROC

; 3084 : {

  07e70	55		 push	 ebp
  07e71	8b ec		 mov	 ebp, esp

; 3085 :     trouble("Return stack overflow");

  07e73	68 00 00 00 00	 push	 OFFSET $SG84991
  07e78	e8 00 00 00 00	 call	 _trouble
  07e7d	83 c4 04	 add	 esp, 4

; 3086 :     evalstat = ATL_RSTACKOVER;

  07e80	c7 05 00 00 00
	00 fd ff ff ff	 mov	 DWORD PTR _evalstat, -3	; fffffffdH

; 3087 : }

  07e8a	5d		 pop	 ebp
  07e8b	c3		 ret	 0
_rstakover ENDP
; Function compile flags: /Odtp
_rstakunder PROC

; 3092 : {

  07e90	55		 push	 ebp
  07e91	8b ec		 mov	 ebp, esp

; 3093 :     trouble("Return stack underflow");

  07e93	68 00 00 00 00	 push	 OFFSET $SG84993
  07e98	e8 00 00 00 00	 call	 _trouble
  07e9d	83 c4 04	 add	 esp, 4

; 3094 :     evalstat = ATL_RSTACKUNDER;

  07ea0	c7 05 00 00 00
	00 fc ff ff ff	 mov	 DWORD PTR _evalstat, -4	; fffffffcH

; 3095 : }

  07eaa	5d		 pop	 ebp
  07eab	c3		 ret	 0
_rstakunder ENDP
; Function compile flags: /Odtp
_heapover PROC

; 3103 : {

  07eb0	55		 push	 ebp
  07eb1	8b ec		 mov	 ebp, esp

; 3104 :     trouble("Heap overflow");

  07eb3	68 00 00 00 00	 push	 OFFSET $SG84995
  07eb8	e8 00 00 00 00	 call	 _trouble
  07ebd	83 c4 04	 add	 esp, 4

; 3105 :     evalstat = ATL_HEAPOVER;

  07ec0	c7 05 00 00 00
	00 fb ff ff ff	 mov	 DWORD PTR _evalstat, -5	; fffffffbH

; 3106 : }

  07eca	5d		 pop	 ebp
  07ecb	c3		 ret	 0
_heapover ENDP
; Function compile flags: /Odtp
_badpointer PROC

; 3111 : {

  07ed0	55		 push	 ebp
  07ed1	8b ec		 mov	 ebp, esp

; 3112 :     trouble("Bad pointer");

  07ed3	68 00 00 00 00	 push	 OFFSET $SG84997
  07ed8	e8 00 00 00 00	 call	 _trouble
  07edd	83 c4 04	 add	 esp, 4

; 3113 :     evalstat = ATL_BADPOINTER;

  07ee0	c7 05 00 00 00
	00 fa ff ff ff	 mov	 DWORD PTR _evalstat, -6	; fffffffaH

; 3114 : }

  07eea	5d		 pop	 ebp
  07eeb	c3		 ret	 0
_badpointer ENDP
; Function compile flags: /Odtp
_notcomp PROC

; 3119 : {

  07ef0	55		 push	 ebp
  07ef1	8b ec		 mov	 ebp, esp

; 3120 :     trouble("Compiler word outside definition");

  07ef3	68 00 00 00 00	 push	 OFFSET $SG84999
  07ef8	e8 00 00 00 00	 call	 _trouble
  07efd	83 c4 04	 add	 esp, 4

; 3121 :     evalstat = ATL_NOTINDEF;

  07f00	c7 05 00 00 00
	00 f7 ff ff ff	 mov	 DWORD PTR _evalstat, -9	; fffffff7H

; 3122 : }

  07f0a	5d		 pop	 ebp
  07f0b	c3		 ret	 0
_notcomp ENDP
; Function compile flags: /Odtp
_divzero PROC

; 3127 : {

  07f10	55		 push	 ebp
  07f11	8b ec		 mov	 ebp, esp

; 3128 :     trouble("Divide by zero");

  07f13	68 00 00 00 00	 push	 OFFSET $SG85001
  07f18	e8 00 00 00 00	 call	 _trouble
  07f1d	83 c4 04	 add	 esp, 4

; 3129 :     evalstat = ATL_DIVZERO;

  07f20	c7 05 00 00 00
	00 f3 ff ff ff	 mov	 DWORD PTR _evalstat, -13 ; fffffff3H

; 3130 : }

  07f2a	5d		 pop	 ebp
  07f2b	c3		 ret	 0
_divzero ENDP
; Function compile flags: /Odtp
_wp$ = 8						; size = 4
_exword	PROC

; 3138 : {

  07f30	55		 push	 ebp
  07f31	8b ec		 mov	 ebp, esp

; 3139 :     curword = wp;

  07f33	8b 45 08	 mov	 eax, DWORD PTR _wp$[ebp]
  07f36	a3 00 00 00 00	 mov	 DWORD PTR _curword, eax

; 3140 : #ifdef TRACE
; 3141 :     if (atl_trace) {

  07f3b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl_trace
  07f41	0b 0d 04 00 00
	00		 or	 ecx, DWORD PTR _atl_trace+4
  07f47	74 1a		 je	 SHORT $LN5@exword

; 3142 :         V printf("\nTrace: %s ", curword->wname + 1);

  07f49	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _curword
  07f4f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  07f52	83 c0 01	 add	 eax, 1
  07f55	50		 push	 eax
  07f56	68 00 00 00 00	 push	 OFFSET $SG85007
  07f5b	e8 00 00 00 00	 call	 _printf
  07f60	83 c4 08	 add	 esp, 8
$LN5@exword:

; 3143 :     }
; 3144 : #endif /* TRACE */
; 3145 :     (*curword->wcode)();	      /* Execute the first word */

  07f63	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _curword
  07f69	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  07f6c	ff d2		 call	 edx
$LN4@exword:

; 3146 :     while (ip != NULL) {

  07f6e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ip, 0
  07f75	74 71		 je	 SHORT $LN3@exword

; 3147 : #ifdef BREAK
; 3148 : #ifdef Keybreak
; 3149 : 	Keybreak();		      /* Poll for asynchronous interrupt */
; 3150 : #endif
; 3151 : 	if (broken) {		      /* Did we receive a break signal */

  07f77	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _broken, 0
  07f7e	74 19		 je	 SHORT $LN2@exword

; 3152 :             trouble("Break signal");

  07f80	68 00 00 00 00	 push	 OFFSET $SG85013
  07f85	e8 00 00 00 00	 call	 _trouble
  07f8a	83 c4 04	 add	 esp, 4

; 3153 : 	    evalstat = ATL_BREAK;

  07f8d	c7 05 00 00 00
	00 f4 ff ff ff	 mov	 DWORD PTR _evalstat, -12 ; fffffff4H

; 3154 : 	    break;

  07f97	eb 4f		 jmp	 SHORT $LN3@exword
$LN2@exword:

; 3155 : 	}
; 3156 : #endif /* BREAK */
; 3157 : 	curword = *ip++;

  07f99	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  07f9e	8b 08		 mov	 ecx, DWORD PTR [eax]
  07fa0	89 0d 00 00 00
	00		 mov	 DWORD PTR _curword, ecx
  07fa6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ip
  07fac	83 c2 04	 add	 edx, 4
  07faf	89 15 00 00 00
	00		 mov	 DWORD PTR _ip, edx

; 3158 : #ifdef TRACE
; 3159 : 	if (atl_trace) {

  07fb5	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_trace
  07fba	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _atl_trace+4
  07fc0	74 1a		 je	 SHORT $LN1@exword

; 3160 :             V printf("\nTrace: %s ", curword->wname + 1);

  07fc2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _curword
  07fc8	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  07fcb	83 c2 01	 add	 edx, 1
  07fce	52		 push	 edx
  07fcf	68 00 00 00 00	 push	 OFFSET $SG85016
  07fd4	e8 00 00 00 00	 call	 _printf
  07fd9	83 c4 08	 add	 esp, 8
$LN1@exword:

; 3161 : 	}
; 3162 : #endif /* TRACE */
; 3163 : 	(*curword->wcode)();	      /* Execute the next word */

  07fdc	a1 00 00 00 00	 mov	 eax, DWORD PTR _curword
  07fe1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  07fe4	ff d1		 call	 ecx

; 3164 :     }

  07fe6	eb 86		 jmp	 SHORT $LN4@exword
$LN3@exword:

; 3165 :     curword = NULL;

  07fe8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _curword, 0

; 3166 : }

  07ff2	5d		 pop	 ebp
  07ff3	c3		 ret	 0
_exword	ENDP
_TEXT	ENDS
PUBLIC	_atl_body
PUBLIC	_atl_vardef
PUBLIC	_atl_init
_BSS	SEGMENT
_rstackbot DD	01H DUP (?)
	ALIGN	8

_s_strlit DQ	01H DUP (?)
_s_flit	DQ	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
tv482 = -28						; size = 8
_si$85109 = -20						; size = 4
_dw$85102 = -16						; size = 4
_i$85101 = -12						; size = 4
_i$85074 = -8						; size = 4
_cp$85075 = -4						; size = 4
_atl_init PROC

; 3178 : {

  08000	55		 push	 ebp
  08001	8b ec		 mov	 ebp, esp
  08003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  08006	56		 push	 esi

; 3179 : 
; 3180 :     /* If any of the following three lines of code produce errors,
; 3181 :        you are probably trying to build on an architecture which
; 3182 :        violates the fundamental reuirement of 64-bit ATLAST that
; 3183 :        stack items, pointers, and real numbers are all 8 byte, 64-bit
; 3184 :        values.  If this is the case and you can't fix the problem by
; 3185 :        changing compiler memory model options, it's best to revert
; 3186 :        to the 32-bit version of ATLAST, which can be built on most
; 3187 :        systems (including 64-bit systems) by compiling and linking
; 3188 :        in 32-bit mode. */
; 3189 :     
; 3190 : /*
; 3191 :     MEMORY_MODEL_ERROR(sizeof(stackitem) != 8);
; 3192 :     MEMORY_MODEL_ERROR(sizeof(stackitem *) != 8);
; 3193 :     MEMORY_MODEL_ERROR(sizeof(atl_real) != 8);
; 3194 : */
; 3195 :     if (dict == NULL) {

  08007	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dict, 0
  0800e	0f 85 e2 04 00
	00		 jne	 $LN25@atl_init

; 3196 : 	atl_primdef(primt);	      /* Define primitive words */

  08014	68 00 00 00 00	 push	 OFFSET _primt
  08019	e8 00 00 00 00	 call	 _atl_primdef
  0801e	83 c4 04	 add	 esp, 4

; 3197 : 	dictprot = dict;	      /* Set protected mark in dictionary */

  08021	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  08026	a3 00 00 00 00	 mov	 DWORD PTR _dictprot, eax

; 3198 : 
; 3199 : 	/* Look up compiler-referenced words in the new dictionary and
; 3200 : 	   save their compile addresses in static variables. */
; 3201 : 
; 3202 : #define Cconst(cell, name)  cell = (stackitem) lookup(name); if(cell==0)abort()
; 3203 :         Cconst(s_exit, "EXIT");

  0802b	68 00 00 00 00	 push	 OFFSET $SG85022
  08030	e8 00 00 00 00	 call	 _lookup
  08035	83 c4 04	 add	 esp, 4
  08038	99		 cdq
  08039	a3 00 00 00 00	 mov	 DWORD PTR _s_exit, eax
  0803e	89 15 04 00 00
	00		 mov	 DWORD PTR _s_exit+4, edx
  08044	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_exit
  0804a	0b 0d 04 00 00
	00		 or	 ecx, DWORD PTR _s_exit+4
  08050	75 05		 jne	 SHORT $LN23@atl_init
  08052	e8 00 00 00 00	 call	 _abort
$LN23@atl_init:

; 3204 :         Cconst(s_lit, "(LIT)");

  08057	68 00 00 00 00	 push	 OFFSET $SG85025
  0805c	e8 00 00 00 00	 call	 _lookup
  08061	83 c4 04	 add	 esp, 4
  08064	99		 cdq
  08065	a3 00 00 00 00	 mov	 DWORD PTR _s_lit, eax
  0806a	89 15 04 00 00
	00		 mov	 DWORD PTR _s_lit+4, edx
  08070	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _s_lit
  08076	0b 15 04 00 00
	00		 or	 edx, DWORD PTR _s_lit+4
  0807c	75 05		 jne	 SHORT $LN22@atl_init
  0807e	e8 00 00 00 00	 call	 _abort
$LN22@atl_init:

; 3205 :         Cconst(s_flit, "(FLIT)");

  08083	68 00 00 00 00	 push	 OFFSET $SG85028
  08088	e8 00 00 00 00	 call	 _lookup
  0808d	83 c4 04	 add	 esp, 4
  08090	99		 cdq
  08091	a3 00 00 00 00	 mov	 DWORD PTR _s_flit, eax
  08096	89 15 04 00 00
	00		 mov	 DWORD PTR _s_flit+4, edx
  0809c	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_flit
  080a1	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _s_flit+4
  080a7	75 05		 jne	 SHORT $LN21@atl_init
  080a9	e8 00 00 00 00	 call	 _abort
$LN21@atl_init:

; 3206 :         Cconst(s_strlit, "(STRLIT)");

  080ae	68 00 00 00 00	 push	 OFFSET $SG85031
  080b3	e8 00 00 00 00	 call	 _lookup
  080b8	83 c4 04	 add	 esp, 4
  080bb	99		 cdq
  080bc	a3 00 00 00 00	 mov	 DWORD PTR _s_strlit, eax
  080c1	89 15 04 00 00
	00		 mov	 DWORD PTR _s_strlit+4, edx
  080c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_strlit
  080cd	0b 0d 04 00 00
	00		 or	 ecx, DWORD PTR _s_strlit+4
  080d3	75 05		 jne	 SHORT $LN20@atl_init
  080d5	e8 00 00 00 00	 call	 _abort
$LN20@atl_init:

; 3207 :         Cconst(s_dotparen, ".(");

  080da	68 00 00 00 00	 push	 OFFSET $SG85034
  080df	e8 00 00 00 00	 call	 _lookup
  080e4	83 c4 04	 add	 esp, 4
  080e7	99		 cdq
  080e8	a3 00 00 00 00	 mov	 DWORD PTR _s_dotparen, eax
  080ed	89 15 04 00 00
	00		 mov	 DWORD PTR _s_dotparen+4, edx
  080f3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _s_dotparen
  080f9	0b 15 04 00 00
	00		 or	 edx, DWORD PTR _s_dotparen+4
  080ff	75 05		 jne	 SHORT $LN19@atl_init
  08101	e8 00 00 00 00	 call	 _abort
$LN19@atl_init:

; 3208 :         Cconst(s_qbranch, "?BRANCH");

  08106	68 00 00 00 00	 push	 OFFSET $SG85037
  0810b	e8 00 00 00 00	 call	 _lookup
  08110	83 c4 04	 add	 esp, 4
  08113	99		 cdq
  08114	a3 00 00 00 00	 mov	 DWORD PTR _s_qbranch, eax
  08119	89 15 04 00 00
	00		 mov	 DWORD PTR _s_qbranch+4, edx
  0811f	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_qbranch
  08124	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _s_qbranch+4
  0812a	75 05		 jne	 SHORT $LN18@atl_init
  0812c	e8 00 00 00 00	 call	 _abort
$LN18@atl_init:

; 3209 :         Cconst(s_branch, "BRANCH");

  08131	68 00 00 00 00	 push	 OFFSET $SG85040
  08136	e8 00 00 00 00	 call	 _lookup
  0813b	83 c4 04	 add	 esp, 4
  0813e	99		 cdq
  0813f	a3 00 00 00 00	 mov	 DWORD PTR _s_branch, eax
  08144	89 15 04 00 00
	00		 mov	 DWORD PTR _s_branch+4, edx
  0814a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_branch
  08150	0b 0d 04 00 00
	00		 or	 ecx, DWORD PTR _s_branch+4
  08156	75 05		 jne	 SHORT $LN17@atl_init
  08158	e8 00 00 00 00	 call	 _abort
$LN17@atl_init:

; 3210 :         Cconst(s_xdo, "(XDO)");

  0815d	68 00 00 00 00	 push	 OFFSET $SG85043
  08162	e8 00 00 00 00	 call	 _lookup
  08167	83 c4 04	 add	 esp, 4
  0816a	99		 cdq
  0816b	a3 00 00 00 00	 mov	 DWORD PTR _s_xdo, eax
  08170	89 15 04 00 00
	00		 mov	 DWORD PTR _s_xdo+4, edx
  08176	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _s_xdo
  0817c	0b 15 04 00 00
	00		 or	 edx, DWORD PTR _s_xdo+4
  08182	75 05		 jne	 SHORT $LN16@atl_init
  08184	e8 00 00 00 00	 call	 _abort
$LN16@atl_init:

; 3211 :         Cconst(s_xqdo, "(X?DO)");

  08189	68 00 00 00 00	 push	 OFFSET $SG85046
  0818e	e8 00 00 00 00	 call	 _lookup
  08193	83 c4 04	 add	 esp, 4
  08196	99		 cdq
  08197	a3 00 00 00 00	 mov	 DWORD PTR _s_xqdo, eax
  0819c	89 15 04 00 00
	00		 mov	 DWORD PTR _s_xqdo+4, edx
  081a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_xqdo
  081a7	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _s_xqdo+4
  081ad	75 05		 jne	 SHORT $LN15@atl_init
  081af	e8 00 00 00 00	 call	 _abort
$LN15@atl_init:

; 3212 :         Cconst(s_xloop, "(XLOOP)");

  081b4	68 00 00 00 00	 push	 OFFSET $SG85049
  081b9	e8 00 00 00 00	 call	 _lookup
  081be	83 c4 04	 add	 esp, 4
  081c1	99		 cdq
  081c2	a3 00 00 00 00	 mov	 DWORD PTR _s_xloop, eax
  081c7	89 15 04 00 00
	00		 mov	 DWORD PTR _s_xloop+4, edx
  081cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_xloop
  081d3	0b 0d 04 00 00
	00		 or	 ecx, DWORD PTR _s_xloop+4
  081d9	75 05		 jne	 SHORT $LN14@atl_init
  081db	e8 00 00 00 00	 call	 _abort
$LN14@atl_init:

; 3213 :         Cconst(s_pxloop, "(+XLOOP)");

  081e0	68 00 00 00 00	 push	 OFFSET $SG85052
  081e5	e8 00 00 00 00	 call	 _lookup
  081ea	83 c4 04	 add	 esp, 4
  081ed	99		 cdq
  081ee	a3 00 00 00 00	 mov	 DWORD PTR _s_pxloop, eax
  081f3	89 15 04 00 00
	00		 mov	 DWORD PTR _s_pxloop+4, edx
  081f9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _s_pxloop
  081ff	0b 15 04 00 00
	00		 or	 edx, DWORD PTR _s_pxloop+4
  08205	75 05		 jne	 SHORT $LN13@atl_init
  08207	e8 00 00 00 00	 call	 _abort
$LN13@atl_init:

; 3214 :         Cconst(s_abortq, "ABORT\"");

  0820c	68 00 00 00 00	 push	 OFFSET $SG85055
  08211	e8 00 00 00 00	 call	 _lookup
  08216	83 c4 04	 add	 esp, 4
  08219	99		 cdq
  0821a	a3 00 00 00 00	 mov	 DWORD PTR _s_abortq, eax
  0821f	89 15 04 00 00
	00		 mov	 DWORD PTR _s_abortq+4, edx
  08225	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_abortq
  0822a	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _s_abortq+4
  08230	75 05		 jne	 SHORT $LN12@atl_init
  08232	e8 00 00 00 00	 call	 _abort
$LN12@atl_init:

; 3215 : #undef Cconst
; 3216 : 
; 3217 : 	if (stack == NULL) {	      /* Allocate stack if needed */

  08237	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _stack, 0
  0823e	75 17		 jne	 SHORT $LN11@atl_init

; 3218 : 	    stack = (stackitem *)
; 3219 : 		alloc(((unsigned int) atl_stklen) * sizeof(stackitem));

  08240	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl_stklen
  08246	c1 e1 03	 shl	 ecx, 3
  08249	51		 push	 ecx
  0824a	e8 00 00 00 00	 call	 _alloc
  0824f	83 c4 04	 add	 esp, 4
  08252	a3 00 00 00 00	 mov	 DWORD PTR _stack, eax
$LN11@atl_init:

; 3220 : 	}
; 3221 : 	stk = stackbot = stack;

  08257	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stack
  0825d	89 15 00 00 00
	00		 mov	 DWORD PTR _stackbot, edx
  08263	a1 00 00 00 00	 mov	 eax, DWORD PTR _stackbot
  08268	a3 00 00 00 00	 mov	 DWORD PTR _stk, eax

; 3222 : #ifdef MEMSTAT
; 3223 : 	stackmax = stack;
; 3224 : #endif
; 3225 : 	stacktop = stack + atl_stklen;

  0826d	6a 00		 push	 0
  0826f	6a 08		 push	 8
  08271	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _atl_stklen+4
  08277	51		 push	 ecx
  08278	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl_stklen
  0827e	52		 push	 edx
  0827f	e8 00 00 00 00	 call	 __allmul
  08284	03 05 00 00 00
	00		 add	 eax, DWORD PTR _stack
  0828a	a3 00 00 00 00	 mov	 DWORD PTR _stacktop, eax

; 3226 : 	if (rstack == NULL) {	      /* Allocate return stack if needed */

  0828f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _rstack, 0
  08296	75 16		 jne	 SHORT $LN10@atl_init

; 3227 : 	    rstack = (dictword ***)
; 3228 : 		alloc(((unsigned int) atl_rstklen) *
; 3229 : 		sizeof(dictword **));

  08298	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_rstklen
  0829d	c1 e0 02	 shl	 eax, 2
  082a0	50		 push	 eax
  082a1	e8 00 00 00 00	 call	 _alloc
  082a6	83 c4 04	 add	 esp, 4
  082a9	a3 00 00 00 00	 mov	 DWORD PTR _rstack, eax
$LN10@atl_init:

; 3230 : 	}
; 3231 : 	rstk = rstackbot = rstack;

  082ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstack
  082b4	89 0d 00 00 00
	00		 mov	 DWORD PTR _rstackbot, ecx
  082ba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstackbot
  082c0	89 15 00 00 00
	00		 mov	 DWORD PTR _rstk, edx

; 3232 : #ifdef MEMSTAT
; 3233 : 	rstackmax = rstack;
; 3234 : #endif
; 3235 : 	rstacktop = rstack + atl_rstklen;

  082c6	6a 00		 push	 0
  082c8	6a 04		 push	 4
  082ca	a1 04 00 00 00	 mov	 eax, DWORD PTR _atl_rstklen+4
  082cf	50		 push	 eax
  082d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl_rstklen
  082d6	51		 push	 ecx
  082d7	e8 00 00 00 00	 call	 __allmul
  082dc	03 05 00 00 00
	00		 add	 eax, DWORD PTR _rstack
  082e2	a3 00 00 00 00	 mov	 DWORD PTR _rstacktop, eax

; 3236 : #ifdef WALKBACK
; 3237 : 	if (wback == NULL) {

  082e7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _wback, 0
  082ee	75 17		 jne	 SHORT $LN9@atl_init

; 3238 : 	    wback = (dictword **) alloc(((unsigned int) atl_rstklen) *
; 3239 : 				    sizeof(dictword *));

  082f0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl_rstklen
  082f6	c1 e2 02	 shl	 edx, 2
  082f9	52		 push	 edx
  082fa	e8 00 00 00 00	 call	 _alloc
  082ff	83 c4 04	 add	 esp, 4
  08302	a3 00 00 00 00	 mov	 DWORD PTR _wback, eax
$LN9@atl_init:

; 3240 : 	}
; 3241 : 	wbptr = wback;

  08307	a1 00 00 00 00	 mov	 eax, DWORD PTR _wback
  0830c	a3 00 00 00 00	 mov	 DWORD PTR _wbptr, eax

; 3242 : #endif
; 3243 : 	if (heap == NULL) {

  08311	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _heap, 0
  08318	0f 85 f2 00 00
	00		 jne	 $LN8@atl_init

; 3244 : 
; 3245 : 	    /* The temporary string buffers are placed at the start of the
; 3246 : 	       heap, which permits us to pointer-check pointers into them
; 3247 : 	       as within the heap extents.  Hence, the size of the buffer
; 3248 : 	       we acquire for the heap is the sum of the heap and temporary
; 3249 : 	       string requests. */
; 3250 : 
; 3251 : 	    int i;
; 3252 : 	    char *cp;
; 3253 : 
; 3254 : 	    /* Force length of temporary strings to even number of
; 3255 : 	       stackitems. */
; 3256 : 	    atl_ltempstr += sizeof(stackitem) -
; 3257 : 		(atl_ltempstr % sizeof(stackitem));

  0831e	6a 00		 push	 0
  08320	6a 08		 push	 8
  08322	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _atl_ltempstr+4
  08328	51		 push	 ecx
  08329	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl_ltempstr
  0832f	52		 push	 edx
  08330	e8 00 00 00 00	 call	 __allrem
  08335	b9 08 00 00 00	 mov	 ecx, 8
  0833a	2b c8		 sub	 ecx, eax
  0833c	b8 00 00 00 00	 mov	 eax, 0
  08341	1b c2		 sbb	 eax, edx
  08343	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _atl_ltempstr
  08349	13 05 04 00 00
	00		 adc	 eax, DWORD PTR _atl_ltempstr+4
  0834f	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl_ltempstr, ecx
  08355	a3 04 00 00 00	 mov	 DWORD PTR _atl_ltempstr+4, eax

; 3258 : 	    cp = alloc((((unsigned int) atl_heaplen) * sizeof(stackitem)) +
; 3259 : 			((unsigned int) (atl_ntempstr * atl_ltempstr)));

  0835a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _atl_heaplen
  08360	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _atl_ltempstr+4
  08366	51		 push	 ecx
  08367	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl_ltempstr
  0836d	52		 push	 edx
  0836e	a1 04 00 00 00	 mov	 eax, DWORD PTR _atl_ntempstr+4
  08373	50		 push	 eax
  08374	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl_ntempstr
  0837a	51		 push	 ecx
  0837b	e8 00 00 00 00	 call	 __allmul
  08380	8d 14 f0	 lea	 edx, DWORD PTR [eax+esi*8]
  08383	52		 push	 edx
  08384	e8 00 00 00 00	 call	 _alloc
  08389	83 c4 04	 add	 esp, 4
  0838c	89 45 fc	 mov	 DWORD PTR _cp$85075[ebp], eax

; 3260 : 	    heapbot = (stackitem *) cp;

  0838f	8b 45 fc	 mov	 eax, DWORD PTR _cp$85075[ebp]
  08392	a3 00 00 00 00	 mov	 DWORD PTR _heapbot, eax

; 3261 : 	    strbuf = (char **) alloc(((unsigned int) atl_ntempstr) *
; 3262 : 				sizeof(char *));

  08397	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl_ntempstr
  0839d	c1 e1 02	 shl	 ecx, 2
  083a0	51		 push	 ecx
  083a1	e8 00 00 00 00	 call	 _alloc
  083a6	83 c4 04	 add	 esp, 4
  083a9	a3 00 00 00 00	 mov	 DWORD PTR _strbuf, eax

; 3263 : 	    for (i = 0; i < atl_ntempstr; i++) {

  083ae	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$85074[ebp], 0
  083b5	eb 09		 jmp	 SHORT $LN7@atl_init
$LN6@atl_init:
  083b7	8b 55 f8	 mov	 edx, DWORD PTR _i$85074[ebp]
  083ba	83 c2 01	 add	 edx, 1
  083bd	89 55 f8	 mov	 DWORD PTR _i$85074[ebp], edx
$LN7@atl_init:
  083c0	8b 45 f8	 mov	 eax, DWORD PTR _i$85074[ebp]
  083c3	99		 cdq
  083c4	89 45 e4	 mov	 DWORD PTR tv482[ebp], eax
  083c7	89 55 e8	 mov	 DWORD PTR tv482[ebp+4], edx
  083ca	8b 45 e8	 mov	 eax, DWORD PTR tv482[ebp+4]
  083cd	3b 05 04 00 00
	00		 cmp	 eax, DWORD PTR _atl_ntempstr+4
  083d3	7f 29		 jg	 SHORT $LN5@atl_init
  083d5	7c 0b		 jl	 SHORT $LN27@atl_init
  083d7	8b 4d e4	 mov	 ecx, DWORD PTR tv482[ebp]
  083da	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl_ntempstr
  083e0	73 1c		 jae	 SHORT $LN5@atl_init
$LN27@atl_init:

; 3264 : 		strbuf[i] = cp;

  083e2	8b 55 f8	 mov	 edx, DWORD PTR _i$85074[ebp]
  083e5	a1 00 00 00 00	 mov	 eax, DWORD PTR _strbuf
  083ea	8b 4d fc	 mov	 ecx, DWORD PTR _cp$85075[ebp]
  083ed	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 3265 : 		cp += ((unsigned int) atl_ltempstr);

  083f0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl_ltempstr
  083f6	03 55 fc	 add	 edx, DWORD PTR _cp$85075[ebp]
  083f9	89 55 fc	 mov	 DWORD PTR _cp$85075[ebp], edx

; 3266 : 	    }

  083fc	eb b9		 jmp	 SHORT $LN6@atl_init
$LN5@atl_init:

; 3267 : 	    cstrbuf = 0;

  083fe	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cstrbuf, 0

; 3268 : 	    heap = (stackitem *) cp;  /* Allocatable heap starts after

  08408	8b 45 fc	 mov	 eax, DWORD PTR _cp$85075[ebp]
  0840b	a3 00 00 00 00	 mov	 DWORD PTR _heap, eax
$LN8@atl_init:

; 3269 : 					 the temporary strings */
; 3270 : 	}
; 3271 : 	/* The system state word is kept in the first word of the heap
; 3272 :            so that pointer checking doesn't bounce references to it.
; 3273 : 	   When creating the heap, we preallocate this word and initialise
; 3274 : 	   the state to the interpretive state. */
; 3275 : 	hptr = heap + 1;

  08410	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _heap
  08416	83 c1 08	 add	 ecx, 8
  08419	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx

; 3276 : 	state = Falsity;

  0841f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _heap
  08425	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0842b	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 3277 : #ifdef MEMSTAT
; 3278 : 	heapmax = hptr;
; 3279 : #endif
; 3280 : 	heaptop = heap + atl_heaplen;

  08432	6a 00		 push	 0
  08434	6a 08		 push	 8
  08436	a1 04 00 00 00	 mov	 eax, DWORD PTR _atl_heaplen+4
  0843b	50		 push	 eax
  0843c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl_heaplen
  08442	51		 push	 ecx
  08443	e8 00 00 00 00	 call	 __allmul
  08448	03 05 00 00 00
	00		 add	 eax, DWORD PTR _heap
  0844e	a3 00 00 00 00	 mov	 DWORD PTR _heaptop, eax

; 3281 : 
; 3282 : 	/* Now that dynamic memory is up and running, allocate constants
; 3283 : 	   and variables built into the system.  */
; 3284 : 
; 3285 : #ifdef FILEIO
; 3286 : 	{   static struct {
; 3287 : 		char *sfn;
; 3288 : 		FILE *sfd;
; 3289 : 	    } stdfiles[] = {
; 3290 :                 {"STDIN", NULL},
; 3291 :                 {"STDOUT", NULL},
; 3292 :                 {"STDERR", NULL}
; 3293 : 	    };
; 3294 : 	    int i;
; 3295 : 	    dictword *dw;
; 3296 : 
; 3297 :     	    /* On some systems stdin, stdout, and stderr aren't
; 3298 : 	       constants which can appear in an initialisation.
; 3299 : 	       So, we initialise them at runtime here. */
; 3300 : 	       
; 3301 :     	    stdfiles[0].sfd = stdin;

  08453	e8 00 00 00 00	 call	 ___iob_func
  08458	a3 04 00 00 00	 mov	 DWORD PTR ?stdfiles@?8??atl_init@@9@9+4, eax

; 3302 : 	    stdfiles[1].sfd = stdout;

  0845d	e8 00 00 00 00	 call	 ___iob_func
  08462	83 c0 20	 add	 eax, 32			; 00000020H
  08465	a3 0c 00 00 00	 mov	 DWORD PTR ?stdfiles@?8??atl_init@@9@9+12, eax

; 3303 : 	    stdfiles[2].sfd = stderr;

  0846a	e8 00 00 00 00	 call	 ___iob_func
  0846f	83 c0 40	 add	 eax, 64			; 00000040H
  08472	a3 14 00 00 00	 mov	 DWORD PTR ?stdfiles@?8??atl_init@@9@9+20, eax

; 3304 : 	    
; 3305 : 	    for (i = 0; i < ELEMENTS(stdfiles); i++) {

  08477	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$85101[ebp], 0
  0847e	eb 09		 jmp	 SHORT $LN4@atl_init
$LN3@atl_init:
  08480	8b 55 f4	 mov	 edx, DWORD PTR _i$85101[ebp]
  08483	83 c2 01	 add	 edx, 1
  08486	89 55 f4	 mov	 DWORD PTR _i$85101[ebp], edx
$LN4@atl_init:
  08489	83 7d f4 03	 cmp	 DWORD PTR _i$85101[ebp], 3
  0848d	73 5b		 jae	 SHORT $LN2@atl_init

; 3306 : 		if ((dw = atl_vardef(stdfiles[i].sfn,
; 3307 : 			2 * sizeof(stackitem))) != NULL) {

  0848f	6a 10		 push	 16			; 00000010H
  08491	8b 45 f4	 mov	 eax, DWORD PTR _i$85101[ebp]
  08494	8b 0c c5 00 00
	00 00		 mov	 ecx, DWORD PTR ?stdfiles@?8??atl_init@@9@9[eax*8]
  0849b	51		 push	 ecx
  0849c	e8 00 00 00 00	 call	 _atl_vardef
  084a1	83 c4 08	 add	 esp, 8
  084a4	89 45 f0	 mov	 DWORD PTR _dw$85102[ebp], eax
  084a7	83 7d f0 00	 cmp	 DWORD PTR _dw$85102[ebp], 0
  084ab	74 3b		 je	 SHORT $LN1@atl_init

; 3308 : 		    stackitem *si = atl_body(dw);

  084ad	8b 55 f0	 mov	 edx, DWORD PTR _dw$85102[ebp]
  084b0	52		 push	 edx
  084b1	e8 00 00 00 00	 call	 _atl_body
  084b6	83 c4 04	 add	 esp, 4
  084b9	89 45 ec	 mov	 DWORD PTR _si$85109[ebp], eax

; 3309 : 		    *si++ = FileSent;

  084bc	8b 45 ec	 mov	 eax, DWORD PTR _si$85109[ebp]
  084bf	c7 00 9d df 1f
	83		 mov	 DWORD PTR [eax], -2095063139 ; 831fdf9dH
  084c5	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  084cc	8b 4d ec	 mov	 ecx, DWORD PTR _si$85109[ebp]
  084cf	83 c1 08	 add	 ecx, 8
  084d2	89 4d ec	 mov	 DWORD PTR _si$85109[ebp], ecx

; 3310 : 		    *si = (stackitem) stdfiles[i].sfd;

  084d5	8b 55 f4	 mov	 edx, DWORD PTR _i$85101[ebp]
  084d8	8b 04 d5 04 00
	00 00		 mov	 eax, DWORD PTR ?stdfiles@?8??atl_init@@9@9[edx*8+4]
  084df	99		 cdq
  084e0	8b 4d ec	 mov	 ecx, DWORD PTR _si$85109[ebp]
  084e3	89 01		 mov	 DWORD PTR [ecx], eax
  084e5	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN1@atl_init:

; 3311 : 		}
; 3312 : 	    }

  084e8	eb 96		 jmp	 SHORT $LN3@atl_init
$LN2@atl_init:

; 3313 : 	}
; 3314 : #endif /* FILEIO */
; 3315 : 	dictprot = dict;	      /* Protect all standard words */

  084ea	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dict
  084f0	89 15 00 00 00
	00		 mov	 DWORD PTR _dictprot, edx
$LN25@atl_init:

; 3316 :     }
; 3317 : }

  084f6	5e		 pop	 esi
  084f7	8b e5		 mov	 esp, ebp
  084f9	5d		 pop	 ebp
  084fa	c3		 ret	 0
_atl_init ENDP
; Function compile flags: /Odtp
_nw$ = -16						; size = 4
_pf$ = -12						; size = 4
_i$ = -8						; size = 4
_n$ = -4						; size = 4
_pt$ = 8						; size = 4
_atl_primdef PROC

; 2964 : {

  08500	55		 push	 ebp
  08501	8b ec		 mov	 ebp, esp
  08503	83 ec 10	 sub	 esp, 16			; 00000010H

; 2965 :     struct primfcn *pf = pt;

  08506	8b 45 08	 mov	 eax, DWORD PTR _pt$[ebp]
  08509	89 45 f4	 mov	 DWORD PTR _pf$[ebp], eax

; 2966 :     dictword *nw;
; 2967 :     int i, n = 0;

  0850c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
$LN6@atl_primde:

; 2968 : #ifdef WORDSUSED
; 2969 : #ifdef READONLYSTRINGS
; 2970 :     unsigned int nltotal;
; 2971 :     char *dynames, *cp;
; 2972 : #endif /* READONLYSTRINGS */
; 2973 : #endif /* WORDSUSED */
; 2974 : 
; 2975 :     /* Count the number of definitions in the table. */
; 2976 : 
; 2977 :     while (pf->pname != NULL) {

  08513	8b 4d f4	 mov	 ecx, DWORD PTR _pf$[ebp]
  08516	83 39 00	 cmp	 DWORD PTR [ecx], 0
  08519	74 14		 je	 SHORT $LN5@atl_primde

; 2978 : 	n++;

  0851b	8b 55 fc	 mov	 edx, DWORD PTR _n$[ebp]
  0851e	83 c2 01	 add	 edx, 1
  08521	89 55 fc	 mov	 DWORD PTR _n$[ebp], edx

; 2979 : 	pf++;

  08524	8b 45 f4	 mov	 eax, DWORD PTR _pf$[ebp]
  08527	83 c0 08	 add	 eax, 8
  0852a	89 45 f4	 mov	 DWORD PTR _pf$[ebp], eax

; 2980 :     }

  0852d	eb e4		 jmp	 SHORT $LN6@atl_primde
$LN5@atl_primde:

; 2981 : 
; 2982 : #ifdef WORDSUSED
; 2983 : #ifdef READONLYSTRINGS
; 2984 :     nltotal = n;
; 2985 :     for (i = 0; i < n; i++) {
; 2986 : 	nltotal += strlen(pt[i].pname);
; 2987 :     }
; 2988 :     cp = dynames = alloc(nltotal);
; 2989 :     for (i = 0; i < n; i++) {
; 2990 : 	strcpy(cp, pt[i].pname);
; 2991 : 	cp += strlen(cp) + 1;
; 2992 :     }
; 2993 :     cp = dynames;
; 2994 : #endif /* READONLYSTRINGS */
; 2995 : #endif /* WORDSUSED */
; 2996 : 
; 2997 :     nw = (dictword *) alloc((unsigned int) (n * sizeof(dictword)));

  0852f	8b 4d fc	 mov	 ecx, DWORD PTR _n$[ebp]
  08532	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  08535	51		 push	 ecx
  08536	e8 00 00 00 00	 call	 _alloc
  0853b	83 c4 04	 add	 esp, 4
  0853e	89 45 f0	 mov	 DWORD PTR _nw$[ebp], eax

; 2998 : 
; 2999 :     nw[n - 1].wnext = dict;

  08541	8b 55 fc	 mov	 edx, DWORD PTR _n$[ebp]
  08544	83 ea 01	 sub	 edx, 1
  08547	6b d2 0c	 imul	 edx, 12			; 0000000cH
  0854a	8b 45 f0	 mov	 eax, DWORD PTR _nw$[ebp]
  0854d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dict
  08553	89 0c 10	 mov	 DWORD PTR [eax+edx], ecx

; 3000 :     dict = nw;

  08556	8b 55 f0	 mov	 edx, DWORD PTR _nw$[ebp]
  08559	89 15 00 00 00
	00		 mov	 DWORD PTR _dict, edx

; 3001 :     for (i = 0; i < n; i++) {

  0855f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  08566	eb 09		 jmp	 SHORT $LN4@atl_primde
$LN3@atl_primde:
  08568	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0856b	83 c0 01	 add	 eax, 1
  0856e	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@atl_primde:
  08571	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  08574	3b 4d fc	 cmp	 ecx, DWORD PTR _n$[ebp]
  08577	7d 41		 jge	 SHORT $LN7@atl_primde

; 3002 : 	nw->wname = pt->pname;

  08579	8b 55 f0	 mov	 edx, DWORD PTR _nw$[ebp]
  0857c	8b 45 08	 mov	 eax, DWORD PTR _pt$[ebp]
  0857f	8b 08		 mov	 ecx, DWORD PTR [eax]
  08581	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 3003 : #ifdef WORDSUSED
; 3004 : #ifdef READONLYSTRINGS
; 3005 :     	nw->wname = cp;
; 3006 : 	cp += strlen(cp) + 1;
; 3007 : #endif /* READONLYSTRINGS */
; 3008 : #endif /* WORDSUSED */
; 3009 : 	nw->wcode = pt->pcode;

  08584	8b 55 f0	 mov	 edx, DWORD PTR _nw$[ebp]
  08587	8b 45 08	 mov	 eax, DWORD PTR _pt$[ebp]
  0858a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0858d	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 3010 : 	if (i != (n - 1)) {

  08590	8b 55 fc	 mov	 edx, DWORD PTR _n$[ebp]
  08593	83 ea 01	 sub	 edx, 1
  08596	39 55 f8	 cmp	 DWORD PTR _i$[ebp], edx
  08599	74 0b		 je	 SHORT $LN1@atl_primde

; 3011 : 	    nw->wnext = nw + 1;

  0859b	8b 45 f0	 mov	 eax, DWORD PTR _nw$[ebp]
  0859e	83 c0 0c	 add	 eax, 12			; 0000000cH
  085a1	8b 4d f0	 mov	 ecx, DWORD PTR _nw$[ebp]
  085a4	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@atl_primde:

; 3012 : 	}
; 3013 : 	nw++;

  085a6	8b 55 f0	 mov	 edx, DWORD PTR _nw$[ebp]
  085a9	83 c2 0c	 add	 edx, 12			; 0000000cH
  085ac	89 55 f0	 mov	 DWORD PTR _nw$[ebp], edx

; 3014 : 	pt++;

  085af	8b 45 08	 mov	 eax, DWORD PTR _pt$[ebp]
  085b2	83 c0 08	 add	 eax, 8
  085b5	89 45 08	 mov	 DWORD PTR _pt$[ebp], eax

; 3015 :     }

  085b8	eb ae		 jmp	 SHORT $LN3@atl_primde
$LN7@atl_primde:

; 3016 : }

  085ba	8b e5		 mov	 esp, ebp
  085bc	5d		 pop	 ebp
  085bd	c3		 ret	 0
_atl_primdef ENDP
_TEXT	ENDS
PUBLIC	_atl_lookup
; Function compile flags: /Odtp
_TEXT	SEGMENT
_name$ = 8						; size = 4
_atl_lookup PROC

; 3325 : {

  085c0	55		 push	 ebp
  085c1	8b ec		 mov	 ebp, esp

; 3326 :     V strcpy(tokbuf, name);	      /* Use built-in token buffer... */

  085c3	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  085c6	50		 push	 eax
  085c7	68 00 00 00 00	 push	 OFFSET _tokbuf
  085cc	e8 00 00 00 00	 call	 _strcpy
  085d1	83 c4 08	 add	 esp, 8

; 3327 :     ucase(tokbuf);                    /* so ucase() doesn't wreck arg string */

  085d4	68 00 00 00 00	 push	 OFFSET _tokbuf
  085d9	e8 00 00 00 00	 call	 _ucase
  085de	83 c4 04	 add	 esp, 4

; 3328 :     return lookup(tokbuf);	      /* Now use normal lookup() on it */

  085e1	68 00 00 00 00	 push	 OFFSET _tokbuf
  085e6	e8 00 00 00 00	 call	 _lookup
  085eb	83 c4 04	 add	 esp, 4

; 3329 : }

  085ee	5d		 pop	 ebp
  085ef	c3		 ret	 0
_atl_lookup ENDP
; Function compile flags: /Odtp
_dw$ = 8						; size = 4
_atl_body PROC

; 3336 : {

  085f0	55		 push	 ebp
  085f1	8b ec		 mov	 ebp, esp

; 3337 :     return ((stackitem *) dw) + Dictwordl;

  085f3	8b 45 08	 mov	 eax, DWORD PTR _dw$[ebp]
  085f6	83 c0 10	 add	 eax, 16			; 00000010H

; 3338 : }

  085f9	5d		 pop	 ebp
  085fa	c3		 ret	 0
_atl_body ENDP
_TEXT	ENDS
PUBLIC	_atl_exec
; Function compile flags: /Odtp
_TEXT	SEGMENT
_sestat$ = -8						; size = 4
_restat$ = -4						; size = 4
_dw$ = 8						; size = 4
_atl_exec PROC

; 3347 : {

  08600	55		 push	 ebp
  08601	8b ec		 mov	 ebp, esp
  08603	83 ec 08	 sub	 esp, 8

; 3348 :     int sestat = evalstat, restat;

  08606	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  0860b	89 45 f8	 mov	 DWORD PTR _sestat$[ebp], eax

; 3349 : 
; 3350 :     evalstat = ATL_SNORM;

  0860e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _evalstat, 0

; 3351 : #ifdef BREAK
; 3352 :     broken = False;		      /* Reset break received */

  08618	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _broken, 0

; 3353 : #endif
; 3354 : #undef Memerrs
; 3355 : #define Memerrs evalstat
; 3356 :     Rso(1);

  08622	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  08628	83 c1 04	 add	 ecx, 4
  0862b	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _rstacktop
  08631	76 0f		 jbe	 SHORT $LN3@atl_exec
  08633	e8 00 00 00 00	 call	 _rstakover
  08638	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  0863d	e9 8b 00 00 00	 jmp	 $LN4@atl_exec
$LN3@atl_exec:

; 3357 :     Rpush = ip; 		      /* Push instruction pointer */

  08642	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  08648	a1 00 00 00 00	 mov	 eax, DWORD PTR _ip
  0864d	89 02		 mov	 DWORD PTR [edx], eax
  0864f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  08655	83 c1 04	 add	 ecx, 4
  08658	89 0d 00 00 00
	00		 mov	 DWORD PTR _rstk, ecx

; 3358 :     ip = NULL;			      /* Keep exword from running away */

  0865e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ip, 0

; 3359 :     exword(dw);

  08668	8b 55 08	 mov	 edx, DWORD PTR _dw$[ebp]
  0866b	52		 push	 edx
  0866c	e8 00 00 00 00	 call	 _exword
  08671	83 c4 04	 add	 esp, 4

; 3360 :     if (evalstat == ATL_SNORM) {      /* If word ran to completion */

  08674	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _evalstat, 0
  0867b	75 3b		 jne	 SHORT $LN2@atl_exec

; 3361 : 	Rsl(1);

  0867d	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  08682	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _rstack
  08688	c1 f8 02	 sar	 eax, 2
  0868b	83 f8 01	 cmp	 eax, 1
  0868e	7d 0c		 jge	 SHORT $LN1@atl_exec
  08690	e8 00 00 00 00	 call	 _rstakunder
  08695	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  0869a	eb 31		 jmp	 SHORT $LN4@atl_exec
$LN1@atl_exec:

; 3362 : 	ip = R0;		      /* Pop the return stack */

  0869c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rstk
  086a2	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  086a5	89 15 00 00 00
	00		 mov	 DWORD PTR _ip, edx

; 3363 : 	Rpop;

  086ab	a1 00 00 00 00	 mov	 eax, DWORD PTR _rstk
  086b0	83 e8 04	 sub	 eax, 4
  086b3	a3 00 00 00 00	 mov	 DWORD PTR _rstk, eax
$LN2@atl_exec:

; 3364 :     }
; 3365 : #undef Memerrs
; 3366 : #define Memerrs
; 3367 :     restat = evalstat;

  086b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _evalstat
  086be	89 4d fc	 mov	 DWORD PTR _restat$[ebp], ecx

; 3368 :     evalstat = sestat;

  086c1	8b 55 f8	 mov	 edx, DWORD PTR _sestat$[ebp]
  086c4	89 15 00 00 00
	00		 mov	 DWORD PTR _evalstat, edx

; 3369 :     return restat;

  086ca	8b 45 fc	 mov	 eax, DWORD PTR _restat$[ebp]
$LN4@atl_exec:

; 3370 : }

  086cd	8b e5		 mov	 esp, ebp
  086cf	5d		 pop	 ebp
  086d0	c3		 ret	 0
_atl_exec ENDP
; Function compile flags: /Odtp
_isize$ = -8						; size = 4
_di$ = -4						; size = 4
_name$ = 8						; size = 4
_size$ = 12						; size = 4
_atl_vardef PROC

; 3383 : {

  086e0	55		 push	 ebp
  086e1	8b ec		 mov	 ebp, esp
  086e3	83 ec 08	 sub	 esp, 8

; 3384 :     dictword *di;
; 3385 :     int isize = (size + (sizeof(stackitem) - 1)) / sizeof(stackitem);

  086e6	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  086e9	83 c0 07	 add	 eax, 7
  086ec	c1 e8 03	 shr	 eax, 3
  086ef	89 45 f8	 mov	 DWORD PTR _isize$[ebp], eax

; 3386 : 
; 3387 : #undef Memerrs
; 3388 : #define Memerrs NULL
; 3389 :     evalstat = ATL_SNORM;

  086f2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _evalstat, 0

; 3390 :     Ho(Dictwordl + isize);

  086fc	8b 4d f8	 mov	 ecx, DWORD PTR _isize$[ebp]
  086ff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  08705	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  08709	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  0870f	76 0c		 jbe	 SHORT $LN4@atl_vardef
  08711	e8 00 00 00 00	 call	 _heapover
  08716	33 c0		 xor	 eax, eax
  08718	e9 aa 00 00 00	 jmp	 $LN5@atl_vardef
$LN4@atl_vardef:

; 3391 : #undef Memerrs
; 3392 : #define Memerrs
; 3393 :     if (evalstat != ATL_SNORM)	      /* Did the heap overflow */

  0871d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _evalstat, 0
  08724	74 07		 je	 SHORT $LN3@atl_vardef

; 3394 : 	return NULL;		      /* Yes.  Return NULL */

  08726	33 c0		 xor	 eax, eax
  08728	e9 9a 00 00 00	 jmp	 $LN5@atl_vardef
$LN3@atl_vardef:

; 3395 :     createword = (dictword *) hptr;   /* Develop address of word */

  0872d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  08733	89 0d 00 00 00
	00		 mov	 DWORD PTR _createword, ecx

; 3396 :     createword->wcode = P_var;	      /* Store default code */

  08739	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _createword
  0873f	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], OFFSET _P_var

; 3397 :     hptr += Dictwordl;		      /* Allocate heap space for word */

  08746	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0874b	83 c0 10	 add	 eax, 16			; 00000010H
  0874e	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax
$LN2@atl_vardef:

; 3398 :     while (isize > 0) {

  08753	83 7d f8 00	 cmp	 DWORD PTR _isize$[ebp], 0
  08757	7e 2d		 jle	 SHORT $LN1@atl_vardef

; 3399 : 	Hstore = 0;		      /* Allocate heap area and clear it */

  08759	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  0875f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  08765	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0876c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  08772	83 c2 08	 add	 edx, 8
  08775	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 3400 : 	isize--;

  0877b	8b 45 f8	 mov	 eax, DWORD PTR _isize$[ebp]
  0877e	83 e8 01	 sub	 eax, 1
  08781	89 45 f8	 mov	 DWORD PTR _isize$[ebp], eax

; 3401 :     }

  08784	eb cd		 jmp	 SHORT $LN2@atl_vardef
$LN1@atl_vardef:

; 3402 :     V strcpy(tokbuf, name);	      /* Use built-in token buffer... */

  08786	8b 4d 08	 mov	 ecx, DWORD PTR _name$[ebp]
  08789	51		 push	 ecx
  0878a	68 00 00 00 00	 push	 OFFSET _tokbuf
  0878f	e8 00 00 00 00	 call	 _strcpy
  08794	83 c4 08	 add	 esp, 8

; 3403 :     ucase(tokbuf);                    /* so ucase() doesn't wreck arg string */

  08797	68 00 00 00 00	 push	 OFFSET _tokbuf
  0879c	e8 00 00 00 00	 call	 _ucase
  087a1	83 c4 04	 add	 esp, 4

; 3404 :     enter(tokbuf);		      /* Make dictionary entry for it */

  087a4	68 00 00 00 00	 push	 OFFSET _tokbuf
  087a9	e8 00 00 00 00	 call	 _enter
  087ae	83 c4 04	 add	 esp, 4

; 3405 :     di = createword;		      /* Save word address */

  087b1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _createword
  087b7	89 55 fc	 mov	 DWORD PTR _di$[ebp], edx

; 3406 :     createword = NULL;		      /* Mark no word underway */

  087ba	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _createword, 0

; 3407 :     return di;			      /* Return new word */

  087c4	8b 45 fc	 mov	 eax, DWORD PTR _di$[ebp]
$LN5@atl_vardef:

; 3408 : }

  087c7	8b e5		 mov	 esp, ebp
  087c9	5d		 pop	 ebp
  087ca	c3		 ret	 0
_atl_vardef ENDP
; Function compile flags: /Odtp
_tkname$ = 8						; size = 4
_enter	PROC

; 547  : {

  087d0	55		 push	 ebp
  087d1	8b ec		 mov	 ebp, esp

; 548  :     /* Allocate name buffer */
; 549  :     createword->wname = alloc(((unsigned int) strlen(tkname) + 2));

  087d3	8b 45 08	 mov	 eax, DWORD PTR _tkname$[ebp]
  087d6	50		 push	 eax
  087d7	e8 00 00 00 00	 call	 _strlen
  087dc	83 c4 04	 add	 esp, 4
  087df	83 c0 02	 add	 eax, 2
  087e2	50		 push	 eax
  087e3	e8 00 00 00 00	 call	 _alloc
  087e8	83 c4 04	 add	 esp, 4
  087eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _createword
  087f1	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 550  :     createword->wname[0] = 0;	      /* Clear flags */

  087f4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _createword
  087fa	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  087fd	c6 00 00	 mov	 BYTE PTR [eax], 0

; 551  :     V strcpy(createword->wname + 1, tkname); /* Copy token to name buffer */

  08800	8b 4d 08	 mov	 ecx, DWORD PTR _tkname$[ebp]
  08803	51		 push	 ecx
  08804	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _createword
  0880a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0880d	83 c0 01	 add	 eax, 1
  08810	50		 push	 eax
  08811	e8 00 00 00 00	 call	 _strcpy
  08816	83 c4 08	 add	 esp, 8

; 552  :     createword->wnext = dict;	      /* Chain rest of dictionary to word */

  08819	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _createword
  0881f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dict
  08825	89 11		 mov	 DWORD PTR [ecx], edx

; 553  :     dict = createword;		      /* Put word at head of dictionary */

  08827	a1 00 00 00 00	 mov	 eax, DWORD PTR _createword
  0882c	a3 00 00 00 00	 mov	 DWORD PTR _dict, eax

; 554  : }

  08831	5d		 pop	 ebp
  08832	c3		 ret	 0
_enter	ENDP
; Function compile flags: /Odtp
_mp$ = 8						; size = 4
_atl_mark PROC

; 3414 : {

  08840	55		 push	 ebp
  08841	8b ec		 mov	 ebp, esp

; 3415 :     mp->mstack = stk;		      /* Save stack position */

  08843	8b 45 08	 mov	 eax, DWORD PTR _mp$[ebp]
  08846	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0884c	89 08		 mov	 DWORD PTR [eax], ecx

; 3416 :     mp->mheap = hptr;		      /* Save heap allocation marker */

  0884e	8b 55 08	 mov	 edx, DWORD PTR _mp$[ebp]
  08851	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  08856	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 3417 :     mp->mrstack = rstk; 	      /* Set return stack pointer */

  08859	8b 4d 08	 mov	 ecx, DWORD PTR _mp$[ebp]
  0885c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _rstk
  08862	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 3418 :     mp->mdict = dict;		      /* Save last item in dictionary */

  08865	8b 45 08	 mov	 eax, DWORD PTR _mp$[ebp]
  08868	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dict
  0886e	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 3419 : }

  08871	5d		 pop	 ebp
  08872	c3		 ret	 0
_atl_mark ENDP
; Function compile flags: /Odtp
_mp$ = 8						; size = 4
_atl_unwind PROC

; 3425 : {

  08880	55		 push	 ebp
  08881	8b ec		 mov	 ebp, esp

; 3426 : 
; 3427 :     /* If atl_mark() was called before the system was initialised, and
; 3428 :        we've initialised since, we cannot unwind.  Just ignore the
; 3429 :        unwind request.	The user must manually atl_init before an
; 3430 :        atl_mark() request is made. */
; 3431 : 
; 3432 :     if (mp->mdict == NULL)	      /* Was mark made before atl_init ? */

  08883	8b 45 08	 mov	 eax, DWORD PTR _mp$[ebp]
  08886	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0888a	75 02		 jne	 SHORT $LN3@atl_unwind

; 3433 : 	return; 		      /* Yes.  Cannot unwind past init */

  0888c	eb 67		 jmp	 SHORT $LN4@atl_unwind
$LN3@atl_unwind:

; 3434 : 
; 3435 :     stk = mp->mstack;		      /* Roll back stack allocation */

  0888e	8b 4d 08	 mov	 ecx, DWORD PTR _mp$[ebp]
  08891	8b 11		 mov	 edx, DWORD PTR [ecx]
  08893	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 3436 :     hptr = mp->mheap;		      /* Reset heap state */

  08899	8b 45 08	 mov	 eax, DWORD PTR _mp$[ebp]
  0889c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0889f	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx

; 3437 :     rstk = mp->mrstack; 	      /* Reset the return stack */

  088a5	8b 55 08	 mov	 edx, DWORD PTR _mp$[ebp]
  088a8	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  088ab	a3 00 00 00 00	 mov	 DWORD PTR _rstk, eax
$LN2@atl_unwind:

; 3438 : 
; 3439 :     /* To unwind the dictionary, we can't just reset the pointer,
; 3440 :        we must walk back through the chain and release all the name
; 3441 :        buffers attached to the items allocated after the mark was
; 3442 :        made. */
; 3443 : 
; 3444 :     while (dict != NULL && dict != dictprot && dict != mp->mdict) {

  088b0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dict, 0
  088b7	74 3c		 je	 SHORT $LN4@atl_unwind
  088b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dict
  088bf	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _dictprot
  088c5	74 2e		 je	 SHORT $LN4@atl_unwind
  088c7	8b 55 08	 mov	 edx, DWORD PTR _mp$[ebp]
  088ca	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  088cf	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  088d2	74 21		 je	 SHORT $LN4@atl_unwind

; 3445 : 	free(dict->wname);	      /* Release name string for item */

  088d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dict
  088da	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  088dd	52		 push	 edx
  088de	e8 00 00 00 00	 call	 _free
  088e3	83 c4 04	 add	 esp, 4

; 3446 : 	dict = dict->wnext;	      /* Link to previous item */

  088e6	a1 00 00 00 00	 mov	 eax, DWORD PTR _dict
  088eb	8b 08		 mov	 ecx, DWORD PTR [eax]
  088ed	89 0d 00 00 00
	00		 mov	 DWORD PTR _dict, ecx

; 3447 :     }

  088f3	eb bb		 jmp	 SHORT $LN2@atl_unwind
$LN4@atl_unwind:

; 3448 : }

  088f5	5d		 pop	 ebp
  088f6	c3		 ret	 0
_atl_unwind ENDP
_TEXT	ENDS
PUBLIC	_atl_break
; Function compile flags: /Odtp
_TEXT	SEGMENT
_atl_break PROC

; 3460 : {

  08900	55		 push	 ebp
  08901	8b ec		 mov	 ebp, esp

; 3461 :     broken = True;		      /* Set break request */

  08903	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _broken, 1

; 3462 : }

  0890d	5d		 pop	 ebp
  0890e	c3		 ret	 0
_atl_break ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp
_TEXT	SEGMENT
_scomm$ = -184						; size = 8
_es$ = -176						; size = 4
_sinstr$ = -172						; size = 4
_s$ = -168						; size = 134
__$ArrayPad$ = -28					; size = 4
_sip$ = -24						; size = 4
_mk$ = -20						; size = 16
_lineno$ = -4						; size = 4
_fp$ = 8						; size = 4
_atl_load PROC

; 3469 : {

  08910	55		 push	 ebp
  08911	8b ec		 mov	 ebp, esp
  08913	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  08919	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0891e	33 c5		 xor	 eax, ebp
  08920	89 45 e4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3470 :     int es = ATL_SNORM;

  08923	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _es$[ebp], 0

; 3471 :     char s[134];
; 3472 :     atl_statemark mk;
; 3473 :     atl_int scomm = atl_comment;      /* Stack comment pending state */

  0892d	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_comment
  08932	89 85 48 ff ff
	ff		 mov	 DWORD PTR _scomm$[ebp], eax
  08938	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _atl_comment+4
  0893e	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _scomm$[ebp+4], ecx

; 3474 :     dictword **sip = ip;	      /* Stack instruction pointer */

  08944	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ip
  0894a	89 55 e8	 mov	 DWORD PTR _sip$[ebp], edx

; 3475 :     char *sinstr = instream;	      /* Stack input stream */

  0894d	a1 00 00 00 00	 mov	 eax, DWORD PTR _instream
  08952	89 85 54 ff ff
	ff		 mov	 DWORD PTR _sinstr$[ebp], eax

; 3476 :     int lineno = 0;		      /* Current line number */

  08958	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lineno$[ebp], 0

; 3477 : 
; 3478 :     atl_errline = 0;		      /* Reset line number of error */

  0895f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl_errline, 0
  08969	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl_errline+4, 0

; 3479 :     atl_mark(&mk);

  08973	8d 4d ec	 lea	 ecx, DWORD PTR _mk$[ebp]
  08976	51		 push	 ecx
  08977	e8 00 00 00 00	 call	 _atl_mark
  0897c	83 c4 04	 add	 esp, 4

; 3480 :     ip = NULL;			      /* Fool atl_eval into interp state */

  0897f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ip, 0
$LN4@atl_load:

; 3481 :     while (atl_fgetsp(s, 132, fp) != NULL) {

  08989	8b 55 08	 mov	 edx, DWORD PTR _fp$[ebp]
  0898c	52		 push	 edx
  0898d	68 84 00 00 00	 push	 132			; 00000084H
  08992	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  08998	50		 push	 eax
  08999	e8 00 00 00 00	 call	 _atl_fgetsp
  0899e	83 c4 0c	 add	 esp, 12			; 0000000cH
  089a1	85 c0		 test	 eax, eax
  089a3	74 46		 je	 SHORT $LN3@atl_load

; 3482 : 	lineno++;

  089a5	8b 4d fc	 mov	 ecx, DWORD PTR _lineno$[ebp]
  089a8	83 c1 01	 add	 ecx, 1
  089ab	89 4d fc	 mov	 DWORD PTR _lineno$[ebp], ecx

; 3483 : 	if ((es = atl_eval(s)) != ATL_SNORM) {

  089ae	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR _s$[ebp]
  089b4	52		 push	 edx
  089b5	e8 00 00 00 00	 call	 _atl_eval
  089ba	83 c4 04	 add	 esp, 4
  089bd	89 85 50 ff ff
	ff		 mov	 DWORD PTR _es$[ebp], eax
  089c3	83 bd 50 ff ff
	ff 00		 cmp	 DWORD PTR _es$[ebp], 0
  089ca	74 1d		 je	 SHORT $LN2@atl_load

; 3484 : 	    atl_errline = lineno;     /* Save line number of error */

  089cc	8b 45 fc	 mov	 eax, DWORD PTR _lineno$[ebp]
  089cf	99		 cdq
  089d0	a3 00 00 00 00	 mov	 DWORD PTR _atl_errline, eax
  089d5	89 15 04 00 00
	00		 mov	 DWORD PTR _atl_errline+4, edx

; 3485 : 	    atl_unwind(&mk);

  089db	8d 45 ec	 lea	 eax, DWORD PTR _mk$[ebp]
  089de	50		 push	 eax
  089df	e8 00 00 00 00	 call	 _atl_unwind
  089e4	83 c4 04	 add	 esp, 4

; 3486 : 	    break;

  089e7	eb 02		 jmp	 SHORT $LN3@atl_load
$LN2@atl_load:

; 3487 : 	}
; 3488 :     }

  089e9	eb 9e		 jmp	 SHORT $LN4@atl_load
$LN3@atl_load:

; 3489 :     /* If there were no other errors, check for a runaway comment.  If
; 3490 :        we ended the file in comment-ignore mode, set the runaway comment
; 3491 :        error status and unwind the file.  */
; 3492 :     if ((es == ATL_SNORM) && (atl_comment == Truth)) {

  089eb	83 bd 50 ff ff
	ff 00		 cmp	 DWORD PTR _es$[ebp], 0
  089f2	75 34		 jne	 SHORT $LN1@atl_load
  089f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl_comment
  089fa	23 0d 04 00 00
	00		 and	 ecx, DWORD PTR _atl_comment+4
  08a00	83 f9 ff	 cmp	 ecx, -1
  08a03	75 23		 jne	 SHORT $LN1@atl_load

; 3493 : #ifdef MEMMESSAGE
; 3494 :         V printf("\nRunaway `(' comment.\n");

  08a05	68 00 00 00 00	 push	 OFFSET $SG85186
  08a0a	e8 00 00 00 00	 call	 _printf
  08a0f	83 c4 04	 add	 esp, 4

; 3495 : #endif
; 3496 : 	es = ATL_RUNCOMM;

  08a12	c7 85 50 ff ff
	ff f5 ff ff ff	 mov	 DWORD PTR _es$[ebp], -11 ; fffffff5H

; 3497 : 	atl_unwind(&mk);

  08a1c	8d 55 ec	 lea	 edx, DWORD PTR _mk$[ebp]
  08a1f	52		 push	 edx
  08a20	e8 00 00 00 00	 call	 _atl_unwind
  08a25	83 c4 04	 add	 esp, 4
$LN1@atl_load:

; 3498 :     }
; 3499 :     atl_comment = scomm;	      /* Unstack comment pending status */

  08a28	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _scomm$[ebp]
  08a2e	a3 00 00 00 00	 mov	 DWORD PTR _atl_comment, eax
  08a33	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _scomm$[ebp+4]
  08a39	89 0d 04 00 00
	00		 mov	 DWORD PTR _atl_comment+4, ecx

; 3500 :     ip = sip;			      /* Unstack instruction pointer */

  08a3f	8b 55 e8	 mov	 edx, DWORD PTR _sip$[ebp]
  08a42	89 15 00 00 00
	00		 mov	 DWORD PTR _ip, edx

; 3501 :     instream = sinstr;		      /* Unstack input stream */

  08a48	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _sinstr$[ebp]
  08a4e	a3 00 00 00 00	 mov	 DWORD PTR _instream, eax

; 3502 :     return es;

  08a53	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _es$[ebp]

; 3503 : }

  08a59	8b 4d e4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  08a5c	33 cd		 xor	 ecx, ebp
  08a5e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  08a63	8b e5		 mov	 esp, ebp
  08a65	5d		 pop	 ebp
  08a66	c3		 ret	 0
_atl_load ENDP
_TEXT	ENDS
PUBLIC	_atl_prologue
; Function compile flags: /Odtp
_TEXT	SEGMENT
_ap$85205 = -12						; size = 4
_vp$85204 = -8						; size = 4
_i$85203 = -4						; size = 4
_sp$ = 8						; size = 4
_atl_prologue PROC

; 3511 : {

  08a70	55		 push	 ebp
  08a71	8b ec		 mov	 ebp, esp
  08a73	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 3512 :     static struct {
; 3513 : 	char *pname;
; 3514 : 	atl_int *pparam;
; 3515 :     } proname[] = {
; 3516 :         {"STACK ", &atl_stklen},
; 3517 :         {"RSTACK ", &atl_rstklen},
; 3518 :         {"HEAP ", &atl_heaplen},
; 3519 :         {"TEMPSTRL ", &atl_ltempstr},
; 3520 :         {"TEMPSTRN ", &atl_ntempstr}
; 3521 :     };
; 3522 : 
; 3523 :     if (strncmp(sp, "\\ *", 3) == 0) {

  08a76	6a 03		 push	 3
  08a78	68 00 00 00 00	 push	 OFFSET $SG85202
  08a7d	8b 45 08	 mov	 eax, DWORD PTR _sp$[ebp]
  08a80	50		 push	 eax
  08a81	e8 00 00 00 00	 call	 _strncmp
  08a86	83 c4 0c	 add	 esp, 12			; 0000000cH
  08a89	85 c0		 test	 eax, eax
  08a8b	0f 85 a4 00 00
	00		 jne	 $LN6@atl_prolog

; 3524 : 	int i;
; 3525 : 	char *vp = sp + 3, *ap;

  08a91	8b 4d 08	 mov	 ecx, DWORD PTR _sp$[ebp]
  08a94	83 c1 03	 add	 ecx, 3
  08a97	89 4d f8	 mov	 DWORD PTR _vp$85204[ebp], ecx

; 3526 : 
; 3527 : 	ucase(vp);

  08a9a	8b 55 f8	 mov	 edx, DWORD PTR _vp$85204[ebp]
  08a9d	52		 push	 edx
  08a9e	e8 00 00 00 00	 call	 _ucase
  08aa3	83 c4 04	 add	 esp, 4

; 3528 : 	for (i = 0; i < ELEMENTS(proname); i++) {

  08aa6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$85203[ebp], 0
  08aad	eb 09		 jmp	 SHORT $LN5@atl_prolog
$LN4@atl_prolog:
  08aaf	8b 45 fc	 mov	 eax, DWORD PTR _i$85203[ebp]
  08ab2	83 c0 01	 add	 eax, 1
  08ab5	89 45 fc	 mov	 DWORD PTR _i$85203[ebp], eax
$LN5@atl_prolog:
  08ab8	83 7d fc 05	 cmp	 DWORD PTR _i$85203[ebp], 5
  08abc	73 77		 jae	 SHORT $LN6@atl_prolog

; 3529 : 	    if (strncmp(sp + 3, proname[i].pname,
; 3530 : 		    strlen(proname[i].pname)) == 0) {

  08abe	8b 4d fc	 mov	 ecx, DWORD PTR _i$85203[ebp]
  08ac1	8b 14 cd 00 00
	00 00		 mov	 edx, DWORD PTR ?proname@?1??atl_prologue@@9@9[ecx*8]
  08ac8	52		 push	 edx
  08ac9	e8 00 00 00 00	 call	 _strlen
  08ace	83 c4 04	 add	 esp, 4
  08ad1	50		 push	 eax
  08ad2	8b 45 fc	 mov	 eax, DWORD PTR _i$85203[ebp]
  08ad5	8b 0c c5 00 00
	00 00		 mov	 ecx, DWORD PTR ?proname@?1??atl_prologue@@9@9[eax*8]
  08adc	51		 push	 ecx
  08add	8b 55 08	 mov	 edx, DWORD PTR _sp$[ebp]
  08ae0	83 c2 03	 add	 edx, 3
  08ae3	52		 push	 edx
  08ae4	e8 00 00 00 00	 call	 _strncmp
  08ae9	83 c4 0c	 add	 esp, 12			; 0000000cH
  08aec	85 c0		 test	 eax, eax
  08aee	75 40		 jne	 SHORT $LN2@atl_prolog

; 3531 :                 if ((ap = strchr(sp + 3, ' ')) != NULL) {

  08af0	6a 20		 push	 32			; 00000020H
  08af2	8b 45 08	 mov	 eax, DWORD PTR _sp$[ebp]
  08af5	83 c0 03	 add	 eax, 3
  08af8	50		 push	 eax
  08af9	e8 00 00 00 00	 call	 _strchr
  08afe	83 c4 08	 add	 esp, 8
  08b01	89 45 f4	 mov	 DWORD PTR _ap$85205[ebp], eax
  08b04	83 7d f4 00	 cmp	 DWORD PTR _ap$85205[ebp], 0
  08b08	74 26		 je	 SHORT $LN2@atl_prolog

; 3532 :                     V sscanf(ap + 1, "%li", proname[i].pparam);

  08b0a	8b 4d fc	 mov	 ecx, DWORD PTR _i$85203[ebp]
  08b0d	8b 14 cd 04 00
	00 00		 mov	 edx, DWORD PTR ?proname@?1??atl_prologue@@9@9[ecx*8+4]
  08b14	52		 push	 edx
  08b15	68 00 00 00 00	 push	 OFFSET $SG85213
  08b1a	8b 45 f4	 mov	 eax, DWORD PTR _ap$85205[ebp]
  08b1d	83 c0 01	 add	 eax, 1
  08b20	50		 push	 eax
  08b21	e8 00 00 00 00	 call	 _sscanf
  08b26	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3533 : #ifdef PROLOGUEDEBUG
; 3534 : V printf("Prologue set %sto %ld\n", proname[i].pname, *proname[i].pparam);
; 3535 : #endif
; 3536 : 		    return 1;

  08b29	b8 01 00 00 00	 mov	 eax, 1
  08b2e	eb 07		 jmp	 SHORT $LN7@atl_prolog
$LN2@atl_prolog:

; 3537 : 	       }
; 3538 : 	    }
; 3539 : 	}

  08b30	e9 7a ff ff ff	 jmp	 $LN4@atl_prolog
$LN6@atl_prolog:

; 3540 :     }
; 3541 :     return 0;

  08b35	33 c0		 xor	 eax, eax
$LN7@atl_prolog:

; 3542 : }

  08b37	8b e5		 mov	 esp, ebp
  08b39	5d		 pop	 ebp
  08b3a	c3		 ret	 0
_atl_prologue ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv437 = -76						; size = 4
tv421 = -72						; size = 4
tv387 = -68						; size = 4
tv353 = -64						; size = 4
tv324 = -60						; size = 4
tv72 = -56						; size = 4
_l$85337 = -52						; size = 4
_l$85325 = -48						; size = 4
_i$85307 = -44						; size = 4
_tru$85313 = -40					; size = 8
_i$85291 = -28						; size = 4
_tru$85297 = -24					; size = 8
__$ArrayPad$ = -16					; size = 4
_dw$85233 = -12						; size = 4
_di$85224 = -8						; size = 4
_i$ = -4						; size = 4
_sp$ = 8						; size = 4
_atl_eval PROC

; 3548 : {

  08b40	55		 push	 ebp
  08b41	8b ec		 mov	 ebp, esp
  08b43	83 ec 4c	 sub	 esp, 76			; 0000004cH
  08b46	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  08b4b	33 c5		 xor	 eax, ebp
  08b4d	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3549 :     int i;
; 3550 : 
; 3551 : #undef Memerrs
; 3552 : #define Memerrs evalstat
; 3553 :     instream = sp;

  08b50	8b 45 08	 mov	 eax, DWORD PTR _sp$[ebp]
  08b53	a3 00 00 00 00	 mov	 DWORD PTR _instream, eax

; 3554 :     evalstat = ATL_SNORM;	      /* Set normal evaluation status */

  08b58	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _evalstat, 0

; 3555 : #ifdef BREAK
; 3556 :     broken = False;		      /* Reset asynchronous break */

  08b62	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _broken, 0

; 3557 : #endif
; 3558 : 
; 3559 : /* If automatic prologue processing is configured and we haven't yet
; 3560 :    initialised, check if this is a prologue statement.	If so, execute
; 3561 :    it.	Otherwise automatically initialise with the memory specifications
; 3562 :    currently operative. */
; 3563 : 
; 3564 : #ifdef PROLOGUE
; 3565 :     if (dict == NULL) {

  08b6c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dict, 0
  08b73	75 1f		 jne	 SHORT $LN64@atl_eval

; 3566 : 	if (atl_prologue(sp))

  08b75	8b 4d 08	 mov	 ecx, DWORD PTR _sp$[ebp]
  08b78	51		 push	 ecx
  08b79	e8 00 00 00 00	 call	 _atl_prologue
  08b7e	83 c4 04	 add	 esp, 4
  08b81	85 c0		 test	 eax, eax
  08b83	74 0a		 je	 SHORT $LN63@atl_eval

; 3567 : 	   return evalstat;

  08b85	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  08b8a	e9 68 07 00 00	 jmp	 $LN65@atl_eval
$LN63@atl_eval:

; 3568 : 	atl_init();

  08b8f	e8 00 00 00 00	 call	 _atl_init
$LN64@atl_eval:

; 3569 :     }
; 3570 : #endif /* PROLOGUE */
; 3571 : 
; 3572 :     while ((evalstat == ATL_SNORM) && (i = token(&instream)) != TokNull) {

  08b94	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _evalstat, 0
  08b9b	0f 85 51 07 00
	00		 jne	 $LN61@atl_eval
  08ba1	68 00 00 00 00	 push	 OFFSET _instream
  08ba6	e8 00 00 00 00	 call	 _token
  08bab	83 c4 04	 add	 esp, 4
  08bae	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  08bb1	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  08bb5	0f 84 37 07 00
	00		 je	 $LN61@atl_eval

; 3573 : 	dictword *di;
; 3574 : 
; 3575 : 	switch (i) {

  08bbb	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  08bbe	89 55 c8	 mov	 DWORD PTR tv72[ebp], edx
  08bc1	8b 45 c8	 mov	 eax, DWORD PTR tv72[ebp]
  08bc4	83 e8 01	 sub	 eax, 1
  08bc7	89 45 c8	 mov	 DWORD PTR tv72[ebp], eax
  08bca	83 7d c8 03	 cmp	 DWORD PTR tv72[ebp], 3
  08bce	0f 87 08 07 00
	00		 ja	 $LN1@atl_eval
  08bd4	8b 4d c8	 mov	 ecx, DWORD PTR tv72[ebp]
  08bd7	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN67@atl_eval[ecx*4]
$LN58@atl_eval:

; 3576 : 	    case TokWord:
; 3577 : 		if (forgetpend) {

  08bde	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _forgetpend, 0
  08be5	0f 84 10 01 00
	00		 je	 $LN57@atl_eval

; 3578 : 		    forgetpend = False;

  08beb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _forgetpend, 0

; 3579 : 		    ucase(tokbuf);

  08bf5	68 00 00 00 00	 push	 OFFSET _tokbuf
  08bfa	e8 00 00 00 00	 call	 _ucase
  08bff	83 c4 04	 add	 esp, 4

; 3580 : 		    if ((di = lookup(tokbuf)) != NULL) {

  08c02	68 00 00 00 00	 push	 OFFSET _tokbuf
  08c07	e8 00 00 00 00	 call	 _lookup
  08c0c	83 c4 04	 add	 esp, 4
  08c0f	89 45 f8	 mov	 DWORD PTR _di$85224[ebp], eax
  08c12	83 7d f8 00	 cmp	 DWORD PTR _di$85224[ebp], 0
  08c16	0f 84 be 00 00
	00		 je	 $LN56@atl_eval

; 3581 : 			dictword *dw = dict;

  08c1c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dict
  08c22	89 55 f4	 mov	 DWORD PTR _dw$85233[ebp], edx
$LN55@atl_eval:

; 3582 : 
; 3583 : 			/* Pass 1.  Rip through the dictionary to make sure
; 3584 : 				    this word is not past the marker that
; 3585 : 				    guards against forgetting too much. */
; 3586 : 
; 3587 : 			while (dw != NULL) {

  08c25	83 7d f4 00	 cmp	 DWORD PTR _dw$85233[ebp], 0
  08c29	74 50		 je	 SHORT $LN54@atl_eval

; 3588 : 			    if (dw == dictprot) {

  08c2b	8b 45 f4	 mov	 eax, DWORD PTR _dw$85233[ebp]
  08c2e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _dictprot
  08c34	75 1e		 jne	 SHORT $LN53@atl_eval

; 3589 : #ifdef MEMMESSAGE
; 3590 :                                 V printf("\nForget protected.\n");

  08c36	68 00 00 00 00	 push	 OFFSET $SG85240
  08c3b	e8 00 00 00 00	 call	 _printf
  08c40	83 c4 04	 add	 esp, 4

; 3591 : #endif
; 3592 : 				evalstat = ATL_FORGETPROT;

  08c43	c7 05 00 00 00
	00 f8 ff ff ff	 mov	 DWORD PTR _evalstat, -8	; fffffff8H

; 3593 : 				di = NULL;

  08c4d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _di$85224[ebp], 0
$LN53@atl_eval:

; 3594 : 			    }
; 3595 : 			    if (strcmp(dw->wname + 1, tokbuf) == 0)

  08c54	68 00 00 00 00	 push	 OFFSET _tokbuf
  08c59	8b 4d f4	 mov	 ecx, DWORD PTR _dw$85233[ebp]
  08c5c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  08c5f	83 c2 01	 add	 edx, 1
  08c62	52		 push	 edx
  08c63	e8 00 00 00 00	 call	 _strcmp
  08c68	83 c4 08	 add	 esp, 8
  08c6b	85 c0		 test	 eax, eax
  08c6d	75 02		 jne	 SHORT $LN52@atl_eval

; 3596 : 				break;

  08c6f	eb 0a		 jmp	 SHORT $LN54@atl_eval
$LN52@atl_eval:

; 3597 : 			    dw = dw->wnext;

  08c71	8b 45 f4	 mov	 eax, DWORD PTR _dw$85233[ebp]
  08c74	8b 08		 mov	 ecx, DWORD PTR [eax]
  08c76	89 4d f4	 mov	 DWORD PTR _dw$85233[ebp], ecx

; 3598 : 			}

  08c79	eb aa		 jmp	 SHORT $LN55@atl_eval
$LN54@atl_eval:

; 3599 : 
; 3600 : 			/* Pass 2.  Walk back through the dictionary
; 3601 : 				    items until we encounter the target
; 3602 :                                     of the FORGET.  Release each item's
; 3603 : 				    name buffer and dechain it from the
; 3604 : 				    dictionary list. */
; 3605 : 
; 3606 : 			if (di != NULL) {

  08c7b	83 7d f8 00	 cmp	 DWORD PTR _di$85224[ebp], 0
  08c7f	74 57		 je	 SHORT $LN46@atl_eval
$LN50@atl_eval:

; 3607 : 			    do {
; 3608 : 				dw = dict;

  08c81	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dict
  08c87	89 55 f4	 mov	 DWORD PTR _dw$85233[ebp], edx

; 3609 : 				if (dw->wname != NULL)

  08c8a	8b 45 f4	 mov	 eax, DWORD PTR _dw$85233[ebp]
  08c8d	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  08c91	74 0f		 je	 SHORT $LN47@atl_eval

; 3610 : 				    free(dw->wname);

  08c93	8b 4d f4	 mov	 ecx, DWORD PTR _dw$85233[ebp]
  08c96	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  08c99	52		 push	 edx
  08c9a	e8 00 00 00 00	 call	 _free
  08c9f	83 c4 04	 add	 esp, 4
$LN47@atl_eval:

; 3611 : 				dict = dw->wnext;

  08ca2	8b 45 f4	 mov	 eax, DWORD PTR _dw$85233[ebp]
  08ca5	8b 08		 mov	 ecx, DWORD PTR [eax]
  08ca7	89 0d 00 00 00
	00		 mov	 DWORD PTR _dict, ecx

; 3612 : 			    } while (dw != di);

  08cad	8b 55 f4	 mov	 edx, DWORD PTR _dw$85233[ebp]
  08cb0	3b 55 f8	 cmp	 edx, DWORD PTR _di$85224[ebp]
  08cb3	75 cc		 jne	 SHORT $LN50@atl_eval

; 3613 : 			    /* Finally, back the heap allocation pointer
; 3614 : 			       up to the start of the last item forgotten. */
; 3615 : 			    hptr = (stackitem *) di;

  08cb5	8b 45 f8	 mov	 eax, DWORD PTR _di$85224[ebp]
  08cb8	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 3616 : 			    /* Uhhhh, just one more thing.  If this word
; 3617 :                                was defined with DOES>, there's a link to
; 3618 : 			       the method address hidden before its
; 3619 :                                wnext field.  See if it's a DOES> by testing
; 3620 : 			       the wcode field for P_dodoes and, if so,
; 3621 : 			       back up the heap one more item. */
; 3622 : 			    if (di->wcode == (codeptr) P_dodoes) {

  08cbd	8b 4d f8	 mov	 ecx, DWORD PTR _di$85224[ebp]
  08cc0	81 79 08 00 00
	00 00		 cmp	 DWORD PTR [ecx+8], OFFSET _P_dodoes
  08cc7	75 0f		 jne	 SHORT $LN46@atl_eval

; 3623 : #ifdef FORGETDEBUG
; 3624 : V printf(" Forgetting DOES> word. ");
; 3625 : #endif
; 3626 : 				hptr--;

  08cc9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  08ccf	83 ea 08	 sub	 edx, 8
  08cd2	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx
$LN46@atl_eval:

; 3627 : 			    }
; 3628 : 			}
; 3629 : 		    } else {

  08cd8	eb 1c		 jmp	 SHORT $LN45@atl_eval
$LN56@atl_eval:

; 3630 : #ifdef MEMMESSAGE
; 3631 :                         V printf(" '%s' undefined ", tokbuf);

  08cda	68 00 00 00 00	 push	 OFFSET _tokbuf
  08cdf	68 00 00 00 00	 push	 OFFSET $SG85255
  08ce4	e8 00 00 00 00	 call	 _printf
  08ce9	83 c4 08	 add	 esp, 8

; 3632 : #endif
; 3633 : 			evalstat = ATL_UNDEFINED;

  08cec	c7 05 00 00 00
	00 f9 ff ff ff	 mov	 DWORD PTR _evalstat, -7	; fffffff9H
$LN45@atl_eval:

; 3634 : 		    }

  08cf6	e9 31 02 00 00	 jmp	 $LN28@atl_eval
$LN57@atl_eval:

; 3635 : 		} else if (tickpend) {

  08cfb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _tickpend, 0
  08d02	0f 84 8d 00 00
	00		 je	 $LN43@atl_eval

; 3636 : 		    tickpend = False;

  08d08	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _tickpend, 0

; 3637 : 		    ucase(tokbuf);

  08d12	68 00 00 00 00	 push	 OFFSET _tokbuf
  08d17	e8 00 00 00 00	 call	 _ucase
  08d1c	83 c4 04	 add	 esp, 4

; 3638 : 		    if ((di = lookup(tokbuf)) != NULL) {

  08d1f	68 00 00 00 00	 push	 OFFSET _tokbuf
  08d24	e8 00 00 00 00	 call	 _lookup
  08d29	83 c4 04	 add	 esp, 4
  08d2c	89 45 f8	 mov	 DWORD PTR _di$85224[ebp], eax
  08d2f	83 7d f8 00	 cmp	 DWORD PTR _di$85224[ebp], 0
  08d33	74 3f		 je	 SHORT $LN42@atl_eval

; 3639 : 			So(1);

  08d35	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  08d3a	83 c0 08	 add	 eax, 8
  08d3d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  08d43	76 0f		 jbe	 SHORT $LN41@atl_eval
  08d45	e8 00 00 00 00	 call	 _stakover
  08d4a	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  08d4f	e9 a3 05 00 00	 jmp	 $LN65@atl_eval
$LN41@atl_eval:

; 3640 : 			Push = (stackitem) di; /* Push word compile address */

  08d54	8b 45 f8	 mov	 eax, DWORD PTR _di$85224[ebp]
  08d57	99		 cdq
  08d58	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  08d5e	89 01		 mov	 DWORD PTR [ecx], eax
  08d60	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  08d63	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  08d69	83 c2 08	 add	 edx, 8
  08d6c	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 3641 : 		    } else {

  08d72	eb 1c		 jmp	 SHORT $LN40@atl_eval
$LN42@atl_eval:

; 3642 : #ifdef MEMMESSAGE
; 3643 :                         V printf(" '%s' undefined ", tokbuf);

  08d74	68 00 00 00 00	 push	 OFFSET _tokbuf
  08d79	68 00 00 00 00	 push	 OFFSET $SG85264
  08d7e	e8 00 00 00 00	 call	 _printf
  08d83	83 c4 08	 add	 esp, 8

; 3644 : #endif
; 3645 : 			evalstat = ATL_UNDEFINED;

  08d86	c7 05 00 00 00
	00 f9 ff ff ff	 mov	 DWORD PTR _evalstat, -7	; fffffff9H
$LN40@atl_eval:

; 3646 : 		    }

  08d90	e9 97 01 00 00	 jmp	 $LN28@atl_eval
$LN43@atl_eval:

; 3647 : 		} else if (defpend) {

  08d95	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _defpend, 0
  08d9c	74 59		 je	 SHORT $LN38@atl_eval

; 3648 : 		    /* If a definition is pending, define the token and
; 3649 : 		       leave the address of the new word item created for
; 3650 : 		       it on the return stack. */
; 3651 : 		    defpend = False;

  08d9e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _defpend, 0

; 3652 : 		    ucase(tokbuf);

  08da8	68 00 00 00 00	 push	 OFFSET _tokbuf
  08dad	e8 00 00 00 00	 call	 _ucase
  08db2	83 c4 04	 add	 esp, 4

; 3653 : 		    if (atl_redef && (lookup(tokbuf) != NULL))

  08db5	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_redef
  08dba	0b 05 04 00 00
	00		 or	 eax, DWORD PTR _atl_redef+4
  08dc0	74 23		 je	 SHORT $LN37@atl_eval
  08dc2	68 00 00 00 00	 push	 OFFSET _tokbuf
  08dc7	e8 00 00 00 00	 call	 _lookup
  08dcc	83 c4 04	 add	 esp, 4
  08dcf	85 c0		 test	 eax, eax
  08dd1	74 12		 je	 SHORT $LN37@atl_eval

; 3654 :                         V printf("\n%s isn't unique.", tokbuf);

  08dd3	68 00 00 00 00	 push	 OFFSET _tokbuf
  08dd8	68 00 00 00 00	 push	 OFFSET $SG85270
  08ddd	e8 00 00 00 00	 call	 _printf
  08de2	83 c4 08	 add	 esp, 8
$LN37@atl_eval:

; 3655 : 		    enter(tokbuf);

  08de5	68 00 00 00 00	 push	 OFFSET _tokbuf
  08dea	e8 00 00 00 00	 call	 _enter
  08def	83 c4 04	 add	 esp, 4

; 3656 : 		} else {

  08df2	e9 35 01 00 00	 jmp	 $LN28@atl_eval
$LN38@atl_eval:

; 3657 : 		    di = lookup(tokbuf);

  08df7	68 00 00 00 00	 push	 OFFSET _tokbuf
  08dfc	e8 00 00 00 00	 call	 _lookup
  08e01	83 c4 04	 add	 esp, 4
  08e04	89 45 f8	 mov	 DWORD PTR _di$85224[ebp], eax

; 3658 : 		    if (di != NULL) {

  08e07	83 7d f8 00	 cmp	 DWORD PTR _di$85224[ebp], 0
  08e0b	0f 84 ec 00 00
	00		 je	 $LN35@atl_eval

; 3659 :                         /* Test the state.  If we're interpreting, execute
; 3660 :                            the word in all cases.  If we're compiling,
; 3661 : 			   compile the word unless it is a compiler word
; 3662 : 			   flagged for immediate execution by the
; 3663 : 			   presence of a space as the first character of
; 3664 : 			   its name in the dictionary entry. */
; 3665 : 			if (state &&
; 3666 : 			    (cbrackpend || ctickpend ||
; 3667 : 			     !(di->wname[0] & IMMEDIATE))) {

  08e11	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _heap
  08e17	89 4d c4	 mov	 DWORD PTR tv324[ebp], ecx
  08e1a	8b 55 c4	 mov	 edx, DWORD PTR tv324[ebp]
  08e1d	8b 45 c4	 mov	 eax, DWORD PTR tv324[ebp]
  08e20	8b 0a		 mov	 ecx, DWORD PTR [edx]
  08e22	0b 48 04	 or	 ecx, DWORD PTR [eax+4]
  08e25	0f 84 c4 00 00
	00		 je	 $LN34@atl_eval
  08e2b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cbrackpend, 0
  08e32	75 1b		 jne	 SHORT $LN33@atl_eval
  08e34	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ctickpend, 0
  08e3b	75 12		 jne	 SHORT $LN33@atl_eval
  08e3d	8b 55 f8	 mov	 edx, DWORD PTR _di$85224[ebp]
  08e40	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  08e43	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  08e46	83 e1 01	 and	 ecx, 1
  08e49	0f 85 a0 00 00
	00		 jne	 $LN34@atl_eval
$LN33@atl_eval:

; 3668 : 			    if (ctickpend) {

  08e4f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ctickpend, 0
  08e56	74 4d		 je	 SHORT $LN32@atl_eval

; 3669 : 				/* If a compile-time tick preceded this
; 3670 : 				   word, compile a (lit) word to cause its
; 3671 : 				   address to be pushed at execution time. */
; 3672 : 				Ho(1);

  08e58	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  08e5e	83 c2 08	 add	 edx, 8
  08e61	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _heaptop
  08e67	76 0f		 jbe	 SHORT $LN31@atl_eval
  08e69	e8 00 00 00 00	 call	 _heapover
  08e6e	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  08e73	e9 7f 04 00 00	 jmp	 $LN65@atl_eval
$LN31@atl_eval:

; 3673 : 				Hstore = s_lit;

  08e78	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  08e7d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_lit
  08e83	89 08		 mov	 DWORD PTR [eax], ecx
  08e85	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _s_lit+4
  08e8b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  08e8e	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  08e93	83 c0 08	 add	 eax, 8
  08e96	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 3674 : 				ctickpend = False;

  08e9b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ctickpend, 0
$LN32@atl_eval:

; 3675 : 			    }
; 3676 : 			    cbrackpend = False;

  08ea5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cbrackpend, 0

; 3677 : 			    Ho(1);	  /* Reserve stack space */

  08eaf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  08eb5	83 c1 08	 add	 ecx, 8
  08eb8	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  08ebe	76 0f		 jbe	 SHORT $LN30@atl_eval
  08ec0	e8 00 00 00 00	 call	 _heapover
  08ec5	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  08eca	e9 28 04 00 00	 jmp	 $LN65@atl_eval
$LN30@atl_eval:

; 3678 : 			    Hstore = (stackitem) di;/* Compile word address */

  08ecf	8b 45 f8	 mov	 eax, DWORD PTR _di$85224[ebp]
  08ed2	99		 cdq
  08ed3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  08ed9	89 01		 mov	 DWORD PTR [ecx], eax
  08edb	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  08ede	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  08ee4	83 c2 08	 add	 edx, 8
  08ee7	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 3679 : 			} else {

  08eed	eb 0c		 jmp	 SHORT $LN29@atl_eval
$LN34@atl_eval:

; 3680 : 			    exword(di);   /* Execute word */

  08eef	8b 45 f8	 mov	 eax, DWORD PTR _di$85224[ebp]
  08ef2	50		 push	 eax
  08ef3	e8 00 00 00 00	 call	 _exword
  08ef8	83 c4 04	 add	 esp, 4
$LN29@atl_eval:

; 3681 : 			}
; 3682 : 		    } else {

  08efb	eb 2f		 jmp	 SHORT $LN28@atl_eval
$LN35@atl_eval:

; 3683 : #ifdef MEMMESSAGE
; 3684 :                         V printf(" '%s' undefined ", tokbuf);

  08efd	68 00 00 00 00	 push	 OFFSET _tokbuf
  08f02	68 00 00 00 00	 push	 OFFSET $SG85283
  08f07	e8 00 00 00 00	 call	 _printf
  08f0c	83 c4 08	 add	 esp, 8

; 3685 : #endif
; 3686 : 			evalstat = ATL_UNDEFINED;

  08f0f	c7 05 00 00 00
	00 f9 ff ff ff	 mov	 DWORD PTR _evalstat, -7	; fffffff9H

; 3687 : 			state = Falsity;

  08f19	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _heap
  08f1f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  08f25	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
$LN28@atl_eval:

; 3688 : 		    }
; 3689 : 		}
; 3690 : 		break;

  08f2c	e9 bc 03 00 00	 jmp	 $LN59@atl_eval
$LN27@atl_eval:

; 3691 : 
; 3692 : 	    case TokInt:
; 3693 : 		if (state) {

  08f31	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _heap
  08f37	89 55 c0	 mov	 DWORD PTR tv353[ebp], edx
  08f3a	8b 45 c0	 mov	 eax, DWORD PTR tv353[ebp]
  08f3d	8b 4d c0	 mov	 ecx, DWORD PTR tv353[ebp]
  08f40	8b 10		 mov	 edx, DWORD PTR [eax]
  08f42	0b 51 04	 or	 edx, DWORD PTR [ecx+4]
  08f45	74 66		 je	 SHORT $LN26@atl_eval

; 3694 : 		    Ho(2);

  08f47	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  08f4c	83 c0 10	 add	 eax, 16			; 00000010H
  08f4f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  08f55	76 0f		 jbe	 SHORT $LN25@atl_eval
  08f57	e8 00 00 00 00	 call	 _heapover
  08f5c	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  08f61	e9 91 03 00 00	 jmp	 $LN65@atl_eval
$LN25@atl_eval:

; 3695 : 		    Hstore = s_lit;   /* Push (lit) */

  08f66	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  08f6c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _s_lit
  08f72	89 11		 mov	 DWORD PTR [ecx], edx
  08f74	a1 04 00 00 00	 mov	 eax, DWORD PTR _s_lit+4
  08f79	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  08f7c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  08f82	83 c1 08	 add	 ecx, 8
  08f85	89 0d 00 00 00
	00		 mov	 DWORD PTR _hptr, ecx

; 3696 : 		    Hstore = tokint;  /* Compile actual literal */

  08f8b	a1 00 00 00 00	 mov	 eax, DWORD PTR _tokint
  08f90	99		 cdq
  08f91	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  08f97	89 01		 mov	 DWORD PTR [ecx], eax
  08f99	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  08f9c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  08fa2	83 c2 08	 add	 edx, 8
  08fa5	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 3697 : 		} else {

  08fab	eb 3f		 jmp	 SHORT $LN24@atl_eval
$LN26@atl_eval:

; 3698 : 		    So(1);

  08fad	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  08fb2	83 c0 08	 add	 eax, 8
  08fb5	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  08fbb	76 0f		 jbe	 SHORT $LN23@atl_eval
  08fbd	e8 00 00 00 00	 call	 _stakover
  08fc2	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  08fc7	e9 2b 03 00 00	 jmp	 $LN65@atl_eval
$LN23@atl_eval:

; 3699 : 		    Push = tokint;

  08fcc	a1 00 00 00 00	 mov	 eax, DWORD PTR _tokint
  08fd1	99		 cdq
  08fd2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  08fd8	89 01		 mov	 DWORD PTR [ecx], eax
  08fda	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  08fdd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  08fe3	83 c2 08	 add	 edx, 8
  08fe6	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx
$LN24@atl_eval:

; 3700 : 		}
; 3701 : 		break;

  08fec	e9 fc 02 00 00	 jmp	 $LN59@atl_eval
$LN22@atl_eval:

; 3702 : 
; 3703 : #ifdef REAL
; 3704 : 	    case TokReal:
; 3705 : 		if (state) {

  08ff1	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  08ff6	89 45 bc	 mov	 DWORD PTR tv387[ebp], eax
  08ff9	8b 4d bc	 mov	 ecx, DWORD PTR tv387[ebp]
  08ffc	8b 55 bc	 mov	 edx, DWORD PTR tv387[ebp]
  08fff	8b 01		 mov	 eax, DWORD PTR [ecx]
  09001	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  09004	0f 84 8d 00 00
	00		 je	 $LN21@atl_eval

; 3706 : 		    int i;
; 3707 :     	    	    union {
; 3708 : 		    	atl_real r;
; 3709 : 			stackitem s[Realsize];
; 3710 : 		    } tru;
; 3711 : 
; 3712 : 		    Ho(Realsize + 1);

  0900a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  09010	83 c1 10	 add	 ecx, 16			; 00000010H
  09013	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  09019	76 0f		 jbe	 SHORT $LN20@atl_eval
  0901b	e8 00 00 00 00	 call	 _heapover
  09020	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  09025	e9 cd 02 00 00	 jmp	 $LN65@atl_eval
$LN20@atl_eval:

; 3713 : 		    Hstore = s_flit;  /* Push (flit) */

  0902a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  09030	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_flit
  09035	89 02		 mov	 DWORD PTR [edx], eax
  09037	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _s_flit+4
  0903d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  09040	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  09046	83 c2 08	 add	 edx, 8
  09049	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 3714 :     	    	    tru.r = tokreal;

  0904f	dd 05 00 00 00
	00		 fld	 QWORD PTR _tokreal
  09055	dd 5d e8	 fstp	 QWORD PTR _tru$85297[ebp]

; 3715 : 		    for (i = 0; i < Realsize; i++) {

  09058	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$85291[ebp], 0
  0905f	eb 09		 jmp	 SHORT $LN19@atl_eval
$LN18@atl_eval:
  09061	8b 45 e4	 mov	 eax, DWORD PTR _i$85291[ebp]
  09064	83 c0 01	 add	 eax, 1
  09067	89 45 e4	 mov	 DWORD PTR _i$85291[ebp], eax
$LN19@atl_eval:
  0906a	83 7d e4 01	 cmp	 DWORD PTR _i$85291[ebp], 1
  0906e	73 25		 jae	 SHORT $LN17@atl_eval

; 3716 : 			Hstore = tru.s[i];

  09070	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  09076	8b 55 e4	 mov	 edx, DWORD PTR _i$85291[ebp]
  09079	8b 44 d5 e8	 mov	 eax, DWORD PTR _tru$85297[ebp+edx*8]
  0907d	89 01		 mov	 DWORD PTR [ecx], eax
  0907f	8b 54 d5 ec	 mov	 edx, DWORD PTR _tru$85297[ebp+edx*8+4]
  09083	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  09086	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0908b	83 c0 08	 add	 eax, 8
  0908e	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 3717 : 		    }

  09093	eb cc		 jmp	 SHORT $LN18@atl_eval
$LN17@atl_eval:

; 3718 : 		} else {

  09095	eb 67		 jmp	 SHORT $LN12@atl_eval
$LN21@atl_eval:

; 3719 : 		    int i;
; 3720 :     	    	    union {
; 3721 : 		    	atl_real r;
; 3722 : 			stackitem s[Realsize];
; 3723 : 		    } tru;
; 3724 : 
; 3725 : 		    So(Realsize);

  09097	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  0909d	83 c1 08	 add	 ecx, 8
  090a0	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _stacktop
  090a6	76 0f		 jbe	 SHORT $LN15@atl_eval
  090a8	e8 00 00 00 00	 call	 _stakover
  090ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  090b2	e9 40 02 00 00	 jmp	 $LN65@atl_eval
$LN15@atl_eval:

; 3726 :     	    	    tru.r = tokreal;

  090b7	dd 05 00 00 00
	00		 fld	 QWORD PTR _tokreal
  090bd	dd 5d d8	 fstp	 QWORD PTR _tru$85313[ebp]

; 3727 : 		    for (i = 0; i < Realsize; i++) {

  090c0	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$85307[ebp], 0
  090c7	eb 09		 jmp	 SHORT $LN14@atl_eval
$LN13@atl_eval:
  090c9	8b 55 d4	 mov	 edx, DWORD PTR _i$85307[ebp]
  090cc	83 c2 01	 add	 edx, 1
  090cf	89 55 d4	 mov	 DWORD PTR _i$85307[ebp], edx
$LN14@atl_eval:
  090d2	83 7d d4 01	 cmp	 DWORD PTR _i$85307[ebp], 1
  090d6	73 26		 jae	 SHORT $LN12@atl_eval

; 3728 : 			Push = tru.s[i];

  090d8	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  090dd	8b 4d d4	 mov	 ecx, DWORD PTR _i$85307[ebp]
  090e0	8b 54 cd d8	 mov	 edx, DWORD PTR _tru$85313[ebp+ecx*8]
  090e4	89 10		 mov	 DWORD PTR [eax], edx
  090e6	8b 4c cd dc	 mov	 ecx, DWORD PTR _tru$85313[ebp+ecx*8+4]
  090ea	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  090ed	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  090f3	83 c2 08	 add	 edx, 8
  090f6	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 3729 : 		    }

  090fc	eb cb		 jmp	 SHORT $LN13@atl_eval
$LN12@atl_eval:

; 3730 : 		}
; 3731 : 		break;

  090fe	e9 ea 01 00 00	 jmp	 $LN59@atl_eval
$LN11@atl_eval:

; 3732 : #endif /* REAL */
; 3733 : 
; 3734 : #ifdef STRING
; 3735 : 	    case TokString:
; 3736 : 		if (stringlit) {

  09103	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _stringlit, 0
  0910a	0f 84 a3 00 00
	00		 je	 $LN10@atl_eval

; 3737 : 		    stringlit = False;

  09110	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _stringlit, 0

; 3738 : 		    if (state) {

  0911a	a1 00 00 00 00	 mov	 eax, DWORD PTR _heap
  0911f	89 45 b8	 mov	 DWORD PTR tv421[ebp], eax
  09122	8b 4d b8	 mov	 ecx, DWORD PTR tv421[ebp]
  09125	8b 55 b8	 mov	 edx, DWORD PTR tv421[ebp]
  09128	8b 01		 mov	 eax, DWORD PTR [ecx]
  0912a	0b 42 04	 or	 eax, DWORD PTR [edx+4]
  0912d	74 6d		 je	 SHORT $LN9@atl_eval

; 3739 : 			int l = (strlen(tokbuf) + 1 + sizeof(stackitem)) /
; 3740 : 				    sizeof(stackitem);

  0912f	68 00 00 00 00	 push	 OFFSET _tokbuf
  09134	e8 00 00 00 00	 call	 _strlen
  09139	83 c4 04	 add	 esp, 4
  0913c	83 c0 09	 add	 eax, 9
  0913f	c1 e8 03	 shr	 eax, 3
  09142	89 45 d0	 mov	 DWORD PTR _l$85325[ebp], eax

; 3741 : 			Ho(l);

  09145	8b 4d d0	 mov	 ecx, DWORD PTR _l$85325[ebp]
  09148	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  0914e	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  09151	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _heaptop
  09157	76 0f		 jbe	 SHORT $LN8@atl_eval
  09159	e8 00 00 00 00	 call	 _heapover
  0915e	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  09163	e9 8f 01 00 00	 jmp	 $LN65@atl_eval
$LN8@atl_eval:

; 3742 : 			*((char *) hptr) = l;  /* Store in-line skip length */

  09168	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  0916e	8a 55 d0	 mov	 dl, BYTE PTR _l$85325[ebp]
  09171	88 11		 mov	 BYTE PTR [ecx], dl

; 3743 : 			V strcpy(((char *) hptr) + 1, tokbuf);

  09173	68 00 00 00 00	 push	 OFFSET _tokbuf
  09178	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  0917d	83 c0 01	 add	 eax, 1
  09180	50		 push	 eax
  09181	e8 00 00 00 00	 call	 _strcpy
  09186	83 c4 08	 add	 esp, 8

; 3744 : 			hptr += l;

  09189	8b 4d d0	 mov	 ecx, DWORD PTR _l$85325[ebp]
  0918c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  09192	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  09195	a3 00 00 00 00	 mov	 DWORD PTR _hptr, eax

; 3745 : 		    } else {

  0919a	eb 12		 jmp	 SHORT $LN7@atl_eval
$LN9@atl_eval:

; 3746 :                         V printf("%s", tokbuf);

  0919c	68 00 00 00 00	 push	 OFFSET _tokbuf
  091a1	68 00 00 00 00	 push	 OFFSET $SG85334
  091a6	e8 00 00 00 00	 call	 _printf
  091ab	83 c4 08	 add	 esp, 8
$LN7@atl_eval:

; 3747 : 		    }
; 3748 : 		} else {

  091ae	e9 27 01 00 00	 jmp	 $LN3@atl_eval
$LN10@atl_eval:

; 3749 : 		    if (state) {

  091b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _heap
  091b9	89 4d b4	 mov	 DWORD PTR tv437[ebp], ecx
  091bc	8b 55 b4	 mov	 edx, DWORD PTR tv437[ebp]
  091bf	8b 45 b4	 mov	 eax, DWORD PTR tv437[ebp]
  091c2	8b 0a		 mov	 ecx, DWORD PTR [edx]
  091c4	0b 48 04	 or	 ecx, DWORD PTR [eax+4]
  091c7	0f 84 93 00 00
	00		 je	 $LN5@atl_eval

; 3750 : 			int l = (strlen(tokbuf) + 1 + sizeof(stackitem)) /
; 3751 : 				    sizeof(stackitem);

  091cd	68 00 00 00 00	 push	 OFFSET _tokbuf
  091d2	e8 00 00 00 00	 call	 _strlen
  091d7	83 c4 04	 add	 esp, 4
  091da	83 c0 09	 add	 eax, 9
  091dd	c1 e8 03	 shr	 eax, 3
  091e0	89 45 cc	 mov	 DWORD PTR _l$85337[ebp], eax

; 3752 : 			Ho(l + 1);

  091e3	8b 55 cc	 mov	 edx, DWORD PTR _l$85337[ebp]
  091e6	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  091eb	8d 4c d0 08	 lea	 ecx, DWORD PTR [eax+edx*8+8]
  091ef	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _heaptop
  091f5	76 0f		 jbe	 SHORT $LN4@atl_eval
  091f7	e8 00 00 00 00	 call	 _heapover
  091fc	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  09201	e9 f1 00 00 00	 jmp	 $LN65@atl_eval
$LN4@atl_eval:

; 3753 : 			/* Compile string literal instruction, followed by
; 3754 : 			   in-line skip length and the string literal */
; 3755 : 			Hstore = s_strlit;

  09206	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  0920c	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_strlit
  09211	89 02		 mov	 DWORD PTR [edx], eax
  09213	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _s_strlit+4
  09219	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0921c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  09222	83 c2 08	 add	 edx, 8
  09225	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 3756 : 			*((char *) hptr) = l;  /* Store in-line skip length */

  0922b	a1 00 00 00 00	 mov	 eax, DWORD PTR _hptr
  09230	8a 4d cc	 mov	 cl, BYTE PTR _l$85337[ebp]
  09233	88 08		 mov	 BYTE PTR [eax], cl

; 3757 : 			V strcpy(((char *) hptr) + 1, tokbuf);

  09235	68 00 00 00 00	 push	 OFFSET _tokbuf
  0923a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hptr
  09240	83 c2 01	 add	 edx, 1
  09243	52		 push	 edx
  09244	e8 00 00 00 00	 call	 _strcpy
  09249	83 c4 08	 add	 esp, 8

; 3758 : 			hptr += l;

  0924c	8b 45 cc	 mov	 eax, DWORD PTR _l$85337[ebp]
  0924f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hptr
  09255	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  09258	89 15 00 00 00
	00		 mov	 DWORD PTR _hptr, edx

; 3759 : 		    } else {

  0925e	eb 7a		 jmp	 SHORT $LN3@atl_eval
$LN5@atl_eval:

; 3760 : 			So(1);

  09260	a1 00 00 00 00	 mov	 eax, DWORD PTR _stk
  09265	83 c0 08	 add	 eax, 8
  09268	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stacktop
  0926e	76 0c		 jbe	 SHORT $LN2@atl_eval
  09270	e8 00 00 00 00	 call	 _stakover
  09275	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  0927a	eb 7b		 jmp	 SHORT $LN65@atl_eval
$LN2@atl_eval:

; 3761 : 			V strcpy(strbuf[cstrbuf], tokbuf);

  0927c	68 00 00 00 00	 push	 OFFSET _tokbuf
  09281	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _cstrbuf
  09287	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _strbuf
  0928d	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  09290	50		 push	 eax
  09291	e8 00 00 00 00	 call	 _strcpy
  09296	83 c4 08	 add	 esp, 8

; 3762 : 			Push = (stackitem) strbuf[cstrbuf];

  09299	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _cstrbuf
  0929f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _strbuf
  092a5	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  092a8	99		 cdq
  092a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stk
  092af	89 01		 mov	 DWORD PTR [ecx], eax
  092b1	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  092b4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stk
  092ba	83 c2 08	 add	 edx, 8
  092bd	89 15 00 00 00
	00		 mov	 DWORD PTR _stk, edx

; 3763 : 			cstrbuf = (cstrbuf + 1) % ((int) atl_ntempstr);

  092c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _cstrbuf
  092c8	83 c0 01	 add	 eax, 1
  092cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl_ntempstr
  092d1	99		 cdq
  092d2	f7 f9		 idiv	 ecx
  092d4	89 15 00 00 00
	00		 mov	 DWORD PTR _cstrbuf, edx
$LN3@atl_eval:

; 3764 : 		    }
; 3765 : 		}
; 3766 : 		break;

  092da	eb 11		 jmp	 SHORT $LN59@atl_eval
$LN1@atl_eval:

; 3767 : #endif /* STRING */
; 3768 : 	    default:
; 3769 :                 V printf("\nUnknown token type %d\n", i);

  092dc	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  092df	52		 push	 edx
  092e0	68 00 00 00 00	 push	 OFFSET $SG85351
  092e5	e8 00 00 00 00	 call	 _printf
  092ea	83 c4 08	 add	 esp, 8
$LN59@atl_eval:

; 3770 : 		break;
; 3771 : 	}
; 3772 :     }

  092ed	e9 a2 f8 ff ff	 jmp	 $LN64@atl_eval
$LN61@atl_eval:

; 3773 :     return evalstat;

  092f2	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
$LN65@atl_eval:

; 3774 : }

  092f7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  092fa	33 cd		 xor	 ecx, ebp
  092fc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  09301	8b e5		 mov	 esp, ebp
  09303	5d		 pop	 ebp
  09304	c3		 ret	 0
  09305	8d 49 00	 npad	 3
$LN67@atl_eval:
  09308	00 00 00 00	 DD	 $LN58@atl_eval
  0930c	00 00 00 00	 DD	 $LN27@atl_eval
  09310	00 00 00 00	 DD	 $LN22@atl_eval
  09314	00 00 00 00	 DD	 $LN11@atl_eval
_atl_eval ENDP
_TEXT	ENDS
END
